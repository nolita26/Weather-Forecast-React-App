{"ast":null,"code":"/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());\n})(this, function () {\n  'use strict';\n\n  /* eslint-disable */\n  var shared, worker, mapboxgl;\n  // define gets called three times: one for each chunk. we rely on the order\n  // they're imported to know which is which\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \"self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (\" + shared + \")(sharedChunk); (\" + worker + \")(sharedChunk); self.onerror = null;\";\n      var sharedChunk = {};\n      shared(sharedChunk);\n      mapboxgl = chunk(sharedChunk);\n      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {\n        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: 'text/javascript'\n        }));\n      }\n    }\n  }\n  define([\"exports\"], function (t) {\n    \"use strict\";\n\n    var e = \"3.3.0\";\n    let r;\n    const n = {\n      API_URL: \"https://api.mapbox.com\",\n      get API_URL_REGEX() {\n        if (null == r) {\n          const t = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n          try {\n            r = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t;\n          } catch (e) {\n            r = t;\n          }\n        }\n        return r;\n      },\n      get API_TILEJSON_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/v[0-9]*\\/.*\\.json.*$)/i;\n      },\n      get API_SPRITE_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*\\/sprite.*\\..*$)/i;\n      },\n      get API_FONTS_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/fonts\\/v[0-9]*\\/)(.*\\.pbf.*$)/i;\n      },\n      get API_STYLE_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*$)/i;\n      },\n      get API_CDN_URL_REGEX() {\n        return /^((https?:)?\\/\\/)?api\\.mapbox\\.c(n|om)(\\/mapbox-gl-js\\/)(.*$)/i;\n      },\n      get EVENTS_URL() {\n        if (!n.API_URL) return null;\n        try {\n          const t = new URL(n.API_URL);\n          return \"api.mapbox.cn\" === t.hostname ? \"https://events.mapbox.cn/events/v2\" : \"api.mapbox.com\" === t.hostname ? \"https://events.mapbox.com/events/v2\" : null;\n        } catch (t) {\n          return null;\n        }\n      },\n      SESSION_PATH: \"/map-sessions/v1\",\n      FEEDBACK_URL: \"https://apps.mapbox.com/feedback\",\n      TILE_URL_VERSION: \"v4\",\n      RASTER_URL_PREFIX: \"raster/v1\",\n      RASTERARRAYS_URL_PREFIX: \"rasterarrays/v1\",\n      REQUIRE_ACCESS_TOKEN: !0,\n      ACCESS_TOKEN: null,\n      DEFAULT_STYLE: \"mapbox://styles/mapbox/standard\",\n      MAX_PARALLEL_IMAGE_REQUESTS: 16,\n      DRACO_URL: \"https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm\",\n      MESHOPT_URL: \"https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm\",\n      MESHOPT_SIMD_URL: \"https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm\",\n      GLYPHS_URL: \"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"\n    };\n    function i(t) {\n      return n.API_URL_REGEX.test(t);\n    }\n    function a(t) {\n      return 0 === t.indexOf(\"mapbox:\");\n    }\n    function s(t) {\n      return n.API_CDN_URL_REGEX.test(t);\n    }\n    function o(t) {\n      return n.API_SPRITE_REGEX.test(t);\n    }\n    function l(t) {\n      return n.API_STYLE_REGEX.test(t) && !o(t);\n    }\n    const u = {\n      create: \"create\",\n      load: \"load\",\n      fullLoad: \"fullLoad\"\n    };\n    function c(t) {\n      const e = t.name.split(\"?\")[0];\n      return s(e) && e.includes(\"mapbox-gl.js\") ? \"javascript\" : s(e) && e.includes(\"mapbox-gl.css\") ? \"css\" : function (t) {\n        return n.API_FONTS_REGEX.test(t);\n      }(e) ? \"fontRange\" : o(e) ? \"sprite\" : l(e) ? \"style\" : function (t) {\n        return n.API_TILEJSON_REGEX.test(t);\n      }(e) ? \"tilejson\" : \"other\";\n    }\n    function h(t) {\n      return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n    }\n    var p = f;\n    function f(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;\n    }\n    f.prototype = {\n      sampleCurveX: function (t) {\n        return ((this.ax * t + this.bx) * t + this.cx) * t;\n      },\n      sampleCurveY: function (t) {\n        return ((this.ay * t + this.by) * t + this.cy) * t;\n      },\n      sampleCurveDerivativeX: function (t) {\n        return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n      },\n      solveCurveX: function (t, e) {\n        if (void 0 === e && (e = 1e-6), t < 0) return 0;\n        if (t > 1) return 1;\n        for (var r = t, n = 0; n < 8; n++) {\n          var i = this.sampleCurveX(r) - t;\n          if (Math.abs(i) < e) return r;\n          var a = this.sampleCurveDerivativeX(r);\n          if (Math.abs(a) < 1e-6) break;\n          r -= i / a;\n        }\n        var s = 0,\n          o = 1;\n        for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? s = r : o = r, r = .5 * (o - s) + s;\n        return r;\n      },\n      solve: function (t, e) {\n        return this.sampleCurveY(this.solveCurveX(t, e));\n      }\n    };\n    var d = h(p),\n      m = y;\n    function y(t, e) {\n      this.x = t, this.y = e;\n    }\n    y.prototype = {\n      clone: function () {\n        return new y(this.x, this.y);\n      },\n      add: function (t) {\n        return this.clone()._add(t);\n      },\n      sub: function (t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function (t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function (t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function (t) {\n        return this.clone()._mult(t);\n      },\n      div: function (t) {\n        return this.clone()._div(t);\n      },\n      rotate: function (t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function (t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function (t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function () {\n        return this.clone()._unit();\n      },\n      perp: function () {\n        return this.clone()._perp();\n      },\n      round: function () {\n        return this.clone()._round();\n      },\n      mag: function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function (t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function (t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function (t) {\n        var e = t.x - this.x,\n          r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function () {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function (t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function (t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function (t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function (t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function (t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function (t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function (t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function (t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function (t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function (t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function () {\n        return this._div(this.mag()), this;\n      },\n      _perp: function () {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function (t) {\n        var e = Math.cos(t),\n          r = Math.sin(t),\n          n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function (t, e) {\n        var r = Math.cos(t),\n          n = Math.sin(t),\n          i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function () {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, y.convert = function (t) {\n      return t instanceof y ? t : Array.isArray(t) ? new y(t[0], t[1]) : t;\n    };\n    var g = h(m);\n    const x = Math.PI / 180,\n      v = 180 / Math.PI;\n    function b(t) {\n      return t * x;\n    }\n    function _(t) {\n      return t * v;\n    }\n    const w = [[0, 0], [1, 0], [1, 1], [0, 1]];\n    function M(t) {\n      if (t <= 0) return 0;\n      if (t >= 1) return 1;\n      const e = t * t,\n        r = e * t;\n      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n    }\n    function A(t, e, r, n) {\n      const i = new d(t, e, r, n);\n      return function (t) {\n        return i.solve(t);\n      };\n    }\n    const S = A(.25, .1, .25, 1);\n    function I(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n    function k(t, e, r) {\n      return (r = I((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);\n    }\n    function P(t, e, r) {\n      const n = r - e,\n        i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n    function E(t, e, r) {\n      if (!t.length) return r(null, []);\n      let n = t.length;\n      const i = new Array(t.length);\n      let a = null;\n      t.forEach((t, s) => {\n        e(t, (t, e) => {\n          t && (a = t), i[s] = e, 0 == --n && r(a, i);\n        });\n      });\n    }\n    function z(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n      return t;\n    }\n    let T = 1;\n    function B() {\n      return T++;\n    }\n    function C() {\n      return function t(e) {\n        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }\n    function R(t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }\n    function D(t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }\n    function V(t, e) {\n      t.forEach(t => {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n    function L(t, e) {\n      return -1 !== t.indexOf(e, t.length - e.length);\n    }\n    function F(t, e, r) {\n      const n = {};\n      for (const i in t) n[i] = e.call(r || this, t[i], i, t);\n      return n;\n    }\n    function N(t, e, r) {\n      const n = {};\n      for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n      return n;\n    }\n    function O(t) {\n      return Array.isArray(t) ? t.map(O) : \"object\" == typeof t && t ? F(t, O) : t;\n    }\n    const U = {};\n    function j(t) {\n      U[t] || (\"undefined\" != typeof console && console.warn(t), U[t] = !0);\n    }\n    function q(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n    function $(t) {\n      let e = 0;\n      for (let r, n, i = 0, a = t.length, s = a - 1; i < a; s = i++) r = t[i], n = t[s], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function G([t, e, r]) {\n      const n = b(e + 90),\n        i = b(r);\n      return {\n        x: t * Math.cos(n) * Math.sin(i),\n        y: t * Math.sin(n) * Math.sin(i),\n        z: t * Math.cos(i),\n        azimuthal: e,\n        polar: r\n      };\n    }\n    function Y() {\n      return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope;\n    }\n    function X(t) {\n      const e = {};\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n        const a = n || i;\n        return e[r] = !a || a.toLowerCase(), \"\";\n      }), e[\"max-age\"]) {\n        const t = parseInt(e[\"max-age\"], 10);\n        isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n      }\n      return e;\n    }\n    let Z,\n      K,\n      H,\n      W,\n      J,\n      Q,\n      tt = null;\n    function et(t) {\n      try {\n        const e = self[t];\n        return e.setItem(\"_mapbox_test_\", 1), e.removeItem(\"_mapbox_test_\"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    function rt(t, e) {\n      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];\n    }\n    function nt(t, e, r, n) {\n      for (; e < r;) {\n        const i = e + r >> 1;\n        t[i] < n ? e = i + 1 : r = i;\n      }\n      return e;\n    }\n    function it(t, e, r, n) {\n      for (; e < r;) {\n        const i = e + r >> 1;\n        t[i] <= n ? e = i + 1 : r = i;\n      }\n      return e;\n    }\n    function at() {\n      return null == Z && (Z = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext(\"2d\") && \"function\" == typeof self.createImageBitmap), Z;\n    }\n    const st = {\n        now: () => void 0 !== W ? W : performance.now(),\n        setNow(t) {\n          W = t;\n        },\n        restoreNow() {\n          W = void 0;\n        },\n        frame(t) {\n          const e = requestAnimationFrame(t);\n          return {\n            cancel: () => cancelAnimationFrame(e)\n          };\n        },\n        getImageData(t, e = 0) {\n          const {\n            width: r,\n            height: n\n          } = t;\n          J || (J = document.createElement(\"canvas\"));\n          const i = J.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n          if (!i) throw new Error(\"failed to create canvas 2d context\");\n          return (r > J.width || n > J.height) && (J.width = r, J.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);\n        },\n        resolveURL: t => (K || (K = document.createElement(\"a\")), K.href = t, K.href),\n        get devicePixelRatio() {\n          return window.devicePixelRatio;\n        },\n        get prefersReducedMotion() {\n          return !!window.matchMedia && (null == H && (H = window.matchMedia(\"(prefers-reduced-motion: reduce)\")), H.matches);\n        },\n        hasCanvasFingerprintNoise() {\n          if (void 0 !== Q) return Q;\n          if (!at()) return Q = !1, !1;\n          const t = new OffscreenCanvas(85, 1),\n            e = t.getContext(\"2d\", {\n              willReadFrequently: !0\n            });\n          let r = 0;\n          for (let n = 0; n < t.width; ++n) e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(n, 0, 1, 1);\n          const n = e.getImageData(0, 0, t.width, t.height);\n          r = 0;\n          for (let t = 0; t < n.data.length; ++t) if (t % 4 != 3 && r++ !== n.data[t]) return Q = !0, !0;\n          return Q = !1, !1;\n        }\n      },\n      ot = \"mapbox-tiles\";\n    let lt = 500,\n      ut = 50;\n    let ct, ht;\n    function pt() {\n      try {\n        return caches;\n      } catch (t) {}\n    }\n    function ft() {\n      const t = pt();\n      t && !ct && (ct = t.open(ot));\n    }\n    function dt(t) {\n      const e = t.indexOf(\"?\");\n      if (e < 0) return t;\n      const r = [\"language\", \"worldview\"],\n        n = new URLSearchParams(),\n        i = new URLSearchParams(t.slice(e));\n      for (const t of r) {\n        const e = i.get(t);\n        e && n.set(t, e);\n      }\n      return `${t.slice(0, e)}?${n.toString()}`;\n    }\n    function mt(t, e) {\n      const r = t.indexOf(\"?\");\n      if (r < 0) return `${t}?${new URLSearchParams(e).toString()}`;\n      const n = new URLSearchParams(t.slice(r));\n      for (const t in e) n.set(t, e[t]);\n      return `${t.slice(0, r)}?${n.toString()}`;\n    }\n    let yt = 1 / 0;\n    const gt = {\n      supported: !1,\n      testSupport: function (t) {\n        !bt && vt && (_t ? Mt(t) : xt = t);\n      }\n    };\n    let xt,\n      vt,\n      bt = !1,\n      _t = !1;\n    const wt = \"undefined\" != typeof self ? self : {};\n    function Mt(t) {\n      const e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, vt), t.isContextLost()) return;\n        gt.supported = !0;\n      } catch (t) {}\n      t.deleteTexture(e), bt = !0;\n    }\n    wt.document && (vt = wt.document.createElement(\"img\"), vt.onload = function () {\n      xt && Mt(xt), xt = null, _t = !0;\n    }, vt.onerror = function () {\n      bt = !0, xt = null;\n    }, vt.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n    const At = {\n      Unknown: \"Unknown\",\n      Style: \"Style\",\n      Source: \"Source\",\n      Tile: \"Tile\",\n      Glyphs: \"Glyphs\",\n      SpriteImage: \"SpriteImage\",\n      SpriteJSON: \"SpriteJSON\",\n      Image: \"Image\",\n      Model: \"Model\"\n    };\n    \"function\" == typeof Object.freeze && Object.freeze(At);\n    class St extends Error {\n      constructor(t, e, r) {\n        401 === e && i(r) && (t += \": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\"), super(t), this.status = e, this.url = r;\n      }\n      toString() {\n        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;\n      }\n    }\n    const It = Y() ? () => self.worker && self.worker.referrer : () => (\"blob:\" === location.protocol ? parent : self).location.href;\n    const kt = function (t, e) {\n        if (!(/^file:/.test(r = t.url) || /^file:/.test(It()) && !/^\\w+:/.test(r))) {\n          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty(\"signal\")) return function (t, e) {\n            const r = new AbortController(),\n              n = new Request(t.url, {\n                method: t.method || \"GET\",\n                body: t.body,\n                credentials: t.credentials,\n                headers: t.headers,\n                referrer: It(),\n                referrerPolicy: t.referrerPolicy,\n                signal: r.signal\n              });\n            let a = !1,\n              s = !1;\n            const o = (l = n.url).indexOf(\"sku=\") > 0 && i(l);\n            var l;\n            \"json\" === t.type && n.headers.set(\"Accept\", \"application/json\");\n            const u = (r, i, a) => {\n                if (s) return;\n                if (r && \"SecurityError\" !== r.message && j(r.toString()), i && a) return c(i);\n                const l = Date.now();\n                fetch(n).then(r => {\n                  if (r.ok) {\n                    const t = o ? r.clone() : null;\n                    return c(r, t, l);\n                  }\n                  return e(new St(r.statusText, r.status, t.url));\n                }).catch(r => {\n                  \"AbortError\" !== r.name && e(new Error(`${r.message} ${t.url}`));\n                });\n              },\n              c = (r, i, o) => {\n                (\"arrayBuffer\" === t.type ? r.arrayBuffer() : \"json\" === t.type ? r.json() : r.text()).then(t => {\n                  s || (i && o && function (t, e, r) {\n                    if (ft(), !ct) return;\n                    const n = X(e.headers.get(\"Cache-Control\") || \"\");\n                    if (n[\"no-store\"]) return;\n                    const i = {\n                      status: e.status,\n                      statusText: e.statusText,\n                      headers: new Headers()\n                    };\n                    e.headers.forEach((t, e) => i.headers.set(e, t)), n[\"max-age\"] && i.headers.set(\"Expires\", new Date(r + 1e3 * n[\"max-age\"]).toUTCString());\n                    const a = i.headers.get(\"Expires\");\n                    if (!a) return;\n                    if (new Date(a).getTime() - r < 42e4) return;\n                    let s = dt(t.url);\n                    if (206 === e.status) {\n                      const e = t.headers.get(\"Range\");\n                      if (!e) return;\n                      i.status = 200, s = mt(s, {\n                        range: e\n                      });\n                    }\n                    !function (t, e) {\n                      if (void 0 === ht) try {\n                        new Response(new ReadableStream()), ht = !0;\n                      } catch (t) {\n                        ht = !1;\n                      }\n                      ht ? e(t.body) : t.blob().then(e);\n                    }(e, t => {\n                      const e = new Response(t, i);\n                      ft(), ct && ct.then(t => t.put(s, e)).catch(t => j(t.message));\n                    });\n                  }(n, i, o), a = !0, e(null, t, r.headers.get(\"Cache-Control\"), r.headers.get(\"Expires\")));\n                }).catch(t => {\n                  s || e(new Error(t.message));\n                });\n              };\n            return o ? function (t, e) {\n              if (ft(), !ct) return e(null);\n              ct.then(r => {\n                let n = dt(t.url);\n                const i = t.headers.get(\"Range\");\n                i && (n = mt(n, {\n                  range: i\n                })), r.match(n).then(t => {\n                  const i = function (t) {\n                    if (!t) return !1;\n                    const e = new Date(t.headers.get(\"Expires\") || 0),\n                      r = X(t.headers.get(\"Cache-Control\") || \"\");\n                    return e > Date.now() && !r[\"no-cache\"];\n                  }(t);\n                  r.delete(n), i && r.put(n, t.clone()), e(null, t, i);\n                }).catch(e);\n              }).catch(e);\n            }(n, u) : u(null, null), {\n              cancel: () => {\n                s = !0, a || r.abort();\n              }\n            };\n          }(t, e);\n          if (Y() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e, void 0, !0);\n        }\n        var r;\n        return function (t, e) {\n          const r = new XMLHttpRequest();\n          r.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (r.responseType = \"arraybuffer\");\n          for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);\n          return \"json\" === t.type && (r.responseType = \"text\", r.setRequestHeader(\"Accept\", \"application/json\")), r.withCredentials = \"include\" === t.credentials, r.onerror = () => {\n            e(new Error(r.statusText));\n          }, r.onload = () => {\n            if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n              let n = r.response;\n              if (\"json\" === t.type) try {\n                n = JSON.parse(r.response);\n              } catch (t) {\n                return e(t);\n              }\n              e(null, n, r.getResponseHeader(\"Cache-Control\"), r.getResponseHeader(\"Expires\"));\n            } else e(new St(r.statusText, r.status, t.url));\n          }, r.send(t.body), {\n            cancel: () => r.abort()\n          };\n        }(t, e);\n      },\n      Pt = function (t, e) {\n        return kt(z(t, {\n          type: \"arrayBuffer\"\n        }), e);\n      };\n    function Et(t) {\n      const e = document.createElement(\"a\");\n      return e.href = t, e.protocol === location.protocol && e.host === location.host;\n    }\n    const zt = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=\";\n    let Tt, Bt;\n    Tt = [], Bt = 0;\n    const Ct = function (t, e) {\n        if (gt.supported && (t.headers || (t.headers = {}), t.headers.accept = \"image/webp,*/*\"), Bt >= n.MAX_PARALLEL_IMAGE_REQUESTS) {\n          const r = {\n            requestParameters: t,\n            callback: e,\n            cancelled: !1,\n            cancel() {\n              this.cancelled = !0;\n            }\n          };\n          return Tt.push(r), r;\n        }\n        Bt++;\n        let r = !1;\n        const i = () => {\n            if (!r) for (r = !0, Bt--; Tt.length && Bt < n.MAX_PARALLEL_IMAGE_REQUESTS;) {\n              const t = Tt.shift(),\n                {\n                  requestParameters: e,\n                  callback: r,\n                  cancelled: n\n                } = t;\n              n || (t.cancel = Ct(e, r).cancel);\n            }\n          },\n          a = Pt(t, (t, r, n, a) => {\n            i(), t ? e(t) : r && (self.createImageBitmap ? function (t, e) {\n              const r = new Blob([new Uint8Array(t)], {\n                type: \"image/png\"\n              });\n              createImageBitmap(r).then(t => {\n                e(null, t);\n              }).catch(t => {\n                e(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));\n              });\n            }(r, (t, r) => e(t, r, n, a)) : function (t, e) {\n              const r = new Image();\n              r.onload = () => {\n                e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(() => {\n                  r.src = zt;\n                });\n              }, r.onerror = () => e(new Error(\"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\"));\n              const n = new Blob([new Uint8Array(t)], {\n                type: \"image/png\"\n              });\n              r.src = t.byteLength ? URL.createObjectURL(n) : zt;\n            }(r, (t, r) => e(t, r, n, a)));\n          });\n        return {\n          cancel: () => {\n            a.cancel(), i();\n          }\n        };\n      },\n      Rt = \"01\",\n      Dt = \"NO_ACCESS_TOKEN\",\n      Vt = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n    function Lt(t) {\n      const e = t.match(Vt);\n      if (!e) throw new Error(\"Unable to parse URL object\");\n      return {\n        protocol: e[1],\n        authority: e[2],\n        path: e[3] || \"/\",\n        params: e[4] ? e[4].split(\"&\") : []\n      };\n    }\n    function Ft(t) {\n      const e = t.params.length ? `?${t.params.join(\"&\")}` : \"\";\n      return `${t.protocol}://${t.authority}${t.path}${e}`;\n    }\n    const Nt = \"mapbox.eventData\";\n    function Ot(t) {\n      if (!t) return null;\n      const e = t.split(\".\");\n      if (!e || 3 !== e.length) return null;\n      try {\n        return JSON.parse(decodeURIComponent(atob(e[1]).split(\"\").map(t => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\")));\n      } catch (t) {\n        return null;\n      }\n    }\n    class Ut {\n      constructor(t) {\n        this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n      }\n      getStorageKey(t) {\n        const e = Ot(n.ACCESS_TOKEN);\n        let r = \"\";\n        return r = e && e.u ? btoa(encodeURIComponent(e.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number(\"0x\" + e)))) : n.ACCESS_TOKEN || \"\", t ? `${Nt}.${t}:${r}` : `${Nt}:${r}`;\n      }\n      fetchEventData() {\n        const t = et(\"localStorage\"),\n          e = this.getStorageKey(),\n          r = this.getStorageKey(\"uuid\");\n        if (t) try {\n          const t = localStorage.getItem(e);\n          t && (this.eventData = JSON.parse(t));\n          const n = localStorage.getItem(r);\n          n && (this.anonId = n);\n        } catch (t) {\n          j(\"Unable to read from LocalStorage\");\n        }\n      }\n      saveEventData() {\n        const t = et(\"localStorage\"),\n          e = this.getStorageKey(),\n          r = this.getStorageKey(\"uuid\"),\n          n = this.anonId;\n        if (t && n) try {\n          localStorage.setItem(r, n), Object.keys(this.eventData).length >= 1 && localStorage.setItem(e, JSON.stringify(this.eventData));\n        } catch (t) {\n          j(\"Unable to write to LocalStorage\");\n        }\n      }\n      processRequests(t) {}\n      postEvent(t, e, r, i) {\n        if (!n.EVENTS_URL) return;\n        const a = Lt(n.EVENTS_URL);\n        a.params.push(`access_token=${i || n.ACCESS_TOKEN || \"\"}`);\n        const s = {\n            event: this.type,\n            created: new Date(t).toISOString()\n          },\n          o = e ? z(s, e) : s,\n          l = {\n            url: Ft(a),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            },\n            body: JSON.stringify([o])\n          };\n        this.pendingRequest = function (t, e) {\n          return kt(z(t, {\n            method: \"POST\"\n          }), e);\n        }(l, t => {\n          this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(i);\n        });\n      }\n      queueRequest(t, e) {\n        this.queue.push(t), this.processRequests(e);\n      }\n    }\n    const jt = new class extends Ut {\n        constructor(t) {\n          super(\"appUserTurnstile\"), this._customAccessToken = t;\n        }\n        postTurnstileEvent(t, e) {\n          n.EVENTS_URL && n.ACCESS_TOKEN && Array.isArray(t) && t.some(t => a(t) || i(t)) && this.queueRequest(Date.now(), e);\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n          const r = Ot(n.ACCESS_TOKEN),\n            i = r ? r.u : n.ACCESS_TOKEN;\n          let a = i !== this.eventData.tokenU;\n          D(this.anonId) || (this.anonId = C(), a = !0);\n          const s = this.queue.shift();\n          if (this.eventData.lastSuccess) {\n            const t = new Date(this.eventData.lastSuccess),\n              e = new Date(s),\n              r = (s - this.eventData.lastSuccess) / 864e5;\n            a = a || r >= 1 || r < -1 || t.getDate() !== e.getDate();\n          } else a = !0;\n          a ? this.postEvent(s, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: e,\n            skuId: Rt,\n            \"enabled.telemetry\": !1,\n            userId: this.anonId\n          }, t => {\n            t || (this.eventData.lastSuccess = s, this.eventData.tokenU = i);\n          }, t) : this.processRequests();\n        }\n      }(),\n      qt = jt.postTurnstileEvent.bind(jt),\n      $t = new class extends Ut {\n        constructor() {\n          super(\"map.load\"), this.success = {}, this.skuToken = \"\";\n        }\n        postMapLoadEvent(t, e, r, i) {\n          this.skuToken = e, this.errorCb = i, n.EVENTS_URL && (r || n.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, r) : this.errorCb(new Error(Dt)));\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: r,\n            timestamp: n\n          } = this.queue.shift();\n          r && this.success[r] || (this.anonId || this.fetchEventData(), D(this.anonId) || (this.anonId = C()), this.postEvent(n, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: e,\n            skuId: Rt,\n            skuToken: this.skuToken,\n            userId: this.anonId\n          }, t => {\n            t ? this.errorCb(t) : r && (this.success[r] = !0);\n          }, t));\n        }\n        remove() {\n          this.errorCb = null;\n        }\n      }(),\n      Gt = $t.postMapLoadEvent.bind($t),\n      Yt = new class extends Ut {\n        constructor() {\n          super(\"gljs.performance\");\n        }\n        postPerformanceEvent(t, e) {\n          n.EVENTS_URL && (t || n.ACCESS_TOKEN) && this.queueRequest({\n            timestamp: Date.now(),\n            performanceData: e\n          }, t);\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n              timestamp: r,\n              performanceData: n\n            } = this.queue.shift(),\n            i = function (t) {\n              const r = performance.getEntriesByType(\"resource\"),\n                n = performance.getEntriesByType(\"mark\"),\n                i = function (t) {\n                  const e = {};\n                  if (t) for (const r in t) if (\"other\" !== r) for (const n of t[r]) {\n                    const t = `${r}ResolveRangeMin`,\n                      i = `${r}ResolveRangeMax`,\n                      a = `${r}RequestCount`,\n                      s = `${r}RequestCachedCount`;\n                    e[t] = Math.min(e[t] || 1 / 0, n.startTime), e[i] = Math.max(e[i] || -1 / 0, n.responseEnd);\n                    const o = t => {\n                      void 0 === e[t] && (e[t] = 0), ++e[t];\n                    };\n                    void 0 !== n.transferSize && 0 === n.transferSize && o(s), o(a);\n                  }\n                  return e;\n                }(function (t, e) {\n                  const r = {};\n                  if (t) for (const n of t) {\n                    const t = e(n);\n                    void 0 === r[t] && (r[t] = []), r[t].push(n);\n                  }\n                  return r;\n                }(r, c)),\n                a = window.devicePixelRatio,\n                s = navigator.connection || navigator.mozConnection || navigator.webkitConnection,\n                o = s ? s.effectiveType : void 0,\n                h = {\n                  counters: [],\n                  metadata: [],\n                  attributes: []\n                },\n                p = (t, e, r) => {\n                  null != r && t.push({\n                    name: e,\n                    value: r.toString()\n                  });\n                };\n              for (const t in i) p(h.counters, t, i[t]);\n              if (t.interactionRange[0] !== 1 / 0 && t.interactionRange[1] !== -1 / 0 && (p(h.counters, \"interactionRangeMin\", t.interactionRange[0]), p(h.counters, \"interactionRangeMax\", t.interactionRange[1])), n) for (const t of Object.keys(u)) {\n                const e = u[t],\n                  r = n.find(t => t.name === e);\n                r && p(h.counters, e, r.startTime);\n              }\n              return p(h.counters, \"visibilityHidden\", t.visibilityHidden), p(h.attributes, \"style\", function (t) {\n                if (t) for (const e of t) {\n                  const t = e.name.split(\"?\")[0];\n                  if (l(t)) {\n                    const e = t.split(\"/\").slice(-2);\n                    if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;\n                  }\n                }\n              }(r)), p(h.attributes, \"terrainEnabled\", t.terrainEnabled ? \"true\" : \"false\"), p(h.attributes, \"fogEnabled\", t.fogEnabled ? \"true\" : \"false\"), p(h.attributes, \"projection\", t.projection), p(h.attributes, \"zoom\", t.zoom), p(h.metadata, \"devicePixelRatio\", a), p(h.metadata, \"connectionEffectiveType\", o), p(h.metadata, \"navigatorUserAgent\", navigator.userAgent), p(h.metadata, \"screenWidth\", window.screen.width), p(h.metadata, \"screenHeight\", window.screen.height), p(h.metadata, \"windowWidth\", window.innerWidth), p(h.metadata, \"windowHeight\", window.innerHeight), p(h.metadata, \"mapWidth\", t.width / a), p(h.metadata, \"mapHeight\", t.height / a), p(h.metadata, \"webglRenderer\", t.renderer), p(h.metadata, \"webglVendor\", t.vendor), p(h.metadata, \"sdkVersion\", e), p(h.metadata, \"sdkIdentifier\", \"mapbox-gl-js\"), h;\n            }(n);\n          for (const t of i.metadata);\n          for (const t of i.counters);\n          for (const t of i.attributes);\n          this.postEvent(r, i, () => {}, t);\n        }\n      }(),\n      Xt = Yt.postPerformanceEvent.bind(Yt),\n      Zt = new class extends Ut {\n        constructor() {\n          super(\"map.auth\"), this.success = {}, this.skuToken = \"\";\n        }\n        getSession(t, e, r, i) {\n          if (!n.API_URL || !n.SESSION_PATH) return;\n          const a = Lt(n.API_URL + n.SESSION_PATH);\n          a.params.push(`sku=${e || \"\"}`), a.params.push(`access_token=${i || n.ACCESS_TOKEN || \"\"}`);\n          const s = {\n            url: Ft(a),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          };\n          this.pendingRequest = function (t, e) {\n            return kt(z(t, {\n              method: \"GET\"\n            }), e);\n          }(s, t => {\n            this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(i);\n          });\n        }\n        getSessionAPI(t, e, r, i) {\n          this.skuToken = e, this.errorCb = i, n.SESSION_PATH && n.API_URL && (r || n.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, r) : this.errorCb(new Error(Dt)));\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: e,\n            timestamp: r\n          } = this.queue.shift();\n          e && this.success[e] || this.getSession(r, this.skuToken, t => {\n            t ? this.errorCb(t) : e && (this.success[e] = !0);\n          }, t);\n        }\n        remove() {\n          this.errorCb = null;\n        }\n      }(),\n      Kt = Zt.getSessionAPI.bind(Zt),\n      Ht = new Set();\n    function Wt(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n    function Jt(t, e, r) {\n      if (r && r[t]) {\n        const n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n    class Qt {\n      constructor(t, e = {}) {\n        z(this, e), this.type = t;\n      }\n    }\n    class te extends Qt {\n      constructor(t, e = {}) {\n        super(\"error\", z({\n          error: t\n        }, e));\n      }\n    }\n    class ee {\n      on(t, e) {\n        return this._listeners = this._listeners || {}, Wt(t, e, this._listeners), this;\n      }\n      off(t, e) {\n        return Jt(t, e, this._listeners), Jt(t, e, this._oneTimeListeners), this;\n      }\n      once(t, e) {\n        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Wt(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));\n      }\n      fire(t, e) {\n        \"string\" == typeof t && (t = new Qt(t, e || {}));\n        const r = t.type;\n        if (this.listens(r)) {\n          t.target = this;\n          const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];\n          for (const r of e) r.call(this, t);\n          const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];\n          for (const e of n) Jt(r, e, this._oneTimeListeners), e.call(this, t);\n          const i = this._eventedParent;\n          i && (z(t, \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));\n        } else t instanceof te && console.error(t.error);\n        return this;\n      }\n      listens(t) {\n        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));\n      }\n      setEventedParent(t, e) {\n        return this._eventedParent = t, this._eventedParentData = e, this;\n      }\n    }\n    t.y = void 0;\n    var re = {\n      transparent: [0, 0, 0, 0],\n      aliceblue: [240, 248, 255, 1],\n      antiquewhite: [250, 235, 215, 1],\n      aqua: [0, 255, 255, 1],\n      aquamarine: [127, 255, 212, 1],\n      azure: [240, 255, 255, 1],\n      beige: [245, 245, 220, 1],\n      bisque: [255, 228, 196, 1],\n      black: [0, 0, 0, 1],\n      blanchedalmond: [255, 235, 205, 1],\n      blue: [0, 0, 255, 1],\n      blueviolet: [138, 43, 226, 1],\n      brown: [165, 42, 42, 1],\n      burlywood: [222, 184, 135, 1],\n      cadetblue: [95, 158, 160, 1],\n      chartreuse: [127, 255, 0, 1],\n      chocolate: [210, 105, 30, 1],\n      coral: [255, 127, 80, 1],\n      cornflowerblue: [100, 149, 237, 1],\n      cornsilk: [255, 248, 220, 1],\n      crimson: [220, 20, 60, 1],\n      cyan: [0, 255, 255, 1],\n      darkblue: [0, 0, 139, 1],\n      darkcyan: [0, 139, 139, 1],\n      darkgoldenrod: [184, 134, 11, 1],\n      darkgray: [169, 169, 169, 1],\n      darkgreen: [0, 100, 0, 1],\n      darkgrey: [169, 169, 169, 1],\n      darkkhaki: [189, 183, 107, 1],\n      darkmagenta: [139, 0, 139, 1],\n      darkolivegreen: [85, 107, 47, 1],\n      darkorange: [255, 140, 0, 1],\n      darkorchid: [153, 50, 204, 1],\n      darkred: [139, 0, 0, 1],\n      darksalmon: [233, 150, 122, 1],\n      darkseagreen: [143, 188, 143, 1],\n      darkslateblue: [72, 61, 139, 1],\n      darkslategray: [47, 79, 79, 1],\n      darkslategrey: [47, 79, 79, 1],\n      darkturquoise: [0, 206, 209, 1],\n      darkviolet: [148, 0, 211, 1],\n      deeppink: [255, 20, 147, 1],\n      deepskyblue: [0, 191, 255, 1],\n      dimgray: [105, 105, 105, 1],\n      dimgrey: [105, 105, 105, 1],\n      dodgerblue: [30, 144, 255, 1],\n      firebrick: [178, 34, 34, 1],\n      floralwhite: [255, 250, 240, 1],\n      forestgreen: [34, 139, 34, 1],\n      fuchsia: [255, 0, 255, 1],\n      gainsboro: [220, 220, 220, 1],\n      ghostwhite: [248, 248, 255, 1],\n      gold: [255, 215, 0, 1],\n      goldenrod: [218, 165, 32, 1],\n      gray: [128, 128, 128, 1],\n      green: [0, 128, 0, 1],\n      greenyellow: [173, 255, 47, 1],\n      grey: [128, 128, 128, 1],\n      honeydew: [240, 255, 240, 1],\n      hotpink: [255, 105, 180, 1],\n      indianred: [205, 92, 92, 1],\n      indigo: [75, 0, 130, 1],\n      ivory: [255, 255, 240, 1],\n      khaki: [240, 230, 140, 1],\n      lavender: [230, 230, 250, 1],\n      lavenderblush: [255, 240, 245, 1],\n      lawngreen: [124, 252, 0, 1],\n      lemonchiffon: [255, 250, 205, 1],\n      lightblue: [173, 216, 230, 1],\n      lightcoral: [240, 128, 128, 1],\n      lightcyan: [224, 255, 255, 1],\n      lightgoldenrodyellow: [250, 250, 210, 1],\n      lightgray: [211, 211, 211, 1],\n      lightgreen: [144, 238, 144, 1],\n      lightgrey: [211, 211, 211, 1],\n      lightpink: [255, 182, 193, 1],\n      lightsalmon: [255, 160, 122, 1],\n      lightseagreen: [32, 178, 170, 1],\n      lightskyblue: [135, 206, 250, 1],\n      lightslategray: [119, 136, 153, 1],\n      lightslategrey: [119, 136, 153, 1],\n      lightsteelblue: [176, 196, 222, 1],\n      lightyellow: [255, 255, 224, 1],\n      lime: [0, 255, 0, 1],\n      limegreen: [50, 205, 50, 1],\n      linen: [250, 240, 230, 1],\n      magenta: [255, 0, 255, 1],\n      maroon: [128, 0, 0, 1],\n      mediumaquamarine: [102, 205, 170, 1],\n      mediumblue: [0, 0, 205, 1],\n      mediumorchid: [186, 85, 211, 1],\n      mediumpurple: [147, 112, 219, 1],\n      mediumseagreen: [60, 179, 113, 1],\n      mediumslateblue: [123, 104, 238, 1],\n      mediumspringgreen: [0, 250, 154, 1],\n      mediumturquoise: [72, 209, 204, 1],\n      mediumvioletred: [199, 21, 133, 1],\n      midnightblue: [25, 25, 112, 1],\n      mintcream: [245, 255, 250, 1],\n      mistyrose: [255, 228, 225, 1],\n      moccasin: [255, 228, 181, 1],\n      navajowhite: [255, 222, 173, 1],\n      navy: [0, 0, 128, 1],\n      oldlace: [253, 245, 230, 1],\n      olive: [128, 128, 0, 1],\n      olivedrab: [107, 142, 35, 1],\n      orange: [255, 165, 0, 1],\n      orangered: [255, 69, 0, 1],\n      orchid: [218, 112, 214, 1],\n      palegoldenrod: [238, 232, 170, 1],\n      palegreen: [152, 251, 152, 1],\n      paleturquoise: [175, 238, 238, 1],\n      palevioletred: [219, 112, 147, 1],\n      papayawhip: [255, 239, 213, 1],\n      peachpuff: [255, 218, 185, 1],\n      peru: [205, 133, 63, 1],\n      pink: [255, 192, 203, 1],\n      plum: [221, 160, 221, 1],\n      powderblue: [176, 224, 230, 1],\n      purple: [128, 0, 128, 1],\n      rebeccapurple: [102, 51, 153, 1],\n      red: [255, 0, 0, 1],\n      rosybrown: [188, 143, 143, 1],\n      royalblue: [65, 105, 225, 1],\n      saddlebrown: [139, 69, 19, 1],\n      salmon: [250, 128, 114, 1],\n      sandybrown: [244, 164, 96, 1],\n      seagreen: [46, 139, 87, 1],\n      seashell: [255, 245, 238, 1],\n      sienna: [160, 82, 45, 1],\n      silver: [192, 192, 192, 1],\n      skyblue: [135, 206, 235, 1],\n      slateblue: [106, 90, 205, 1],\n      slategray: [112, 128, 144, 1],\n      slategrey: [112, 128, 144, 1],\n      snow: [255, 250, 250, 1],\n      springgreen: [0, 255, 127, 1],\n      steelblue: [70, 130, 180, 1],\n      tan: [210, 180, 140, 1],\n      teal: [0, 128, 128, 1],\n      thistle: [216, 191, 216, 1],\n      tomato: [255, 99, 71, 1],\n      turquoise: [64, 224, 208, 1],\n      violet: [238, 130, 238, 1],\n      wheat: [245, 222, 179, 1],\n      white: [255, 255, 255, 1],\n      whitesmoke: [245, 245, 245, 1],\n      yellow: [255, 255, 0, 1],\n      yellowgreen: [154, 205, 50, 1]\n    };\n    function ne(t) {\n      return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n    }\n    function ie(t) {\n      return ne(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n    }\n    function ae(t) {\n      return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n      var e;\n    }\n    function se(t, e, r) {\n      return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n    }\n    try {\n      t.y = {}.parseCSSColor = function (t) {\n        var e,\n          r = t.replace(/ /g, \"\").toLowerCase();\n        if (r in re) return re[r].slice();\n        if (\"#\" === r[0]) return 4 === r.length ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === r.length && (e = parseInt(r.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n        var n = r.indexOf(\"(\"),\n          i = r.indexOf(\")\");\n        if (-1 !== n && i + 1 === r.length) {\n          var a = r.substr(0, n),\n            s = r.substr(n + 1, i - (n + 1)).split(\",\"),\n            o = 1;\n          switch (a) {\n            case \"rgba\":\n              if (4 !== s.length) return null;\n              o = ae(s.pop());\n            case \"rgb\":\n              return 3 !== s.length ? null : [ie(s[0]), ie(s[1]), ie(s[2]), o];\n            case \"hsla\":\n              if (4 !== s.length) return null;\n              o = ae(s.pop());\n            case \"hsl\":\n              if (3 !== s.length) return null;\n              var l = (parseFloat(s[0]) % 360 + 360) % 360 / 360,\n                u = ae(s[1]),\n                c = ae(s[2]),\n                h = c <= .5 ? c * (u + 1) : c + u - c * u,\n                p = 2 * c - h;\n              return [ne(255 * se(p, h, l + 1 / 3)), ne(255 * se(p, h, l)), ne(255 * se(p, h, l - 1 / 3)), o];\n            default:\n              return null;\n          }\n        }\n        return null;\n      };\n    } catch (t) {}\n    class oe {\n      constructor(t, e, r, n = 1) {\n        this.r = t, this.g = e, this.b = r, this.a = n;\n      }\n      static parse(e) {\n        if (!e) return;\n        if (e instanceof oe) return e;\n        if (\"string\" != typeof e) return;\n        const r = t.y(e);\n        return r ? new oe(r[0] / 255 * r[3], r[1] / 255 * r[3], r[2] / 255 * r[3], r[3]) : void 0;\n      }\n      toString() {\n        const [t, e, r, n] = this.toArray();\n        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;\n      }\n      toArray() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];\n      }\n      toArray01() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, r / n, n];\n      }\n      toArray01Scaled(t) {\n        const {\n          r: e,\n          g: r,\n          b: n,\n          a: i\n        } = this;\n        return 0 === i ? [0, 0, 0] : [e / i * t, r / i * t, n / i * t];\n      }\n      toArray01PremultipliedAlpha() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return [t, e, r, n];\n      }\n      toArray01Linear() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [Math.pow(t / n, 2.2), Math.pow(e / n, 2.2), Math.pow(r / n, 2.2), n];\n      }\n    }\n    oe.black = new oe(0, 0, 0, 1), oe.white = new oe(1, 1, 1, 1), oe.transparent = new oe(0, 0, 0, 0), oe.red = new oe(1, 0, 0, 1), oe.blue = new oe(0, 0, 1, 1);\n    var le = oe;\n    function ue(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n    function ce(t, e, r) {\n      return t.map((t, n) => ue(t, e[n], r));\n    }\n    var he = Object.freeze({\n      __proto__: null,\n      array: ce,\n      color: function (t, e, r) {\n        return new le(ue(t.r, e.r, r), ue(t.g, e.g, r), ue(t.b, e.b, r), ue(t.a, e.a, r));\n      },\n      number: ue\n    });\n    function pe(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n      return t;\n    }\n    class fe extends Error {\n      constructor(t, e) {\n        super(e), this.message = e, this.key = t;\n      }\n    }\n    var de = fe;\n    class me {\n      constructor(t, e = []) {\n        this.parent = t, this.bindings = {};\n        for (const [t, r] of e) this.bindings[t] = r;\n      }\n      concat(t) {\n        return new me(this, t);\n      }\n      get(t) {\n        if (this.bindings[t]) return this.bindings[t];\n        if (this.parent) return this.parent.get(t);\n        throw new Error(`${t} not found in scope.`);\n      }\n      has(t) {\n        return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n      }\n    }\n    var ye = me;\n    const ge = {\n        kind: \"null\"\n      },\n      xe = {\n        kind: \"number\"\n      },\n      ve = {\n        kind: \"string\"\n      },\n      be = {\n        kind: \"boolean\"\n      },\n      _e = {\n        kind: \"color\"\n      },\n      we = {\n        kind: \"object\"\n      },\n      Me = {\n        kind: \"value\"\n      },\n      Ae = {\n        kind: \"collator\"\n      },\n      Se = {\n        kind: \"formatted\"\n      },\n      Ie = {\n        kind: \"resolvedImage\"\n      };\n    function ke(t, e) {\n      return {\n        kind: \"array\",\n        itemType: t,\n        N: e\n      };\n    }\n    function Pe(t) {\n      if (\"array\" === t.kind) {\n        const e = Pe(t.itemType);\n        return \"number\" == typeof t.N ? `array<${e}, ${t.N}>` : \"value\" === t.itemType.kind ? \"array\" : `array<${e}>`;\n      }\n      return t.kind;\n    }\n    const Ee = [ge, xe, ve, be, _e, Se, we, ke(Me), Ie];\n    function ze(t, e) {\n      if (\"error\" === e.kind) return null;\n      if (\"array\" === t.kind) {\n        if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !ze(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if (\"value\" === t.kind) for (const t of Ee) if (!ze(t, e)) return null;\n      }\n      return `Expected ${Pe(t)} but found ${Pe(e)} instead.`;\n    }\n    function Te(t, e) {\n      return e.some(e => e.kind === t.kind);\n    }\n    function Be(t, e) {\n      return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n    }\n    class Ce {\n      constructor(t, e, r) {\n        this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n          sensitivity: this.sensitivity,\n          usage: \"search\"\n        });\n      }\n      compare(t, e) {\n        return this.collator.compare(t, e);\n      }\n      resolvedLocale() {\n        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n      }\n    }\n    class Re {\n      constructor(t, e, r, n, i) {\n        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      }\n    }\n    class De {\n      constructor(t) {\n        this.sections = t;\n      }\n      static fromString(t) {\n        return new De([new Re(t, null, null, null, null)]);\n      }\n      isEmpty() {\n        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.namePrimary.length);\n      }\n      static factory(t) {\n        return t instanceof De ? t : De.fromString(t);\n      }\n      toString() {\n        return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          if (e.image) {\n            t.push([\"image\", e.image.namePrimary]);\n            continue;\n          }\n          t.push(e.text);\n          const r = {};\n          e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toArray())), t.push(r);\n        }\n        return t;\n      }\n    }\n    class Ve {\n      constructor(t) {\n        this.namePrimary = t.namePrimary, t.nameSecondary && (this.nameSecondary = t.nameSecondary), this.available = t.available;\n      }\n      toString() {\n        return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;\n      }\n      static fromString(t, e) {\n        return t ? new Ve({\n          namePrimary: t,\n          nameSecondary: e,\n          available: !1\n        }) : null;\n      }\n      serialize() {\n        return this.nameSecondary ? [\"image\", this.namePrimary, this.nameSecondary] : [\"image\", this.namePrimary];\n      }\n    }\n    function Le(t, e, r, n) {\n      return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n    function Fe(t) {\n      if (null === t) return !0;\n      if (\"string\" == typeof t) return !0;\n      if (\"boolean\" == typeof t) return !0;\n      if (\"number\" == typeof t) return !0;\n      if (t instanceof le) return !0;\n      if (t instanceof Ce) return !0;\n      if (t instanceof De) return !0;\n      if (t instanceof Ve) return !0;\n      if (Array.isArray(t)) {\n        for (const e of t) if (!Fe(e)) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof t) {\n        for (const e in t) if (!Fe(t[e])) return !1;\n        return !0;\n      }\n      return !1;\n    }\n    function Ne(t) {\n      if (null === t) return ge;\n      if (\"string\" == typeof t) return ve;\n      if (\"boolean\" == typeof t) return be;\n      if (\"number\" == typeof t) return xe;\n      if (t instanceof le) return _e;\n      if (t instanceof Ce) return Ae;\n      if (t instanceof De) return Se;\n      if (t instanceof Ve) return Ie;\n      if (Array.isArray(t)) {\n        const e = t.length;\n        let r;\n        for (const e of t) {\n          const t = Ne(e);\n          if (r) {\n            if (r === t) continue;\n            r = Me;\n            break;\n          }\n          r = t;\n        }\n        return ke(r || Me, e);\n      }\n      return we;\n    }\n    function Oe(t) {\n      const e = typeof t;\n      return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof le || t instanceof De || t instanceof Ve ? t.toString() : JSON.stringify(t);\n    }\n    class Ue {\n      constructor(t, e) {\n        this.type = t, this.value = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (!Fe(t[1])) return e.error(\"invalid value\");\n        const r = t[1];\n        let n = Ne(r);\n        const i = e.expectedType;\n        return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new Ue(n, r);\n      }\n      evaluate() {\n        return this.value;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof le ? [\"rgba\"].concat(this.value.toArray()) : this.value instanceof De ? this.value.serialize() : this.value;\n      }\n    }\n    var je = Ue,\n      qe = class {\n        constructor(t) {\n          this.name = \"ExpressionEvaluationError\", this.message = t;\n        }\n        toJSON() {\n          return this.message;\n        }\n      };\n    const $e = {\n      string: ve,\n      number: xe,\n      boolean: be,\n      object: we\n    };\n    class Ge {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        let r,\n          n = 1;\n        const i = t[0];\n        if (\"array\" === i) {\n          let i, a;\n          if (t.length > 2) {\n            const r = t[1];\n            if (\"string\" != typeof r || !(r in $e) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            i = $e[r], n++;\n          } else i = Me;\n          if (t.length > 3) {\n            if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n            a = t[2], n++;\n          }\n          r = ke(i, a);\n        } else r = $e[i];\n        const a = [];\n        for (; n < t.length; n++) {\n          const r = e.parse(t[n], n, Me);\n          if (!r) return null;\n          a.push(r);\n        }\n        return new Ge(r, a);\n      }\n      evaluate(t) {\n        for (let e = 0; e < this.args.length; e++) {\n          const r = this.args[e].evaluate(t);\n          if (!ze(this.type, Ne(r))) return r;\n          if (e === this.args.length - 1) throw new qe(`Expected value to be of type ${Pe(this.type)}, but found ${Pe(Ne(r))} instead.`);\n        }\n        return null;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = this.type,\n          e = [t.kind];\n        if (\"array\" === t.kind) {\n          const r = t.itemType;\n          if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n            e.push(r.kind);\n            const n = t.N;\n            (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n          }\n        }\n        return e.concat(this.args.map(t => t.serialize()));\n      }\n    }\n    var Ye = Ge;\n    class Xe {\n      constructor(t) {\n        this.type = Se, this.sections = t;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[1];\n        if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n        const n = [];\n        let i = !1;\n        for (let r = 1; r <= t.length - 1; ++r) {\n          const a = t[r];\n          if (i && \"object\" == typeof a && !Array.isArray(a)) {\n            i = !1;\n            let t = null;\n            if (a[\"font-scale\"] && (t = e.parse(a[\"font-scale\"], 1, xe), !t)) return null;\n            let r = null;\n            if (a[\"text-font\"] && (r = e.parse(a[\"text-font\"], 1, ke(ve)), !r)) return null;\n            let s = null;\n            if (a[\"text-color\"] && (s = e.parse(a[\"text-color\"], 1, _e), !s)) return null;\n            const o = n[n.length - 1];\n            o.scale = t, o.font = r, o.textColor = s;\n          } else {\n            const a = e.parse(t[r], 1, Me);\n            if (!a) return null;\n            const s = a.type.kind;\n            if (\"string\" !== s && \"value\" !== s && \"null\" !== s && \"resolvedImage\" !== s) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n            i = !0, n.push({\n              content: a,\n              scale: null,\n              font: null,\n              textColor: null\n            });\n          }\n        }\n        return new Xe(n);\n      }\n      evaluate(t) {\n        return new De(this.sections.map(e => {\n          const r = e.content.evaluate(t);\n          return Ne(r) === Ie ? new Re(\"\", r, null, null, null) : new Re(Oe(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n        }));\n      }\n      eachChild(t) {\n        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          t.push(e.content.serialize());\n          const r = {};\n          e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n        }\n        return t;\n      }\n    }\n    class Ze {\n      constructor(t, e) {\n        this.type = Ie, this.inputPrimary = t, this.inputSecondary = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected two or more arguments.\");\n        const r = e.parse(t[1], 1, ve);\n        if (!r) return e.error(\"No image name provided.\");\n        if (2 === t.length) return new Ze(r);\n        const n = e.parse(t[2], 1, ve);\n        return n ? new Ze(r, n) : e.error(\"Secondary image variant is not a string.\");\n      }\n      evaluate(t) {\n        const e = Ve.fromString(this.inputPrimary.evaluate(t), this.inputSecondary ? this.inputSecondary.evaluate(t) : void 0);\n        return e && t.availableImages && (e.available = t.availableImages.indexOf(e.namePrimary) > -1, e.nameSecondary && e.available && t.availableImages && (e.available = t.availableImages.indexOf(e.nameSecondary) > -1)), e;\n      }\n      eachChild(t) {\n        t(this.inputPrimary), this.inputSecondary && t(this.inputSecondary);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return this.inputSecondary ? [\"image\", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : [\"image\", this.inputPrimary.serialize()];\n      }\n    }\n    function Ke(t) {\n      return t instanceof Number ? \"number\" : t instanceof String ? \"string\" : t instanceof Boolean ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n    }\n    const He = {\n      \"to-boolean\": be,\n      \"to-color\": _e,\n      \"to-number\": xe,\n      \"to-string\": ve\n    };\n    class We {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[0],\n          n = [];\n        let i = ge;\n        if (\"to-array\" === r) {\n          if (!Array.isArray(t[1])) return null;\n          const r = t[1].length;\n          if (e.expectedType) {\n            if (\"array\" !== e.expectedType.kind) return e.error(`Expected ${e.expectedType.kind} but found array.`);\n            i = ke(e.expectedType.itemType, r);\n          } else {\n            if (!(r > 0 && Fe(t[1][0]))) return null;\n            i = ke(Ne(t[1][0]), r);\n          }\n          for (let a = 0; a < r; a++) {\n            const r = t[1][a];\n            let s;\n            if (\"array\" === Ke(r)) s = e.parse(r, void 0, i.itemType);else {\n              const t = Ke(r);\n              if (t !== i.itemType.kind) return e.error(`Expected ${i.itemType.kind} but found ${t}.`);\n              s = e.registry.literal.parse([\"literal\", void 0 === r ? null : r], e);\n            }\n            if (!s) return null;\n            n.push(s);\n          }\n        } else {\n          if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n          i = He[r];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], r, Me);\n            if (!i) return null;\n            n.push(i);\n          }\n        }\n        return new We(i, n);\n      }\n      evaluate(t) {\n        if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n        if (\"color\" === this.type.kind) {\n          let e, r;\n          for (const n of this.args) {\n            if (e = n.evaluate(t), r = null, e instanceof le) return e;\n            if (\"string\" == typeof e) {\n              const r = t.parseColor(e);\n              if (r) return r;\n            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Le(e[0], e[1], e[2], e[3]), !r)) return new le(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n          }\n          throw new qe(r || `Could not parse color from value '${\"string\" == typeof e ? e : String(JSON.stringify(e))}'`);\n        }\n        if (\"number\" === this.type.kind) {\n          let e = null;\n          for (const r of this.args) {\n            if (e = r.evaluate(t), null === e) return 0;\n            const n = Number(e);\n            if (!isNaN(n)) return n;\n          }\n          throw new qe(`Could not convert ${JSON.stringify(e)} to number.`);\n        }\n        return \"formatted\" === this.type.kind ? De.fromString(Oe(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? Ve.fromString(Oe(this.args[0].evaluate(t))) : \"array\" === this.type.kind ? this.args.map(e => e.evaluate(t)) : Oe(this.args[0].evaluate(t));\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        if (\"formatted\" === this.type.kind) return new Xe([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n        if (\"resolvedImage\" === this.type.kind) return new Ze(this.args[0]).serialize();\n        const t = \"array\" === this.type.kind ? [] : [`to-${this.type.kind}`];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    var Je = We;\n    const Qe = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n    var tr = class {\n      constructor(t, e) {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t, this.options = e;\n      }\n      id() {\n        return this.feature && void 0 !== this.feature.id ? this.feature.id : null;\n      }\n      geometryType() {\n        return this.feature ? \"number\" == typeof this.feature.type ? Qe[this.feature.type] : this.feature.type : null;\n      }\n      geometry() {\n        return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n      }\n      canonicalID() {\n        return this.canonical;\n      }\n      properties() {\n        return this.feature && this.feature.properties || {};\n      }\n      measureLight(t) {\n        return this.globals.brightness || 0;\n      }\n      distanceFromCenter() {\n        if (this.featureTileCoord && this.featureDistanceData) {\n          const t = this.featureDistanceData.center,\n            e = this.featureDistanceData.scale,\n            {\n              x: r,\n              y: n\n            } = this.featureTileCoord;\n          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);\n        }\n        return 0;\n      }\n      parseColor(t) {\n        let e = this._parseColorCache[t];\n        return e || (e = this._parseColorCache[t] = le.parse(t)), e;\n      }\n      getConfig(t) {\n        return this.options ? this.options.get(t) : null;\n      }\n    };\n    class er {\n      constructor(t, e, r, n, i) {\n        this.name = t, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;\n      }\n      evaluate(t) {\n        if (!this._evaluate) {\n          const t = er.definitions[this.name];\n          this._evaluate = Array.isArray(t) ? t[2] : t.overloads[this._overloadIndex][1];\n        }\n        return this._evaluate(t, this.args);\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [this.name].concat(this.args.map(t => t.serialize()));\n      }\n      static parse(t, e) {\n        const r = t[0],\n          n = er.definitions[r];\n        if (!n) return e.error(`Unknown expression \"${r}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        const i = Array.isArray(n) ? n[0] : n.type,\n          a = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n          s = [];\n        let o = null,\n          l = -1;\n        for (const [n, u] of a) {\n          if (Array.isArray(n) && n.length !== t.length - 1) continue;\n          s.push(n), l++, o = new _n(e.registry, e.path, null, e.scope, void 0, e._scope, e.options);\n          const a = [];\n          let c = !1;\n          for (let e = 1; e < t.length; e++) {\n            const r = t[e],\n              i = Array.isArray(n) ? n[e - 1] : n.type,\n              s = o.parse(r, 1 + a.length, i);\n            if (!s) {\n              c = !0;\n              break;\n            }\n            a.push(s);\n          }\n          if (!c) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {\n            for (let t = 0; t < a.length; t++) {\n              const e = Array.isArray(n) ? n[t] : n.type,\n                r = a[t];\n              o.concat(t + 1).checkSubtype(e, r.type);\n            }\n            if (0 === o.errors.length) return new er(r, i, u, a, l);\n          }\n        }\n        if (1 === s.length) e.errors.push(...o.errors);else {\n          const r = (s.length ? s : a.map(([t]) => t)).map(rr).join(\" | \"),\n            n = [];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], 1 + n.length);\n            if (!i) return null;\n            n.push(Pe(i.type));\n          }\n          e.error(`Expected arguments of type ${r}, but found (${n.join(\", \")}) instead.`);\n        }\n        return null;\n      }\n      static register(t, e) {\n        er.definitions = e;\n        for (const r in e) t[r] = er;\n      }\n    }\n    function rr(t) {\n      return Array.isArray(t) ? `(${t.map(Pe).join(\", \")})` : `(${Pe(t.type)}...)`;\n    }\n    var nr = er;\n    class ir {\n      constructor(t, e, r) {\n        this.type = Ae, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected one argument.\");\n        const r = t[1];\n        if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n        const n = e.parse(void 0 !== r[\"case-sensitive\"] && r[\"case-sensitive\"], 1, be);\n        if (!n) return null;\n        const i = e.parse(void 0 !== r[\"diacritic-sensitive\"] && r[\"diacritic-sensitive\"], 1, be);\n        if (!i) return null;\n        let a = null;\n        return r.locale && (a = e.parse(r.locale, 1, ve), !a) ? null : new ir(n, i, a);\n      }\n      evaluate(t) {\n        return new Ce(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n      }\n      eachChild(t) {\n        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n      }\n    }\n    var ar = {\n      exports: {}\n    };\n    ar.exports = function () {\n      function t(r, n, i, a, s) {\n        for (; a > i;) {\n          if (a - i > 600) {\n            var o = a - i + 1,\n              l = n - i + 1,\n              u = Math.log(o),\n              c = .5 * Math.exp(2 * u / 3),\n              h = .5 * Math.sqrt(u * c * (o - c) / o) * (l - o / 2 < 0 ? -1 : 1);\n            t(r, n, Math.max(i, Math.floor(n - l * c / o + h)), Math.min(a, Math.floor(n + (o - l) * c / o + h)), s);\n          }\n          var p = r[n],\n            f = i,\n            d = a;\n          for (e(r, i, n), s(r[a], p) > 0 && e(r, i, a); f < d;) {\n            for (e(r, f, d), f++, d--; s(r[f], p) < 0;) f++;\n            for (; s(r[d], p) > 0;) d--;\n          }\n          0 === s(r[i], p) ? e(r, i, d) : e(r, ++d, a), d <= n && (i = d + 1), n <= d && (a = d - 1);\n        }\n      }\n      function e(t, e, r) {\n        var n = t[e];\n        t[e] = t[r], t[r] = n;\n      }\n      function r(t, e) {\n        return t < e ? -1 : t > e ? 1 : 0;\n      }\n      return function (e, n, i, a, s) {\n        t(e, n, i || 0, a || e.length - 1, s || r);\n      };\n    }();\n    var sr = h(ar.exports);\n    function or(t) {\n      let e = 0;\n      for (let r, n, i = 0, a = t.length, s = a - 1; i < a; s = i++) r = t[i], n = t[s], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function lr(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n    function ur(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n    function cr(t, e, r) {\n      const n = t[0] - e[0],\n        i = t[1] - e[1],\n        a = t[0] - r[0],\n        s = t[1] - r[1];\n      return n * s - a * i == 0 && n * a <= 0 && i * s <= 0;\n    }\n    function hr(t, e, r = !1) {\n      let n = !1;\n      for (let o = 0, l = e.length; o < l; o++) {\n        const l = e[o];\n        for (let e = 0, o = l.length, u = o - 1; e < o; u = e++) {\n          const o = l[u],\n            c = l[e];\n          if (cr(t, o, c)) return r;\n          (a = o)[1] > (i = t)[1] != (s = c)[1] > i[1] && i[0] < (s[0] - a[0]) * (i[1] - a[1]) / (s[1] - a[1]) + a[0] && (n = !n);\n        }\n      }\n      var i, a, s;\n      return n;\n    }\n    function pr(t, e, r, n) {\n      const i = n[0] - r[0],\n        a = n[1] - r[1],\n        s = (t[0] - r[0]) * a - i * (t[1] - r[1]),\n        o = (e[0] - r[0]) * a - i * (e[1] - r[1]);\n      return s > 0 && o < 0 || s < 0 && o > 0;\n    }\n    function fr(t, e, r, n) {\n      return 0 != (i = [n[0] - r[0], n[1] - r[1]])[0] * (a = [e[0] - t[0], e[1] - t[1]])[1] - i[1] * a[0] && !(!pr(t, e, r, n) || !pr(r, n, t, e));\n      var i, a;\n    }\n    const dr = 8192;\n    function mr(t, e) {\n      const r = (180 + t[0]) / 360,\n        n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n        i = Math.pow(2, e.z);\n      return [Math.round(r * i * dr), Math.round(n * i * dr)];\n    }\n    function yr(t, e) {\n      for (let r = 0; r < e.length; r++) if (hr(t, e[r])) return !0;\n      return !1;\n    }\n    function gr(t, e, r) {\n      for (const n of r) for (let r = 0, i = n.length, a = i - 1; r < i; a = r++) if (fr(t, e, n[a], n[r])) return !0;\n      return !1;\n    }\n    function xr(t, e) {\n      for (let r = 0; r < t.length; ++r) if (!hr(t[r], e)) return !1;\n      for (let r = 0; r < t.length - 1; ++r) if (gr(t[r], t[r + 1], e)) return !1;\n      return !0;\n    }\n    function vr(t, e) {\n      for (let r = 0; r < e.length; r++) if (xr(t, e[r])) return !0;\n      return !1;\n    }\n    function br(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const a = [];\n        for (let n = 0; n < t[i].length; n++) {\n          const s = mr(t[i][n], r);\n          lr(e, s), a.push(s);\n        }\n        n.push(a);\n      }\n      return n;\n    }\n    function _r(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const a = br(t[i], e, r);\n        n.push(a);\n      }\n      return n;\n    }\n    function wr(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        const e = .5 * n;\n        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n      }\n      lr(e, t);\n    }\n    function Mr(t, e, r, n) {\n      const i = Math.pow(2, n.z) * dr,\n        a = [n.x * dr, n.y * dr],\n        s = [];\n      if (!t) return s;\n      for (const n of t) for (const t of n) {\n        const n = [t.x + a[0], t.y + a[1]];\n        wr(n, e, r, i), s.push(n);\n      }\n      return s;\n    }\n    function Ar(t, e, r, n) {\n      const i = Math.pow(2, n.z) * dr,\n        a = [n.x * dr, n.y * dr],\n        s = [];\n      if (!t) return s;\n      for (const r of t) {\n        const t = [];\n        for (const n of r) {\n          const r = [n.x + a[0], n.y + a[1]];\n          lr(e, r), t.push(r);\n        }\n        s.push(t);\n      }\n      if (e[2] - e[0] <= i / 2) {\n        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;\n        for (const t of s) for (const n of t) wr(n, e, r, i);\n      }\n      var o;\n      return s;\n    }\n    class Sr {\n      constructor(t, e) {\n        this.type = be, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (Fe(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n            const r = e.features[t].geometry.type;\n            if (\"Polygon\" === r || \"MultiPolygon\" === r) return new Sr(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            const t = e.geometry.type;\n            if (\"Polygon\" === t || \"MultiPolygon\" === t) return new Sr(e, e.geometry);\n          } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new Sr(e, e);\n        }\n        return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n      }\n      evaluate(t) {\n        if (null != t.geometry() && null != t.canonicalID()) {\n          if (\"Point\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const a = br(e.coordinates, n, i),\n                s = Mr(t.geometry(), r, n, i);\n              if (!ur(r, n)) return !1;\n              for (const t of s) if (!hr(t, a)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const a = _r(e.coordinates, n, i),\n                s = Mr(t.geometry(), r, n, i);\n              if (!ur(r, n)) return !1;\n              for (const t of s) if (!yr(t, a)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const a = br(e.coordinates, n, i),\n                s = Ar(t.geometry(), r, n, i);\n              if (!ur(r, n)) return !1;\n              for (const t of s) if (!xr(t, a)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const a = _r(e.coordinates, n, i),\n                s = Ar(t.geometry(), r, n, i);\n              if (!ur(r, n)) return !1;\n              for (const t of s) if (!vr(t, a)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n        }\n        return !1;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"within\", this.geojson];\n      }\n    }\n    var Ir = Sr,\n      kr = {\n        exports: {}\n      };\n    kr.exports = function () {\n      var t = {\n          kilometers: 1,\n          miles: 1e3 / 1609.344,\n          nauticalmiles: 1e3 / 1852,\n          meters: 1e3,\n          metres: 1e3,\n          yards: 1e3 / .9144,\n          feet: 1e3 / .3048,\n          inches: 1e3 / .0254\n        },\n        e = 1 / 298.257223563,\n        r = e * (2 - e),\n        n = Math.PI / 180,\n        i = function (e, i) {\n          if (void 0 === e) throw new Error(\"No latitude given.\");\n          if (i && !t[i]) throw new Error(\"Unknown unit \" + i + \". Use one of: \" + Object.keys(t).join(\", \"));\n          var a = 6378.137 * n * (i ? t[i] : 1),\n            s = Math.cos(e * n),\n            o = 1 / (1 - r * (1 - s * s)),\n            l = Math.sqrt(o);\n          this.kx = a * l * s, this.ky = a * l * o * (1 - r);\n        },\n        a = {\n          units: {\n            configurable: !0\n          }\n        };\n      function s(t, e) {\n        return t[0] === e[0] && t[1] === e[1];\n      }\n      function o(t, e, r) {\n        var n = l(e[0] - t[0]);\n        return [t[0] + n * r, t[1] + (e[1] - t[1]) * r];\n      }\n      function l(t) {\n        for (; t < -180;) t += 360;\n        for (; t > 180;) t -= 360;\n        return t;\n      }\n      return i.fromTile = function (t, e, r) {\n        var a = Math.PI * (1 - 2 * (t + .5) / Math.pow(2, e)),\n          s = Math.atan(.5 * (Math.exp(a) - Math.exp(-a))) / n;\n        return new i(s, r);\n      }, a.units.get = function () {\n        return t;\n      }, i.prototype.distance = function (t, e) {\n        var r = l(t[0] - e[0]) * this.kx,\n          n = (t[1] - e[1]) * this.ky;\n        return Math.sqrt(r * r + n * n);\n      }, i.prototype.bearing = function (t, e) {\n        var r = l(e[0] - t[0]) * this.kx;\n        return Math.atan2(r, (e[1] - t[1]) * this.ky) / n;\n      }, i.prototype.destination = function (t, e, r) {\n        var i = r * n;\n        return this.offset(t, Math.sin(i) * e, Math.cos(i) * e);\n      }, i.prototype.offset = function (t, e, r) {\n        return [t[0] + e / this.kx, t[1] + r / this.ky];\n      }, i.prototype.lineDistance = function (t) {\n        for (var e = 0, r = 0; r < t.length - 1; r++) e += this.distance(t[r], t[r + 1]);\n        return e;\n      }, i.prototype.area = function (t) {\n        for (var e = 0, r = 0; r < t.length; r++) for (var n = t[r], i = 0, a = n.length, s = a - 1; i < a; s = i++) e += l(n[i][0] - n[s][0]) * (n[i][1] + n[s][1]) * (r ? -1 : 1);\n        return Math.abs(e) / 2 * this.kx * this.ky;\n      }, i.prototype.along = function (t, e) {\n        var r = 0;\n        if (e <= 0) return t[0];\n        for (var n = 0; n < t.length - 1; n++) {\n          var i = t[n],\n            a = t[n + 1],\n            s = this.distance(i, a);\n          if ((r += s) > e) return o(i, a, (e - (r - s)) / s);\n        }\n        return t[t.length - 1];\n      }, i.prototype.pointToSegmentDistance = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          a = l(r[0] - n) * this.kx,\n          s = (r[1] - i) * this.ky,\n          o = 0;\n        return 0 === a && 0 === s || ((o = (l(t[0] - n) * this.kx * a + (t[1] - i) * this.ky * s) / (a * a + s * s)) > 1 ? (n = r[0], i = r[1]) : o > 0 && (n += a / this.kx * o, i += s / this.ky * o)), a = l(t[0] - n) * this.kx, s = (t[1] - i) * this.ky, Math.sqrt(a * a + s * s);\n      }, i.prototype.pointOnLine = function (t, e) {\n        for (var r, n, i, a, s = 1 / 0, o = 0; o < t.length - 1; o++) {\n          var u = t[o][0],\n            c = t[o][1],\n            h = l(t[o + 1][0] - u) * this.kx,\n            p = (t[o + 1][1] - c) * this.ky,\n            f = 0;\n          0 === h && 0 === p || ((f = (l(e[0] - u) * this.kx * h + (e[1] - c) * this.ky * p) / (h * h + p * p)) > 1 ? (u = t[o + 1][0], c = t[o + 1][1]) : f > 0 && (u += h / this.kx * f, c += p / this.ky * f));\n          var d = (h = l(e[0] - u) * this.kx) * h + (p = (e[1] - c) * this.ky) * p;\n          d < s && (s = d, r = u, n = c, i = o, a = f);\n        }\n        return {\n          point: [r, n],\n          index: i,\n          t: Math.max(0, Math.min(1, a))\n        };\n      }, i.prototype.lineSlice = function (t, e, r) {\n        var n = this.pointOnLine(r, t),\n          i = this.pointOnLine(r, e);\n        if (n.index > i.index || n.index === i.index && n.t > i.t) {\n          var a = n;\n          n = i, i = a;\n        }\n        var o = [n.point],\n          l = n.index + 1,\n          u = i.index;\n        !s(r[l], o[0]) && l <= u && o.push(r[l]);\n        for (var c = l + 1; c <= u; c++) o.push(r[c]);\n        return s(r[u], i.point) || o.push(i.point), o;\n      }, i.prototype.lineSliceAlong = function (t, e, r) {\n        for (var n = 0, i = [], a = 0; a < r.length - 1; a++) {\n          var s = r[a],\n            l = r[a + 1],\n            u = this.distance(s, l);\n          if ((n += u) > t && 0 === i.length && i.push(o(s, l, (t - (n - u)) / u)), n >= e) return i.push(o(s, l, (e - (n - u)) / u)), i;\n          n > t && i.push(l);\n        }\n        return i;\n      }, i.prototype.bufferPoint = function (t, e) {\n        var r = e / this.ky,\n          n = e / this.kx;\n        return [t[0] - n, t[1] - r, t[0] + n, t[1] + r];\n      }, i.prototype.bufferBBox = function (t, e) {\n        var r = e / this.ky,\n          n = e / this.kx;\n        return [t[0] - n, t[1] - r, t[2] + n, t[3] + r];\n      }, i.prototype.insideBBox = function (t, e) {\n        return l(t[0] - e[0]) >= 0 && l(t[0] - e[2]) <= 0 && t[1] >= e[1] && t[1] <= e[3];\n      }, Object.defineProperties(i, a), i;\n    }();\n    var Pr = h(kr.exports),\n      Er = {\n        exports: {}\n      };\n    Er.exports = function () {\n      var t = function (t, r) {\n        if (void 0 === t && (t = []), void 0 === r && (r = e), this.data = t, this.length = this.data.length, this.compare = r, this.length > 0) for (var n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);\n      };\n      function e(t, e) {\n        return t < e ? -1 : t > e ? 1 : 0;\n      }\n      return t.prototype.push = function (t) {\n        this.data.push(t), this.length++, this._up(this.length - 1);\n      }, t.prototype.pop = function () {\n        if (0 !== this.length) {\n          var t = this.data[0],\n            e = this.data.pop();\n          return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n        }\n      }, t.prototype.peek = function () {\n        return this.data[0];\n      }, t.prototype._up = function (t) {\n        for (var e = this.data, r = this.compare, n = e[t]; t > 0;) {\n          var i = t - 1 >> 1,\n            a = e[i];\n          if (r(n, a) >= 0) break;\n          e[t] = a, t = i;\n        }\n        e[t] = n;\n      }, t.prototype._down = function (t) {\n        for (var e = this.data, r = this.compare, n = this.length >> 1, i = e[t]; t < n;) {\n          var a = 1 + (t << 1),\n            s = e[a],\n            o = a + 1;\n          if (o < this.length && r(e[o], s) < 0 && (a = o, s = e[o]), r(s, i) >= 0) break;\n          e[t] = s, t = a;\n        }\n        e[t] = i;\n      }, t;\n    }();\n    var zr = h(Er.exports),\n      Tr = 8192;\n    function Br(t, e) {\n      return e.dist - t.dist;\n    }\n    const Cr = 100,\n      Rr = 50;\n    function Dr(t) {\n      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      if (e.length !== t.length) return !1;\n      for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n      return !0;\n    }\n    function Vr(t) {\n      return t[1] - t[0] + 1;\n    }\n    function Lr(t, e) {\n      const r = t[1] >= t[0] && t[1] < e;\n      return r || console.warn(\"Distance Expression: Index is out of range\"), r;\n    }\n    function Fr(t, e) {\n      if (t[0] > t[1]) return [null, null];\n      const r = Vr(t);\n      if (e) {\n        if (2 === r) return [t, null];\n        const e = Math.floor(r / 2);\n        return [[t[0], t[0] + e], [t[0] + e, t[1]]];\n      }\n      {\n        if (1 === r) return [t, null];\n        const e = Math.floor(r / 2) - 1;\n        return [[t[0], t[0] + e], [t[0] + e + 1, t[1]]];\n      }\n    }\n    function Nr(t, e) {\n      const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      if (!Lr(e, t.length)) return r;\n      for (let n = e[0]; n <= e[1]; ++n) lr(r, t[n]);\n      return r;\n    }\n    function Or(t) {\n      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      for (let r = 0; r < t.length; ++r) for (let n = 0; n < t[r].length; ++n) lr(e, t[r][n]);\n      return e;\n    }\n    function Ur(t, e, r) {\n      if (Dr(t) || Dr(e)) return NaN;\n      let n = 0,\n        i = 0;\n      return t[2] < e[0] && (n = e[0] - t[2]), t[0] > e[2] && (n = t[0] - e[2]), t[1] > e[3] && (i = t[1] - e[3]), t[3] < e[1] && (i = e[1] - t[3]), r.distance([0, 0], [n, i]);\n    }\n    function jr(t) {\n      return 360 * t - 180;\n    }\n    function qr(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function $r(t, e) {\n      const r = Math.pow(2, e.z),\n        n = (t.y / Tr + e.y) / r;\n      return [jr((t.x / Tr + e.x) / r), qr(n)];\n    }\n    function Gr(t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; ++n) r.push($r(t[n], e));\n      return r;\n    }\n    function Yr(t, e, r) {\n      const n = r.pointOnLine(e, t).point;\n      return r.distance(t, n);\n    }\n    function Xr(t, e, r, n, i) {\n      const a = r.slice(n[0], n[1] + 1);\n      let s = 1 / 0;\n      for (let r = e[0]; r <= e[1]; ++r) if (0 === (s = Math.min(s, Yr(t[r], a, i)))) return 0;\n      return s;\n    }\n    function Zr(t, e, r, n, i) {\n      const a = Math.min(i.pointToSegmentDistance(t, r, n), i.pointToSegmentDistance(e, r, n)),\n        s = Math.min(i.pointToSegmentDistance(r, t, e), i.pointToSegmentDistance(n, t, e));\n      return Math.min(a, s);\n    }\n    function Kr(t, e, r, n, i) {\n      if (!Lr(e, t.length) || !Lr(n, r.length)) return NaN;\n      let a = 1 / 0;\n      for (let s = e[0]; s < e[1]; ++s) for (let e = n[0]; e < n[1]; ++e) {\n        if (fr(t[s], t[s + 1], r[e], r[e + 1])) return 0;\n        a = Math.min(a, Zr(t[s], t[s + 1], r[e], r[e + 1], i));\n      }\n      return a;\n    }\n    function Hr(t, e, r, n, i) {\n      if (!Lr(e, t.length) || !Lr(n, r.length)) return NaN;\n      let a = 1 / 0;\n      for (let s = e[0]; s <= e[1]; ++s) for (let e = n[0]; e <= n[1]; ++e) if (0 === (a = Math.min(a, i.distance(t[s], r[e])))) return a;\n      return a;\n    }\n    function Wr(t, e, r) {\n      if (hr(t, e, !0)) return 0;\n      let n = 1 / 0;\n      for (const i of e) {\n        const e = i.length;\n        if (e < 2) return console.warn(\"Distance Expression: Invalid polygon!\"), NaN;\n        if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t, i[e - 1], i[0])))) return n;\n        if (0 === (n = Math.min(n, Yr(t, i, r)))) return n;\n      }\n      return n;\n    }\n    function Jr(t, e, r, n) {\n      if (!Lr(e, t.length)) return NaN;\n      for (let n = e[0]; n <= e[1]; ++n) if (hr(t[n], r, !0)) return 0;\n      let i = 1 / 0;\n      for (let a = e[0]; a < e[1]; ++a) for (const e of r) for (let r = 0, s = e.length, o = s - 1; r < s; o = r++) {\n        if (fr(t[a], t[a + 1], e[o], e[r])) return 0;\n        i = Math.min(i, Zr(t[a], t[a + 1], e[o], e[r], n));\n      }\n      return i;\n    }\n    function Qr(t, e) {\n      for (const r of t) for (let t = 0; t <= r.length - 1; ++t) if (hr(r[t], e, !0)) return !0;\n      return !1;\n    }\n    function tn(t, e, r, n = 1 / 0) {\n      const i = Or(t),\n        a = Or(e);\n      if (n !== 1 / 0 && Ur(i, a, r) >= n) return n;\n      if (ur(i, a)) {\n        if (Qr(t, e)) return 0;\n      } else if (Qr(e, t)) return 0;\n      let s = n;\n      for (const n of t) for (let t = 0, i = n.length, a = i - 1; t < i; a = t++) for (const i of e) for (let e = 0, o = i.length, l = o - 1; e < o; l = e++) {\n        if (fr(n[a], n[t], i[l], i[e])) return 0;\n        s = Math.min(s, Zr(n[a], n[t], i[l], i[e], r));\n      }\n      return s;\n    }\n    function en(t, e, r, n, i, a, s) {\n      if (null === a || null === s) return;\n      const o = Ur(Nr(n, a), Nr(i, s), r);\n      o < e && t.push({\n        dist: o,\n        range1: a,\n        range2: s\n      });\n    }\n    function rn(t, e, r, n, i = 1 / 0) {\n      let a = Math.min(n.distance(t[0], r[0][0]), i);\n      if (0 === a) return a;\n      const s = new zr([{\n          dist: 0,\n          range1: [0, t.length - 1],\n          range2: [0, 0]\n        }], Br),\n        o = e ? Rr : Cr,\n        l = Or(r);\n      for (; s.length;) {\n        const i = s.pop();\n        if (i.dist >= a) continue;\n        const u = i.range1;\n        if (Vr(u) <= o) {\n          if (!Lr(u, t.length)) return NaN;\n          if (e) {\n            const e = Jr(t, u, r, n);\n            if (0 === (a = Math.min(a, e))) return a;\n          } else for (let e = u[0]; e <= u[1]; ++e) {\n            const i = Wr(t[e], r, n);\n            if (0 === (a = Math.min(a, i))) return a;\n          }\n        } else {\n          const r = Fr(u, e);\n          if (null !== r[0]) {\n            const e = Ur(Nr(t, r[0]), l, n);\n            e < a && s.push({\n              dist: e,\n              range1: r[0],\n              range2: [0, 0]\n            });\n          }\n          if (null !== r[1]) {\n            const e = Ur(Nr(t, r[1]), l, n);\n            e < a && s.push({\n              dist: e,\n              range1: r[1],\n              range2: [0, 0]\n            });\n          }\n        }\n      }\n      return a;\n    }\n    function nn(t, e, r, n, i, a = 1 / 0) {\n      let s = Math.min(a, i.distance(t[0], r[0]));\n      if (0 === s) return s;\n      const o = new zr([{\n          dist: 0,\n          range1: [0, t.length - 1],\n          range2: [0, r.length - 1]\n        }], Br),\n        l = e ? Rr : Cr,\n        u = n ? Rr : Cr;\n      for (; o.length;) {\n        const a = o.pop();\n        if (a.dist >= s) continue;\n        const c = a.range1,\n          h = a.range2;\n        if (Vr(c) <= l && Vr(h) <= u) {\n          if (!Lr(c, t.length) || !Lr(h, r.length)) return NaN;\n          if (e && n ? s = Math.min(s, Kr(t, c, r, h, i)) : e || n ? e && !n ? s = Math.min(s, Xr(r, h, t, c, i)) : !e && n && (s = Math.min(s, Xr(t, c, r, h, i))) : s = Math.min(s, Hr(t, c, r, h, i)), 0 === s) return s;\n        } else {\n          const a = Fr(c, e),\n            l = Fr(h, n);\n          en(o, s, i, t, r, a[0], l[0]), en(o, s, i, t, r, a[0], l[1]), en(o, s, i, t, r, a[1], l[0]), en(o, s, i, t, r, a[1], l[1]);\n        }\n      }\n      return s;\n    }\n    function an(t, e, r, n, i = 1 / 0) {\n      let a = i;\n      const s = Nr(t, [0, t.length - 1]);\n      for (const i of r) if (!(a !== 1 / 0 && Ur(s, Nr(i, [0, i.length - 1]), n) >= a) && (a = Math.min(a, nn(t, e, i, !0, n, a)), 0 === a)) return a;\n      return a;\n    }\n    function sn(t, e, r, n, i = 1 / 0) {\n      let a = i;\n      const s = Nr(t, [0, t.length - 1]);\n      for (const i of r) {\n        if (a !== 1 / 0 && Ur(s, Or(i), n) >= a) continue;\n        const r = rn(t, e, i, n, a);\n        if (isNaN(r)) return r;\n        if (0 === (a = Math.min(a, r))) return a;\n      }\n      return a;\n    }\n    function on(t) {\n      return \"Point\" === t || \"MultiPoint\" === t || \"LineString\" === t || \"MultiLineString\" === t || \"Polygon\" === t || \"MultiPolygon\" === t;\n    }\n    class ln {\n      constructor(t, e) {\n        this.type = xe, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'distance' expression requires either one argument, but found ' ${t.length - 1} instead.`);\n        if (Fe(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) {\n            for (let t = 0; t < e.features.length; ++t) if (on(e.features[t].geometry.type)) return new ln(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            if (on(e.geometry.type)) return new ln(e, e.geometry);\n          } else if (on(e.type)) return new ln(e, e);\n        }\n        return e.error(\"'distance' expression needs to be an array with format ['Distance', GeoJSONObj].\");\n      }\n      evaluate(t) {\n        const e = t.geometry(),\n          r = t.canonicalID();\n        if (null != e && null != r) {\n          if (\"Point\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of t) for (const t of r) n.push($r(t, e));\n            const i = new Pr(n[0][1], \"meters\");\n            return \"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type ? nn(n, !1, \"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, i) : \"MultiLineString\" === r.type ? an(n, !1, r.coordinates, i) : \"Polygon\" === r.type || \"MultiPolygon\" === r.type ? sn(n, !1, \"Polygon\" === r.type ? [r.coordinates] : r.coordinates, i) : null;\n          }(e, r, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of t) {\n              const t = [];\n              for (const n of r) t.push($r(n, e));\n              n.push(t);\n            }\n            const i = new Pr(n[0][0][1], \"meters\");\n            if (\"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type) return an(\"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, n, i);\n            if (\"MultiLineString\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < r.coordinates.length; e++) {\n                const a = an(r.coordinates[e], !0, n, i, t);\n                if (isNaN(a)) return a;\n                if (0 === (t = Math.min(t, a))) return t;\n              }\n              return t;\n            }\n            if (\"Polygon\" === r.type || \"MultiPolygon\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < n.length; e++) {\n                const a = sn(n[e], !0, \"Polygon\" === r.type ? [r.coordinates] : r.coordinates, i, t);\n                if (isNaN(a)) return a;\n                if (0 === (t = Math.min(t, a))) return t;\n              }\n              return t;\n            }\n            return null;\n          }(e, r, this.geometries);\n          if (\"Polygon\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of function (t, e) {\n              const r = t.length;\n              if (r <= 1) return [t];\n              const n = [];\n              let i, a;\n              for (let e = 0; e < r; e++) {\n                const r = or(t[e]);\n                0 !== r && (t[e].area = Math.abs(r), void 0 === a && (a = r < 0), a === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n              }\n              return i && n.push(i), n;\n            }(t)) {\n              const t = [];\n              for (let n = 0; n < r.length; ++n) t.push(Gr(r[n], e));\n              n.push(t);\n            }\n            const i = new Pr(n[0][0][0][1], \"meters\");\n            if (\"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type) return sn(\"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, n, i);\n            if (\"MultiLineString\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < r.coordinates.length; e++) {\n                const a = sn(r.coordinates[e], !0, n, i, t);\n                if (isNaN(a)) return a;\n                if (0 === (t = Math.min(t, a))) return t;\n              }\n              return t;\n            }\n            return \"Polygon\" === r.type || \"MultiPolygon\" === r.type ? function (t, e, r) {\n              let n = 1 / 0;\n              for (const i of t) for (const t of e) {\n                const e = tn(i, t, r, n);\n                if (isNaN(e)) return e;\n                if (0 === (n = Math.min(n, e))) return n;\n              }\n              return n;\n            }(\"Polygon\" === r.type ? [r.coordinates] : r.coordinates, n, i) : null;\n          }(e, r, this.geometries);\n          console.warn(\"Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.\");\n        } else console.warn(\"Distance Expression: requirs valid feature and canonical information.\");\n        return null;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"distance\", this.geojson];\n      }\n    }\n    var un = ln;\n    function cn(t, e) {\n      switch (t) {\n        case \"string\":\n          return Oe(e);\n        case \"number\":\n          return +e;\n        case \"boolean\":\n          return !!e;\n        case \"color\":\n          return le.parse(e);\n        case \"formatted\":\n          return De.fromString(Oe(e));\n        case \"resolvedImage\":\n          return Ve.fromString(Oe(e));\n      }\n      return e;\n    }\n    function hn(t, e, r, n) {\n      return void 0 !== n && (t = n * Math.round(t / n)), void 0 !== e && t < e && (t = e), void 0 !== r && t > r && (t = r), t;\n    }\n    class pn {\n      constructor(t, e, r) {\n        this.type = t, this.key = e, this.scope = r;\n      }\n      static parse(t, e) {\n        let r = e.expectedType;\n        if (null == r && (r = Me), t.length < 2 || t.length > 3) return e.error(\"Invalid number of arguments for 'config' expression.\");\n        const n = e.parse(t[1], 1);\n        if (!(n instanceof je)) return e.error(\"Key name of 'config' expression must be a string literal.\");\n        if (t.length >= 3) {\n          const i = e.parse(t[2], 2);\n          return i instanceof je ? new pn(r, Oe(n.value), Oe(i.value)) : e.error(\"Scope of 'config' expression must be a string literal.\");\n        }\n        return new pn(r, Oe(n.value));\n      }\n      evaluate(t) {\n        const e = [this.key, this.scope, t.scope].filter(Boolean).join(\"\u001f\"),\n          r = t.getConfig(e);\n        if (!r) return null;\n        const {\n            type: n,\n            value: i,\n            values: a,\n            minValue: s,\n            maxValue: o,\n            stepValue: l\n          } = r,\n          u = r.default.evaluate(t);\n        let c = u;\n        if (i) {\n          const e = t.scope;\n          t.scope = (e || \"\").split(\"\u001f\").slice(1).join(\"\u001f\"), c = i.evaluate(t), t.scope = e;\n        }\n        return n && (c = cn(n, c)), void 0 === c || void 0 === s && void 0 === o && void 0 === l || (\"number\" == typeof c ? c = hn(c, s, o, l) : Array.isArray(c) && (c = c.map(t => \"number\" == typeof t ? hn(t, s, o, l) : t))), void 0 !== i && void 0 !== c && a && !a.includes(c) && (c = u, n && (c = cn(n, c))), (n && n !== this.type || void 0 !== c && Ne(c) !== this.type) && (c = cn(this.type.kind, c)), c;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"config\", this.key];\n        return this.scope && t.concat(this.key), t;\n      }\n    }\n    var fn = pn;\n    function dn(t) {\n      if (t instanceof nr) {\n        if (\"get\" === t.name && 1 === t.args.length) return !1;\n        if (\"feature-state\" === t.name) return !1;\n        if (\"has\" === t.name && 1 === t.args.length) return !1;\n        if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n      if (t instanceof Ir) return !1;\n      if (t instanceof un) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !dn(t) && (e = !1);\n      }), e;\n    }\n    function mn(t) {\n      if (t instanceof nr && \"feature-state\" === t.name) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !mn(t) && (e = !1);\n      }), e;\n    }\n    function yn(t) {\n      if (t instanceof fn) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !yn(t) && (e = !1);\n      }), e;\n    }\n    function gn(t, e) {\n      if (t instanceof nr && e.indexOf(t.name) >= 0) return !1;\n      let r = !0;\n      return t.eachChild(t => {\n        r && !gn(t, e) && (r = !1);\n      }), r;\n    }\n    class xn {\n      constructor(t, e) {\n        this.type = e.type, this.name = t, this.boundExpression = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n        const r = t[1];\n        return e.scope.has(r) ? new xn(r, e.scope.get(r)) : e.error(`Unknown variable \"${r}\". Make sure \"${r}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n      }\n      evaluate(t) {\n        return this.boundExpression.evaluate(t);\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"var\", this.name];\n      }\n    }\n    var vn = xn;\n    class bn {\n      constructor(t, e = [], r, n = new ye(), i = [], a, s) {\n        this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r, this._scope = a, this.options = s;\n      }\n      parse(t, e, r, n, i = {}) {\n        return e || r ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n      }\n      _parse(t, e) {\n        function r(t, e, r) {\n          return \"assert\" === r ? new Ye(e, [t]) : \"coerce\" === r ? new Je(e, [t]) : t;\n        }\n        if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n          const n = \"string\" == typeof t[0] ? this.registry[t[0]] : void 0;\n          if (n) {\n            let i = n.parse(t, this);\n            if (!i) return null;\n            if (this.expectedType) {\n              const t = this.expectedType,\n                n = i.type;\n              if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== n.kind) {\n                if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== n.kind && \"string\" !== n.kind) {\n                  if (this.checkSubtype(t, n)) return null;\n                } else i = r(i, t, e.typeAnnotation || \"coerce\");\n              } else i = r(i, t, e.typeAnnotation || \"assert\");\n            }\n            if (!(i instanceof je) && \"resolvedImage\" !== i.type.kind && wn(i)) {\n              const t = new tr(this._scope, this.options);\n              try {\n                i = new je(i.type, i.evaluate(t));\n              } catch (t) {\n                return this.error(t.message), null;\n              }\n            }\n            return i;\n          }\n          return Je.parse([\"to-array\", t], this);\n        }\n        return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);\n      }\n      concat(t, e, r) {\n        const n = \"number\" == typeof t ? this.path.concat(t) : this.path,\n          i = r ? this.scope.concat(r) : this.scope;\n        return new bn(this.registry, n, e || null, i, this.errors, this._scope, this.options);\n      }\n      error(t, ...e) {\n        const r = `${this.key}${e.map(t => `[${t}]`).join(\"\")}`;\n        this.errors.push(new de(r, t));\n      }\n      checkSubtype(t, e) {\n        const r = ze(t, e);\n        return r && this.error(r), r;\n      }\n    }\n    var _n = bn;\n    function wn(t) {\n      if (t instanceof vn) return wn(t.boundExpression);\n      if (t instanceof nr && \"error\" === t.name) return !1;\n      if (t instanceof ir) return !1;\n      if (t instanceof Ir) return !1;\n      if (t instanceof un) return !1;\n      if (t instanceof fn) return !1;\n      const e = t instanceof Je || t instanceof Ye;\n      let r = !0;\n      return t.eachChild(t => {\n        r = e ? r && wn(t) : r && t instanceof je;\n      }), !!r && dn(t) && gn(t, [\"zoom\", \"heatmap-density\", \"line-progress\", \"raster-value\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\", \"measure-light\", \"raster-particle-speed\"]);\n    }\n    function Mn(t, e) {\n      const r = t.length - 1;\n      let n,\n        i,\n        a = 0,\n        s = r,\n        o = 0;\n      for (; a <= s;) if (o = Math.floor((a + s) / 2), n = t[o], i = t[o + 1], n <= e) {\n        if (o === r || e < i) return o;\n        a = o + 1;\n      } else {\n        if (!(n > e)) throw new qe(\"Input is not a number.\");\n        s = o - 1;\n      }\n      return 0;\n    }\n    class An {\n      constructor(t, e, r) {\n        this.type = t, this.input = e, this.labels = [], this.outputs = [];\n        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n      }\n      static parse(t, e) {\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        const r = e.parse(t[1], 1, xe);\n        if (!r) return null;\n        const n = [];\n        let i = null;\n        e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n        for (let r = 1; r < t.length; r += 2) {\n          const a = 1 === r ? -1 / 0 : t[r],\n            s = t[r + 1],\n            o = r,\n            l = r + 1;\n          if (\"number\" != typeof a) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);\n          if (n.length && n[n.length - 1][0] >= a) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', o);\n          const u = e.parse(s, l, i);\n          if (!u) return null;\n          i = i || u.type, n.push([a, u]);\n        }\n        return new An(i, r, n);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Mn(e, n)].evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"step\", this.input.serialize()];\n        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n        return t;\n      }\n    }\n    var Sn = An;\n    const In = .95047,\n      kn = 1.08883,\n      Pn = 4 / 29,\n      En = 6 / 29,\n      zn = 3 * En * En,\n      Tn = En * En * En,\n      Bn = Math.PI / 180,\n      Cn = 180 / Math.PI;\n    function Rn(t) {\n      return t > Tn ? Math.pow(t, 1 / 3) : t / zn + Pn;\n    }\n    function Dn(t) {\n      return t > En ? t * t * t : zn * (t - Pn);\n    }\n    function Vn(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n    function Ln(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n    function Fn(t) {\n      const e = Ln(t.r),\n        r = Ln(t.g),\n        n = Ln(t.b),\n        i = Rn((.4124564 * e + .3575761 * r + .1804375 * n) / In),\n        a = Rn((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * a - 16,\n        a: 500 * (i - a),\n        b: 200 * (a - Rn((.0193339 * e + .119192 * r + .9503041 * n) / kn)),\n        alpha: t.a\n      };\n    }\n    function Nn(t) {\n      let e = (t.l + 16) / 116,\n        r = isNaN(t.a) ? e : e + t.a / 500,\n        n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * Dn(e), r = In * Dn(r), n = kn * Dn(n), new le(Vn(3.2404542 * r - 1.5371385 * e - .4985314 * n), Vn(-.969266 * r + 1.8760108 * e + .041556 * n), Vn(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n    function On(t, e, r) {\n      const n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n    const Un = {\n        forward: Fn,\n        reverse: Nn,\n        interpolate: function (t, e, r) {\n          return {\n            l: ue(t.l, e.l, r),\n            a: ue(t.a, e.a, r),\n            b: ue(t.b, e.b, r),\n            alpha: ue(t.alpha, e.alpha, r)\n          };\n        }\n      },\n      jn = {\n        forward: function (t) {\n          const {\n              l: e,\n              a: r,\n              b: n\n            } = Fn(t),\n            i = Math.atan2(n, r) * Cn;\n          return {\n            h: i < 0 ? i + 360 : i,\n            c: Math.sqrt(r * r + n * n),\n            l: e,\n            alpha: t.a\n          };\n        },\n        reverse: function (t) {\n          const e = t.h * Bn,\n            r = t.c;\n          return Nn({\n            l: t.l,\n            a: Math.cos(e) * r,\n            b: Math.sin(e) * r,\n            alpha: t.alpha\n          });\n        },\n        interpolate: function (t, e, r) {\n          return {\n            h: On(t.h, e.h, r),\n            c: ue(t.c, e.c, r),\n            l: ue(t.l, e.l, r),\n            alpha: ue(t.alpha, e.alpha, r)\n          };\n        }\n      };\n    var qn = Object.freeze({\n      __proto__: null,\n      hcl: jn,\n      lab: Un\n    });\n    class $n {\n      constructor(t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n      }\n      static interpolationFactor(t, e, r, n) {\n        let i = 0;\n        if (\"exponential\" === t.name) i = Gn(e, t.base, r, n);else if (\"linear\" === t.name) i = Gn(e, 1, r, n);else if (\"cubic-bezier\" === t.name) {\n          const a = t.controlPoints;\n          i = new d(a[0], a[1], a[2], a[3]).solve(Gn(e, 1, r, n));\n        }\n        return i;\n      }\n      static parse(t, e) {\n        let [r, n, i, ...a] = t;\n        if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n        if (\"linear\" === n[0]) n = {\n          name: \"linear\"\n        };else if (\"exponential\" === n[0]) {\n          const t = n[1];\n          if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n          n = {\n            name: \"exponential\",\n            base: t\n          };\n        } else {\n          if (\"cubic-bezier\" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);\n          {\n            const t = n.slice(1);\n            if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n            n = {\n              name: \"cubic-bezier\",\n              controlPoints: t\n            };\n          }\n        }\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        if (i = e.parse(i, 2, xe), !i) return null;\n        const s = [];\n        let o = null;\n        \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? o = _e : e.expectedType && \"value\" !== e.expectedType.kind && (o = e.expectedType);\n        for (let t = 0; t < a.length; t += 2) {\n          const r = a[t],\n            n = a[t + 1],\n            i = t + 3,\n            l = t + 4;\n          if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n          if (s.length && s[s.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n          const u = e.parse(n, l, o);\n          if (!u) return null;\n          o = o || u.type, s.push([r, u]);\n        }\n        return \"number\" === o.kind || \"color\" === o.kind || \"array\" === o.kind && \"number\" === o.itemType.kind && \"number\" == typeof o.N ? new $n(o, r, n, i, s) : e.error(`Type ${Pe(o)} is not interpolatable.`);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n        const a = Mn(e, n),\n          s = $n.interpolationFactor(this.interpolation, n, e[a], e[a + 1]),\n          o = r[a].evaluate(t),\n          l = r[a + 1].evaluate(t);\n        return \"interpolate\" === this.operator ? he[this.type.kind.toLowerCase()](o, l, s) : \"interpolate-hcl\" === this.operator ? jn.reverse(jn.interpolate(jn.forward(o), jn.forward(l), s)) : Un.reverse(Un.interpolate(Un.forward(o), Un.forward(l), s));\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        let t;\n        t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\"].concat(this.interpolation.controlPoints);\n        const e = [this.operator, t, this.input.serialize()];\n        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n        return e;\n      }\n    }\n    function Gn(t, e, r, n) {\n      const i = n - r,\n        a = t - r;\n      return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n    }\n    var Yn = $n;\n    class Xn {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n        let r = null;\n        const n = e.expectedType;\n        n && \"value\" !== n.kind && (r = n);\n        const i = [];\n        for (const n of t.slice(1)) {\n          const t = e.parse(n, 1 + i.length, r, void 0, {\n            typeAnnotation: \"omit\"\n          });\n          if (!t) return null;\n          r = r || t.type, i.push(t);\n        }\n        const a = n && i.some(t => ze(n, t.type));\n        return new Xn(a ? Me : r, i);\n      }\n      evaluate(t) {\n        let e,\n          r = null,\n          n = 0;\n        for (const i of this.args) {\n          if (n++, r = i.evaluate(t), r && r instanceof Ve && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;\n          if (null !== r) break;\n        }\n        return r;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"coalesce\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    var Zn = Xn;\n    class Kn {\n      constructor(t, e) {\n        this.type = e.type, this.bindings = [].concat(t), this.result = e;\n      }\n      evaluate(t) {\n        return this.result.evaluate(t);\n      }\n      eachChild(t) {\n        for (const e of this.bindings) t(e[1]);\n        t(this.result);\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);\n        const r = [];\n        for (let n = 1; n < t.length - 1; n += 2) {\n          const i = t[n];\n          if (\"string\" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);\n          if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n          const a = e.parse(t[n + 1], n + 1);\n          if (!a) return null;\n          r.push([i, a]);\n        }\n        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n        return n ? new Kn(r, n) : null;\n      }\n      outputDefined() {\n        return this.result.outputDefined();\n      }\n      serialize() {\n        const t = [\"let\"];\n        for (const [e, r] of this.bindings) t.push(e, r.serialize());\n        return t.push(this.result.serialize()), t;\n      }\n    }\n    var Hn = Kn;\n    class Wn {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, xe),\n          n = e.parse(t[2], 2, ke(e.expectedType || Me));\n        return r && n ? new Wn(n.type.itemType, r, n) : null;\n      }\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n        if (e < 0) throw new qe(`Array index out of bounds: ${e} < 0.`);\n        if (e >= r.length) throw new qe(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n        if (e !== Math.floor(e)) throw new qe(`Array index must be an integer, but found ${e} instead.`);\n        return r[e];\n      }\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n      }\n    }\n    var Jn = Wn;\n    class Qn {\n      constructor(t, e) {\n        this.type = be, this.needle = t, this.haystack = e;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Me),\n          n = e.parse(t[2], 2, Me);\n        return r && n ? Te(r.type, [be, ve, xe, ge, Me]) ? new Qn(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(r.type)} instead`) : null;\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (null == r) return !1;\n        if (!Be(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new qe(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(Ne(e))} instead.`);\n        if (!Be(r, [\"string\", \"array\"])) throw new qe(`Expected second argument to be of type array or string, but found ${Pe(Ne(r))} instead.`);\n        return r.indexOf(e) >= 0;\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack);\n      }\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    var ti = Qn;\n    class ei {\n      constructor(t, e, r) {\n        this.type = xe, this.needle = t, this.haystack = e, this.fromIndex = r;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Me),\n          n = e.parse(t[2], 2, Me);\n        if (!r || !n) return null;\n        if (!Te(r.type, [be, ve, xe, ge, Me])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(r.type)} instead`);\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, xe);\n          return i ? new ei(r, n, i) : null;\n        }\n        return new ei(r, n);\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (!Be(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new qe(`Expected first argument to be of type boolean, string, number or null, but found ${Pe(Ne(e))} instead.`);\n        if (!Be(r, [\"string\", \"array\"])) throw new qe(`Expected second argument to be of type array or string, but found ${Pe(Ne(r))} instead.`);\n        if (this.fromIndex) {\n          const n = this.fromIndex.evaluate(t);\n          return r.indexOf(e, n);\n        }\n        return r.indexOf(e);\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.fromIndex && void 0 !== this.fromIndex) {\n          const t = this.fromIndex.serialize();\n          return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n        }\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    var ri = ei;\n    class ni {\n      constructor(t, e, r, n, i, a) {\n        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = a;\n      }\n      static parse(t, e) {\n        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n        let r, n;\n        e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n        const i = {},\n          a = [];\n        for (let s = 2; s < t.length - 1; s += 2) {\n          let o = t[s];\n          const l = t[s + 1];\n          Array.isArray(o) || (o = [o]);\n          const u = e.concat(s);\n          if (0 === o.length) return u.error(\"Expected at least one branch label.\");\n          for (const t of o) {\n            if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n            if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n            if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n            if (r) {\n              if (u.checkSubtype(r, Ne(t))) return null;\n            } else r = Ne(t);\n            if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n            i[String(t)] = a.length;\n          }\n          const c = e.parse(l, s, n);\n          if (!c) return null;\n          n = n || c.type, a.push(c);\n        }\n        const s = e.parse(t[1], 1, Me);\n        if (!s) return null;\n        const o = e.parse(t[t.length - 1], t.length - 1, n);\n        return o ? \"value\" !== s.type.kind && e.concat(1).checkSubtype(r, s.type) ? null : new ni(r, n, s, i, a, o) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        return (Ne(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input), this.outputs.forEach(t), t(this.otherwise);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"match\", this.input.serialize()],\n          e = Object.keys(this.cases).sort(),\n          r = [],\n          n = {};\n        for (const t of e) {\n          const e = n[this.cases[t]];\n          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n        }\n        const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n        return t.push(this.otherwise.serialize()), t;\n      }\n    }\n    var ii = ni;\n    class ai {\n      constructor(t, e, r) {\n        this.type = t, this.branches = e, this.otherwise = r;\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n        let r;\n        e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n        const n = [];\n        for (let i = 1; i < t.length - 1; i += 2) {\n          const a = e.parse(t[i], i, be);\n          if (!a) return null;\n          const s = e.parse(t[i + 1], i + 1, r);\n          if (!s) return null;\n          n.push([a, s]), r = r || s.type;\n        }\n        const i = e.parse(t[t.length - 1], t.length - 1, r);\n        return i ? new ai(r, n, i) : null;\n      }\n      evaluate(t) {\n        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n        return this.otherwise.evaluate(t);\n      }\n      eachChild(t) {\n        for (const [e, r] of this.branches) t(e), t(r);\n        t(this.otherwise);\n      }\n      outputDefined() {\n        return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"case\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    var si = ai;\n    class oi {\n      constructor(t, e, r, n) {\n        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Me),\n          n = e.parse(t[2], 2, xe);\n        if (!r || !n) return null;\n        if (!Te(r.type, [ke(Me), ve, Me])) return e.error(`Expected first argument to be of type array or string, but found ${Pe(r.type)} instead`);\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, xe);\n          return i ? new oi(r.type, r, n, i) : null;\n        }\n        return new oi(r.type, r, n);\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n          r = this.beginIndex.evaluate(t);\n        if (!Be(e, [\"string\", \"array\"])) throw new qe(`Expected first argument to be of type array or string, but found ${Pe(Ne(e))} instead.`);\n        if (this.endIndex) {\n          const n = this.endIndex.evaluate(t);\n          return e.slice(r, n);\n        }\n        return e.slice(r);\n      }\n      eachChild(t) {\n        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.endIndex && void 0 !== this.endIndex) {\n          const t = this.endIndex.serialize();\n          return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n        }\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n      }\n    }\n    var li = oi;\n    function ui(t, e) {\n      return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n    }\n    function ci(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n    function hi(t, e, r) {\n      const n = \"==\" !== t && \"!=\" !== t;\n      return class i {\n        constructor(t, e, r) {\n          this.type = be, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n        }\n        static parse(t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n          const r = t[0];\n          let a = e.parse(t[1], 1, Me);\n          if (!a) return null;\n          if (!ui(r, a.type)) return e.concat(1).error(`\"${r}\" comparisons are not supported for type '${Pe(a.type)}'.`);\n          let s = e.parse(t[2], 2, Me);\n          if (!s) return null;\n          if (!ui(r, s.type)) return e.concat(2).error(`\"${r}\" comparisons are not supported for type '${Pe(s.type)}'.`);\n          if (a.type.kind !== s.type.kind && \"value\" !== a.type.kind && \"value\" !== s.type.kind) return e.error(`Cannot compare types '${Pe(a.type)}' and '${Pe(s.type)}'.`);\n          n && (\"value\" === a.type.kind && \"value\" !== s.type.kind ? a = new Ye(s.type, [a]) : \"value\" !== a.type.kind && \"value\" === s.type.kind && (s = new Ye(a.type, [s])));\n          let o = null;\n          if (4 === t.length) {\n            if (\"string\" !== a.type.kind && \"string\" !== s.type.kind && \"value\" !== a.type.kind && \"value\" !== s.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n            if (o = e.parse(t[3], 3, Ae), !o) return null;\n          }\n          return new i(a, s, o);\n        }\n        evaluate(i) {\n          const a = this.lhs.evaluate(i),\n            s = this.rhs.evaluate(i);\n          if (n && this.hasUntypedArgument) {\n            const e = Ne(a),\n              r = Ne(s);\n            if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new qe(`Expected arguments for \"${t}\" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);\n          }\n          if (this.collator && !n && this.hasUntypedArgument) {\n            const t = Ne(a),\n              r = Ne(s);\n            if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, a, s);\n          }\n          return this.collator ? r(i, a, s, this.collator.evaluate(i)) : e(i, a, s);\n        }\n        eachChild(t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }\n        outputDefined() {\n          return !0;\n        }\n        serialize() {\n          const e = [t];\n          return this.eachChild(t => {\n            e.push(t.serialize());\n          }), e;\n        }\n      };\n    }\n    const pi = hi(\"==\", function (t, e, r) {\n        return e === r;\n      }, ci),\n      fi = hi(\"!=\", function (t, e, r) {\n        return e !== r;\n      }, function (t, e, r, n) {\n        return !ci(0, e, r, n);\n      }),\n      di = hi(\"<\", function (t, e, r) {\n        return e < r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) < 0;\n      }),\n      mi = hi(\">\", function (t, e, r) {\n        return e > r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) > 0;\n      }),\n      yi = hi(\"<=\", function (t, e, r) {\n        return e <= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) <= 0;\n      }),\n      gi = hi(\">=\", function (t, e, r) {\n        return e >= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) >= 0;\n      });\n    class xi {\n      constructor(t, e, r, n, i, a) {\n        this.type = ve, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = a;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, xe);\n        if (!r) return null;\n        const n = t[2];\n        if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n        let i = null;\n        if (n.locale && (i = e.parse(n.locale, 1, ve), !i)) return null;\n        let a = null;\n        if (n.currency && (a = e.parse(n.currency, 1, ve), !a)) return null;\n        let s = null;\n        if (n.unit && (s = e.parse(n.unit, 1, ve), !s)) return null;\n        let o = null;\n        if (n[\"min-fraction-digits\"] && (o = e.parse(n[\"min-fraction-digits\"], 1, xe), !o)) return null;\n        let l = null;\n        return n[\"max-fraction-digits\"] && (l = e.parse(n[\"max-fraction-digits\"], 1, xe), !l) ? null : new xi(r, i, a, s, o, l);\n      }\n      evaluate(t) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n          style: (this.currency ? \"currency\" : this.unit && \"unit\") || \"decimal\",\n          currency: this.currency ? this.currency.evaluate(t) : void 0,\n          unit: this.unit ? this.unit.evaluate(t) : void 0,\n          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n        }).format(this.number.evaluate(t));\n      }\n      eachChild(t) {\n        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n      }\n    }\n    class vi {\n      constructor(t) {\n        this.type = xe, this.input = t;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1);\n        return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${Pe(r.type)} instead.`) : new vi(r) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        if (\"string\" == typeof e) return e.length;\n        if (Array.isArray(e)) return e.length;\n        throw new qe(`Expected value to be of type string or array, but found ${Pe(Ne(e))} instead.`);\n      }\n      eachChild(t) {\n        t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"length\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    function bi(t) {\n      return function () {\n        t = 1831565813 + (t |= 0) | 0;\n        let e = Math.imul(t ^ t >>> 15, 1 | t);\n        return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;\n      };\n    }\n    const _i = {\n      \"==\": pi,\n      \"!=\": fi,\n      \">\": mi,\n      \"<\": di,\n      \">=\": gi,\n      \"<=\": yi,\n      array: Ye,\n      at: Jn,\n      boolean: Ye,\n      case: si,\n      coalesce: Zn,\n      collator: ir,\n      format: Xe,\n      image: Ze,\n      in: ti,\n      \"index-of\": ri,\n      interpolate: Yn,\n      \"interpolate-hcl\": Yn,\n      \"interpolate-lab\": Yn,\n      length: vi,\n      let: Hn,\n      literal: je,\n      match: ii,\n      number: Ye,\n      \"number-format\": xi,\n      object: Ye,\n      slice: li,\n      step: Sn,\n      string: Ye,\n      \"to-boolean\": Je,\n      \"to-color\": Je,\n      \"to-number\": Je,\n      \"to-string\": Je,\n      var: vn,\n      within: Ir,\n      distance: un,\n      config: fn\n    };\n    function wi(t, [e, r, n, i]) {\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const a = i ? i.evaluate(t) : 1,\n        s = Le(e, r, n, a);\n      if (s) throw new qe(s);\n      return new le(e / 255 * a, r / 255 * a, n / 255 * a, a);\n    }\n    function Mi(t, [e, r, n, i]) {\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const a = i ? i.evaluate(t) : 1,\n        s = function (t, e, r, n) {\n          return \"number\" == typeof t && t >= 0 && t <= 360 ? \"number\" == typeof e && e >= 0 && e <= 100 && \"number\" == typeof r && r >= 0 && r <= 100 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid hsla value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'h' must be between 0 and 360.`;\n        }(e, r, n, a);\n      if (s) throw new qe(s);\n      const o = `hsla(${e}, ${r}%, ${n}%, ${a})`,\n        l = le.parse(o);\n      if (!l) throw new qe(`Failed to parse HSLA color: ${o}`);\n      return l;\n    }\n    function Ai(t, e) {\n      return t in e;\n    }\n    function Si(t, e) {\n      const r = e[t];\n      return void 0 === r ? null : r;\n    }\n    function Ii(t) {\n      return {\n        type: t\n      };\n    }\n    nr.register(_i, {\n      error: [{\n        kind: \"error\"\n      }, [ve], (t, [e]) => {\n        throw new qe(e.evaluate(t));\n      }],\n      typeof: [ve, [Me], (t, [e]) => Pe(Ne(e.evaluate(t)))],\n      \"to-rgba\": [ke(xe, 4), [_e], (t, [e]) => e.evaluate(t).toArray()],\n      rgb: [_e, [xe, xe, xe], wi],\n      rgba: [_e, [xe, xe, xe, xe], wi],\n      hsl: [_e, [xe, xe, xe], Mi],\n      hsla: [_e, [xe, xe, xe, xe], Mi],\n      has: {\n        type: be,\n        overloads: [[[ve], (t, [e]) => Ai(e.evaluate(t), t.properties())], [[ve, we], (t, [e, r]) => Ai(e.evaluate(t), r.evaluate(t))]]\n      },\n      get: {\n        type: Me,\n        overloads: [[[ve], (t, [e]) => Si(e.evaluate(t), t.properties())], [[ve, we], (t, [e, r]) => Si(e.evaluate(t), r.evaluate(t))]]\n      },\n      \"feature-state\": [Me, [ve], (t, [e]) => Si(e.evaluate(t), t.featureState || {})],\n      properties: [we, [], t => t.properties()],\n      \"geometry-type\": [ve, [], t => t.geometryType()],\n      id: [Me, [], t => t.id()],\n      zoom: [xe, [], t => t.globals.zoom],\n      pitch: [xe, [], t => t.globals.pitch || 0],\n      \"distance-from-center\": [xe, [], t => t.distanceFromCenter()],\n      \"measure-light\": [xe, [ve], (t, [e]) => t.measureLight(e.evaluate(t))],\n      \"heatmap-density\": [xe, [], t => t.globals.heatmapDensity || 0],\n      \"line-progress\": [xe, [], t => t.globals.lineProgress || 0],\n      \"raster-value\": [xe, [], t => t.globals.rasterValue || 0],\n      \"raster-particle-speed\": [xe, [], t => t.globals.rasterParticleSpeed || 0],\n      \"sky-radial-progress\": [xe, [], t => t.globals.skyRadialProgress || 0],\n      accumulated: [Me, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n      \"+\": [xe, Ii(xe), (t, e) => {\n        let r = 0;\n        for (const n of e) r += n.evaluate(t);\n        return r;\n      }],\n      \"*\": [xe, Ii(xe), (t, e) => {\n        let r = 1;\n        for (const n of e) r *= n.evaluate(t);\n        return r;\n      }],\n      \"-\": {\n        type: xe,\n        overloads: [[[xe, xe], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[xe], (t, [e]) => -e.evaluate(t)]]\n      },\n      \"/\": [xe, [xe, xe], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],\n      \"%\": [xe, [xe, xe], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],\n      ln2: [xe, [], () => Math.LN2],\n      pi: [xe, [], () => Math.PI],\n      e: [xe, [], () => Math.E],\n      \"^\": [xe, [xe, xe], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],\n      sqrt: [xe, [xe], (t, [e]) => Math.sqrt(e.evaluate(t))],\n      log10: [xe, [xe], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],\n      ln: [xe, [xe], (t, [e]) => Math.log(e.evaluate(t))],\n      log2: [xe, [xe], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],\n      sin: [xe, [xe], (t, [e]) => Math.sin(e.evaluate(t))],\n      cos: [xe, [xe], (t, [e]) => Math.cos(e.evaluate(t))],\n      tan: [xe, [xe], (t, [e]) => Math.tan(e.evaluate(t))],\n      asin: [xe, [xe], (t, [e]) => Math.asin(e.evaluate(t))],\n      acos: [xe, [xe], (t, [e]) => Math.acos(e.evaluate(t))],\n      atan: [xe, [xe], (t, [e]) => Math.atan(e.evaluate(t))],\n      min: [xe, Ii(xe), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n      max: [xe, Ii(xe), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n      abs: [xe, [xe], (t, [e]) => Math.abs(e.evaluate(t))],\n      round: [xe, [xe], (t, [e]) => {\n        const r = e.evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [xe, [xe], (t, [e]) => Math.floor(e.evaluate(t))],\n      ceil: [xe, [xe], (t, [e]) => Math.ceil(e.evaluate(t))],\n      \"filter-==\": [be, [ve, Me], (t, [e, r]) => t.properties()[e.value] === r.value],\n      \"filter-id-==\": [be, [Me], (t, [e]) => t.id() === e.value],\n      \"filter-type-==\": [be, [ve], (t, [e]) => t.geometryType() === e.value],\n      \"filter-<\": [be, [ve, Me], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      \"filter-id-<\": [be, [Me], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r < n;\n      }],\n      \"filter->\": [be, [ve, Me], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      \"filter-id->\": [be, [Me], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r > n;\n      }],\n      \"filter-<=\": [be, [ve, Me], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      \"filter-id-<=\": [be, [Me], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r <= n;\n      }],\n      \"filter->=\": [be, [ve, Me], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      \"filter-id->=\": [be, [Me], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r >= n;\n      }],\n      \"filter-has\": [be, [Me], (t, [e]) => e.value in t.properties()],\n      \"filter-has-id\": [be, [], t => null !== t.id() && void 0 !== t.id()],\n      \"filter-type-in\": [be, [ke(ve)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],\n      \"filter-id-in\": [be, [ke(Me)], (t, [e]) => e.value.indexOf(t.id()) >= 0],\n      \"filter-in-small\": [be, [ve, ke(Me)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],\n      \"filter-in-large\": [be, [ve, ke(Me)], (t, [e, r]) => function (t, e, r, n) {\n        for (; r <= n;) {\n          const i = r + n >> 1;\n          if (e[i] === t) return !0;\n          e[i] > t ? n = i - 1 : r = i + 1;\n        }\n        return !1;\n      }(t.properties()[e.value], r.value, 0, r.value.length - 1)],\n      all: {\n        type: be,\n        overloads: [[[be, be], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Ii(be), (t, e) => {\n          for (const r of e) if (!r.evaluate(t)) return !1;\n          return !0;\n        }]]\n      },\n      any: {\n        type: be,\n        overloads: [[[be, be], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Ii(be), (t, e) => {\n          for (const r of e) if (r.evaluate(t)) return !0;\n          return !1;\n        }]]\n      },\n      \"!\": [be, [be], (t, [e]) => !e.evaluate(t)],\n      \"is-supported-script\": [be, [ve], (t, [e]) => {\n        const r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e.evaluate(t));\n      }],\n      upcase: [ve, [ve], (t, [e]) => e.evaluate(t).toUpperCase()],\n      downcase: [ve, [ve], (t, [e]) => e.evaluate(t).toLowerCase()],\n      concat: [ve, Ii(Me), (t, e) => e.map(e => Oe(e.evaluate(t))).join(\"\")],\n      \"resolved-locale\": [ve, [Ae], (t, [e]) => e.evaluate(t).resolvedLocale()],\n      random: [xe, [xe, xe, Me], (t, e) => {\n        const [r, n, i] = e.map(e => e.evaluate(t));\n        if (r > n) return r;\n        if (r === n) return r;\n        let a;\n        if (\"string\" == typeof i) a = function (t) {\n          let e = 0;\n          if (0 === t.length) return e;\n          for (let r = 0; r < t.length; r++) e = (e << 5) - e + t.charCodeAt(r), e |= 0;\n          return e;\n        }(i);else {\n          if (\"number\" != typeof i) throw new qe(`Invalid seed input: ${i}`);\n          a = i;\n        }\n        return r + bi(a)() * (n - r);\n      }]\n    });\n    var ki = _i;\n    function Pi(t) {\n      return {\n        result: \"success\",\n        value: t\n      };\n    }\n    function Ei(t) {\n      return {\n        result: \"error\",\n        value: t\n      };\n    }\n    function zi(t, e) {\n      return !!t && !!t.parameters && t.parameters.indexOf(e) > -1;\n    }\n    function Ti(t) {\n      return \"data-driven\" === t[\"property-type\"];\n    }\n    function Bi(t) {\n      return zi(t.expression, \"measure-light\");\n    }\n    function Ci(t) {\n      return zi(t.expression, \"zoom\");\n    }\n    function Ri(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n    function Di(t) {\n      return \"object\" == typeof t && null !== t && !Array.isArray(t);\n    }\n    function Vi(t) {\n      return t;\n    }\n    function Li(t, e) {\n      const r = \"color\" === e.type,\n        n = t.stops && \"object\" == typeof t.stops[0][0],\n        i = n || !(n || void 0 !== t.property),\n        a = t.type || (Ri(e) ? \"exponential\" : \"interval\");\n      if (r && ((t = pe({}, t)).stops && (t.stops = t.stops.map(t => [t[0], le.parse(t[1])])), t.default = le.parse(t.default ? t.default : e.default)), t.colorSpace && \"rgb\" !== t.colorSpace && !qn[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);\n      let s, o, l;\n      if (\"exponential\" === a) s = Ui;else if (\"interval\" === a) s = Oi;else if (\"categorical\" === a) {\n        s = Ni, o = Object.create(null);\n        for (const e of t.stops) o[e[0]] = e[1];\n        l = typeof t.stops[0][0];\n      } else {\n        if (\"identity\" !== a) throw new Error(`Unknown function type \"${a}\"`);\n        s = ji;\n      }\n      if (n) {\n        const r = {},\n          n = [];\n        for (let e = 0; e < t.stops.length; e++) {\n          const i = t.stops[e],\n            a = i[0].zoom;\n          void 0 === r[a] && (r[a] = {\n            zoom: a,\n            type: t.type,\n            property: t.property,\n            default: t.default,\n            stops: []\n          }, n.push(a)), r[a].stops.push([i[0].value, i[1]]);\n        }\n        const i = [];\n        for (const t of n) i.push([r[t].zoom, Li(r[t], e)]);\n        const a = {\n          name: \"linear\"\n        };\n        return {\n          kind: \"composite\",\n          interpolationType: a,\n          interpolationFactor: Yn.interpolationFactor.bind(void 0, a),\n          zoomStops: i.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }, n) => Ui({\n            stops: i,\n            base: t.base\n          }, e, r).evaluate(r, n)\n        };\n      }\n      if (i) {\n        const r = \"exponential\" === a ? {\n          name: \"exponential\",\n          base: void 0 !== t.base ? t.base : 1\n        } : null;\n        return {\n          kind: \"camera\",\n          interpolationType: r,\n          interpolationFactor: Yn.interpolationFactor.bind(void 0, r),\n          zoomStops: t.stops.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }) => s(t, e, r, o, l)\n        };\n      }\n      return {\n        kind: \"source\",\n        evaluate(r, n) {\n          const i = n && n.properties ? n.properties[t.property] : void 0;\n          return void 0 === i ? Fi(t.default, e.default) : s(t, e, i, o, l);\n        }\n      };\n    }\n    function Fi(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n    function Ni(t, e, r, n, i) {\n      return Fi(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n    function Oi(t, e, r) {\n      if (\"number\" !== Ke(r)) return Fi(t.default, e.default);\n      const n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      const i = Mn(t.stops.map(t => t[0]), r);\n      return t.stops[i][1];\n    }\n    function Ui(t, e, r) {\n      const n = void 0 !== t.base ? t.base : 1;\n      if (\"number\" !== Ke(r)) return Fi(t.default, e.default);\n      const i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n      const a = Mn(t.stops.map(t => t[0]), r),\n        s = function (t, e, r, n) {\n          const i = n - r,\n            a = t - r;\n          return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);\n        }(r, n, t.stops[a][0], t.stops[a + 1][0]),\n        o = t.stops[a][1],\n        l = t.stops[a + 1][1];\n      let u = he[e.type] || Vi;\n      if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n        const e = qn[t.colorSpace];\n        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), s));\n      }\n      return \"function\" == typeof o.evaluate ? {\n        evaluate(...t) {\n          const e = o.evaluate.apply(void 0, t),\n            r = l.evaluate.apply(void 0, t);\n          if (void 0 !== e && void 0 !== r) return u(e, r, s);\n        }\n      } : u(o, l, s);\n    }\n    function ji(t, e, r) {\n      return \"color\" === e.type ? r = le.parse(r) : \"formatted\" === e.type ? r = De.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = Ve.fromString(r.toString()) : Ke(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), Fi(r, t.default, e.default);\n    }\n    class qi {\n      constructor(t, e, r, n) {\n        this.expression = t, this._warningHistory = {}, this._evaluator = new tr(r, n), this._defaultValue = e ? function (t) {\n          return \"color\" === t.type && (Di(t.default) || Array.isArray(t.default)) ? new le(0, 0, 0, 0) : \"color\" === t.type ? le.parse(t.default) || null : void 0 === t.default ? null : t.default;\n        }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null;\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, a, s, o) {\n        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);\n      }\n      evaluate(t, e, r, n, i, a, s, o) {\n        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = o || null;\n        try {\n          const t = this.expression.evaluate(this._evaluator);\n          if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n          if (this._enumValues && !(t in this._enumValues)) throw new qe(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \")}, but found ${JSON.stringify(t)} instead.`);\n          return t;\n        } catch (t) {\n          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(t.message)), this._defaultValue;\n        }\n      }\n    }\n    function $i(t) {\n      return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in ki;\n    }\n    function Gi(t, e, r, n) {\n      const i = new _n(ki, [], e ? function (t) {\n          const e = {\n            color: _e,\n            string: ve,\n            number: xe,\n            enum: ve,\n            boolean: be,\n            formatted: Se,\n            resolvedImage: Ie\n          };\n          return \"array\" === t.type ? ke(e[t.value] || Me, t.length) : e[t.type];\n        }(e) : void 0, void 0, void 0, r, n),\n        a = i.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n          typeAnnotation: \"coerce\"\n        } : void 0);\n      return a ? Pi(new qi(a, e, r, n)) : Ei(i.errors);\n    }\n    class Yi {\n      constructor(t, e, r) {\n        this.kind = t, this._styleExpression = e, this.isLightConstant = r, this.isStateDependent = \"constant\" !== t && !mn(e.expression), this.isConfigDependent = !yn(e.expression);\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, a) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n      }\n      evaluate(t, e, r, n, i, a) {\n        return this._styleExpression.evaluate(t, e, r, n, i, a);\n      }\n    }\n    class Xi {\n      constructor(t, e, r, n, i) {\n        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !mn(e.expression), this.isLightConstant = i, this.isConfigDependent = !yn(e.expression), this.interpolationType = n;\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, a) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, a);\n      }\n      evaluate(t, e, r, n, i, a) {\n        return this._styleExpression.evaluate(t, e, r, n, i, a);\n      }\n      interpolationFactor(t, e, r) {\n        return this.interpolationType ? Yn.interpolationFactor(this.interpolationType, t, e, r) : 0;\n      }\n    }\n    function Zi(t, e, r, n) {\n      if (\"error\" === (t = Gi(t, e, r, n)).result) return t;\n      const i = t.value.expression,\n        a = dn(i);\n      if (!a && !Ti(e)) return Ei([new de(\"\", \"data expressions not supported\")]);\n      const s = gn(i, [\"zoom\", \"pitch\", \"distance-from-center\"]);\n      if (!s && !Ci(e)) return Ei([new de(\"\", \"zoom expressions not supported\")]);\n      const o = gn(i, [\"measure-light\"]);\n      if (!o && !Bi(e)) return Ei([new de(\"\", \"measure-light expression not supported\")]);\n      const l = e.expression && e.expression.relaxZoomRestriction,\n        u = Hi(i);\n      return u || s || l ? u instanceof de ? Ei([u]) : u instanceof Yn && !Ri(e) ? Ei([new de(\"\", '\"interpolate\" expressions cannot be used with this property')]) : Pi(u ? new Xi(a ? \"camera\" : \"composite\", t.value, u.labels, u instanceof Yn ? u.interpolation : void 0, o) : new Yi(a ? \"constant\" : \"source\", t.value, o)) : Ei([new de(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression, or in the properties of atmosphere.')]);\n    }\n    class Ki {\n      constructor(t, e) {\n        this._parameters = t, this._specification = e, pe(this, Li(this._parameters, this._specification));\n      }\n      static deserialize(t) {\n        return new Ki(t._parameters, t._specification);\n      }\n      static serialize(t) {\n        return {\n          _parameters: t._parameters,\n          _specification: t._specification\n        };\n      }\n    }\n    function Hi(t) {\n      let e = null;\n      if (t instanceof Hn) e = Hi(t.result);else if (t instanceof Zn) {\n        for (const r of t.args) if (e = Hi(r), e) break;\n      } else (t instanceof Sn || t instanceof Yn) && t.input instanceof nr && \"zoom\" === t.input.name && (e = t);\n      return e instanceof de || t.eachChild(t => {\n        const r = Hi(t);\n        r instanceof de ? e = r : e && r && e !== r && (e = new de(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), e;\n    }\n    var Wi = Qi,\n      Ji = 3;\n    function Qi(t, e, r) {\n      var n = this.cells = [];\n      if (t instanceof ArrayBuffer) {\n        this.arrayBuffer = t;\n        var i = new Int32Array(this.arrayBuffer);\n        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n        for (var a = 0; a < this.d * this.d; a++) {\n          var s = i[Ji + a],\n            o = i[Ji + a + 1];\n          n.push(s === o ? null : i.subarray(s, o));\n        }\n        var l = i[Ji + n.length + 1];\n        this.keys = i.subarray(i[Ji + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;\n      } else {\n        this.d = e + 2 * r;\n        for (var u = 0; u < this.d * this.d; u++) n.push([]);\n        this.keys = [], this.bboxes = [];\n      }\n      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n      var c = r / e * t;\n      this.min = -c, this.max = t + c;\n    }\n    Qi.prototype.insert = function (t, e, r, n, i) {\n      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n    }, Qi.prototype._insertReadonly = function () {\n      throw \"Cannot insert into a GridIndex created from an ArrayBuffer.\";\n    }, Qi.prototype._insertCell = function (t, e, r, n, i, a) {\n      this.cells[i].push(a);\n    }, Qi.prototype.query = function (t, e, r, n, i) {\n      var a = this.min,\n        s = this.max;\n      if (t <= a && e <= a && s <= r && s <= n && !i) return Array.prototype.slice.call(this.keys);\n      var o = [];\n      return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;\n    }, Qi.prototype._queryCell = function (t, e, r, n, i, a, s, o) {\n      var l = this.cells[i];\n      if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {\n        var p = l[h];\n        if (void 0 === s[p]) {\n          var f = 4 * p;\n          (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (s[p] = !0, a.push(u[p])) : s[p] = !1;\n        }\n      }\n    }, Qi.prototype._forEachCell = function (t, e, r, n, i, a, s, o) {\n      for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {\n        var d = this.d * f + p;\n        if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, a, s, o)) return;\n      }\n    }, Qi.prototype._convertFromCellCoord = function (t) {\n      return (t - this.padding) / this.scale;\n    }, Qi.prototype._convertToCellCoord = function (t) {\n      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n    }, Qi.prototype.toArrayBuffer = function () {\n      if (this.arrayBuffer) return this.arrayBuffer;\n      for (var t = this.cells, e = Ji + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;\n      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n      for (var a = e, s = 0; s < t.length; s++) {\n        var o = t[s];\n        i[Ji + s] = a, i.set(o, a), a += o.length;\n      }\n      return i[Ji + t.length] = a, i.set(this.keys, a), i[Ji + t.length + 1] = a += this.keys.length, i.set(this.bboxes, a), a += this.bboxes.length, i.buffer;\n    };\n    var ta = h(Wi);\n    const ea = {};\n    function ra(t, e, r = {}) {\n      Object.defineProperty(t, \"_classRegistryKey\", {\n        value: e,\n        writeable: !1\n      }), ea[e] = {\n        klass: t,\n        omit: r.omit || []\n      };\n    }\n    ra(Object, \"Object\"), ta.serialize = function (t, e) {\n      const r = t.toArrayBuffer();\n      return e && e.add(r), {\n        buffer: r\n      };\n    }, ta.deserialize = function (t) {\n      return new ta(t.buffer);\n    }, Object.defineProperty(ta, \"name\", {\n      value: \"Grid\"\n    }), ra(ta, \"Grid\"), ra(le, \"Color\"), ra(Error, \"Error\"), ra(De, \"Formatted\"), ra(Re, \"FormattedSection\"), ra(St, \"AJAXError\"), ra(Ve, \"ResolvedImage\"), ra(Ki, \"StylePropertyFunction\"), ra(qi, \"StyleExpression\", {\n      omit: [\"_evaluator\"]\n    }), ra(Xi, \"ZoomDependentExpression\"), ra(Yi, \"ZoomConstantExpression\"), ra(nr, \"CompoundExpression\", {\n      omit: [\"_evaluate\"]\n    });\n    for (const t in ki) ea[ki[t]._classRegistryKey] || ra(ki[t], `Expression${t}`);\n    function na(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n    function ia(t) {\n      return self.ImageBitmap && t instanceof ImageBitmap;\n    }\n    function aa(t, e) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (na(t) || ia(t)) return e && e.add(t), t;\n      if (ArrayBuffer.isView(t)) {\n        const r = t;\n        return e && e.add(r.buffer), r;\n      }\n      if (t instanceof ImageData) return e && e.add(t.data.buffer), t;\n      if (Array.isArray(t)) {\n        const r = [];\n        for (const n of t) r.push(aa(n, e));\n        return r;\n      }\n      if (t instanceof Map) {\n        const e = {\n          $name: \"Map\"\n        };\n        for (const [r, n] of t.entries()) e[r] = aa(n);\n        return e;\n      }\n      if (\"object\" == typeof t) {\n        const r = t.constructor,\n          n = r._classRegistryKey;\n        if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);\n        const i = r.serialize ? r.serialize(t, e) : {};\n        if (!r.serialize) {\n          for (const r in t) t.hasOwnProperty(r) && (ea[n].omit.indexOf(r) >= 0 || (i[r] = aa(t[r], e)));\n          t instanceof Error && (i.message = t.message);\n        }\n        if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n        return \"Object\" !== n && (i.$name = n), i;\n      }\n      throw new Error(\"can't serialize object of type \" + typeof t);\n    }\n    function sa(t) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || na(t) || ia(t) || ArrayBuffer.isView(t) || t instanceof ImageData) return t;\n      if (Array.isArray(t)) return t.map(sa);\n      if (\"object\" == typeof t) {\n        const e = t.$name || \"Object\";\n        if (\"Map\" === e) {\n          const e = new Map();\n          for (const r of Object.keys(t)) \"$name\" !== r && e.set(r, sa(t[r]));\n          return e;\n        }\n        const {\n          klass: r\n        } = ea[e];\n        if (!r) throw new Error(`can't deserialize unregistered class ${e}`);\n        if (r.deserialize) return r.deserialize(t);\n        const n = Object.create(r.prototype);\n        for (const e of Object.keys(t)) \"$name\" !== e && (n[e] = sa(t[e]));\n        return n;\n      }\n      throw new Error(\"can't deserialize object of type \" + typeof t);\n    }\n    const oa = {\n      \"Latin-1 Supplement\": t => t >= 128 && t <= 255,\n      Arabic: t => t >= 1536 && t <= 1791,\n      \"Arabic Supplement\": t => t >= 1872 && t <= 1919,\n      \"Arabic Extended-A\": t => t >= 2208 && t <= 2303,\n      \"Hangul Jamo\": t => t >= 4352 && t <= 4607,\n      \"Unified Canadian Aboriginal Syllabics\": t => t >= 5120 && t <= 5759,\n      Khmer: t => t >= 6016 && t <= 6143,\n      \"Unified Canadian Aboriginal Syllabics Extended\": t => t >= 6320 && t <= 6399,\n      \"General Punctuation\": t => t >= 8192 && t <= 8303,\n      \"Letterlike Symbols\": t => t >= 8448 && t <= 8527,\n      \"Number Forms\": t => t >= 8528 && t <= 8591,\n      \"Miscellaneous Technical\": t => t >= 8960 && t <= 9215,\n      \"Control Pictures\": t => t >= 9216 && t <= 9279,\n      \"Optical Character Recognition\": t => t >= 9280 && t <= 9311,\n      \"Enclosed Alphanumerics\": t => t >= 9312 && t <= 9471,\n      \"Geometric Shapes\": t => t >= 9632 && t <= 9727,\n      \"Miscellaneous Symbols\": t => t >= 9728 && t <= 9983,\n      \"Miscellaneous Symbols and Arrows\": t => t >= 11008 && t <= 11263,\n      \"CJK Radicals Supplement\": t => t >= 11904 && t <= 12031,\n      \"Kangxi Radicals\": t => t >= 12032 && t <= 12255,\n      \"Ideographic Description Characters\": t => t >= 12272 && t <= 12287,\n      \"CJK Symbols and Punctuation\": t => t >= 12288 && t <= 12351,\n      Hiragana: t => t >= 12352 && t <= 12447,\n      Katakana: t => t >= 12448 && t <= 12543,\n      Bopomofo: t => t >= 12544 && t <= 12591,\n      \"Hangul Compatibility Jamo\": t => t >= 12592 && t <= 12687,\n      Kanbun: t => t >= 12688 && t <= 12703,\n      \"Bopomofo Extended\": t => t >= 12704 && t <= 12735,\n      \"CJK Strokes\": t => t >= 12736 && t <= 12783,\n      \"Katakana Phonetic Extensions\": t => t >= 12784 && t <= 12799,\n      \"Enclosed CJK Letters and Months\": t => t >= 12800 && t <= 13055,\n      \"CJK Compatibility\": t => t >= 13056 && t <= 13311,\n      \"CJK Unified Ideographs Extension A\": t => t >= 13312 && t <= 19903,\n      \"Yijing Hexagram Symbols\": t => t >= 19904 && t <= 19967,\n      \"CJK Unified Ideographs\": t => t >= 19968 && t <= 40959,\n      \"Yi Syllables\": t => t >= 40960 && t <= 42127,\n      \"Yi Radicals\": t => t >= 42128 && t <= 42191,\n      \"Hangul Jamo Extended-A\": t => t >= 43360 && t <= 43391,\n      \"Hangul Syllables\": t => t >= 44032 && t <= 55215,\n      \"Hangul Jamo Extended-B\": t => t >= 55216 && t <= 55295,\n      \"Private Use Area\": t => t >= 57344 && t <= 63743,\n      \"CJK Compatibility Ideographs\": t => t >= 63744 && t <= 64255,\n      \"Arabic Presentation Forms-A\": t => t >= 64336 && t <= 65023,\n      \"Vertical Forms\": t => t >= 65040 && t <= 65055,\n      \"CJK Compatibility Forms\": t => t >= 65072 && t <= 65103,\n      \"Small Form Variants\": t => t >= 65104 && t <= 65135,\n      \"Arabic Presentation Forms-B\": t => t >= 65136 && t <= 65279,\n      \"Halfwidth and Fullwidth Forms\": t => t >= 65280 && t <= 65519,\n      \"CJK Unified Ideographs Extension B\": t => t >= 131072 && t <= 173791\n    };\n    function la(t) {\n      for (const e of t) if (ha(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    function ua(t) {\n      for (const e of t) if (!ca(e.charCodeAt(0))) return !1;\n      return !0;\n    }\n    function ca(t) {\n      return !(oa.Arabic(t) || oa[\"Arabic Supplement\"](t) || oa[\"Arabic Extended-A\"](t) || oa[\"Arabic Presentation Forms-A\"](t) || oa[\"Arabic Presentation Forms-B\"](t));\n    }\n    function ha(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(oa[\"Bopomofo Extended\"](t) || oa.Bopomofo(t) || oa[\"CJK Compatibility Forms\"](t) && !(t >= 65097 && t <= 65103) || oa[\"CJK Compatibility Ideographs\"](t) || oa[\"CJK Compatibility\"](t) || oa[\"CJK Radicals Supplement\"](t) || oa[\"CJK Strokes\"](t) || !(!oa[\"CJK Symbols and Punctuation\"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || oa[\"CJK Unified Ideographs Extension A\"](t) || oa[\"CJK Unified Ideographs\"](t) || oa[\"Enclosed CJK Letters and Months\"](t) || oa[\"Hangul Compatibility Jamo\"](t) || oa[\"Hangul Jamo Extended-A\"](t) || oa[\"Hangul Jamo Extended-B\"](t) || oa[\"Hangul Jamo\"](t) || oa[\"Hangul Syllables\"](t) || oa.Hiragana(t) || oa[\"Ideographic Description Characters\"](t) || oa.Kanbun(t) || oa[\"Kangxi Radicals\"](t) || oa[\"Katakana Phonetic Extensions\"](t) || oa.Katakana(t) && 12540 !== t || !(!oa[\"Halfwidth and Fullwidth Forms\"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!oa[\"Small Form Variants\"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || oa[\"Unified Canadian Aboriginal Syllabics\"](t) || oa[\"Unified Canadian Aboriginal Syllabics Extended\"](t) || oa[\"Vertical Forms\"](t) || oa[\"Yijing Hexagram Symbols\"](t) || oa[\"Yi Syllables\"](t) || oa[\"Yi Radicals\"](t))));\n    }\n    function pa(t) {\n      return !(ha(t) || function (t) {\n        return !!(oa[\"Latin-1 Supplement\"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || oa[\"General Punctuation\"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || oa[\"Letterlike Symbols\"](t) || oa[\"Number Forms\"](t) || oa[\"Miscellaneous Technical\"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || oa[\"Control Pictures\"](t) && 9251 !== t || oa[\"Optical Character Recognition\"](t) || oa[\"Enclosed Alphanumerics\"](t) || oa[\"Geometric Shapes\"](t) || oa[\"Miscellaneous Symbols\"](t) && !(t >= 9754 && t <= 9759) || oa[\"Miscellaneous Symbols and Arrows\"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || oa[\"CJK Symbols and Punctuation\"](t) || oa.Katakana(t) || oa[\"Private Use Area\"](t) || oa[\"CJK Compatibility Forms\"](t) || oa[\"Small Form Variants\"](t) || oa[\"Halfwidth and Fullwidth Forms\"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n    function fa(t) {\n      return t >= 1424 && t <= 2303 || oa[\"Arabic Presentation Forms-A\"](t) || oa[\"Arabic Presentation Forms-B\"](t);\n    }\n    function da(t, e) {\n      return !(!e && fa(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || oa.Khmer(t));\n    }\n    function ma(t) {\n      for (const e of t) if (fa(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    const ya = \"deferred\",\n      ga = \"loading\",\n      xa = \"loaded\";\n    let va = null,\n      ba = \"unavailable\",\n      _a = null;\n    const wa = function (t) {\n      t && \"string\" == typeof t && t.indexOf(\"NetworkError\") > -1 && (ba = \"error\"), va && va(t);\n    };\n    function Ma() {\n      Aa.fire(new Qt(\"pluginStateChange\", {\n        pluginStatus: ba,\n        pluginURL: _a\n      }));\n    }\n    const Aa = new ee(),\n      Sa = function () {\n        return ba;\n      },\n      Ia = function () {\n        if (ba !== ya || !_a) throw new Error(\"rtl-text-plugin cannot be downloaded unless a pluginURL is specified\");\n        ba = ga, Ma(), _a && Pt({\n          url: _a\n        }, t => {\n          t ? wa(t) : (ba = xa, Ma());\n        });\n      },\n      ka = {\n        applyArabicShaping: null,\n        processBidirectionalText: null,\n        processStyledBidirectionalText: null,\n        isLoaded: () => ba === xa || null != ka.applyArabicShaping,\n        isLoading: () => ba === ga,\n        setState(t) {\n          ba = t.pluginStatus, _a = t.pluginURL;\n        },\n        isParsed: () => null != ka.applyArabicShaping && null != ka.processBidirectionalText && null != ka.processStyledBidirectionalText,\n        getPluginURL: () => _a\n      };\n    class Pa {\n      constructor(t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);\n      }\n      isSupportedScript(t) {\n        return function (t, e) {\n          for (const r of t) if (!da(r.charCodeAt(0), e)) return !1;\n          return !0;\n        }(t, ka.isLoaded());\n      }\n    }\n    class Ea {\n      constructor(t, e, r, n) {\n        this.property = t, this.value = e, this.expression = function (t, e, r, n) {\n          if (Di(t)) return new Ki(t, e);\n          if ($i(t) || Array.isArray(t) && t.length > 0) {\n            const i = Zi(t, e, r, n);\n            if (\"error\" === i.result) throw new Error(i.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n            return i.value;\n          }\n          {\n            let r = t;\n            return \"string\" == typeof t && \"color\" === e.type && (r = le.parse(t)), {\n              kind: \"constant\",\n              isConfigDependent: !1,\n              evaluate: () => r\n            };\n          }\n        }(void 0 === e ? t.specification.default : e, t.specification, r, n);\n      }\n      isDataDriven() {\n        return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n      }\n      possiblyEvaluate(t, e, r) {\n        return this.property.possiblyEvaluate(this, t, e, r);\n      }\n    }\n    class za {\n      constructor(t, e, r) {\n        this.property = t, this.value = new Ea(t, void 0, e, r);\n      }\n      transitioned(t, e) {\n        return new Ba(this.property, this.value, e, z({}, t.transition, this.transition), t.now);\n      }\n      untransitioned() {\n        return new Ba(this.property, this.value, null, {}, 0);\n      }\n    }\n    class Ta {\n      constructor(t, e, r) {\n        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this.isConfigDependent = !1;\n      }\n      getValue(t) {\n        return O(this._values[t].value.value);\n      }\n      setValue(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new za(this._values[t].property, this._scope, this._options)), this._values[t].value = new Ea(this._values[t].property, null === e ? void 0 : O(e), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t].value.expression.isConfigDependent;\n      }\n      setTransitionOrValue(t, e) {\n        e && (this._options = e);\n        const r = this._properties.properties;\n        if (t) for (const e in t) {\n          const n = t[e];\n          if (L(e, \"-transition\")) {\n            const t = e.slice(0, -11);\n            r[t] && this.setTransition(t, n);\n          } else r[e] && this.setValue(e, n);\n        }\n      }\n      getTransition(t) {\n        return O(this._values[t].transition);\n      }\n      setTransition(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new za(this._values[t].property)), this._values[t].transition = O(e) || void 0;\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n          const n = this.getTransition(e);\n          void 0 !== n && (t[`${e}-transition`] = n);\n        }\n        return t;\n      }\n      transitioned(t, e) {\n        const r = new Ca(this._properties);\n        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n        return r;\n      }\n      untransitioned() {\n        const t = new Ca(this._properties);\n        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n        return t;\n      }\n    }\n    class Ba {\n      constructor(t, e, r, n, i) {\n        const a = n.delay || 0,\n          s = n.duration || 0;\n        i = i || 0, this.property = t, this.value = e, this.begin = i + a, this.end = this.begin + s, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = t.now || 0,\n          i = this.value.possiblyEvaluate(t, e, r),\n          a = this.prior;\n        if (a) {\n          if (n > this.end) return this.prior = null, i;\n          if (this.value.isDataDriven()) return this.prior = null, i;\n          if (n < this.begin) return a.possiblyEvaluate(t, e, r);\n          {\n            const s = (n - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(a.possiblyEvaluate(t, e, r), i, M(s));\n          }\n        }\n        return i;\n      }\n    }\n    class Ca {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new Va(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n      hasTransition() {\n        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n        return !1;\n      }\n    }\n    class Ra {\n      constructor(t, e, r) {\n        this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._scope = e, this._options = r, this.isConfigDependent = !1;\n      }\n      getValue(t) {\n        return O(this._values[t].value);\n      }\n      setValue(t, e) {\n        this._values[t] = new Ea(this._values[t].property, null === e ? void 0 : O(e), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t].expression.isConfigDependent;\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n        }\n        return t;\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new Va(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n    }\n    class Da {\n      constructor(t, e, r) {\n        this.property = t, this.value = e, this.parameters = r;\n      }\n      isConstant() {\n        return \"constant\" === this.value.kind;\n      }\n      constantOr(t) {\n        return \"constant\" === this.value.kind ? this.value.value : t;\n      }\n      evaluate(t, e, r, n) {\n        return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n      }\n    }\n    class Va {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n      }\n      get(t) {\n        return this._values[t];\n      }\n    }\n    class La {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return t.expression.evaluate(e);\n      }\n      interpolate(t, e, r) {\n        const n = he[this.specification.type];\n        return n ? n(t, e, r) : t;\n      }\n    }\n    class Fa {\n      constructor(t, e) {\n        this.specification = t, this.overrides = e;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return new Da(this, \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? {\n          kind: \"constant\",\n          value: t.expression.evaluate(e, null, {}, r, n)\n        } : t.expression, e);\n      }\n      interpolate(t, e, r) {\n        if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n        if (void 0 === t.value.value || void 0 === e.value.value) return new Da(this, {\n          kind: \"constant\",\n          value: void 0\n        }, t.parameters);\n        const n = he[this.specification.type];\n        return n ? new Da(this, {\n          kind: \"constant\",\n          value: n(t.value.value, e.value.value, r)\n        }, t.parameters) : t;\n      }\n      evaluate(t, e, r, n, i, a) {\n        return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, a);\n      }\n    }\n    class Na {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return !!t.expression.evaluate(e, null, {}, r, n);\n      }\n      interpolate() {\n        return !1;\n      }\n    }\n    class Oa {\n      constructor(t) {\n        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n        const e = new Pa(0, {});\n        for (const r in t) {\n          const n = t[r];\n          n.specification.overridable && this.overridableProperties.push(r);\n          const i = this.defaultPropertyValues[r] = new Ea(n, void 0),\n            a = this.defaultTransitionablePropertyValues[r] = new za(n);\n          this.defaultTransitioningPropertyValues[r] = a.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);\n        }\n      }\n    }\n    function Ua(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n    function ja(t) {\n      if (Array.isArray(t)) return t.map(ja);\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        const e = {};\n        for (const r in t) e[r] = ja(t[r]);\n        return e;\n      }\n      return Ua(t);\n    }\n    ra(Fa, \"DataDrivenProperty\"), ra(La, \"DataConstantProperty\"), ra(Na, \"ColorRampProperty\");\n    var qa = JSON.parse('{\"$version\":8,\"$root\":{\"version\":{\"required\":true,\"type\":\"enum\",\"values\":[8]},\"fragment\":{\"type\":\"boolean\"},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360},\"pitch\":{\"type\":\"number\",\"default\":0},\"light\":{\"type\":\"light\"},\"lights\":{\"required\":false,\"type\":\"array\",\"value\":\"light-3d\"},\"terrain\":{\"type\":\"terrain\",\"optional\":true},\"fog\":{\"type\":\"fog\"},\"camera\":{\"type\":\"camera\"},\"imports\":{\"type\":\"array\",\"value\":\"import\"},\"schema\":{\"type\":\"schema\"},\"sources\":{\"required\":true,\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\",\"default\":\"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"required\":true,\"type\":\"array\",\"value\":\"layer\"},\"models\":{\"type\":\"models\"}},\"model\":{\"type\":\"string\",\"required\":true},\"import\":{\"id\":{\"type\":\"string\",\"required\":true},\"url\":{\"type\":\"string\",\"required\":true},\"config\":{\"type\":\"config\"},\"data\":{\"type\":\"$root\"}},\"config\":{\"*\":{\"type\":\"*\"}},\"schema\":{\"*\":{\"type\":\"option\"}},\"option\":{\"default\":{\"type\":\"*\",\"required\":true},\"type\":{\"type\":\"enum\",\"values\":{\"string\":1,\"number\":1,\"boolean\":1,\"color\":1}},\"array\":{\"type\":\"boolean\"},\"minValue\":{\"type\":\"number\"},\"maxValue\":{\"type\":\"number\"},\"stepValue\":{\"type\":\"number\"},\"values\":{\"type\":\"array\",\"value\":\"*\"},\"metadata\":{\"type\":\"*\"}},\"models\":{\"*\":{\"type\":\"model\"}},\"light-3d\":{\"id\":{\"type\":\"string\",\"required\":true},\"properties\":{\"type\":\"properties\"},\"type\":{\"type\":\"enum\",\"values\":{\"ambient\":{},\"directional\":{},\"flat\":{}}}},\"properties\":[\"properties_light_directional\",\"properties_light_ambient\",\"properties_light_flat\"],\"properties_light_directional\":{\"direction\":{\"type\":\"array\",\"default\":[210,30],\"minimum\":[0,0],\"maximum\":[360,90],\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"cast-shadows\":{\"type\":\"boolean\",\"default\":false,\"expression\":{},\"property-type\":\"data-constant\"},\"shadow-intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_ambient\":{\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_flat\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"property-type\":\"data-constant\",\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_raster_array\",\"source_geojson\",\"source_video\",\"source_image\",\"source_model\"],\"source_vector\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"vector\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster-dem\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":1,\"mapbox\":1},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_array\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster-array\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"rasterLayers\":{\"type\":\"*\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"geojson\":1}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"}},\"source_video\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"video\":1}},\"urls\":{\"required\":true,\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"image\":1}},\"url\":{\"required\":false,\"type\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_model\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"model\":1,\"batched-model\":1}},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"tiles\":{\"type\":\"array\",\"value\":\"string\"}},\"layer\":{\"id\":{\"type\":\"string\",\"required\":true},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"raster\":{},\"raster-particle\":{},\"hillshade\":{},\"model\":{},\"background\":{},\"sky\":{},\"slot\":{}},\"required\":true},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"slot\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"}},\"layout\":[\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_symbol\",\"layout_raster\",\"layout_raster-particle\",\"layout_hillshade\",\"layout_background\",\"layout_sky\",\"layout_model\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_model\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"},\"model-id\":{\"type\":\"string\",\"default\":\"\",\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"},\"fill-extrusion-edge-radius\":{\"type\":\"number\",\"private\":true,\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"constant\"}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":1,\"round\":1,\"square\":1},\"default\":\"butt\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":1,\"round\":1,\"miter\":1},\"default\":\"miter\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":1,\"line\":1,\"line-center\":1},\"default\":\"point\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"viewport-y\":1,\"source\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-z-elevate\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":1,\"width\":1,\"height\":1,\"both\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"left\":1,\"center\":1,\"right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"default\":0,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":1,\"vertical\":1},\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":1,\"uppercase\":1,\"lowercase\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_raster-particle\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":1,\"!=\":1,\">\":1,\">=\":1,\"<\":1,\"<=\":1,\"in\":1,\"!in\":1,\"all\":1,\"any\":1,\"none\":1,\"has\":1,\"!has\":1}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":1,\"LineString\":1,\"Polygon\":1}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":1,\"exponential\":1,\"interval\":1,\"categorical\":1},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":1,\"lab\":1,\"hcl\":1},\"default\":\"rgb\"},\"default\":{\"type\":\"*\",\"required\":false}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"high-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#245cdf\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"space-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,\"#010b19\",7,\"#367ab9\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,0.2,7,0.1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"star-intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],5,0.35,6,0],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vertical-range\":{\"type\":\"array\",\"default\":[0,0],\"minimum\":0,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}}},\"camera\":{\"camera-projection\":{\"type\":\"enum\",\"values\":{\"perspective\":1,\"orthographic\":1},\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"default\":\"perspective\",\"property-type\":\"data-constant\"}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"property-type\":\"data-constant\",\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":1,\"equalEarth\":1,\"equirectangular\":1,\"lambertConformalConic\":1,\"mercator\":1,\"naturalEarth\":1,\"winkelTripel\":1,\"globe\":1},\"default\":\"mercator\",\"required\":true},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"minimum\":[-180,-90],\"maximum\":[180,90]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"minimum\":[-90,-90],\"maximum\":[90,90]}},\"terrain\":{\"source\":{\"type\":\"string\",\"required\":true},\"exaggeration\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_symbol\",\"paint_raster\",\"paint_hillshade\",\"paint_background\",\"paint_sky\",\"paint_model\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-ambient-occlusion-intensity\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"private\":true,\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"private\":true,\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-wall-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-attenuation\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-flood-light-color\":{\"property-type\":\"data-constant\",\"type\":\"color\",\"default\":\"#ffffff\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-intensity\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-attenuation\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-vertical-scale\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-rounded-roof\":{\"property-type\":\"data-constant\",\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"fill-extrusion-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-gradient\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]},\"property-type\":\"color-ramp\"},\"line-trim-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"property-type\":\"constant\"},\"line-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"line-border-width\":{\"type\":\"number\",\"private\":true,\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-border-color\":{\"type\":\"color\",\"private\":true,\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]},\"property-type\":\"color-ramp\"},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-image-cross-fade\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"overridable\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-color-saturation\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{},\"property-type\":\"data-constant\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-color\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-value\"]},\"property-type\":\"color-ramp\"},\"raster-color-mix\":{\"type\":\"array\",\"default\":[0.2126,0.7152,0.0722,0],\"length\":4,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color-range\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":1,\"nearest\":1},\"default\":\"linear\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"raster-array-band\":{\"type\":\"string\",\"required\":false,\"property-type\":\"data-constant\"},\"raster-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_raster-particle\":{\"raster-particle-array-band\":{\"type\":\"string\",\"required\":false,\"property-type\":\"data-constant\"},\"raster-particle-count\":{\"type\":\"number\",\"default\":512,\"minimum\":1,\"property-type\":\"data-constant\"},\"raster-particle-color\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-particle-speed\"]},\"property-type\":\"color-ramp\"},\"raster-particle-max-speed\":{\"type\":\"number\",\"default\":1,\"minimum\":1,\"property-type\":\"data-constant\"},\"raster-particle-speed-factor\":{\"type\":\"number\",\"default\":0.2,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-particle-fade-opacity-factor\":{\"type\":\"number\",\"default\":0.98,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-particle-reset-rate-factor\":{\"type\":\"number\",\"default\":0.8,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-constant\"}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"hillshade-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_background\":{\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":1,\"atmosphere\":1},\"default\":\"atmosphere\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"maximum\":100,\"property-type\":\"data-constant\"},\"sky-gradient-center\":{\"type\":\"array\",\"value\":\"number\",\"default\":[0,0],\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient-radius\":{\"type\":\"number\",\"default\":90,\"minimum\":0,\"maximum\":180,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]},\"property-type\":\"color-ramp\"},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\",\"property-type\":\"data-constant\"},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\",\"property-type\":\"data-constant\"},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_model\":{\"model-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"model-rotation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-scale\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[1,1,1],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-translation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\",\"zoom\"]},\"transition\":true},\"model-color-mix-intensity\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-type\":{\"type\":\"enum\",\"values\":{\"common-3d\":1,\"location-indicator\":1},\"default\":\"common-3d\",\"property-type\":\"data-constant\"},\"model-cast-shadows\":{\"type\":\"boolean\",\"default\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"model-receive-shadows\":{\"type\":\"boolean\",\"default\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"model-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\",\"transition\":true},\"model-emissive-strength\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-roughness\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]},\"transition\":true},\"model-height-based-emissive-strength-multiplier\":{\"type\":\"array\",\"default\":[1,1,1,1,0],\"length\":5,\"value\":\"number\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0}},\"property-type\":{\"data-driven\":{\"type\":\"property-type\"},\"color-ramp\":{\"type\":\"property-type\"},\"data-constant\":{\"type\":\"property-type\"},\"constant\":{\"type\":\"property-type\"}},\"promoteId\":{\"*\":{\"type\":\"string\"}}}');\n    function $a(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n      switch (t[0]) {\n        case \"has\":\n          return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n        case \"in\":\n          return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n        case \"!in\":\n        case \"!has\":\n        case \"none\":\n          return !1;\n        case \"==\":\n        case \"!=\":\n        case \">\":\n        case \">=\":\n        case \"<\":\n        case \"<=\":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n        case \"any\":\n        case \"all\":\n          for (const e of t.slice(1)) if (!$a(e) && \"boolean\" != typeof e) return !1;\n          return !0;\n        default:\n          return !0;\n      }\n    }\n    function Ga(t, e = \"fill\") {\n      if (null == t) return {\n        filter: () => !0,\n        needGeometry: !1,\n        needFeature: !1\n      };\n      $a(t) || (t = Ja(t));\n      const r = t;\n      let n = !0;\n      try {\n        n = function (t) {\n          if (!Za(t)) return t;\n          let e = ja(t);\n          return Xa(e), e = Ya(e), e;\n        }(r);\n      } catch (t) {\n        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n${JSON.stringify(r, null, 2)}\\n        `);\n      }\n      const i = qa[`filter_${e}`],\n        a = Gi(n, i);\n      let s = null;\n      if (\"error\" === a.result) throw new Error(a.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n      s = (t, e, r) => a.value.evaluate(t, e, {}, r);\n      let o = null,\n        l = null;\n      if (n !== r) {\n        const t = Gi(r, i);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n        o = (e, r, n, i, a) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, a), l = !dn(t.value.expression);\n      }\n      return {\n        filter: s,\n        dynamicFilter: o || void 0,\n        needGeometry: Wa(n),\n        needFeature: !!l\n      };\n    }\n    function Ya(t) {\n      if (!Array.isArray(t)) return t;\n      const e = function (t) {\n        if (Ka.has(t[0])) for (let e = 1; e < t.length; e++) if (Za(t[e])) return !0;\n        return t;\n      }(t);\n      return !0 === e ? e : e.map(t => Ya(t));\n    }\n    function Xa(t) {\n      let e = !1;\n      const r = [];\n      if (\"case\" === t[0]) {\n        for (let n = 1; n < t.length - 1; n += 2) e = e || Za(t[n]), r.push(t[n + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"match\" === t[0]) {\n        e = e || Za(t[1]);\n        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"step\" === t[0]) {\n        e = e || Za(t[1]);\n        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);\n      }\n      e && (t.length = 0, t.push(\"any\", ...r));\n      for (let e = 1; e < t.length; e++) Xa(t[e]);\n    }\n    function Za(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"pitch\" === (e = t[0]) || \"distance-from-center\" === e) return !0;\n      var e;\n      for (let e = 1; e < t.length; e++) if (Za(t[e])) return !0;\n      return !1;\n    }\n    const Ka = new Set([\"in\", \"==\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"to-boolean\"]);\n    function Ha(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function Wa(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"within\" === t[0] || \"distance\" === t[0]) return !0;\n      for (let e = 1; e < t.length; e++) if (Wa(t[e])) return !0;\n      return !1;\n    }\n    function Ja(t) {\n      if (!t) return !0;\n      const e = t[0];\n      return t.length <= 1 ? \"any\" !== e : \"==\" === e ? Qa(t[1], t[2], \"==\") : \"!=\" === e ? rs(Qa(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? Qa(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(Ja))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(Ja)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(Ja).map(rs)) : \"in\" === e ? ts(t[1], t.slice(2)) : \"!in\" === e ? rs(ts(t[1], t.slice(2))) : \"has\" === e ? es(t[1]) : \"!has\" !== e || rs(es(t[1]));\n      var r;\n    }\n    function Qa(t, e, r) {\n      switch (t) {\n        case \"$type\":\n          return [`filter-type-${r}`, e];\n        case \"$id\":\n          return [`filter-id-${r}`, e];\n        default:\n          return [`filter-${r}`, t, e];\n      }\n    }\n    function ts(t, e) {\n      if (0 === e.length) return !1;\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-in\", [\"literal\", e]];\n        case \"$id\":\n          return [\"filter-id-in\", [\"literal\", e]];\n        default:\n          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort(Ha)]] : [\"filter-in-small\", t, [\"literal\", e]];\n      }\n    }\n    function es(t) {\n      switch (t) {\n        case \"$type\":\n          return !0;\n        case \"$id\":\n          return [\"filter-has-id\"];\n        default:\n          return [\"filter-has\", t];\n      }\n    }\n    function rs(t) {\n      return [\"!\", t];\n    }\n    const ns = \"\u001f\";\n    function is(t, e) {\n      return e ? `${t}${ns}${e}` : t;\n    }\n    const as = \"-transition\";\n    class ss extends ee {\n      constructor(t, e, r, n) {\n        if (super(), this.id = t.id, this.fqid = is(this.id, r), this.type = t.type, this.scope = r, this.options = n, this._featureFilter = {\n          filter: () => !0,\n          needGeometry: !1,\n          needFeature: !1\n        }, this._filterCompiled = !1, this.isConfigDependent = !1, \"custom\" !== t.type && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, \"background\" !== t.type && \"sky\" !== t.type && \"slot\" !== t.type && (this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter), t.slot && (this.slot = t.slot), e.layout && (this._unevaluatedLayout = new Ra(e.layout, this.scope, n), this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent), e.paint)) {\n          this._transitionablePaint = new Ta(e.paint, this.scope, n);\n          for (const e in t.paint) this.setPaintProperty(e, t.paint[e]);\n          for (const e in t.layout) this.setLayoutProperty(e, t.layout[e]);\n          this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent, this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Va(e.paint);\n        }\n      }\n      getLayoutProperty(t) {\n        return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }\n      setLayoutProperty(t, e) {\n        if (\"custom\" === this.type && \"visibility\" === t) return void (this.visibility = e);\n        const r = this._unevaluatedLayout;\n        r._properties.properties[t] && (r.setValue(t, e), this.isConfigDependent = this.isConfigDependent || r.isConfigDependent, \"visibility\" === t && this.possiblyEvaluateVisibility());\n      }\n      possiblyEvaluateVisibility() {\n        this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({\n          zoom: 0\n        });\n      }\n      getPaintProperty(t) {\n        return L(t, as) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);\n      }\n      setPaintProperty(t, e) {\n        const r = this._transitionablePaint,\n          n = r._properties.properties;\n        if (L(t, as)) {\n          const i = t.slice(0, -11);\n          return n[i] && r.setTransition(i, e || void 0), !1;\n        }\n        if (!n[t]) return !1;\n        const i = r._values[t],\n          a = i.value.isDataDriven(),\n          s = i.value;\n        r.setValue(t, e), this.isConfigDependent = this.isConfigDependent || r.isConfigDependent, this._handleSpecialPaintPropertyUpdate(t);\n        const o = r._values[t].value,\n          l = o.isDataDriven(),\n          u = L(t, \"pattern\") || \"line-dasharray\" === t;\n        return l || a || u || this._handleOverridablePaintPropertyUpdate(t, s, o);\n      }\n      _handleSpecialPaintPropertyUpdate(t) {}\n      getProgramIds() {\n        return null;\n      }\n      getDefaultProgramParams(t, e) {\n        return null;\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !1;\n      }\n      isHidden(t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n      }\n      updateTransitions(t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }\n      hasTransition() {\n        return this._transitioningPaint.hasTransition();\n      }\n      recalculate(t, e) {\n        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }\n      serialize() {\n        return N({\n          id: this.id,\n          type: this.type,\n          slot: this.slot,\n          source: this.source,\n          \"source-layer\": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        }, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n      }\n      is3D() {\n        return !1;\n      }\n      isSky() {\n        return !1;\n      }\n      isTileClipped() {\n        return !1;\n      }\n      hasOffscreenPass() {\n        return !1;\n      }\n      hasShadowPass() {\n        return !1;\n      }\n      canCastShadows() {\n        return !1;\n      }\n      hasLightBeamPass() {\n        return !1;\n      }\n      cutoffRange() {\n        return 0;\n      }\n      tileCoverLift() {\n        return 0;\n      }\n      resize() {}\n      isStateDependent() {\n        for (const t in this.paint._values) {\n          const e = this.paint.get(t);\n          if (e instanceof Da && Ti(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n        return !1;\n      }\n      compileFilter() {\n        this._filterCompiled || (this._featureFilter = Ga(this.filter), this._filterCompiled = !0);\n      }\n      invalidateCompiledFilter() {\n        this._filterCompiled = !1;\n      }\n      dynamicFilter() {\n        return this._featureFilter.dynamicFilter;\n      }\n      dynamicFilterNeedsFeature() {\n        return this._featureFilter.needFeature;\n      }\n      getLayerRenderingStats() {\n        return this._stats;\n      }\n      resetLayerRenderingStats(t) {\n        this._stats && (\"shadow\" === t.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);\n      }\n    }\n    const os = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    };\n    class ls {\n      constructor(t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      }\n    }\n    class us {\n      constructor() {\n        this.isTransferred = !1, this.capacity = -1, this.resize(0);\n      }\n      static serialize(t, e) {\n        return t._trim(), e && (t.isTransferred = !0, e.add(t.arrayBuffer)), {\n          length: t.length,\n          arrayBuffer: t.arrayBuffer\n        };\n      }\n      static deserialize(t) {\n        const e = Object.create(this.prototype);\n        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n      }\n      _trim() {\n        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n      }\n      clear() {\n        this.length = 0;\n      }\n      resize(t) {\n        this.reserve(t), this.length = t;\n      }\n      reserve(t) {\n        if (t > this.capacity) {\n          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n          const e = this.uint8;\n          this._refreshViews(), e && this.uint8.set(e);\n        }\n      }\n      _refreshViews() {\n        throw new Error(\"StructArray#_refreshViews() must be implemented by each concrete StructArray layout\");\n      }\n      emplace(...t) {\n        throw new Error(\"StructArray#emplace() must be implemented by each concrete StructArray layout\");\n      }\n      emplaceBack(...t) {\n        throw new Error(\"StructArray#emplaceBack() must be implemented by each concrete StructArray layout\");\n      }\n      destroy() {\n        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;\n      }\n    }\n    function cs(t, e = 1) {\n      let r = 0,\n        n = 0;\n      return {\n        members: t.map(t => {\n          const i = os[t.type].BYTES_PER_ELEMENT,\n            a = r = hs(r, Math.max(e, i)),\n            s = t.components || 1;\n          return n = Math.max(n, i), r += i * s, {\n            name: t.name,\n            type: t.type,\n            components: s,\n            offset: a\n          };\n        }),\n        size: hs(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n    function hs(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n    class ps extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }\n    }\n    ps.prototype.bytesPerElement = 4, ra(ps, \"StructArrayLayout2i4\");\n    class fs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n    }\n    fs.prototype.bytesPerElement = 6, ra(fs, \"StructArrayLayout3i6\");\n    class ds extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const a = 4 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, t;\n      }\n    }\n    ds.prototype.bytesPerElement = 8, ra(ds, \"StructArrayLayout4i8\");\n    class ms extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, a) {\n        const s = 5 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, t;\n      }\n    }\n    ms.prototype.bytesPerElement = 10, ra(ms, \"StructArrayLayout5i10\");\n    class ys extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a, s);\n      }\n      emplace(t, e, r, n, i, a, s, o) {\n        const l = 6 * t,\n          u = 12 * t,\n          c = 3 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = a, this.uint8[u + 7] = s, this.float32[c + 2] = o, t;\n      }\n    }\n    ys.prototype.bytesPerElement = 12, ra(ys, \"StructArrayLayout2i4ub1f12\");\n    class gs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const a = 4 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, t;\n      }\n    }\n    gs.prototype.bytesPerElement = 16, ra(gs, \"StructArrayLayout4f16\");\n    class xs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, a) {\n        const s = 6 * t,\n          o = 3 * t;\n        return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, this.float32[o + 2] = a, t;\n      }\n    }\n    xs.prototype.bytesPerElement = 12, ra(xs, \"StructArrayLayout4ui1f12\");\n    class vs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const a = 4 * t;\n        return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, t;\n      }\n    }\n    vs.prototype.bytesPerElement = 8, ra(vs, \"StructArrayLayout4ui8\");\n    class bs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i, a);\n      }\n      emplace(t, e, r, n, i, a, s) {\n        const o = 6 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = a, this.int16[o + 5] = s, t;\n      }\n    }\n    bs.prototype.bytesPerElement = 12, ra(bs, \"StructArrayLayout6i12\");\n    class _s extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s, o, l, u, c, h) {\n        const p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, a, s, o, l, u, c, h);\n      }\n      emplace(t, e, r, n, i, a, s, o, l, u, c, h, p) {\n        const f = 12 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = a, this.uint16[f + 5] = s, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t;\n      }\n    }\n    _s.prototype.bytesPerElement = 24, ra(_s, \"StructArrayLayout4i4ui4i24\");\n    class ws extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i, a);\n      }\n      emplace(t, e, r, n, i, a, s) {\n        const o = 10 * t,\n          l = 5 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = a, this.float32[l + 4] = s, t;\n      }\n    }\n    ws.prototype.bytesPerElement = 20, ra(ws, \"StructArrayLayout3i3f20\");\n    class Ms extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }\n    }\n    Ms.prototype.bytesPerElement = 4, ra(Ms, \"StructArrayLayout1ul4\");\n    class As extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }\n    }\n    As.prototype.bytesPerElement = 4, ra(As, \"StructArrayLayout2ui4\");\n    class Ss extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s, o, l, u, c, h, p) {\n        const f = this.length;\n        return this.resize(f + 1), this.emplace(f, t, e, r, n, i, a, s, o, l, u, c, h, p);\n      }\n      emplace(t, e, r, n, i, a, s, o, l, u, c, h, p, f) {\n        const d = 20 * t,\n          m = 10 * t;\n        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = a, this.float32[m + 3] = s, this.float32[m + 4] = o, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[d + 14] = c, this.uint32[m + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t;\n      }\n    }\n    Ss.prototype.bytesPerElement = 40, ra(Ss, \"StructArrayLayout5i4f1i1ul2ui40\");\n    class Is extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a, s);\n      }\n      emplace(t, e, r, n, i, a, s, o) {\n        const l = 8 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = a, this.int16[l + 6] = s, this.int16[l + 7] = o, t;\n      }\n    }\n    Is.prototype.bytesPerElement = 16, ra(Is, \"StructArrayLayout3i2i2i16\");\n    class ks extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, a) {\n        const s = 4 * t,\n          o = 8 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = a, t;\n      }\n    }\n    ks.prototype.bytesPerElement = 16, ra(ks, \"StructArrayLayout2f1f2i16\");\n    class Ps extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const a = 12 * t,\n          s = 3 * t;\n        return this.uint8[a + 0] = e, this.uint8[a + 1] = r, this.float32[s + 1] = n, this.float32[s + 2] = i, t;\n      }\n    }\n    Ps.prototype.bytesPerElement = 12, ra(Ps, \"StructArrayLayout2ub2f12\");\n    class Es extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }\n    }\n    Es.prototype.bytesPerElement = 6, ra(Es, \"StructArrayLayout3ui6\");\n    class zs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b) {\n        const _ = this.length;\n        return this.resize(_ + 1), this.emplace(_, t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b);\n      }\n      emplace(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _) {\n        const w = 30 * t,\n          M = 15 * t,\n          A = 60 * t;\n        return this.int16[w + 0] = e, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[M + 2] = i, this.float32[M + 3] = a, this.uint16[w + 8] = s, this.uint16[w + 9] = o, this.uint32[M + 5] = l, this.uint32[M + 6] = u, this.uint32[M + 7] = c, this.uint16[w + 16] = h, this.uint16[w + 17] = p, this.uint16[w + 18] = f, this.float32[M + 10] = d, this.float32[M + 11] = m, this.uint8[A + 48] = y, this.uint8[A + 49] = g, this.uint8[A + 50] = x, this.uint32[M + 13] = v, this.int16[w + 28] = b, this.uint8[A + 58] = _, t;\n      }\n    }\n    zs.prototype.bytesPerElement = 60, ra(zs, \"StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60\");\n    class Ts extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, k, P, E, z, T) {\n        const B = this.length;\n        return this.resize(B + 1), this.emplace(B, t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, k, P, E, z, T);\n      }\n      emplace(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, k, P, E, z, T, B) {\n        const C = 20 * t,\n          R = 40 * t,\n          D = 80 * t;\n        return this.float32[C + 0] = e, this.float32[C + 1] = r, this.int16[R + 4] = n, this.int16[R + 5] = i, this.int16[R + 6] = a, this.int16[R + 7] = s, this.int16[R + 8] = o, this.int16[R + 9] = l, this.int16[R + 10] = u, this.int16[R + 11] = c, this.int16[R + 12] = h, this.uint16[R + 13] = p, this.uint16[R + 14] = f, this.uint16[R + 15] = d, this.uint16[R + 16] = m, this.uint16[R + 17] = y, this.uint16[R + 18] = g, this.uint16[R + 19] = x, this.uint16[R + 20] = v, this.uint16[R + 21] = b, this.uint16[R + 22] = _, this.uint16[R + 23] = w, this.uint16[R + 24] = M, this.uint16[R + 25] = A, this.uint16[R + 26] = S, this.uint16[R + 27] = I, this.uint32[C + 14] = k, this.float32[C + 15] = P, this.float32[C + 16] = E, this.float32[C + 17] = z, this.float32[C + 18] = T, this.uint8[D + 76] = B, t;\n      }\n    }\n    Ts.prototype.bytesPerElement = 80, ra(Ts, \"StructArrayLayout2f9i15ui1ul4f1ub80\");\n    class Bs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }\n    }\n    Bs.prototype.bytesPerElement = 4, ra(Bs, \"StructArrayLayout1f4\");\n    class Cs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, a) {\n        const s = 5 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, this.float32[s + 4] = a, t;\n      }\n    }\n    Cs.prototype.bytesPerElement = 20, ra(Cs, \"StructArrayLayout5f20\");\n    class Rs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a, s);\n      }\n      emplace(t, e, r, n, i, a, s, o) {\n        const l = 7 * t;\n        return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = a, this.float32[l + 5] = s, this.float32[l + 6] = o, t;\n      }\n    }\n    Rs.prototype.bytesPerElement = 28, ra(Rs, \"StructArrayLayout7f28\");\n    class Ds extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const a = 6 * t;\n        return this.uint32[3 * t + 0] = e, this.uint16[a + 2] = r, this.uint16[a + 3] = n, this.uint16[a + 4] = i, t;\n      }\n    }\n    Ds.prototype.bytesPerElement = 12, ra(Ds, \"StructArrayLayout1ul3ui12\");\n    class Vs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }\n    }\n    Vs.prototype.bytesPerElement = 2, ra(Vs, \"StructArrayLayout1ui2\");\n    class Ls extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }\n    }\n    Ls.prototype.bytesPerElement = 12, ra(Ls, \"StructArrayLayout3f12\");\n    class Fs extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }\n    }\n    Fs.prototype.bytesPerElement = 8, ra(Fs, \"StructArrayLayout2f8\");\n    class Ns extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m) {\n        const y = this.length;\n        return this.resize(y + 1), this.emplace(y, t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m);\n      }\n      emplace(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y) {\n        const g = 16 * t;\n        return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = a, this.float32[g + 5] = s, this.float32[g + 6] = o, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = f, this.float32[g + 13] = d, this.float32[g + 14] = m, this.float32[g + 15] = y, t;\n      }\n    }\n    Ns.prototype.bytesPerElement = 64, ra(Ns, \"StructArrayLayout16f64\");\n    class Os extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, a, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, a, s);\n      }\n      emplace(t, e, r, n, i, a, s, o) {\n        const l = 10 * t,\n          u = 5 * t;\n        return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = a, this.float32[u + 3] = s, this.float32[u + 4] = o, t;\n      }\n    }\n    Os.prototype.bytesPerElement = 20, ra(Os, \"StructArrayLayout4ui3f20\");\n    class Us extends us {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint8[1 * t + 0] = e, t;\n      }\n    }\n    Us.prototype.bytesPerElement = 1, ra(Us, \"StructArrayLayout1ub1\");\n    class js extends ls {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n      get tileAnchorY() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get x1() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get y1() {\n        return this._structArray.float32[this._pos4 + 4];\n      }\n      get x2() {\n        return this._structArray.float32[this._pos4 + 5];\n      }\n      get y2() {\n        return this._structArray.float32[this._pos4 + 6];\n      }\n      get padding() {\n        return this._structArray.int16[this._pos2 + 14];\n      }\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 8];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n    }\n    js.prototype.size = 40;\n    class qs extends Ss {\n      get(t) {\n        return new js(this, t);\n      }\n    }\n    ra(qs, \"CollisionBoxArray\");\n    class $s extends ls {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get glyphStartIndex() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n      get numGlyphs() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n      get vertexStartIndex() {\n        return this._structArray.uint32[this._pos4 + 5];\n      }\n      get lineStartIndex() {\n        return this._structArray.uint32[this._pos4 + 6];\n      }\n      get lineLength() {\n        return this._structArray.uint32[this._pos4 + 7];\n      }\n      get segment() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get lowerSize() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get upperSize() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get lineOffsetX() {\n        return this._structArray.float32[this._pos4 + 10];\n      }\n      get lineOffsetY() {\n        return this._structArray.float32[this._pos4 + 11];\n      }\n      get writingMode() {\n        return this._structArray.uint8[this._pos1 + 48];\n      }\n      get placedOrientation() {\n        return this._structArray.uint8[this._pos1 + 49];\n      }\n      set placedOrientation(t) {\n        this._structArray.uint8[this._pos1 + 49] = t;\n      }\n      get hidden() {\n        return this._structArray.uint8[this._pos1 + 50];\n      }\n      set hidden(t) {\n        this._structArray.uint8[this._pos1 + 50] = t;\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 13];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 13] = t;\n      }\n      get associatedIconIndex() {\n        return this._structArray.int16[this._pos2 + 28];\n      }\n      get flipState() {\n        return this._structArray.uint8[this._pos1 + 58];\n      }\n      set flipState(t) {\n        this._structArray.uint8[this._pos1 + 58] = t;\n      }\n    }\n    $s.prototype.size = 60;\n    class Gs extends zs {\n      get(t) {\n        return new $s(this, t);\n      }\n    }\n    ra(Gs, \"PlacedSymbolArray\");\n    class Ys extends ls {\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 0];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 1];\n      }\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 6];\n      }\n      get rightJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 7];\n      }\n      get centerJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 8];\n      }\n      get leftJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 9];\n      }\n      get verticalPlacedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 10];\n      }\n      get placedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 11];\n      }\n      get verticalPlacedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 12];\n      }\n      get key() {\n        return this._structArray.uint16[this._pos2 + 13];\n      }\n      get textBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 14];\n      }\n      get textBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 15];\n      }\n      get verticalTextBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get verticalTextBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get iconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get iconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n      get verticalIconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 20];\n      }\n      get verticalIconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 21];\n      }\n      get featureIndex() {\n        return this._structArray.uint16[this._pos2 + 22];\n      }\n      get numHorizontalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 23];\n      }\n      get numVerticalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 24];\n      }\n      get numIconVertices() {\n        return this._structArray.uint16[this._pos2 + 25];\n      }\n      get numVerticalIconVertices() {\n        return this._structArray.uint16[this._pos2 + 26];\n      }\n      get useRuntimeCollisionCircles() {\n        return this._structArray.uint16[this._pos2 + 27];\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 14];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 14] = t;\n      }\n      get textOffset0() {\n        return this._structArray.float32[this._pos4 + 15];\n      }\n      get textOffset1() {\n        return this._structArray.float32[this._pos4 + 16];\n      }\n      get collisionCircleDiameter() {\n        return this._structArray.float32[this._pos4 + 17];\n      }\n      get zOffset() {\n        return this._structArray.float32[this._pos4 + 18];\n      }\n      set zOffset(t) {\n        this._structArray.float32[this._pos4 + 18] = t;\n      }\n      get hasIconTextFit() {\n        return this._structArray.uint8[this._pos1 + 76];\n      }\n    }\n    Ys.prototype.size = 80;\n    class Xs extends Ts {\n      get(t) {\n        return new Ys(this, t);\n      }\n    }\n    ra(Xs, \"SymbolInstanceArray\");\n    class Zs extends Bs {\n      getoffsetX(t) {\n        return this.float32[1 * t + 0];\n      }\n    }\n    ra(Zs, \"GlyphOffsetArray\");\n    class Ks extends ps {\n      getx(t) {\n        return this.int16[2 * t + 0];\n      }\n      gety(t) {\n        return this.int16[2 * t + 1];\n      }\n    }\n    ra(Ks, \"SymbolLineVertexArray\");\n    class Hs extends ls {\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 0];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n      get layoutVertexArrayOffset() {\n        return this._structArray.uint16[this._pos2 + 4];\n      }\n    }\n    Hs.prototype.size = 12;\n    class Ws extends Ds {\n      get(t) {\n        return new Hs(this, t);\n      }\n    }\n    ra(Ws, \"FeatureIndexArray\");\n    class Js extends As {\n      geta_centroid_pos0(t) {\n        return this.uint16[2 * t + 0];\n      }\n      geta_centroid_pos1(t) {\n        return this.uint16[2 * t + 1];\n      }\n    }\n    ra(Js, \"FillExtrusionCentroidArray\");\n    const Qs = cs([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      to = cs([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    class eo {\n      constructor(t = []) {\n        this.segments = t;\n      }\n      _prepareSegment(t, e, r, n) {\n        let i = this.segments[this.segments.length - 1];\n        return t > eo.MAX_VERTEX_ARRAY_LENGTH && j(`Max vertices per segment is ${eo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > eo.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n          vertexOffset: e,\n          primitiveOffset: r,\n          vertexLength: 0,\n          primitiveLength: 0\n        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n      }\n      prepareSegment(t, e, r, n) {\n        return this._prepareSegment(t, e.length, r.length, n);\n      }\n      get() {\n        return this.segments;\n      }\n      destroy() {\n        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n      }\n      static simpleSegment(t, e, r, n) {\n        return new eo([{\n          vertexOffset: t,\n          primitiveOffset: e,\n          vertexLength: r,\n          primitiveLength: n,\n          vaos: {},\n          sortKey: 0\n        }]);\n      }\n    }\n    function ro(t, e) {\n      return 256 * (t = I(Math.floor(t), 0, 255)) + I(Math.floor(e), 0, 255);\n    }\n    eo.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ra(eo, \"SegmentVector\");\n    const no = cs([{\n        name: \"a_pattern\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixel_ratio\",\n        components: 1,\n        type: \"Float32\"\n      }]),\n      io = cs([{\n        name: \"a_dash\",\n        components: 4,\n        type: \"Uint16\"\n      }]);\n    var ao = {\n        exports: {}\n      },\n      so = {\n        exports: {}\n      };\n    !function (t) {\n      t.exports = function (t, e) {\n        var r, n, i, a, s, o, l, u;\n        for (n = t.length - (r = 3 & t.length), i = e, s = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (a = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16);\n        switch (l = 0, r) {\n          case 3:\n            l ^= (255 & t.charCodeAt(u + 2)) << 16;\n          case 2:\n            l ^= (255 & t.charCodeAt(u + 1)) << 8;\n          case 1:\n            i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;\n        }\n        return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n      };\n    }(so);\n    var oo = so.exports,\n      lo = {\n        exports: {}\n      };\n    !function (t) {\n      t.exports = function (t, e) {\n        for (var r, n = t.length, i = e ^ n, a = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(a) | (255 & t.charCodeAt(++a)) << 8 | (255 & t.charCodeAt(++a)) << 16 | (255 & t.charCodeAt(++a)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++a;\n        switch (n) {\n          case 3:\n            i ^= (255 & t.charCodeAt(a + 2)) << 16;\n          case 2:\n            i ^= (255 & t.charCodeAt(a + 1)) << 8;\n          case 1:\n            i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(a))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n        }\n        return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n      };\n    }(lo);\n    var uo = oo,\n      co = lo.exports;\n    ao.exports = uo, ao.exports.murmur3 = uo, ao.exports.murmur2 = co;\n    var ho = h(ao.exports);\n    class po {\n      constructor() {\n        this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;\n      }\n      add(t, e, r, n) {\n        this.ids.push(fo(t)), this.positions.push(e, r, n);\n      }\n      eachPosition(t, e) {\n        const r = fo(t);\n        let n = 0,\n          i = this.ids.length - 1;\n        for (; n < i;) {\n          const t = n + i >> 1;\n          this.ids[t] >= r ? i = t : n = t + 1;\n        }\n        for (; this.ids[n] === r;) e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;\n      }\n      static serialize(t, e) {\n        const r = new Float64Array(t.ids),\n          n = new Uint32Array(t.positions);\n        return mo(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {\n          ids: r,\n          positions: n\n        };\n      }\n      static deserialize(t) {\n        const e = new po();\n        let r;\n        e.ids = t.ids, e.positions = t.positions;\n        for (const t of e.ids) t !== r && e.uniqueIds.push(t), r = t;\n        return e.indexed = !0, e;\n      }\n    }\n    function fo(t) {\n      const e = +t;\n      return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : ho(String(t));\n    }\n    function mo(t, e, r, n) {\n      for (; r < n;) {\n        const i = t[r + n >> 1];\n        let a = r - 1,\n          s = n + 1;\n        for (;;) {\n          do {\n            a++;\n          } while (t[a] < i);\n          do {\n            s--;\n          } while (t[s] > i);\n          if (a >= s) break;\n          yo(t, a, s), yo(e, 3 * a, 3 * s), yo(e, 3 * a + 1, 3 * s + 1), yo(e, 3 * a + 2, 3 * s + 2);\n        }\n        s - r < n - s ? (mo(t, e, r, s), r = s + 1) : (mo(t, e, s + 1, n), n = s);\n      }\n    }\n    function yo(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    ra(po, \"FeaturePositionMap\");\n    class go {\n      constructor(t) {\n        this.gl = t.gl, this.initialized = !1;\n      }\n      fetchUniformLocation(t, e) {\n        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;\n      }\n    }\n    class xo extends go {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));\n      }\n    }\n    class vo extends go {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));\n      }\n    }\n    class bo extends go {\n      constructor(t) {\n        super(t), this.current = [0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));\n      }\n    }\n    class _o extends go {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));\n      }\n    }\n    class wo extends go {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));\n      }\n    }\n    class Mo extends go {\n      constructor(t) {\n        super(t), this.current = le.transparent;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));\n      }\n    }\n    const Ao = new Float32Array(16);\n    class So extends go {\n      constructor(t) {\n        super(t), this.current = Ao;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) {\n          if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);\n          for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {\n            this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);\n            break;\n          }\n        }\n      }\n    }\n    const Io = new Float32Array(9),\n      ko = new Float32Array(4);\n    class Po extends go {\n      constructor(t) {\n        super(t), this.current = ko;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 4; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);\n          break;\n        }\n      }\n    }\n    function Eo(t) {\n      return [ro(255 * t.r, 255 * t.g), ro(255 * t.b, 255 * t.a)];\n    }\n    class zo {\n      constructor(t, e, r) {\n        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;\n      }\n      setUniform(t, e, r, n, i) {\n        e.set(t, i, n.constantOr(this.value));\n      }\n      getBinding(t, e) {\n        return \"color\" === this.type ? new Mo(t) : new vo(t);\n      }\n    }\n    class To {\n      constructor(t, e) {\n        this.uniformNames = e.map(t => `u_${t}`), this.pattern = null, this.pixelRatio = 1;\n      }\n      setConstantPatternPositions(t) {\n        this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br);\n      }\n      setUniform(t, e, r, n, i) {\n        const a = \"u_pattern\" === i || \"u_dash\" === i ? this.pattern : \"u_pixel_ratio\" === i ? this.pixelRatio : null;\n        a && e.set(t, i, a);\n      }\n      getBinding(t, e) {\n        return \"u_pattern\" === e || \"u_dash\" === e ? new wo(t) : new vo(t);\n      }\n    }\n    class Bo {\n      constructor(t, e, r, n) {\n        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 2 : 1,\n          offset: 0\n        })), this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r, n, i, a, s) {\n        const o = this.paintVertexArray.length,\n          l = this.expression.evaluate(new Pa(0, {\n            brightness: a\n          }), e, {}, i, n, s);\n        this.paintVertexArray.resize(t), this._setPaintValue(o, t, l);\n      }\n      updatePaintArray(t, e, r, n, i, a, s) {\n        const o = this.expression.evaluate({\n          zoom: 0,\n          brightness: s\n        }, r, n, void 0, i);\n        this._setPaintValue(t, e, o);\n      }\n      _setPaintValue(t, e, r) {\n        if (\"color\" === this.type) {\n          const n = Eo(r);\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);\n        } else {\n          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class Co {\n      constructor(t, e, r, n, i, a) {\n        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 4 : 2,\n          offset: 0\n        })), this.paintVertexArray = new a();\n      }\n      populatePaintArray(t, e, r, n, i, a, s) {\n        const o = this.expression.evaluate(new Pa(this.zoom, {\n            brightness: a\n          }), e, {}, i, n, s),\n          l = this.expression.evaluate(new Pa(this.zoom + 1, {\n            brightness: a\n          }), e, {}, i, n, s),\n          u = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValue(u, t, o, l);\n      }\n      updatePaintArray(t, e, r, n, i, a, s) {\n        const o = this.expression.evaluate({\n            zoom: this.zoom,\n            brightness: s\n          }, r, n, void 0, i),\n          l = this.expression.evaluate({\n            zoom: this.zoom + 1,\n            brightness: s\n          }, r, n, void 0, i);\n        this._setPaintValue(t, e, o, l);\n      }\n      _setPaintValue(t, e, r, n) {\n        if (\"color\" === this.type) {\n          const i = Eo(r),\n            a = Eo(n);\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], a[0], a[1]);\n        } else {\n          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n      setUniform(t, e, r, n, i) {\n        const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,\n          s = I(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);\n        e.set(t, i, s);\n      }\n      getBinding(t, e) {\n        return new vo(t);\n      }\n    }\n    class Ro {\n      constructor(t, e, r, n, i) {\n        this.expression = t, this.layerId = i, this.paintVertexAttributes = (\"array\" === r ? io : no).members;\n        for (let t = 0; t < e.length; ++t);\n        this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r) {\n        const n = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n      }\n      updatePaintArray(t, e, r, n, i, a, s) {\n        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], a);\n      }\n      _setPaintValues(t, e, r, n) {\n        if (!n || !r) return;\n        const i = n[r];\n        if (!i) return;\n        const {\n          tl: a,\n          br: s,\n          pixelRatio: o\n        } = i;\n        for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, a[0], a[1], s[0], s[1], o);\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class Do {\n      constructor(t, e, r = () => !0) {\n        this.binders = {}, this._buffers = [];\n        const n = [];\n        for (const i in t.paint._values) {\n          const a = t.paint.get(i);\n          if (!r(i)) continue;\n          if (!(a instanceof Da && Ti(a.property.specification))) continue;\n          const s = Fo(i, t.type),\n            o = a.value,\n            l = a.property.specification.type,\n            u = !!a.property.useIntegerZoom,\n            c = \"line-dasharray\" === i || i.endsWith(\"pattern\"),\n            h = \"line-dasharray\" === i && \"constant\" !== t.layout.get(\"line-cap\").value.kind;\n          if (\"constant\" !== o.kind || h) {\n            if (\"source\" === o.kind || h || c) {\n              const e = Uo(i, l, \"source\");\n              this.binders[i] = c ? new Ro(o, s, l, e, t.id) : new Bo(o, s, l, e), n.push(`/a_${i}`);\n            } else {\n              const t = Uo(i, l, \"composite\");\n              this.binders[i] = new Co(o, s, l, u, e, t), n.push(`/z_${i}`);\n            }\n          } else this.binders[i] = c ? new To(o.value, s) : new zo(o.value, s, l), n.push(`/u_${i}`);\n        }\n        this.cacheKey = n.sort().join(\"\");\n      }\n      getMaxValue(t) {\n        const e = this.binders[t];\n        return e instanceof Bo || e instanceof Co ? e.maxValue : 0;\n      }\n      populatePaintArrays(t, e, r, n, i, a, s) {\n        for (const o in this.binders) {\n          const l = this.binders[o];\n          (l instanceof Bo || l instanceof Co || l instanceof Ro) && l.populatePaintArray(t, e, r, n, i, a, s);\n        }\n      }\n      setConstantPatternPositions(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          r instanceof To && r.setConstantPatternPositions(t);\n        }\n      }\n      updatePaintArrays(t, e, r, n, i, a, s, o) {\n        let l = !1;\n        const u = Object.keys(t),\n          c = 0 !== u.length,\n          h = c ? u : e.uniqueIds;\n        for (const u in this.binders) {\n          const p = this.binders[u];\n          if ((p instanceof Bo || p instanceof Co || p instanceof Ro) && (!0 === p.expression.isStateDependent || !1 === p.expression.isLightConstant)) {\n            const f = i.paint.get(u);\n            p.expression = f.value;\n            for (const r of h) {\n              const i = t[r.toString()];\n              e.eachPosition(r, (t, e, r) => {\n                const l = n.feature(t);\n                p.updatePaintArray(e, r, l, i, a, s, o);\n              });\n            }\n            if (!c) for (const e of r.uniqueIds) {\n              const i = t[e.toString()];\n              r.eachPosition(e, (t, e, r) => {\n                const l = n.feature(t);\n                p.updatePaintArray(e, r, l, i, a, s, o);\n              });\n            }\n            l = !0;\n          }\n        }\n        return l;\n      }\n      defines() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof zo || r instanceof To) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));\n        }\n        return t;\n      }\n      getBinderAttributes() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Bo || r instanceof Co || r instanceof Ro) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);\n        }\n        return t;\n      }\n      getBinderUniforms() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof zo || r instanceof To || r instanceof Co) for (const e of r.uniformNames) t.push(e);\n        }\n        return t;\n      }\n      getPaintVertexBuffers() {\n        return this._buffers;\n      }\n      getUniforms(t) {\n        const e = [];\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          if (n instanceof zo || n instanceof To || n instanceof Co) for (const i of n.uniformNames) e.push({\n            name: i,\n            property: r,\n            binding: n.getBinding(t, i)\n          });\n        }\n        return e;\n      }\n      setUniforms(t, e, r, n, i) {\n        for (const {\n          name: e,\n          property: a,\n          binding: s\n        } of r) this.binders[a].setUniform(t, s, i, n.get(a), e);\n      }\n      updatePaintBuffers() {\n        this._buffers = [];\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Bo || e instanceof Co || e instanceof Ro) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);\n        }\n      }\n      upload(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Bo || r instanceof Co || r instanceof Ro) && r.upload(t);\n        }\n        this.updatePaintBuffers();\n      }\n      destroy() {\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Bo || e instanceof Co || e instanceof Ro) && e.destroy();\n        }\n      }\n    }\n    class Vo {\n      constructor(t, e, r = () => !0) {\n        this.programConfigurations = {};\n        for (const n of t) this.programConfigurations[n.id] = new Do(n, e, r);\n        this.needsUpload = !1, this._featureMap = new po(), this._featureMapWithoutIds = new po(), this._bufferOffset = 0, this._idlessCounter = 0;\n      }\n      populatePaintArrays(t, e, r, n, i, a, s, o) {\n        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, a, s, o);\n        void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t), this._idlessCounter += 1), this._bufferOffset = t, this.needsUpload = !0;\n      }\n      updatePaintArrays(t, e, r, n, i, a) {\n        for (const s of r) this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, this._featureMapWithoutIds, e, s, n, i, a || 0) || this.needsUpload;\n      }\n      get(t) {\n        return this.programConfigurations[t];\n      }\n      upload(t) {\n        if (this.needsUpload) {\n          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n          this.needsUpload = !1;\n        }\n      }\n      destroy() {\n        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n      }\n    }\n    const Lo = {\n      \"text-opacity\": [\"opacity\"],\n      \"icon-opacity\": [\"opacity\"],\n      \"text-color\": [\"fill_color\"],\n      \"icon-color\": [\"fill_color\"],\n      \"text-emissive-strength\": [\"emissive_strength\"],\n      \"icon-emissive-strength\": [\"emissive_strength\"],\n      \"text-halo-color\": [\"halo_color\"],\n      \"icon-halo-color\": [\"halo_color\"],\n      \"text-halo-blur\": [\"halo_blur\"],\n      \"icon-halo-blur\": [\"halo_blur\"],\n      \"text-halo-width\": [\"halo_width\"],\n      \"icon-halo-width\": [\"halo_width\"],\n      \"line-gap-width\": [\"gapwidth\"],\n      \"line-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"fill-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"fill-extrusion-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"line-dasharray\": [\"dash\"]\n    };\n    function Fo(t, e) {\n      return Lo[t] || [t.replace(`${e}-`, \"\").replace(/-/g, \"_\")];\n    }\n    const No = {\n        \"line-pattern\": {\n          source: xs,\n          composite: xs\n        },\n        \"fill-pattern\": {\n          source: xs,\n          composite: xs\n        },\n        \"fill-extrusion-pattern\": {\n          source: xs,\n          composite: xs\n        },\n        \"line-dasharray\": {\n          source: vs,\n          composite: vs\n        }\n      },\n      Oo = {\n        color: {\n          source: Fs,\n          composite: gs\n        },\n        number: {\n          source: Bs,\n          composite: Fs\n        }\n      };\n    function Uo(t, e, r) {\n      const n = No[t];\n      return n && n[r] || Oo[e][r];\n    }\n    ra(zo, \"ConstantBinder\"), ra(To, \"PatternConstantBinder\"), ra(Bo, \"SourceExpressionBinder\"), ra(Ro, \"PatternCompositeBinder\"), ra(Co, \"CompositeExpressionBinder\"), ra(Do, \"ProgramConfiguration\", {\n      omit: [\"_buffers\"]\n    }), ra(Vo, \"ProgramConfigurationSet\");\n    const jo = Tr / Math.PI / 2,\n      qo = 5,\n      $o = 6,\n      Go = 16383,\n      Yo = 64,\n      Xo = [Yo, 32, 16],\n      Zo = -jo,\n      Ko = jo;\n    function Ho(t, e, r, n = jo) {\n      return r = b(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];\n    }\n    function Wo(t, e, r) {\n      return Ho(Math.cos(b(t)), Math.sin(b(t)), e, r);\n    }\n    const Jo = 6371008.8,\n      Qo = 2 * Math.PI * Jo;\n    class tl {\n      constructor(t, e) {\n        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);\n        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n      }\n      wrap() {\n        return new tl(P(this.lng, -180, 180), this.lat);\n      }\n      toArray() {\n        return [this.lng, this.lat];\n      }\n      toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n      }\n      distanceTo(t) {\n        const e = Math.PI / 180,\n          r = this.lat * e,\n          n = t.lat * e,\n          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n        return Jo * Math.acos(Math.min(i, 1));\n      }\n      toBounds(t = 0) {\n        const e = 360 * t / 40075017,\n          r = e / Math.cos(Math.PI / 180 * this.lat);\n        return new el({\n          lng: this.lng - r,\n          lat: this.lat - e\n        }, {\n          lng: this.lng + r,\n          lat: this.lat + e\n        });\n      }\n      toEcef(t) {\n        return Wo(this.lat, this.lng, jo + t * jo / Jo);\n      }\n      static convert(t) {\n        if (t instanceof tl) return t;\n        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new tl(Number(t[0]), Number(t[1]));\n        if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new tl(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n      }\n    }\n    class el {\n      constructor(t, e) {\n        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n      }\n      setNorthEast(t) {\n        return this._ne = t instanceof tl ? new tl(t.lng, t.lat) : tl.convert(t), this;\n      }\n      setSouthWest(t) {\n        return this._sw = t instanceof tl ? new tl(t.lng, t.lat) : tl.convert(t), this;\n      }\n      extend(t) {\n        const e = this._sw,\n          r = this._ne;\n        let n, i;\n        if (t instanceof tl) n = t, i = t;else {\n          if (!(t instanceof el)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(el.convert(t)) : this.extend(tl.convert(t)) : \"object\" == typeof t && null !== t && t.hasOwnProperty(\"lat\") && (t.hasOwnProperty(\"lon\") || t.hasOwnProperty(\"lng\")) ? this.extend(tl.convert(t)) : this;\n          if (n = t._sw, i = t._ne, !n || !i) return this;\n        }\n        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new tl(n.lng, n.lat), this._ne = new tl(i.lng, i.lat)), this;\n      }\n      getCenter() {\n        return new tl((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n      }\n      getSouthWest() {\n        return this._sw;\n      }\n      getNorthEast() {\n        return this._ne;\n      }\n      getNorthWest() {\n        return new tl(this.getWest(), this.getNorth());\n      }\n      getSouthEast() {\n        return new tl(this.getEast(), this.getSouth());\n      }\n      getWest() {\n        return this._sw.lng;\n      }\n      getSouth() {\n        return this._sw.lat;\n      }\n      getEast() {\n        return this._ne.lng;\n      }\n      getNorth() {\n        return this._ne.lat;\n      }\n      toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n      }\n      toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n      }\n      isEmpty() {\n        return !(this._sw && this._ne);\n      }\n      contains(t) {\n        const {\n          lng: e,\n          lat: r\n        } = tl.convert(t);\n        let n = this._sw.lng <= e && e <= this._ne.lng;\n        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n      }\n      static convert(t) {\n        return !t || t instanceof el ? t : new el(t);\n      }\n    }\n    var rl = {};\n    !function (t, e) {\n      !function (t) {\n        function e(t, e, n) {\n          var i = r(256 * t, 256 * (e = Math.pow(2, n) - e - 1), n),\n            a = r(256 * (t + 1), 256 * (e + 1), n);\n          return i[0] + \",\" + i[1] + \",\" + a[0] + \",\" + a[1];\n        }\n        function r(t, e, r) {\n          var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n          return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n        }\n        t.getURL = function (t, r, n, i, a, s) {\n          return s = s || {}, t + \"?\" + [\"bbox=\" + e(n, i, a), \"format=\" + (s.format || \"image/png\"), \"service=\" + (s.service || \"WMS\"), \"version=\" + (s.version || \"1.1.1\"), \"request=\" + (s.request || \"GetMap\"), \"srs=\" + (s.srs || \"EPSG:3857\"), \"width=\" + (s.width || 256), \"height=\" + (s.height || 256), \"layers=\" + r].join(\"&\");\n        }, t.getTileBBox = e, t.getMercCoords = r, Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      }(e);\n    }(0, rl);\n    var nl = rl;\n    class il {\n      constructor(t, e, r) {\n        this.z = t, this.x = e, this.y = r, this.key = ol(0, t, t, e, r);\n      }\n      equals(t) {\n        return this.z === t.z && this.x === t.x && this.y === t.y;\n      }\n      url(t, e) {\n        const r = nl.getTileBBox(this.x, this.y, this.z),\n          n = function (t, e, r) {\n            let n,\n              i = \"\";\n            for (let a = t; a > 0; a--) n = 1 << a - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n            return i;\n          }(this.z, this.x, this.y);\n        return t[(this.x + this.y) % t.length].replace(\"{prefix}\", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(\"tms\" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(\"{quadkey}\", n).replace(\"{bbox-epsg-3857}\", r);\n      }\n      toString() {\n        return `${this.z}/${this.x}/${this.y}`;\n      }\n    }\n    class al {\n      constructor(t, e) {\n        this.wrap = t, this.canonical = e, this.key = ol(t, e.z, e.z, e.x, e.y);\n      }\n    }\n    class sl {\n      constructor(t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new il(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : ol(e, t, r, n, i);\n      }\n      equals(t) {\n        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n      }\n      scaledTo(t) {\n        const e = this.canonical.z - t;\n        return t > this.canonical.z ? new sl(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new sl(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n      }\n      calculateScaledKey(t, e = !0) {\n        if (this.overscaledZ === t && e) return this.key;\n        if (t > this.canonical.z) return ol(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);\n        {\n          const r = this.canonical.z - t;\n          return ol(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n        }\n      }\n      isChildOf(t) {\n        if (t.wrap !== this.wrap) return !1;\n        const e = this.canonical.z - t.canonical.z;\n        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.z < this.canonical.z && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n      }\n      children(t) {\n        if (this.overscaledZ >= t) return [new sl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        const e = this.canonical.z + 1,\n          r = 2 * this.canonical.x,\n          n = 2 * this.canonical.y;\n        return [new sl(e, this.wrap, e, r, n), new sl(e, this.wrap, e, r + 1, n), new sl(e, this.wrap, e, r, n + 1), new sl(e, this.wrap, e, r + 1, n + 1)];\n      }\n      isLessThan(t) {\n        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n      }\n      wrapped() {\n        return new sl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      unwrapTo(t) {\n        return new sl(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n      }\n      toUnwrapped() {\n        return new al(this.wrap, this.canonical);\n      }\n      toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n      }\n    }\n    function ol(t, e, r, n, i) {\n      const a = 1 << Math.min(r, 22);\n      let s = a * (i % a) + n % a;\n      return t && r < 22 && (s += a * a * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * s + r) + (e - r);\n    }\n    const ll = [t => {\n      let e = t.canonical.x - 1,\n        r = t.wrap;\n      return e < 0 && (e = (1 << t.canonical.z) - 1, r--), new sl(t.overscaledZ, r, t.canonical.z, e, t.canonical.y);\n    }, t => {\n      let e = t.canonical.x + 1,\n        r = t.wrap;\n      return e === 1 << t.canonical.z && (e = 0, r++), new sl(t.overscaledZ, r, t.canonical.z, e, t.canonical.y);\n    }, t => new sl(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new sl(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)];\n    ra(il, \"CanonicalTileID\"), ra(sl, \"OverscaledTileID\", {\n      omit: [\"projMatrix\", \"expandedProjMatrix\"]\n    });\n    const ul = 0,\n      cl = 25.5;\n    function hl(t) {\n      return Qo * Math.cos(t * Math.PI / 180);\n    }\n    function pl(t) {\n      return (180 + t) / 360;\n    }\n    function fl(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n    function dl(t, e) {\n      return t / hl(e);\n    }\n    function ml(t) {\n      return 360 * t - 180;\n    }\n    function yl(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function gl(t, e) {\n      return t * hl(yl(e));\n    }\n    const xl = 85.051129;\n    function vl(t) {\n      return Math.cos(b(I(t, -xl, xl)));\n    }\n    function bl(t, e) {\n      const r = I(e, ul, cl),\n        n = Math.pow(2, r);\n      return vl(t) * Qo / (512 * n);\n    }\n    function _l(t) {\n      return 1 / Math.cos(t * Math.PI / 180);\n    }\n    function wl(t, e = 0) {\n      const r = Math.exp(Math.PI * (1 - (t.y + e / Tr) / (1 << t.z) * 2));\n      return 80150034 * r / (r * r + 1) / Tr / (1 << t.z);\n    }\n    class Ml {\n      constructor(t, e, r = 0) {\n        this.x = +t, this.y = +e, this.z = +r;\n      }\n      static fromLngLat(t, e = 0) {\n        const r = tl.convert(t);\n        return new Ml(pl(r.lng), fl(r.lat), dl(e, r.lat));\n      }\n      toLngLat() {\n        return new tl(ml(this.x), yl(this.y));\n      }\n      toAltitude() {\n        return gl(this.z, this.y);\n      }\n      meterInMercatorCoordinateUnits() {\n        return 1 / Qo * _l(yl(this.y));\n      }\n    }\n    function Al(t, e, r, n, i, a, s, o, l) {\n      const u = (e + n) / 2,\n        c = (r + i) / 2,\n        h = new g(u, c);\n      o(h), function (t, e, r, n, i, a) {\n        const s = r - i,\n          o = n - a;\n        return Math.abs((n - e) * s - (r - t) * o) / Math.hypot(s, o);\n      }(h.x, h.y, a.x, a.y, s.x, s.y) >= l ? (Al(t, e, r, u, c, a, h, o, l), Al(t, u, c, n, i, h, s, o, l)) : t.push(s);\n    }\n    function Sl(t, e, r) {\n      let n = t[0],\n        i = n.x,\n        a = n.y;\n      e(n);\n      const s = [n];\n      for (let o = 1; o < t.length; o++) {\n        const l = t[o],\n          {\n            x: u,\n            y: c\n          } = l;\n        e(l), Al(s, i, a, u, c, n, l, e, r), i = u, a = c, n = l;\n      }\n      return s;\n    }\n    function Il(t, e, r, n) {\n      if (n(e, r)) {\n        const i = e.add(r)._mult(.5);\n        Il(t, e, i, n), Il(t, i, r, n);\n      } else t.push(r);\n    }\n    function kl(t, e) {\n      let r = t[0];\n      const n = [r];\n      for (let i = 1; i < t.length; i++) {\n        const a = t[i];\n        Il(n, r, a, e), r = a;\n      }\n      return n;\n    }\n    const Pl = Math.pow(2, 14) - 1,\n      El = -Pl - 1;\n    function zl(t, e) {\n      const r = Math.round(t.x * e),\n        n = Math.round(t.y * e);\n      return t.x = I(r, El, Pl), t.y = I(n, El, Pl), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && j(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\"), t;\n    }\n    function Tl(t, e, r) {\n      const n = t.loadGeometry(),\n        i = t.extent,\n        a = Tr / i;\n      if (e && r && r.projection.isReprojectedInTileSpace) {\n        const a = 1 << e.z,\n          {\n            scale: s,\n            x: o,\n            y: l,\n            projection: u\n          } = r,\n          c = t => {\n            const r = ml((e.x + t.x / i) / a),\n              n = yl((e.y + t.y / i) / a),\n              c = u.project(r, n);\n            t.x = (c.x * s - o) * i, t.y = (c.y * s - l) * i;\n          };\n        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = Sl(n[e], c, 1);else {\n          const t = [];\n          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));\n          n[e] = t;\n        }\n      }\n      for (const t of n) for (const e of t) zl(e, a);\n      return n;\n    }\n    function Bl(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? Tl(t) : []\n      };\n    }\n    function Cl(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n    function Rl(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class Dl {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new ps(), this.indexArray = new Es(), this.segments = new eo(), this.programConfigurations = new Vo(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          a = [];\n        let s = null;\n        \"circle\" === i.type && (s = i.layout.get(\"circle-sort-key\"));\n        for (const {\n          feature: e,\n          id: i,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = Bl(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Pa(this.zoom), u, r)) continue;\n          const c = s ? s.evaluate(u, {}, r) : void 0,\n            h = {\n              id: i,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: t ? u.geometry : Tl(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          a.push(h);\n        }\n        s && a.sort((t, e) => t.sortKey - e.sortKey);\n        let o = null;\n        \"globe\" === n.projection.name && (this.globeExtVertexArray = new bs(), o = n.projection);\n        for (const n of a) {\n          const {\n              geometry: i,\n              index: a,\n              sourceLayerIndex: s\n            } = n,\n            l = t[a].feature;\n          this.addFeature(n, i, a, e.availableImages, r, o, e.brightness), e.featureIndex.insert(l, i, a, s, this.index);\n        }\n      }\n      update(t, e, r, n, i) {\n        const a = 0 !== Object.keys(t).length;\n        a && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t, e, a ? this.stateDependentLayers : this.layers, r, n, i);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Qs.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, to.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());\n      }\n      addFeature(t, e, r, n, i, a, s) {\n        for (const r of e) for (const e of r) {\n          const r = e.x,\n            n = e.y;\n          if (r < 0 || r >= Tr || n < 0 || n >= Tr) continue;\n          if (a) {\n            const t = a.projectTilePoint(r, n, i),\n              e = a.upVector(i, r, n),\n              s = this.globeExtVertexArray;\n            Rl(s, t, e), Rl(s, t, e), Rl(s, t, e), Rl(s, t, e);\n          }\n          const s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n            o = s.vertexLength;\n          Cl(this.layoutVertexArray, r, n, -1, -1), Cl(this.layoutVertexArray, r, n, 1, -1), Cl(this.layoutVertexArray, r, n, 1, 1), Cl(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), s.vertexLength += 4, s.primitiveLength += 2;\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i, s);\n      }\n    }\n    function Vl(t, e) {\n      for (let r = 0; r < t.length; r++) if (Gl(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (Gl(t, e[r])) return !0;\n      return !!Ol(t, e);\n    }\n    function Ll(t, e, r) {\n      return !!Gl(t, e) || !!jl(e, t, r);\n    }\n    function Fl(t, e) {\n      if (1 === t.length) return $l(e, t[0]);\n      for (let r = 0; r < e.length; r++) {\n        const n = e[r];\n        for (let e = 0; e < n.length; e++) if (Gl(t, n[e])) return !0;\n      }\n      for (let r = 0; r < t.length; r++) if ($l(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (Ol(t, e[r])) return !0;\n      return !1;\n    }\n    function Nl(t, e, r) {\n      if (t.length > 1) {\n        if (Ol(t, e)) return !0;\n        for (let n = 0; n < e.length; n++) if (jl(e[n], t, r)) return !0;\n      }\n      for (let n = 0; n < t.length; n++) if (jl(t[n], e, r)) return !0;\n      return !1;\n    }\n    function Ol(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1];\n        for (let t = 0; t < e.length - 1; t++) if (Ul(n, i, e[t], e[t + 1])) return !0;\n      }\n      return !1;\n    }\n    function Ul(t, e, r, n) {\n      return q(t, r, n) !== q(e, r, n) && q(t, e, r) !== q(t, e, n);\n    }\n    function jl(t, e, r) {\n      const n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n      for (let r = 1; r < e.length; r++) if (ql(t, e[r - 1], e[r]) < n) return !0;\n      return !1;\n    }\n    function ql(t, e, r) {\n      const n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n    function $l(t, e) {\n      let r,\n        n,\n        i,\n        a = !1;\n      for (let s = 0; s < t.length; s++) {\n        r = t[s];\n        for (let t = 0, s = r.length - 1; t < r.length; s = t++) n = r[t], i = r[s], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (a = !a);\n      }\n      return a;\n    }\n    function Gl(t, e) {\n      let r = !1;\n      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n        const a = t[n],\n          s = t[i];\n        a.y > e.y != s.y > e.y && e.x < (s.x - a.x) * (e.y - a.y) / (s.y - a.y) + a.x && (r = !r);\n      }\n      return r;\n    }\n    function Yl(t, e, r, n, i) {\n      for (const a of t) if (e <= a.x && r <= a.y && n >= a.x && i >= a.y) return !0;\n      const a = [new g(e, r), new g(e, i), new g(n, i), new g(n, r)];\n      if (t.length > 2) for (const e of a) if (Gl(t, e)) return !0;\n      for (let e = 0; e < t.length - 1; e++) if (Xl(t[e], t[e + 1], a)) return !0;\n      return !1;\n    }\n    function Xl(t, e, r) {\n      const n = r[0],\n        i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      const a = q(t, e, r[0]);\n      return a !== q(t, e, r[1]) || a !== q(t, e, r[2]) || a !== q(t, e, r[3]);\n    }\n    function Zl(t, e, r, n, i, a) {\n      let s = e.y - t.y,\n        o = t.x - e.x;\n      if (a = a || 0) {\n        const t = s * s + o * o;\n        if (0 === t) return !0;\n        const e = Math.sqrt(t);\n        s /= e, o /= e;\n      }\n      return !((r.x - t.x) * s + (r.y - t.y) * o - a < 0 || (n.x - t.x) * s + (n.y - t.y) * o - a < 0 || (i.x - t.x) * s + (i.y - t.y) * o - a < 0);\n    }\n    function Kl(t, e, r, n, i, a, s) {\n      return !(Zl(t, e, n, i, a, s) || Zl(e, r, n, i, a, s) || Zl(r, t, n, i, a, s) || Zl(n, i, t, e, r, s) || Zl(i, a, t, e, r, s) || Zl(a, n, t, e, r, s));\n    }\n    function Hl(t, e, r) {\n      const n = e.paint.get(t).value;\n      return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n    function Wl(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n    function Jl(t, e, r, n, i) {\n      if (!e[0] && !e[1]) return t;\n      const a = g.convert(e)._mult(i);\n      \"viewport\" === r && a._rotate(-n);\n      const s = [];\n      for (let e = 0; e < t.length; e++) s.push(t[e].sub(a));\n      return s;\n    }\n    function Ql(t, e, r, n) {\n      const i = g.convert(t)._mult(n);\n      return \"viewport\" === e && i._rotate(-r), i;\n    }\n    ra(Dl, \"CircleBucket\", {\n      omit: [\"layers\"]\n    });\n    const tu = new Oa({\n      \"circle-sort-key\": new Fa(qa.layout_circle[\"circle-sort-key\"]),\n      visibility: new La(qa.layout_circle.visibility)\n    });\n    var eu = {\n        paint: new Oa({\n          \"circle-radius\": new Fa(qa.paint_circle[\"circle-radius\"]),\n          \"circle-color\": new Fa(qa.paint_circle[\"circle-color\"]),\n          \"circle-blur\": new Fa(qa.paint_circle[\"circle-blur\"]),\n          \"circle-opacity\": new Fa(qa.paint_circle[\"circle-opacity\"]),\n          \"circle-translate\": new La(qa.paint_circle[\"circle-translate\"]),\n          \"circle-translate-anchor\": new La(qa.paint_circle[\"circle-translate-anchor\"]),\n          \"circle-pitch-scale\": new La(qa.paint_circle[\"circle-pitch-scale\"]),\n          \"circle-pitch-alignment\": new La(qa.paint_circle[\"circle-pitch-alignment\"]),\n          \"circle-stroke-width\": new Fa(qa.paint_circle[\"circle-stroke-width\"]),\n          \"circle-stroke-color\": new Fa(qa.paint_circle[\"circle-stroke-color\"]),\n          \"circle-stroke-opacity\": new Fa(qa.paint_circle[\"circle-stroke-opacity\"]),\n          \"circle-emissive-strength\": new La(qa.paint_circle[\"circle-emissive-strength\"])\n        }),\n        layout: tu\n      },\n      ru = {},\n      nu = {};\n    Object.defineProperty(nu, \"__esModule\", {\n      value: !0\n    }), nu.setMatrixArrayType = function (t) {\n      nu.ARRAY_TYPE = au = t;\n    }, nu.toRadian = function (t) {\n      return t * ou;\n    }, nu.equals = function (t, e) {\n      return Math.abs(t - e) <= iu * Math.max(1, Math.abs(t), Math.abs(e));\n    }, nu.RANDOM = nu.ARRAY_TYPE = nu.EPSILON = void 0;\n    var iu = 1e-6;\n    nu.EPSILON = iu;\n    var au = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n    nu.ARRAY_TYPE = au;\n    var su = Math.random;\n    nu.RANDOM = su;\n    var ou = Math.PI / 180;\n    Math.hypot || (Math.hypot = function () {\n      for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];\n      return Math.sqrt(t);\n    });\n    var lu = {};\n    function uu(t) {\n      return uu = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, uu(t);\n    }\n    Object.defineProperty(lu, \"__esModule\", {\n      value: !0\n    }), lu.create = function () {\n      var t = new cu.ARRAY_TYPE(4);\n      return cu.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n    }, lu.clone = function (t) {\n      var e = new cu.ARRAY_TYPE(4);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;\n    }, lu.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;\n    }, lu.identity = function (t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;\n    }, lu.fromValues = function (t, e, r, n) {\n      var i = new cu.ARRAY_TYPE(4);\n      return i[0] = t, i[1] = e, i[2] = r, i[3] = n, i;\n    }, lu.set = function (t, e, r, n, i) {\n      return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t;\n    }, lu.transpose = function (t, e) {\n      if (t === e) {\n        var r = e[1];\n        t[1] = e[2], t[2] = r;\n      } else t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3];\n      return t;\n    }, lu.invert = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = r * a - i * n;\n      return s ? (t[0] = a * (s = 1 / s), t[1] = -n * s, t[2] = -i * s, t[3] = r * s, t) : null;\n    }, lu.adjoint = function (t, e) {\n      var r = e[0];\n      return t[0] = e[3], t[1] = -e[1], t[2] = -e[2], t[3] = r, t;\n    }, lu.determinant = function (t) {\n      return t[0] * t[3] - t[2] * t[1];\n    }, lu.multiply = pu, lu.rotate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = n * -o + a * l, t[3] = i * -o + s * l, t;\n    }, lu.scale = function (t, e, r) {\n      var n = e[1],\n        i = e[2],\n        a = e[3],\n        s = r[0],\n        o = r[1];\n      return t[0] = e[0] * s, t[1] = n * s, t[2] = i * o, t[3] = a * o, t;\n    }, lu.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t;\n    }, lu.fromScaling = function (t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t;\n    }, lu.str = function (t) {\n      return \"mat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n    }, lu.frob = function (t) {\n      return Math.hypot(t[0], t[1], t[2], t[3]);\n    }, lu.LDU = function (t, e, r, n) {\n      return t[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t[2] * r[1], [t, e, r];\n    }, lu.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t;\n    }, lu.subtract = fu, lu.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n    }, lu.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t[3],\n        s = e[0],\n        o = e[1],\n        l = e[2],\n        u = e[3];\n      return Math.abs(r - s) <= cu.EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - o) <= cu.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= cu.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(a - u) <= cu.EPSILON * Math.max(1, Math.abs(a), Math.abs(u));\n    }, lu.multiplyScalar = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, lu.multiplyScalarAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t;\n    }, lu.sub = lu.mul = void 0;\n    var cu = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== uu(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = hu(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function hu(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (hu = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function pu(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = r[0],\n        l = r[1],\n        u = r[2],\n        c = r[3];\n      return t[0] = n * o + a * l, t[1] = i * o + s * l, t[2] = n * u + a * c, t[3] = i * u + s * c, t;\n    }\n    function fu(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t;\n    }\n    lu.mul = pu, lu.sub = fu;\n    var du = {};\n    function mu(t) {\n      return mu = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, mu(t);\n    }\n    Object.defineProperty(du, \"__esModule\", {\n      value: !0\n    }), du.create = function () {\n      var t = new yu.ARRAY_TYPE(6);\n      return yu.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;\n    }, du.clone = function (t) {\n      var e = new yu.ARRAY_TYPE(6);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;\n    }, du.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;\n    }, du.identity = function (t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;\n    }, du.fromValues = function (t, e, r, n, i, a) {\n      var s = new yu.ARRAY_TYPE(6);\n      return s[0] = t, s[1] = e, s[2] = r, s[3] = n, s[4] = i, s[5] = a, s;\n    }, du.set = function (t, e, r, n, i, a, s) {\n      return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = a, t[5] = s, t;\n    }, du.invert = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = r * a - n * i;\n      return l ? (t[0] = a * (l = 1 / l), t[1] = -n * l, t[2] = -i * l, t[3] = r * l, t[4] = (i * o - a * s) * l, t[5] = (n * s - r * o) * l, t) : null;\n    }, du.determinant = function (t) {\n      return t[0] * t[3] - t[1] * t[2];\n    }, du.multiply = xu, du.rotate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = Math.sin(r),\n        c = Math.cos(r);\n      return t[0] = n * c + a * u, t[1] = i * c + s * u, t[2] = n * -u + a * c, t[3] = i * -u + s * c, t[4] = o, t[5] = l, t;\n    }, du.scale = function (t, e, r) {\n      var n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = r[0],\n        u = r[1];\n      return t[0] = e[0] * l, t[1] = n * l, t[2] = i * u, t[3] = a * u, t[4] = s, t[5] = o, t;\n    }, du.translate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = r[0],\n        c = r[1];\n      return t[0] = n, t[1] = i, t[2] = a, t[3] = s, t[4] = n * u + a * c + o, t[5] = i * u + s * c + l, t;\n    }, du.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t[4] = 0, t[5] = 0, t;\n    }, du.fromScaling = function (t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t[4] = 0, t[5] = 0, t;\n    }, du.fromTranslation = function (t, e) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = e[0], t[5] = e[1], t;\n    }, du.str = function (t) {\n      return \"mat2d(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \")\";\n    }, du.frob = function (t) {\n      return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);\n    }, du.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t;\n    }, du.subtract = vu, du.multiplyScalar = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t;\n    }, du.multiplyScalarAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t[4] = e[4] + r[4] * n, t[5] = e[5] + r[5] * n, t;\n    }, du.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5];\n    }, du.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t[3],\n        s = t[4],\n        o = t[5],\n        l = e[0],\n        u = e[1],\n        c = e[2],\n        h = e[3],\n        p = e[4],\n        f = e[5];\n      return Math.abs(r - l) <= yu.EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - u) <= yu.EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(i - c) <= yu.EPSILON * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(a - h) <= yu.EPSILON * Math.max(1, Math.abs(a), Math.abs(h)) && Math.abs(s - p) <= yu.EPSILON * Math.max(1, Math.abs(s), Math.abs(p)) && Math.abs(o - f) <= yu.EPSILON * Math.max(1, Math.abs(o), Math.abs(f));\n    }, du.sub = du.mul = void 0;\n    var yu = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== mu(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = gu(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function gu(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (gu = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function xu(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = r[0],\n        c = r[1],\n        h = r[2],\n        p = r[3],\n        f = r[4],\n        d = r[5];\n      return t[0] = n * u + a * c, t[1] = i * u + s * c, t[2] = n * h + a * p, t[3] = i * h + s * p, t[4] = n * f + a * d + o, t[5] = i * f + s * d + l, t;\n    }\n    function vu(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t;\n    }\n    du.mul = xu, du.sub = vu;\n    var bu = {};\n    function _u(t) {\n      return _u = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, _u(t);\n    }\n    Object.defineProperty(bu, \"__esModule\", {\n      value: !0\n    }), bu.create = function () {\n      var t = new wu.ARRAY_TYPE(9);\n      return wu.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }, bu.fromMat4 = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;\n    }, bu.clone = function (t) {\n      var e = new wu.ARRAY_TYPE(9);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;\n    }, bu.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;\n    }, bu.fromValues = function (t, e, r, n, i, a, s, o, l) {\n      var u = new wu.ARRAY_TYPE(9);\n      return u[0] = t, u[1] = e, u[2] = r, u[3] = n, u[4] = i, u[5] = a, u[6] = s, u[7] = o, u[8] = l, u;\n    }, bu.set = function (t, e, r, n, i, a, s, o, l, u) {\n      return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = a, t[5] = s, t[6] = o, t[7] = l, t[8] = u, t;\n    }, bu.identity = function (t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, bu.transpose = function (t, e) {\n      if (t === e) {\n        var r = e[1],\n          n = e[2],\n          i = e[5];\n        t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;\n      } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];\n      return t;\n    }, bu.invert = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = c * s - o * u,\n        p = -c * a + o * l,\n        f = u * a - s * l,\n        d = r * h + n * p + i * f;\n      return d ? (t[0] = h * (d = 1 / d), t[1] = (-c * n + i * u) * d, t[2] = (o * n - i * s) * d, t[3] = p * d, t[4] = (c * r - i * l) * d, t[5] = (-o * r + i * a) * d, t[6] = f * d, t[7] = (-u * r + n * l) * d, t[8] = (s * r - n * a) * d, t) : null;\n    }, bu.adjoint = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8];\n      return t[0] = s * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * s, t[3] = o * l - a * c, t[4] = r * c - i * l, t[5] = i * a - r * o, t[6] = a * u - s * l, t[7] = n * l - r * u, t[8] = r * s - n * a, t;\n    }, bu.determinant = function (t) {\n      var e = t[3],\n        r = t[4],\n        n = t[5],\n        i = t[6],\n        a = t[7],\n        s = t[8];\n      return t[0] * (s * r - n * a) + t[1] * (-s * e + n * i) + t[2] * (a * e - r * i);\n    }, bu.multiply = Au, bu.translate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = r[0],\n        f = r[1];\n      return t[0] = n, t[1] = i, t[2] = a, t[3] = s, t[4] = o, t[5] = l, t[6] = p * n + f * s + u, t[7] = p * i + f * o + c, t[8] = p * a + f * l + h, t;\n    }, bu.rotate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = Math.sin(r),\n        f = Math.cos(r);\n      return t[0] = f * n + p * s, t[1] = f * i + p * o, t[2] = f * a + p * l, t[3] = f * s - p * n, t[4] = f * o - p * i, t[5] = f * l - p * a, t[6] = u, t[7] = c, t[8] = h, t;\n    }, bu.scale = function (t, e, r) {\n      var n = r[0],\n        i = r[1];\n      return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;\n    }, bu.fromTranslation = function (t, e) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t;\n    }, bu.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, bu.fromScaling = function (t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, bu.fromMat2d = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t;\n    }, bu.fromQuat = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = r + r,\n        o = n + n,\n        l = i + i,\n        u = r * s,\n        c = n * s,\n        h = n * o,\n        p = i * s,\n        f = i * o,\n        d = i * l,\n        m = a * s,\n        y = a * o,\n        g = a * l;\n      return t[0] = 1 - h - d, t[3] = c - g, t[6] = p + y, t[1] = c + g, t[4] = 1 - u - d, t[7] = f - m, t[2] = p - y, t[5] = f + m, t[8] = 1 - u - h, t;\n    }, bu.normalFromMat4 = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = e[9],\n        p = e[10],\n        f = e[11],\n        d = e[12],\n        m = e[13],\n        y = e[14],\n        g = e[15],\n        x = r * o - n * s,\n        v = r * l - i * s,\n        b = r * u - a * s,\n        _ = n * l - i * o,\n        w = n * u - a * o,\n        M = i * u - a * l,\n        A = c * m - h * d,\n        S = c * y - p * d,\n        I = c * g - f * d,\n        k = h * y - p * m,\n        P = h * g - f * m,\n        E = p * g - f * y,\n        z = x * E - v * P + b * k + _ * I - w * S + M * A;\n      return z ? (t[0] = (o * E - l * P + u * k) * (z = 1 / z), t[1] = (l * I - s * E - u * S) * z, t[2] = (s * P - o * I + u * A) * z, t[3] = (i * P - n * E - a * k) * z, t[4] = (r * E - i * I + a * S) * z, t[5] = (n * I - r * P - a * A) * z, t[6] = (m * M - y * w + g * _) * z, t[7] = (y * b - d * M - g * v) * z, t[8] = (d * w - m * b + g * x) * z, t) : null;\n    }, bu.projection = function (t, e, r) {\n      return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;\n    }, bu.str = function (t) {\n      return \"mat3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \")\";\n    }, bu.frob = function (t) {\n      return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n    }, bu.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t[8] = e[8] + r[8], t;\n    }, bu.subtract = Su, bu.multiplyScalar = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * r, t;\n    }, bu.multiplyScalarAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t[4] = e[4] + r[4] * n, t[5] = e[5] + r[5] * n, t[6] = e[6] + r[6] * n, t[7] = e[7] + r[7] * n, t[8] = e[8] + r[8] * n, t;\n    }, bu.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];\n    }, bu.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t[3],\n        s = t[4],\n        o = t[5],\n        l = t[6],\n        u = t[7],\n        c = t[8],\n        h = e[0],\n        p = e[1],\n        f = e[2],\n        d = e[3],\n        m = e[4],\n        y = e[5],\n        g = e[6],\n        x = e[7],\n        v = e[8];\n      return Math.abs(r - h) <= wu.EPSILON * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(n - p) <= wu.EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(i - f) <= wu.EPSILON * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(a - d) <= wu.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(s - m) <= wu.EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(o - y) <= wu.EPSILON * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(l - g) <= wu.EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - x) <= wu.EPSILON * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(c - v) <= wu.EPSILON * Math.max(1, Math.abs(c), Math.abs(v));\n    }, bu.sub = bu.mul = void 0;\n    var wu = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== _u(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = Mu(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function Mu(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (Mu = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function Au(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = r[0],\n        f = r[1],\n        d = r[2],\n        m = r[3],\n        y = r[4],\n        g = r[5],\n        x = r[6],\n        v = r[7],\n        b = r[8];\n      return t[0] = p * n + f * s + d * u, t[1] = p * i + f * o + d * c, t[2] = p * a + f * l + d * h, t[3] = m * n + y * s + g * u, t[4] = m * i + y * o + g * c, t[5] = m * a + y * l + g * h, t[6] = x * n + v * s + b * u, t[7] = x * i + v * o + b * c, t[8] = x * a + v * l + b * h, t;\n    }\n    function Su(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t[6] = e[6] - r[6], t[7] = e[7] - r[7], t[8] = e[8] - r[8], t;\n    }\n    bu.mul = Au, bu.sub = Su;\n    var Iu = {};\n    function ku(t) {\n      return ku = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, ku(t);\n    }\n    Object.defineProperty(Iu, \"__esModule\", {\n      value: !0\n    }), Iu.create = function () {\n      var t = new Pu.ARRAY_TYPE(16);\n      return Pu.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, Iu.clone = function (t) {\n      var e = new Pu.ARRAY_TYPE(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, Iu.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }, Iu.fromValues = function (t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m) {\n      var y = new Pu.ARRAY_TYPE(16);\n      return y[0] = t, y[1] = e, y[2] = r, y[3] = n, y[4] = i, y[5] = a, y[6] = s, y[7] = o, y[8] = l, y[9] = u, y[10] = c, y[11] = h, y[12] = p, y[13] = f, y[14] = d, y[15] = m, y;\n    }, Iu.set = function (t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y) {\n      return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = a, t[5] = s, t[6] = o, t[7] = l, t[8] = u, t[9] = c, t[10] = h, t[11] = p, t[12] = f, t[13] = d, t[14] = m, t[15] = y, t;\n    }, Iu.identity = zu, Iu.transpose = function (t, e) {\n      if (t === e) {\n        var r = e[1],\n          n = e[2],\n          i = e[3],\n          a = e[6],\n          s = e[7],\n          o = e[11];\n        t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = r, t[6] = e[9], t[7] = e[13], t[8] = n, t[9] = a, t[11] = e[14], t[12] = i, t[13] = s, t[14] = o;\n      } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];\n      return t;\n    }, Iu.invert = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = e[9],\n        p = e[10],\n        f = e[11],\n        d = e[12],\n        m = e[13],\n        y = e[14],\n        g = e[15],\n        x = r * o - n * s,\n        v = r * l - i * s,\n        b = r * u - a * s,\n        _ = n * l - i * o,\n        w = n * u - a * o,\n        M = i * u - a * l,\n        A = c * m - h * d,\n        S = c * y - p * d,\n        I = c * g - f * d,\n        k = h * y - p * m,\n        P = h * g - f * m,\n        E = p * g - f * y,\n        z = x * E - v * P + b * k + _ * I - w * S + M * A;\n      return z ? (t[0] = (o * E - l * P + u * k) * (z = 1 / z), t[1] = (i * P - n * E - a * k) * z, t[2] = (m * M - y * w + g * _) * z, t[3] = (p * w - h * M - f * _) * z, t[4] = (l * I - s * E - u * S) * z, t[5] = (r * E - i * I + a * S) * z, t[6] = (y * b - d * M - g * v) * z, t[7] = (c * M - p * b + f * v) * z, t[8] = (s * P - o * I + u * A) * z, t[9] = (n * I - r * P - a * A) * z, t[10] = (d * w - m * b + g * x) * z, t[11] = (h * b - c * w - f * x) * z, t[12] = (o * S - s * k - l * A) * z, t[13] = (r * k - n * S + i * A) * z, t[14] = (m * v - d * _ - y * x) * z, t[15] = (c * _ - h * v + p * x) * z, t) : null;\n    }, Iu.adjoint = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = e[9],\n        p = e[10],\n        f = e[11],\n        d = e[12],\n        m = e[13],\n        y = e[14],\n        g = e[15];\n      return t[0] = o * (p * g - f * y) - h * (l * g - u * y) + m * (l * f - u * p), t[1] = -(n * (p * g - f * y) - h * (i * g - a * y) + m * (i * f - a * p)), t[2] = n * (l * g - u * y) - o * (i * g - a * y) + m * (i * u - a * l), t[3] = -(n * (l * f - u * p) - o * (i * f - a * p) + h * (i * u - a * l)), t[4] = -(s * (p * g - f * y) - c * (l * g - u * y) + d * (l * f - u * p)), t[5] = r * (p * g - f * y) - c * (i * g - a * y) + d * (i * f - a * p), t[6] = -(r * (l * g - u * y) - s * (i * g - a * y) + d * (i * u - a * l)), t[7] = r * (l * f - u * p) - s * (i * f - a * p) + c * (i * u - a * l), t[8] = s * (h * g - f * m) - c * (o * g - u * m) + d * (o * f - u * h), t[9] = -(r * (h * g - f * m) - c * (n * g - a * m) + d * (n * f - a * h)), t[10] = r * (o * g - u * m) - s * (n * g - a * m) + d * (n * u - a * o), t[11] = -(r * (o * f - u * h) - s * (n * f - a * h) + c * (n * u - a * o)), t[12] = -(s * (h * y - p * m) - c * (o * y - l * m) + d * (o * p - l * h)), t[13] = r * (h * y - p * m) - c * (n * y - i * m) + d * (n * p - i * h), t[14] = -(r * (o * y - l * m) - s * (n * y - i * m) + d * (n * l - i * o)), t[15] = r * (o * p - l * h) - s * (n * p - i * h) + c * (n * l - i * o), t;\n    }, Iu.determinant = function (t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2],\n        i = t[3],\n        a = t[4],\n        s = t[5],\n        o = t[6],\n        l = t[7],\n        u = t[8],\n        c = t[9],\n        h = t[10],\n        p = t[11],\n        f = t[12],\n        d = t[13],\n        m = t[14],\n        y = t[15];\n      return (e * s - r * a) * (h * y - p * m) - (e * o - n * a) * (c * y - p * d) + (e * l - i * a) * (c * m - h * d) + (r * o - n * s) * (u * y - p * f) - (r * l - i * s) * (u * m - h * f) + (n * l - i * o) * (u * d - c * f);\n    }, Iu.multiply = Tu, Iu.translate = function (t, e, r) {\n      var n,\n        i,\n        a,\n        s,\n        o,\n        l,\n        u,\n        c,\n        h,\n        p,\n        f,\n        d,\n        m = r[0],\n        y = r[1],\n        g = r[2];\n      return e === t ? (t[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = a, t[3] = s, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * m + o * y + h * g + e[12], t[13] = i * m + l * y + p * g + e[13], t[14] = a * m + u * y + f * g + e[14], t[15] = s * m + c * y + d * g + e[15]), t;\n    }, Iu.scale = function (t, e, r) {\n      var n = r[0],\n        i = r[1],\n        a = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }, Iu.rotate = function (t, e, r, n) {\n      var i,\n        a,\n        s,\n        o,\n        l,\n        u,\n        c,\n        h,\n        p,\n        f,\n        d,\n        m,\n        y,\n        g,\n        x,\n        v,\n        b,\n        _,\n        w,\n        M,\n        A,\n        S,\n        I,\n        k,\n        P = n[0],\n        E = n[1],\n        z = n[2],\n        T = Math.hypot(P, E, z);\n      return T < Pu.EPSILON ? null : (P *= T = 1 / T, E *= T, z *= T, i = Math.sin(r), a = Math.cos(r), l = e[1], u = e[2], c = e[3], p = e[5], f = e[6], d = e[7], y = e[9], g = e[10], x = e[11], v = P * P * (s = 1 - a) + a, w = P * E * s - z * i, M = E * E * s + a, A = z * E * s + P * i, S = P * z * s + E * i, I = E * z * s - P * i, k = z * z * s + a, t[0] = (o = e[0]) * v + (h = e[4]) * (b = E * P * s + z * i) + (m = e[8]) * (_ = z * P * s - E * i), t[1] = l * v + p * b + y * _, t[2] = u * v + f * b + g * _, t[3] = c * v + d * b + x * _, t[4] = o * w + h * M + m * A, t[5] = l * w + p * M + y * A, t[6] = u * w + f * M + g * A, t[7] = c * w + d * M + x * A, t[8] = o * S + h * I + m * k, t[9] = l * S + p * I + y * k, t[10] = u * S + f * I + g * k, t[11] = c * S + d * I + x * k, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);\n    }, Iu.rotateX = function (t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        a = e[4],\n        s = e[5],\n        o = e[6],\n        l = e[7],\n        u = e[8],\n        c = e[9],\n        h = e[10],\n        p = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + u * n, t[5] = s * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - a * n, t[9] = c * i - s * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;\n    }, Iu.rotateY = function (t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        a = e[0],\n        s = e[1],\n        o = e[2],\n        l = e[3],\n        u = e[8],\n        c = e[9],\n        h = e[10],\n        p = e[11];\n      return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i - u * n, t[1] = s * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = a * n + u * i, t[9] = s * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;\n    }, Iu.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        a = e[0],\n        s = e[1],\n        o = e[2],\n        l = e[3],\n        u = e[4],\n        c = e[5],\n        h = e[6],\n        p = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + u * n, t[1] = s * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - a * n, t[5] = c * i - s * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;\n    }, Iu.fromTranslation = function (t, e) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t;\n    }, Iu.fromScaling = function (t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, Iu.fromRotation = function (t, e, r) {\n      var n,\n        i,\n        a,\n        s = r[0],\n        o = r[1],\n        l = r[2],\n        u = Math.hypot(s, o, l);\n      return u < Pu.EPSILON ? null : (s *= u = 1 / u, o *= u, l *= u, n = Math.sin(e), i = Math.cos(e), t[0] = s * s * (a = 1 - i) + i, t[1] = o * s * a + l * n, t[2] = l * s * a - o * n, t[3] = 0, t[4] = s * o * a - l * n, t[5] = o * o * a + i, t[6] = l * o * a + s * n, t[7] = 0, t[8] = s * l * a + o * n, t[9] = o * l * a - s * n, t[10] = l * l * a + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);\n    }, Iu.fromXRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, Iu.fromYRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, Iu.fromZRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, Iu.fromRotationTranslation = Bu, Iu.fromQuat2 = function (t, e) {\n      var r = new Pu.ARRAY_TYPE(3),\n        n = -e[0],\n        i = -e[1],\n        a = -e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = n * n + i * i + a * a + s * s;\n      return h > 0 ? (r[0] = 2 * (o * s + c * n + l * a - u * i) / h, r[1] = 2 * (l * s + c * i + u * n - o * a) / h, r[2] = 2 * (u * s + c * a + o * i - l * n) / h) : (r[0] = 2 * (o * s + c * n + l * a - u * i), r[1] = 2 * (l * s + c * i + u * n - o * a), r[2] = 2 * (u * s + c * a + o * i - l * n)), Bu(t, e, r), t;\n    }, Iu.getTranslation = function (t, e) {\n      return t[0] = e[12], t[1] = e[13], t[2] = e[14], t;\n    }, Iu.getScaling = Cu, Iu.getRotation = function (t, e) {\n      var r = new Pu.ARRAY_TYPE(3);\n      Cu(r, e);\n      var n = 1 / r[0],\n        i = 1 / r[1],\n        a = 1 / r[2],\n        s = e[0] * n,\n        o = e[1] * i,\n        l = e[2] * a,\n        u = e[4] * n,\n        c = e[5] * i,\n        h = e[6] * a,\n        p = e[8] * n,\n        f = e[9] * i,\n        d = e[10] * a,\n        m = s + c + d,\n        y = 0;\n      return m > 0 ? (y = 2 * Math.sqrt(m + 1), t[3] = .25 * y, t[0] = (h - f) / y, t[1] = (p - l) / y, t[2] = (o - u) / y) : s > c && s > d ? (y = 2 * Math.sqrt(1 + s - c - d), t[3] = (h - f) / y, t[0] = .25 * y, t[1] = (o + u) / y, t[2] = (p + l) / y) : c > d ? (y = 2 * Math.sqrt(1 + c - s - d), t[3] = (p - l) / y, t[0] = (o + u) / y, t[1] = .25 * y, t[2] = (h + f) / y) : (y = 2 * Math.sqrt(1 + d - s - c), t[3] = (o - u) / y, t[0] = (p + l) / y, t[1] = (h + f) / y, t[2] = .25 * y), t;\n    }, Iu.fromRotationTranslationScale = function (t, e, r, n) {\n      var i = e[0],\n        a = e[1],\n        s = e[2],\n        o = e[3],\n        l = i + i,\n        u = a + a,\n        c = s + s,\n        h = i * l,\n        p = i * u,\n        f = i * c,\n        d = a * u,\n        m = a * c,\n        y = s * c,\n        g = o * l,\n        x = o * u,\n        v = o * c,\n        b = n[0],\n        _ = n[1],\n        w = n[2];\n      return t[0] = (1 - (d + y)) * b, t[1] = (p + v) * b, t[2] = (f - x) * b, t[3] = 0, t[4] = (p - v) * _, t[5] = (1 - (h + y)) * _, t[6] = (m + g) * _, t[7] = 0, t[8] = (f + x) * w, t[9] = (m - g) * w, t[10] = (1 - (h + d)) * w, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n    }, Iu.fromRotationTranslationScaleOrigin = function (t, e, r, n, i) {\n      var a = e[0],\n        s = e[1],\n        o = e[2],\n        l = e[3],\n        u = a + a,\n        c = s + s,\n        h = o + o,\n        p = a * u,\n        f = a * c,\n        d = a * h,\n        m = s * c,\n        y = s * h,\n        g = o * h,\n        x = l * u,\n        v = l * c,\n        b = l * h,\n        _ = n[0],\n        w = n[1],\n        M = n[2],\n        A = i[0],\n        S = i[1],\n        I = i[2],\n        k = (1 - (m + g)) * _,\n        P = (f + b) * _,\n        E = (d - v) * _,\n        z = (f - b) * w,\n        T = (1 - (p + g)) * w,\n        B = (y + x) * w,\n        C = (d + v) * M,\n        R = (y - x) * M,\n        D = (1 - (p + m)) * M;\n      return t[0] = k, t[1] = P, t[2] = E, t[3] = 0, t[4] = z, t[5] = T, t[6] = B, t[7] = 0, t[8] = C, t[9] = R, t[10] = D, t[11] = 0, t[12] = r[0] + A - (k * A + z * S + C * I), t[13] = r[1] + S - (P * A + T * S + R * I), t[14] = r[2] + I - (E * A + B * S + D * I), t[15] = 1, t;\n    }, Iu.fromQuat = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = r + r,\n        o = n + n,\n        l = i + i,\n        u = r * s,\n        c = n * s,\n        h = n * o,\n        p = i * s,\n        f = i * o,\n        d = i * l,\n        m = a * s,\n        y = a * o,\n        g = a * l;\n      return t[0] = 1 - h - d, t[1] = c + g, t[2] = p - y, t[3] = 0, t[4] = c - g, t[5] = 1 - u - d, t[6] = f + m, t[7] = 0, t[8] = p + y, t[9] = f - m, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, Iu.frustum = function (t, e, r, n, i, a, s) {\n      var o = 1 / (r - e),\n        l = 1 / (i - n),\n        u = 1 / (a - s);\n      return t[0] = 2 * a * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * a * l, t[6] = 0, t[7] = 0, t[8] = (r + e) * o, t[9] = (i + n) * l, t[10] = (s + a) * u, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = s * a * 2 * u, t[15] = 0, t;\n    }, Iu.perspectiveNO = Ru, Iu.perspectiveZO = function (t, e, r, n, i) {\n      var a,\n        s = 1 / Math.tan(e / 2);\n      return t[0] = s / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = i * (a = 1 / (n - i)), t[14] = i * n * a) : (t[10] = -1, t[14] = -n), t;\n    }, Iu.perspectiveFromFieldOfView = function (t, e, r, n) {\n      var i = Math.tan(e.upDegrees * Math.PI / 180),\n        a = Math.tan(e.downDegrees * Math.PI / 180),\n        s = Math.tan(e.leftDegrees * Math.PI / 180),\n        o = Math.tan(e.rightDegrees * Math.PI / 180),\n        l = 2 / (s + o),\n        u = 2 / (i + a);\n      return t[0] = l, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = -(s - o) * l * .5, t[9] = (i - a) * u * .5, t[10] = n / (r - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r / (r - n), t[15] = 0, t;\n    }, Iu.orthoNO = Du, Iu.orthoZO = function (t, e, r, n, i, a, s) {\n      var o = 1 / (e - r),\n        l = 1 / (n - i),\n        u = 1 / (a - s);\n      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = a * u, t[15] = 1, t;\n    }, Iu.lookAt = function (t, e, r, n) {\n      var i,\n        a,\n        s,\n        o,\n        l,\n        u,\n        c,\n        h,\n        p,\n        f,\n        d = e[0],\n        m = e[1],\n        y = e[2],\n        g = n[0],\n        x = n[1],\n        v = n[2],\n        b = r[0],\n        _ = r[1],\n        w = r[2];\n      return Math.abs(d - b) < Pu.EPSILON && Math.abs(m - _) < Pu.EPSILON && Math.abs(y - w) < Pu.EPSILON ? zu(t) : (c = d - b, h = m - _, p = y - w, i = x * (p *= f = 1 / Math.hypot(c, h, p)) - v * (h *= f), a = v * (c *= f) - g * p, s = g * h - x * c, (f = Math.hypot(i, a, s)) ? (i *= f = 1 / f, a *= f, s *= f) : (i = 0, a = 0, s = 0), o = h * s - p * a, l = p * i - c * s, u = c * a - h * i, (f = Math.hypot(o, l, u)) ? (o *= f = 1 / f, l *= f, u *= f) : (o = 0, l = 0, u = 0), t[0] = i, t[1] = o, t[2] = c, t[3] = 0, t[4] = a, t[5] = l, t[6] = h, t[7] = 0, t[8] = s, t[9] = u, t[10] = p, t[11] = 0, t[12] = -(i * d + a * m + s * y), t[13] = -(o * d + l * m + u * y), t[14] = -(c * d + h * m + p * y), t[15] = 1, t);\n    }, Iu.targetTo = function (t, e, r, n) {\n      var i = e[0],\n        a = e[1],\n        s = e[2],\n        o = n[0],\n        l = n[1],\n        u = n[2],\n        c = i - r[0],\n        h = a - r[1],\n        p = s - r[2],\n        f = c * c + h * h + p * p;\n      f > 0 && (c *= f = 1 / Math.sqrt(f), h *= f, p *= f);\n      var d = l * p - u * h,\n        m = u * c - o * p,\n        y = o * h - l * c;\n      return (f = d * d + m * m + y * y) > 0 && (d *= f = 1 / Math.sqrt(f), m *= f, y *= f), t[0] = d, t[1] = m, t[2] = y, t[3] = 0, t[4] = h * y - p * m, t[5] = p * d - c * y, t[6] = c * m - h * d, t[7] = 0, t[8] = c, t[9] = h, t[10] = p, t[11] = 0, t[12] = i, t[13] = a, t[14] = s, t[15] = 1, t;\n    }, Iu.str = function (t) {\n      return \"mat4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \", \" + t[9] + \", \" + t[10] + \", \" + t[11] + \", \" + t[12] + \", \" + t[13] + \", \" + t[14] + \", \" + t[15] + \")\";\n    }, Iu.frob = function (t) {\n      return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);\n    }, Iu.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t[8] = e[8] + r[8], t[9] = e[9] + r[9], t[10] = e[10] + r[10], t[11] = e[11] + r[11], t[12] = e[12] + r[12], t[13] = e[13] + r[13], t[14] = e[14] + r[14], t[15] = e[15] + r[15], t;\n    }, Iu.subtract = Vu, Iu.multiplyScalar = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * r, t[9] = e[9] * r, t[10] = e[10] * r, t[11] = e[11] * r, t[12] = e[12] * r, t[13] = e[13] * r, t[14] = e[14] * r, t[15] = e[15] * r, t;\n    }, Iu.multiplyScalarAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t[4] = e[4] + r[4] * n, t[5] = e[5] + r[5] * n, t[6] = e[6] + r[6] * n, t[7] = e[7] + r[7] * n, t[8] = e[8] + r[8] * n, t[9] = e[9] + r[9] * n, t[10] = e[10] + r[10] * n, t[11] = e[11] + r[11] * n, t[12] = e[12] + r[12] * n, t[13] = e[13] + r[13] * n, t[14] = e[14] + r[14] * n, t[15] = e[15] + r[15] * n, t;\n    }, Iu.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15];\n    }, Iu.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t[3],\n        s = t[4],\n        o = t[5],\n        l = t[6],\n        u = t[7],\n        c = t[8],\n        h = t[9],\n        p = t[10],\n        f = t[11],\n        d = t[12],\n        m = t[13],\n        y = t[14],\n        g = t[15],\n        x = e[0],\n        v = e[1],\n        b = e[2],\n        _ = e[3],\n        w = e[4],\n        M = e[5],\n        A = e[6],\n        S = e[7],\n        I = e[8],\n        k = e[9],\n        P = e[10],\n        E = e[11],\n        z = e[12],\n        T = e[13],\n        B = e[14],\n        C = e[15];\n      return Math.abs(r - x) <= Pu.EPSILON * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(n - v) <= Pu.EPSILON * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(i - b) <= Pu.EPSILON * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(a - _) <= Pu.EPSILON * Math.max(1, Math.abs(a), Math.abs(_)) && Math.abs(s - w) <= Pu.EPSILON * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(o - M) <= Pu.EPSILON * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(l - A) <= Pu.EPSILON * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(u - S) <= Pu.EPSILON * Math.max(1, Math.abs(u), Math.abs(S)) && Math.abs(c - I) <= Pu.EPSILON * Math.max(1, Math.abs(c), Math.abs(I)) && Math.abs(h - k) <= Pu.EPSILON * Math.max(1, Math.abs(h), Math.abs(k)) && Math.abs(p - P) <= Pu.EPSILON * Math.max(1, Math.abs(p), Math.abs(P)) && Math.abs(f - E) <= Pu.EPSILON * Math.max(1, Math.abs(f), Math.abs(E)) && Math.abs(d - z) <= Pu.EPSILON * Math.max(1, Math.abs(d), Math.abs(z)) && Math.abs(m - T) <= Pu.EPSILON * Math.max(1, Math.abs(m), Math.abs(T)) && Math.abs(y - B) <= Pu.EPSILON * Math.max(1, Math.abs(y), Math.abs(B)) && Math.abs(g - C) <= Pu.EPSILON * Math.max(1, Math.abs(g), Math.abs(C));\n    }, Iu.sub = Iu.mul = Iu.ortho = Iu.perspective = void 0;\n    var Pu = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== ku(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = Eu(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function Eu(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (Eu = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function zu(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    function Tu(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = e[9],\n        f = e[10],\n        d = e[11],\n        m = e[12],\n        y = e[13],\n        g = e[14],\n        x = e[15],\n        v = r[0],\n        b = r[1],\n        _ = r[2],\n        w = r[3];\n      return t[0] = v * n + b * o + _ * h + w * m, t[1] = v * i + b * l + _ * p + w * y, t[2] = v * a + b * u + _ * f + w * g, t[3] = v * s + b * c + _ * d + w * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * m, t[5] = v * i + b * l + _ * p + w * y, t[6] = v * a + b * u + _ * f + w * g, t[7] = v * s + b * c + _ * d + w * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * m, t[9] = v * i + b * l + _ * p + w * y, t[10] = v * a + b * u + _ * f + w * g, t[11] = v * s + b * c + _ * d + w * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * m, t[13] = v * i + b * l + _ * p + w * y, t[14] = v * a + b * u + _ * f + w * g, t[15] = v * s + b * c + _ * d + w * x, t;\n    }\n    function Bu(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = n + n,\n        l = i + i,\n        u = a + a,\n        c = n * o,\n        h = n * l,\n        p = n * u,\n        f = i * l,\n        d = i * u,\n        m = a * u,\n        y = s * o,\n        g = s * l,\n        x = s * u;\n      return t[0] = 1 - (f + m), t[1] = h + x, t[2] = p - g, t[3] = 0, t[4] = h - x, t[5] = 1 - (c + m), t[6] = d + y, t[7] = 0, t[8] = p + g, t[9] = d - y, t[10] = 1 - (c + f), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n    }\n    function Cu(t, e) {\n      var r = e[4],\n        n = e[5],\n        i = e[6],\n        a = e[8],\n        s = e[9],\n        o = e[10];\n      return t[0] = Math.hypot(e[0], e[1], e[2]), t[1] = Math.hypot(r, n, i), t[2] = Math.hypot(a, s, o), t;\n    }\n    function Ru(t, e, r, n, i) {\n      var a,\n        s = 1 / Math.tan(e / 2);\n      return t[0] = s / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (a = 1 / (n - i)), t[14] = 2 * i * n * a) : (t[10] = -1, t[14] = -2 * n), t;\n    }\n    function Du(t, e, r, n, i, a, s) {\n      var o = 1 / (e - r),\n        l = 1 / (n - i),\n        u = 1 / (a - s);\n      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (s + a) * u, t[15] = 1, t;\n    }\n    function Vu(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t[6] = e[6] - r[6], t[7] = e[7] - r[7], t[8] = e[8] - r[8], t[9] = e[9] - r[9], t[10] = e[10] - r[10], t[11] = e[11] - r[11], t[12] = e[12] - r[12], t[13] = e[13] - r[13], t[14] = e[14] - r[14], t[15] = e[15] - r[15], t;\n    }\n    Iu.perspective = Ru, Iu.ortho = Du, Iu.mul = Tu, Iu.sub = Vu;\n    var Lu = {},\n      Fu = {};\n    function Nu(t) {\n      return Nu = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, Nu(t);\n    }\n    Object.defineProperty(Fu, \"__esModule\", {\n      value: !0\n    }), Fu.create = ju, Fu.clone = function (t) {\n      var e = new Ou.ARRAY_TYPE(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }, Fu.length = qu, Fu.fromValues = function (t, e, r) {\n      var n = new Ou.ARRAY_TYPE(3);\n      return n[0] = t, n[1] = e, n[2] = r, n;\n    }, Fu.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;\n    }, Fu.set = function (t, e, r, n) {\n      return t[0] = e, t[1] = r, t[2] = n, t;\n    }, Fu.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }, Fu.subtract = $u, Fu.multiply = Gu, Fu.divide = Yu, Fu.ceil = function (t, e) {\n      return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t;\n    }, Fu.floor = function (t, e) {\n      return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t;\n    }, Fu.min = function (t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;\n    }, Fu.max = function (t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;\n    }, Fu.round = function (t, e) {\n      return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t;\n    }, Fu.scale = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }, Fu.scaleAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;\n    }, Fu.distance = Xu, Fu.squaredDistance = Zu, Fu.squaredLength = Ku, Fu.negate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;\n    }, Fu.inverse = function (t, e) {\n      return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t;\n    }, Fu.normalize = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = r * r + n * n + i * i;\n      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;\n    }, Fu.dot = Hu, Fu.cross = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = r[0],\n        o = r[1],\n        l = r[2];\n      return t[0] = i * l - a * o, t[1] = a * s - n * l, t[2] = n * o - i * s, t;\n    }, Fu.lerp = function (t, e, r, n) {\n      var i = e[0],\n        a = e[1],\n        s = e[2];\n      return t[0] = i + n * (r[0] - i), t[1] = a + n * (r[1] - a), t[2] = s + n * (r[2] - s), t;\n    }, Fu.hermite = function (t, e, r, n, i, a) {\n      var s = a * a,\n        o = s * (2 * a - 3) + 1,\n        l = s * (a - 2) + a,\n        u = s * (a - 1),\n        c = s * (3 - 2 * a);\n      return t[0] = e[0] * o + r[0] * l + n[0] * u + i[0] * c, t[1] = e[1] * o + r[1] * l + n[1] * u + i[1] * c, t[2] = e[2] * o + r[2] * l + n[2] * u + i[2] * c, t;\n    }, Fu.bezier = function (t, e, r, n, i, a) {\n      var s = 1 - a,\n        o = s * s,\n        l = a * a,\n        u = o * s,\n        c = 3 * a * o,\n        h = 3 * l * s,\n        p = l * a;\n      return t[0] = e[0] * u + r[0] * c + n[0] * h + i[0] * p, t[1] = e[1] * u + r[1] * c + n[1] * h + i[1] * p, t[2] = e[2] * u + r[2] * c + n[2] * h + i[2] * p, t;\n    }, Fu.random = function (t, e) {\n      e = e || 1;\n      var r = 2 * Ou.RANDOM() * Math.PI,\n        n = 2 * Ou.RANDOM() - 1,\n        i = Math.sqrt(1 - n * n) * e;\n      return t[0] = Math.cos(r) * i, t[1] = Math.sin(r) * i, t[2] = n * e, t;\n    }, Fu.transformMat4 = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = r[3] * n + r[7] * i + r[11] * a + r[15];\n      return t[0] = (r[0] * n + r[4] * i + r[8] * a + r[12]) / (s = s || 1), t[1] = (r[1] * n + r[5] * i + r[9] * a + r[13]) / s, t[2] = (r[2] * n + r[6] * i + r[10] * a + r[14]) / s, t;\n    }, Fu.transformMat3 = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2];\n      return t[0] = n * r[0] + i * r[3] + a * r[6], t[1] = n * r[1] + i * r[4] + a * r[7], t[2] = n * r[2] + i * r[5] + a * r[8], t;\n    }, Fu.transformQuat = function (t, e, r) {\n      var n = r[0],\n        i = r[1],\n        a = r[2],\n        s = e[0],\n        o = e[1],\n        l = e[2],\n        u = i * l - a * o,\n        c = a * s - n * l,\n        h = n * o - i * s,\n        p = i * h - a * c,\n        f = a * u - n * h,\n        d = n * c - i * u,\n        m = 2 * r[3];\n      return c *= m, h *= m, f *= 2, d *= 2, t[0] = s + (u *= m) + (p *= 2), t[1] = o + c + f, t[2] = l + h + d, t;\n    }, Fu.rotateX = function (t, e, r, n) {\n      var i = [],\n        a = [];\n      return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], a[0] = i[0], a[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), a[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;\n    }, Fu.rotateY = function (t, e, r, n) {\n      var i = [],\n        a = [];\n      return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], a[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), a[1] = i[1], a[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;\n    }, Fu.rotateZ = function (t, e, r, n) {\n      var i = [],\n        a = [];\n      return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], a[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), a[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), a[2] = i[2], t[0] = a[0] + r[0], t[1] = a[1] + r[1], t[2] = a[2] + r[2], t;\n    }, Fu.angle = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = e[0],\n        s = e[1],\n        o = e[2],\n        l = Math.sqrt(r * r + n * n + i * i) * Math.sqrt(a * a + s * s + o * o),\n        u = l && Hu(t, e) / l;\n      return Math.acos(Math.min(Math.max(u, -1), 1));\n    }, Fu.zero = function (t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t;\n    }, Fu.str = function (t) {\n      return \"vec3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \")\";\n    }, Fu.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];\n    }, Fu.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = e[0],\n        s = e[1],\n        o = e[2];\n      return Math.abs(r - a) <= Ou.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(n - s) <= Ou.EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(i - o) <= Ou.EPSILON * Math.max(1, Math.abs(i), Math.abs(o));\n    }, Fu.forEach = Fu.sqrLen = Fu.len = Fu.sqrDist = Fu.dist = Fu.div = Fu.mul = Fu.sub = void 0;\n    var Ou = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== Nu(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = Uu(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function Uu(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (Uu = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function ju() {\n      var t = new Ou.ARRAY_TYPE(3);\n      return Ou.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n    }\n    function qu(t) {\n      return Math.hypot(t[0], t[1], t[2]);\n    }\n    function $u(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }\n    function Gu(t, e, r) {\n      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;\n    }\n    function Yu(t, e, r) {\n      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;\n    }\n    function Xu(t, e) {\n      return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n    }\n    function Zu(t, e) {\n      var r = e[0] - t[0],\n        n = e[1] - t[1],\n        i = e[2] - t[2];\n      return r * r + n * n + i * i;\n    }\n    function Ku(t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2];\n      return e * e + r * r + n * n;\n    }\n    function Hu(t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }\n    Fu.sub = $u, Fu.mul = Gu, Fu.div = Yu, Fu.dist = Xu, Fu.sqrDist = Zu, Fu.len = qu, Fu.sqrLen = Ku;\n    var Wu,\n      Ju = (Wu = ju(), function (t, e, r, n, i, a) {\n        var s, o;\n        for (e || (e = 3), r || (r = 0), o = n ? Math.min(n * e + r, t.length) : t.length, s = r; s < o; s += e) Wu[0] = t[s], Wu[1] = t[s + 1], Wu[2] = t[s + 2], i(Wu, Wu, a), t[s] = Wu[0], t[s + 1] = Wu[1], t[s + 2] = Wu[2];\n        return t;\n      });\n    Fu.forEach = Ju;\n    var Qu = {};\n    function tc(t) {\n      return tc = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, tc(t);\n    }\n    Object.defineProperty(Qu, \"__esModule\", {\n      value: !0\n    }), Qu.create = nc, Qu.clone = function (t) {\n      var e = new ec.ARRAY_TYPE(4);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;\n    }, Qu.fromValues = function (t, e, r, n) {\n      var i = new ec.ARRAY_TYPE(4);\n      return i[0] = t, i[1] = e, i[2] = r, i[3] = n, i;\n    }, Qu.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;\n    }, Qu.set = function (t, e, r, n, i) {\n      return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t;\n    }, Qu.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t;\n    }, Qu.subtract = ic, Qu.multiply = ac, Qu.divide = sc, Qu.ceil = function (t, e) {\n      return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t;\n    }, Qu.floor = function (t, e) {\n      return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t;\n    }, Qu.min = function (t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t[3] = Math.min(e[3], r[3]), t;\n    }, Qu.max = function (t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t[3] = Math.max(e[3], r[3]), t;\n    }, Qu.round = function (t, e) {\n      return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t[3] = Math.round(e[3]), t;\n    }, Qu.scale = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }, Qu.scaleAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t;\n    }, Qu.distance = oc, Qu.squaredDistance = lc, Qu.length = uc, Qu.squaredLength = cc, Qu.negate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t;\n    }, Qu.inverse = function (t, e) {\n      return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t;\n    }, Qu.normalize = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = r * r + n * n + i * i + a * a;\n      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = r * s, t[1] = n * s, t[2] = i * s, t[3] = a * s, t;\n    }, Qu.dot = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];\n    }, Qu.cross = function (t, e, r, n) {\n      var i = r[0] * n[1] - r[1] * n[0],\n        a = r[0] * n[2] - r[2] * n[0],\n        s = r[0] * n[3] - r[3] * n[0],\n        o = r[1] * n[2] - r[2] * n[1],\n        l = r[1] * n[3] - r[3] * n[1],\n        u = r[2] * n[3] - r[3] * n[2],\n        c = e[0],\n        h = e[1],\n        p = e[2],\n        f = e[3];\n      return t[0] = h * u - p * l + f * o, t[1] = -c * u + p * s - f * a, t[2] = c * l - h * s + f * i, t[3] = -c * o + h * a - p * i, t;\n    }, Qu.lerp = function (t, e, r, n) {\n      var i = e[0],\n        a = e[1],\n        s = e[2],\n        o = e[3];\n      return t[0] = i + n * (r[0] - i), t[1] = a + n * (r[1] - a), t[2] = s + n * (r[2] - s), t[3] = o + n * (r[3] - o), t;\n    }, Qu.random = function (t, e) {\n      var r, n, i, a, s, o;\n      e = e || 1;\n      do {\n        s = (r = 2 * ec.RANDOM() - 1) * r + (n = 2 * ec.RANDOM() - 1) * n;\n      } while (s >= 1);\n      do {\n        o = (i = 2 * ec.RANDOM() - 1) * i + (a = 2 * ec.RANDOM() - 1) * a;\n      } while (o >= 1);\n      var l = Math.sqrt((1 - s) / o);\n      return t[0] = e * r, t[1] = e * n, t[2] = e * i * l, t[3] = e * a * l, t;\n    }, Qu.transformMat4 = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * a + r[12] * s, t[1] = r[1] * n + r[5] * i + r[9] * a + r[13] * s, t[2] = r[2] * n + r[6] * i + r[10] * a + r[14] * s, t[3] = r[3] * n + r[7] * i + r[11] * a + r[15] * s, t;\n    }, Qu.transformQuat = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = r[0],\n        o = r[1],\n        l = r[2],\n        u = r[3],\n        c = u * n + o * a - l * i,\n        h = u * i + l * n - s * a,\n        p = u * a + s * i - o * n,\n        f = -s * n - o * i - l * a;\n      return t[0] = c * u + f * -s + h * -l - p * -o, t[1] = h * u + f * -o + p * -s - c * -l, t[2] = p * u + f * -l + c * -o - h * -s, t[3] = e[3], t;\n    }, Qu.zero = function (t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;\n    }, Qu.str = function (t) {\n      return \"vec4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n    }, Qu.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n    }, Qu.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t[3],\n        s = e[0],\n        o = e[1],\n        l = e[2],\n        u = e[3];\n      return Math.abs(r - s) <= ec.EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - o) <= ec.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= ec.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(a - u) <= ec.EPSILON * Math.max(1, Math.abs(a), Math.abs(u));\n    }, Qu.forEach = Qu.sqrLen = Qu.len = Qu.sqrDist = Qu.dist = Qu.div = Qu.mul = Qu.sub = void 0;\n    var ec = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== tc(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = rc(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function rc(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (rc = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function nc() {\n      var t = new ec.ARRAY_TYPE(4);\n      return ec.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;\n    }\n    function ic(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t;\n    }\n    function ac(t, e, r) {\n      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;\n    }\n    function sc(t, e, r) {\n      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t[3] = e[3] / r[3], t;\n    }\n    function oc(t, e) {\n      return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]);\n    }\n    function lc(t, e) {\n      var r = e[0] - t[0],\n        n = e[1] - t[1],\n        i = e[2] - t[2],\n        a = e[3] - t[3];\n      return r * r + n * n + i * i + a * a;\n    }\n    function uc(t) {\n      return Math.hypot(t[0], t[1], t[2], t[3]);\n    }\n    function cc(t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2],\n        i = t[3];\n      return e * e + r * r + n * n + i * i;\n    }\n    Qu.sub = ic, Qu.mul = ac, Qu.div = sc, Qu.dist = oc, Qu.sqrDist = lc, Qu.len = uc, Qu.sqrLen = cc;\n    var hc = function () {\n      var t = nc();\n      return function (e, r, n, i, a, s) {\n        var o, l;\n        for (r || (r = 4), n || (n = 0), l = i ? Math.min(i * r + n, e.length) : e.length, o = n; o < l; o += r) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], t[3] = e[o + 3], a(t, t, s), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2], e[o + 3] = t[3];\n        return e;\n      };\n    }();\n    function pc(t) {\n      return pc = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, pc(t);\n    }\n    Qu.forEach = hc, Object.defineProperty(Lu, \"__esModule\", {\n      value: !0\n    }), Lu.create = vc, Lu.identity = function (t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n    }, Lu.setAxisAngle = bc, Lu.getAxisAngle = function (t, e) {\n      var r = 2 * Math.acos(e[3]),\n        n = Math.sin(r / 2);\n      return n > fc.EPSILON ? (t[0] = e[0] / n, t[1] = e[1] / n, t[2] = e[2] / n) : (t[0] = 1, t[1] = 0, t[2] = 0), r;\n    }, Lu.getAngle = function (t, e) {\n      var r = kc(t, e);\n      return Math.acos(2 * r * r - 1);\n    }, Lu.multiply = _c, Lu.rotateX = function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + s * o, t[1] = i * l + a * o, t[2] = a * l - i * o, t[3] = s * l - n * o, t;\n    }, Lu.rotateY = function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l - a * o, t[1] = i * l + s * o, t[2] = a * l + n * o, t[3] = s * l - i * o, t;\n    }, Lu.rotateZ = function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = a * l + s * o, t[3] = s * l - a * o, t;\n    }, Lu.calculateW = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2];\n      return t[0] = r, t[1] = n, t[2] = i, t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - i * i)), t;\n    }, Lu.exp = wc, Lu.ln = Mc, Lu.pow = function (t, e, r) {\n      return Mc(t, e), Ic(t, t, r), wc(t, t), t;\n    }, Lu.slerp = Ac, Lu.random = function (t) {\n      var e = fc.RANDOM(),\n        r = fc.RANDOM(),\n        n = fc.RANDOM(),\n        i = Math.sqrt(1 - e),\n        a = Math.sqrt(e);\n      return t[0] = i * Math.sin(2 * Math.PI * r), t[1] = i * Math.cos(2 * Math.PI * r), t[2] = a * Math.sin(2 * Math.PI * n), t[3] = a * Math.cos(2 * Math.PI * n), t;\n    }, Lu.invert = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = r * r + n * n + i * i + a * a,\n        o = s ? 1 / s : 0;\n      return t[0] = -r * o, t[1] = -n * o, t[2] = -i * o, t[3] = a * o, t;\n    }, Lu.conjugate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;\n    }, Lu.fromMat3 = Sc, Lu.fromEuler = function (t, e, r, n) {\n      var i = .5 * Math.PI / 180;\n      e *= i, r *= i, n *= i;\n      var a = Math.sin(e),\n        s = Math.cos(e),\n        o = Math.sin(r),\n        l = Math.cos(r),\n        u = Math.sin(n),\n        c = Math.cos(n);\n      return t[0] = a * l * c - s * o * u, t[1] = s * o * c + a * l * u, t[2] = s * l * u - a * o * c, t[3] = s * l * c + a * o * u, t;\n    }, Lu.str = function (t) {\n      return \"quat(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n    }, Lu.setAxes = Lu.sqlerp = Lu.rotationTo = Lu.equals = Lu.exactEquals = Lu.normalize = Lu.sqrLen = Lu.squaredLength = Lu.len = Lu.length = Lu.lerp = Lu.dot = Lu.scale = Lu.mul = Lu.add = Lu.set = Lu.copy = Lu.fromValues = Lu.clone = void 0;\n    var fc = xc(nu),\n      dc = xc(bu),\n      mc = xc(Fu),\n      yc = xc(Qu);\n    function gc(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (gc = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function xc(t, e) {\n      if (!e && t && t.__esModule) return t;\n      if (null === t || \"object\" !== pc(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = gc(e);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }\n    function vc() {\n      var t = new fc.ARRAY_TYPE(4);\n      return fc.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n    }\n    function bc(t, e, r) {\n      r *= .5;\n      var n = Math.sin(r);\n      return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = Math.cos(r), t;\n    }\n    function _c(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = r[0],\n        l = r[1],\n        u = r[2],\n        c = r[3];\n      return t[0] = n * c + s * o + i * u - a * l, t[1] = i * c + s * l + a * o - n * u, t[2] = a * c + s * u + n * l - i * o, t[3] = s * c - n * o - i * l - a * u, t;\n    }\n    function wc(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = Math.sqrt(r * r + n * n + i * i),\n        o = Math.exp(a),\n        l = s > 0 ? o * Math.sin(s) / s : 0;\n      return t[0] = r * l, t[1] = n * l, t[2] = i * l, t[3] = o * Math.cos(s), t;\n    }\n    function Mc(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        a = e[3],\n        s = Math.sqrt(r * r + n * n + i * i),\n        o = s > 0 ? Math.atan2(s, a) / s : 0;\n      return t[0] = r * o, t[1] = n * o, t[2] = i * o, t[3] = .5 * Math.log(r * r + n * n + i * i + a * a), t;\n    }\n    function Ac(t, e, r, n) {\n      var i,\n        a,\n        s,\n        o,\n        l,\n        u = e[0],\n        c = e[1],\n        h = e[2],\n        p = e[3],\n        f = r[0],\n        d = r[1],\n        m = r[2],\n        y = r[3];\n      return (a = u * f + c * d + h * m + p * y) < 0 && (a = -a, f = -f, d = -d, m = -m, y = -y), 1 - a > fc.EPSILON ? (i = Math.acos(a), s = Math.sin(i), o = Math.sin((1 - n) * i) / s, l = Math.sin(n * i) / s) : (o = 1 - n, l = n), t[0] = o * u + l * f, t[1] = o * c + l * d, t[2] = o * h + l * m, t[3] = o * p + l * y, t;\n    }\n    function Sc(t, e) {\n      var r,\n        n = e[0] + e[4] + e[8];\n      if (n > 0) r = Math.sqrt(n + 1), t[3] = .5 * r, t[0] = (e[5] - e[7]) * (r = .5 / r), t[1] = (e[6] - e[2]) * r, t[2] = (e[1] - e[3]) * r;else {\n        var i = 0;\n        e[4] > e[0] && (i = 1), e[8] > e[3 * i + i] && (i = 2);\n        var a = (i + 1) % 3,\n          s = (i + 2) % 3;\n        r = Math.sqrt(e[3 * i + i] - e[3 * a + a] - e[3 * s + s] + 1), t[i] = .5 * r, t[3] = (e[3 * a + s] - e[3 * s + a]) * (r = .5 / r), t[a] = (e[3 * a + i] + e[3 * i + a]) * r, t[s] = (e[3 * s + i] + e[3 * i + s]) * r;\n      }\n      return t;\n    }\n    Lu.clone = yc.clone, Lu.fromValues = yc.fromValues, Lu.copy = yc.copy, Lu.set = yc.set, Lu.add = yc.add, Lu.mul = _c;\n    var Ic = yc.scale;\n    Lu.scale = Ic;\n    var kc = yc.dot;\n    Lu.dot = kc, Lu.lerp = yc.lerp;\n    var Pc = yc.length;\n    Lu.length = Pc, Lu.len = Pc;\n    var Ec = yc.squaredLength;\n    Lu.squaredLength = Ec, Lu.sqrLen = Ec;\n    var zc = yc.normalize;\n    Lu.normalize = zc, Lu.exactEquals = yc.exactEquals, Lu.equals = yc.equals;\n    var Tc,\n      Bc,\n      Cc,\n      Rc = (Tc = mc.create(), Bc = mc.fromValues(1, 0, 0), Cc = mc.fromValues(0, 1, 0), function (t, e, r) {\n        var n = mc.dot(e, r);\n        return n < -.999999 ? (mc.cross(Tc, Bc, e), mc.len(Tc) < 1e-6 && mc.cross(Tc, Cc, e), mc.normalize(Tc, Tc), bc(t, Tc, Math.PI), t) : n > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (mc.cross(Tc, e, r), t[0] = Tc[0], t[1] = Tc[1], t[2] = Tc[2], t[3] = 1 + n, zc(t, t));\n      });\n    Lu.rotationTo = Rc;\n    var Dc,\n      Vc,\n      Lc = (Dc = vc(), Vc = vc(), function (t, e, r, n, i, a) {\n        return Ac(Dc, e, i, a), Ac(Vc, r, n, a), Ac(t, Dc, Vc, 2 * a * (1 - a)), t;\n      });\n    Lu.sqlerp = Lc;\n    var Fc,\n      Nc = (Fc = dc.create(), function (t, e, r, n) {\n        return Fc[0] = r[0], Fc[3] = r[1], Fc[6] = r[2], Fc[1] = n[0], Fc[4] = n[1], Fc[7] = n[2], Fc[2] = -e[0], Fc[5] = -e[1], Fc[8] = -e[2], zc(t, Sc(t, Fc));\n      });\n    Lu.setAxes = Nc;\n    var Oc = {};\n    function Uc(t) {\n      return Uc = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, Uc(t);\n    }\n    Object.defineProperty(Oc, \"__esModule\", {\n      value: !0\n    }), Oc.create = function () {\n      var t = new jc.ARRAY_TYPE(8);\n      return jc.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;\n    }, Oc.clone = function (t) {\n      var e = new jc.ARRAY_TYPE(8);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e;\n    }, Oc.fromValues = function (t, e, r, n, i, a, s, o) {\n      var l = new jc.ARRAY_TYPE(8);\n      return l[0] = t, l[1] = e, l[2] = r, l[3] = n, l[4] = i, l[5] = a, l[6] = s, l[7] = o, l;\n    }, Oc.fromRotationTranslationValues = function (t, e, r, n, i, a, s) {\n      var o = new jc.ARRAY_TYPE(8);\n      o[0] = t, o[1] = e, o[2] = r, o[3] = n;\n      var l = .5 * i,\n        u = .5 * a,\n        c = .5 * s;\n      return o[4] = l * n + u * r - c * e, o[5] = u * n + c * t - l * r, o[6] = c * n + l * e - u * t, o[7] = -l * t - u * e - c * r, o;\n    }, Oc.fromRotationTranslation = Xc, Oc.fromTranslation = function (t, e) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * e[0], t[5] = .5 * e[1], t[6] = .5 * e[2], t[7] = 0, t;\n    }, Oc.fromRotation = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n    }, Oc.fromMat4 = function (t, e) {\n      var r = qc.create();\n      $c.getRotation(r, e);\n      var n = new jc.ARRAY_TYPE(3);\n      return $c.getTranslation(n, e), Xc(t, r, n), t;\n    }, Oc.copy = Zc, Oc.identity = function (t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n    }, Oc.set = function (t, e, r, n, i, a, s, o, l) {\n      return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = a, t[5] = s, t[6] = o, t[7] = l, t;\n    }, Oc.getDual = function (t, e) {\n      return t[0] = e[4], t[1] = e[5], t[2] = e[6], t[3] = e[7], t;\n    }, Oc.setDual = function (t, e) {\n      return t[4] = e[0], t[5] = e[1], t[6] = e[2], t[7] = e[3], t;\n    }, Oc.getTranslation = function (t, e) {\n      var r = e[4],\n        n = e[5],\n        i = e[6],\n        a = e[7],\n        s = -e[0],\n        o = -e[1],\n        l = -e[2],\n        u = e[3];\n      return t[0] = 2 * (r * u + a * s + n * l - i * o), t[1] = 2 * (n * u + a * o + i * s - r * l), t[2] = 2 * (i * u + a * l + r * o - n * s), t;\n    }, Oc.translate = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = .5 * r[0],\n        l = .5 * r[1],\n        u = .5 * r[2],\n        c = e[4],\n        h = e[5],\n        p = e[6],\n        f = e[7];\n      return t[0] = n, t[1] = i, t[2] = a, t[3] = s, t[4] = s * o + i * u - a * l + c, t[5] = s * l + a * o - n * u + h, t[6] = s * u + n * l - i * o + p, t[7] = -n * o - i * l - a * u + f, t;\n    }, Oc.rotateX = function (t, e, r) {\n      var n = -e[0],\n        i = -e[1],\n        a = -e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = o * s + c * n + l * a - u * i,\n        p = l * s + c * i + u * n - o * a,\n        f = u * s + c * a + o * i - l * n,\n        d = c * s - o * n - l * i - u * a;\n      return qc.rotateX(t, e, r), t[4] = h * (s = t[3]) + d * (n = t[0]) + p * (a = t[2]) - f * (i = t[1]), t[5] = p * s + d * i + f * n - h * a, t[6] = f * s + d * a + h * i - p * n, t[7] = d * s - h * n - p * i - f * a, t;\n    }, Oc.rotateY = function (t, e, r) {\n      var n = -e[0],\n        i = -e[1],\n        a = -e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = o * s + c * n + l * a - u * i,\n        p = l * s + c * i + u * n - o * a,\n        f = u * s + c * a + o * i - l * n,\n        d = c * s - o * n - l * i - u * a;\n      return qc.rotateY(t, e, r), t[4] = h * (s = t[3]) + d * (n = t[0]) + p * (a = t[2]) - f * (i = t[1]), t[5] = p * s + d * i + f * n - h * a, t[6] = f * s + d * a + h * i - p * n, t[7] = d * s - h * n - p * i - f * a, t;\n    }, Oc.rotateZ = function (t, e, r) {\n      var n = -e[0],\n        i = -e[1],\n        a = -e[2],\n        s = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = o * s + c * n + l * a - u * i,\n        p = l * s + c * i + u * n - o * a,\n        f = u * s + c * a + o * i - l * n,\n        d = c * s - o * n - l * i - u * a;\n      return qc.rotateZ(t, e, r), t[4] = h * (s = t[3]) + d * (n = t[0]) + p * (a = t[2]) - f * (i = t[1]), t[5] = p * s + d * i + f * n - h * a, t[6] = f * s + d * a + h * i - p * n, t[7] = d * s - h * n - p * i - f * a, t;\n    }, Oc.rotateByQuatAppend = function (t, e, r) {\n      var n = r[0],\n        i = r[1],\n        a = r[2],\n        s = r[3],\n        o = e[0],\n        l = e[1],\n        u = e[2],\n        c = e[3];\n      return t[0] = o * s + c * n + l * a - u * i, t[1] = l * s + c * i + u * n - o * a, t[2] = u * s + c * a + o * i - l * n, t[3] = c * s - o * n - l * i - u * a, t[4] = (o = e[4]) * s + (c = e[7]) * n + (l = e[5]) * a - (u = e[6]) * i, t[5] = l * s + c * i + u * n - o * a, t[6] = u * s + c * a + o * i - l * n, t[7] = c * s - o * n - l * i - u * a, t;\n    }, Oc.rotateByQuatPrepend = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = r[0],\n        l = r[1],\n        u = r[2],\n        c = r[3];\n      return t[0] = n * c + s * o + i * u - a * l, t[1] = i * c + s * l + a * o - n * u, t[2] = a * c + s * u + n * l - i * o, t[3] = s * c - n * o - i * l - a * u, t[4] = n * (c = r[7]) + s * (o = r[4]) + i * (u = r[6]) - a * (l = r[5]), t[5] = i * c + s * l + a * o - n * u, t[6] = a * c + s * u + n * l - i * o, t[7] = s * c - n * o - i * l - a * u, t;\n    }, Oc.rotateAroundAxis = function (t, e, r, n) {\n      if (Math.abs(n) < jc.EPSILON) return Zc(t, e);\n      var i = Math.hypot(r[0], r[1], r[2]);\n      n *= .5;\n      var a = Math.sin(n),\n        s = a * r[0] / i,\n        o = a * r[1] / i,\n        l = a * r[2] / i,\n        u = Math.cos(n),\n        c = e[0],\n        h = e[1],\n        p = e[2],\n        f = e[3];\n      t[0] = c * u + f * s + h * l - p * o, t[1] = h * u + f * o + p * s - c * l, t[2] = p * u + f * l + c * o - h * s, t[3] = f * u - c * s - h * o - p * l;\n      var d = e[4],\n        m = e[5],\n        y = e[6],\n        g = e[7];\n      return t[4] = d * u + g * s + m * l - y * o, t[5] = m * u + g * o + y * s - d * l, t[6] = y * u + g * l + d * o - m * s, t[7] = g * u - d * s - m * o - y * l, t;\n    }, Oc.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t;\n    }, Oc.multiply = Kc, Oc.scale = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t;\n    }, Oc.lerp = function (t, e, r, n) {\n      var i = 1 - n;\n      return Hc(e, r) < 0 && (n = -n), t[0] = e[0] * i + r[0] * n, t[1] = e[1] * i + r[1] * n, t[2] = e[2] * i + r[2] * n, t[3] = e[3] * i + r[3] * n, t[4] = e[4] * i + r[4] * n, t[5] = e[5] * i + r[5] * n, t[6] = e[6] * i + r[6] * n, t[7] = e[7] * i + r[7] * n, t;\n    }, Oc.invert = function (t, e) {\n      var r = Jc(e);\n      return t[0] = -e[0] / r, t[1] = -e[1] / r, t[2] = -e[2] / r, t[3] = e[3] / r, t[4] = -e[4] / r, t[5] = -e[5] / r, t[6] = -e[6] / r, t[7] = e[7] / r, t;\n    }, Oc.conjugate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = e[7], t;\n    }, Oc.normalize = function (t, e) {\n      var r = Jc(e);\n      if (r > 0) {\n        r = Math.sqrt(r);\n        var n = e[0] / r,\n          i = e[1] / r,\n          a = e[2] / r,\n          s = e[3] / r,\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = n * o + i * l + a * u + s * c;\n        t[0] = n, t[1] = i, t[2] = a, t[3] = s, t[4] = (o - n * h) / r, t[5] = (l - i * h) / r, t[6] = (u - a * h) / r, t[7] = (c - s * h) / r;\n      }\n      return t;\n    }, Oc.str = function (t) {\n      return \"quat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \")\";\n    }, Oc.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7];\n    }, Oc.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = t[2],\n        a = t[3],\n        s = t[4],\n        o = t[5],\n        l = t[6],\n        u = t[7],\n        c = e[0],\n        h = e[1],\n        p = e[2],\n        f = e[3],\n        d = e[4],\n        m = e[5],\n        y = e[6],\n        g = e[7];\n      return Math.abs(r - c) <= jc.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(n - h) <= jc.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(i - p) <= jc.EPSILON * Math.max(1, Math.abs(i), Math.abs(p)) && Math.abs(a - f) <= jc.EPSILON * Math.max(1, Math.abs(a), Math.abs(f)) && Math.abs(s - d) <= jc.EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(o - m) <= jc.EPSILON * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(l - y) <= jc.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - g) <= jc.EPSILON * Math.max(1, Math.abs(u), Math.abs(g));\n    }, Oc.sqrLen = Oc.squaredLength = Oc.len = Oc.length = Oc.dot = Oc.mul = Oc.setReal = Oc.getReal = void 0;\n    var jc = Yc(nu),\n      qc = Yc(Lu),\n      $c = Yc(Iu);\n    function Gc(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (Gc = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function Yc(t, e) {\n      if (!e && t && t.__esModule) return t;\n      if (null === t || \"object\" !== Uc(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = Gc(e);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }\n    function Xc(t, e, r) {\n      var n = .5 * r[0],\n        i = .5 * r[1],\n        a = .5 * r[2],\n        s = e[0],\n        o = e[1],\n        l = e[2],\n        u = e[3];\n      return t[0] = s, t[1] = o, t[2] = l, t[3] = u, t[4] = n * u + i * l - a * o, t[5] = i * u + a * s - n * l, t[6] = a * u + n * o - i * s, t[7] = -n * s - i * o - a * l, t;\n    }\n    function Zc(t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t;\n    }\n    function Kc(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        a = e[2],\n        s = e[3],\n        o = r[4],\n        l = r[5],\n        u = r[6],\n        c = r[7],\n        h = e[4],\n        p = e[5],\n        f = e[6],\n        d = e[7],\n        m = r[0],\n        y = r[1],\n        g = r[2],\n        x = r[3];\n      return t[0] = n * x + s * m + i * g - a * y, t[1] = i * x + s * y + a * m - n * g, t[2] = a * x + s * g + n * y - i * m, t[3] = s * x - n * m - i * y - a * g, t[4] = n * c + s * o + i * u - a * l + h * x + d * m + p * g - f * y, t[5] = i * c + s * l + a * o - n * u + p * x + d * y + f * m - h * g, t[6] = a * c + s * u + n * l - i * o + f * x + d * g + h * y - p * m, t[7] = s * c - n * o - i * l - a * u + d * x - h * m - p * y - f * g, t;\n    }\n    Oc.getReal = qc.copy, Oc.setReal = qc.copy, Oc.mul = Kc;\n    var Hc = qc.dot;\n    Oc.dot = Hc;\n    var Wc = qc.length;\n    Oc.length = Wc, Oc.len = Wc;\n    var Jc = qc.squaredLength;\n    Oc.squaredLength = Jc, Oc.sqrLen = Jc;\n    var Qc = {};\n    function th(t) {\n      return th = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, th(t);\n    }\n    Object.defineProperty(Qc, \"__esModule\", {\n      value: !0\n    }), Qc.create = nh, Qc.clone = function (t) {\n      var e = new eh.ARRAY_TYPE(2);\n      return e[0] = t[0], e[1] = t[1], e;\n    }, Qc.fromValues = function (t, e) {\n      var r = new eh.ARRAY_TYPE(2);\n      return r[0] = t, r[1] = e, r;\n    }, Qc.copy = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t;\n    }, Qc.set = function (t, e, r) {\n      return t[0] = e, t[1] = r, t;\n    }, Qc.add = function (t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t;\n    }, Qc.subtract = ih, Qc.multiply = ah, Qc.divide = sh, Qc.ceil = function (t, e) {\n      return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t;\n    }, Qc.floor = function (t, e) {\n      return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t;\n    }, Qc.min = function (t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t;\n    }, Qc.max = function (t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t;\n    }, Qc.round = function (t, e) {\n      return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t;\n    }, Qc.scale = function (t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t;\n    }, Qc.scaleAndAdd = function (t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t;\n    }, Qc.distance = oh, Qc.squaredDistance = lh, Qc.length = uh, Qc.squaredLength = ch, Qc.negate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t;\n    }, Qc.inverse = function (t, e) {\n      return t[0] = 1 / e[0], t[1] = 1 / e[1], t;\n    }, Qc.normalize = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = r * r + n * n;\n      return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t;\n    }, Qc.dot = function (t, e) {\n      return t[0] * e[0] + t[1] * e[1];\n    }, Qc.cross = function (t, e, r) {\n      var n = e[0] * r[1] - e[1] * r[0];\n      return t[0] = t[1] = 0, t[2] = n, t;\n    }, Qc.lerp = function (t, e, r, n) {\n      var i = e[0],\n        a = e[1];\n      return t[0] = i + n * (r[0] - i), t[1] = a + n * (r[1] - a), t;\n    }, Qc.random = function (t, e) {\n      e = e || 1;\n      var r = 2 * eh.RANDOM() * Math.PI;\n      return t[0] = Math.cos(r) * e, t[1] = Math.sin(r) * e, t;\n    }, Qc.transformMat2 = function (t, e, r) {\n      var n = e[0],\n        i = e[1];\n      return t[0] = r[0] * n + r[2] * i, t[1] = r[1] * n + r[3] * i, t;\n    }, Qc.transformMat2d = function (t, e, r) {\n      var n = e[0],\n        i = e[1];\n      return t[0] = r[0] * n + r[2] * i + r[4], t[1] = r[1] * n + r[3] * i + r[5], t;\n    }, Qc.transformMat3 = function (t, e, r) {\n      var n = e[0],\n        i = e[1];\n      return t[0] = r[0] * n + r[3] * i + r[6], t[1] = r[1] * n + r[4] * i + r[7], t;\n    }, Qc.transformMat4 = function (t, e, r) {\n      var n = e[0],\n        i = e[1];\n      return t[0] = r[0] * n + r[4] * i + r[12], t[1] = r[1] * n + r[5] * i + r[13], t;\n    }, Qc.rotate = function (t, e, r, n) {\n      var i = e[0] - r[0],\n        a = e[1] - r[1],\n        s = Math.sin(n),\n        o = Math.cos(n);\n      return t[0] = i * o - a * s + r[0], t[1] = i * s + a * o + r[1], t;\n    }, Qc.angle = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = e[0],\n        a = e[1],\n        s = Math.sqrt(r * r + n * n) * Math.sqrt(i * i + a * a);\n      return Math.acos(Math.min(Math.max(s && (r * i + n * a) / s, -1), 1));\n    }, Qc.zero = function (t) {\n      return t[0] = 0, t[1] = 0, t;\n    }, Qc.str = function (t) {\n      return \"vec2(\" + t[0] + \", \" + t[1] + \")\";\n    }, Qc.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1];\n    }, Qc.equals = function (t, e) {\n      var r = t[0],\n        n = t[1],\n        i = e[0],\n        a = e[1];\n      return Math.abs(r - i) <= eh.EPSILON * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(n - a) <= eh.EPSILON * Math.max(1, Math.abs(n), Math.abs(a));\n    }, Qc.forEach = Qc.sqrLen = Qc.sqrDist = Qc.dist = Qc.div = Qc.mul = Qc.sub = Qc.len = void 0;\n    var eh = function (t, e) {\n      if (t && t.__esModule) return t;\n      if (null === t || \"object\" !== th(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = rh(void 0);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }(nu);\n    function rh(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (rh = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function nh() {\n      var t = new eh.ARRAY_TYPE(2);\n      return eh.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;\n    }\n    function ih(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t;\n    }\n    function ah(t, e, r) {\n      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t;\n    }\n    function sh(t, e, r) {\n      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t;\n    }\n    function oh(t, e) {\n      return Math.hypot(e[0] - t[0], e[1] - t[1]);\n    }\n    function lh(t, e) {\n      var r = e[0] - t[0],\n        n = e[1] - t[1];\n      return r * r + n * n;\n    }\n    function uh(t) {\n      return Math.hypot(t[0], t[1]);\n    }\n    function ch(t) {\n      var e = t[0],\n        r = t[1];\n      return e * e + r * r;\n    }\n    Qc.len = uh, Qc.sub = ih, Qc.mul = ah, Qc.div = sh, Qc.dist = oh, Qc.sqrDist = lh, Qc.sqrLen = ch;\n    var hh = function () {\n      var t = nh();\n      return function (e, r, n, i, a, s) {\n        var o, l;\n        for (r || (r = 2), n || (n = 0), l = i ? Math.min(i * r + n, e.length) : e.length, o = n; o < l; o += r) t[0] = e[o], t[1] = e[o + 1], a(t, t, s), e[o] = t[0], e[o + 1] = t[1];\n        return e;\n      };\n    }();\n    function ph(t) {\n      return ph = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n        return typeof t;\n      } : function (t) {\n        return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n      }, ph(t);\n    }\n    Qc.forEach = hh, Object.defineProperty(ru, \"__esModule\", {\n      value: !0\n    }), t.a7 = ru.vec4 = t.N = ru.vec3 = ru.vec2 = ru.quat2 = t.bi = ru.quat = t.a6 = ru.mat4 = t.co = ru.mat3 = ru.mat2d = t.b4 = ru.mat2 = ru.glMatrix = void 0;\n    var fh = Ah(nu);\n    ru.glMatrix = fh;\n    var dh = Ah(lu);\n    t.b4 = ru.mat2 = dh;\n    var mh = Ah(du);\n    ru.mat2d = mh;\n    var yh = Ah(bu);\n    t.co = ru.mat3 = yh;\n    var gh = Ah(Iu);\n    t.a6 = ru.mat4 = gh;\n    var xh = Ah(Lu);\n    t.bi = ru.quat = xh;\n    var vh = Ah(Oc);\n    ru.quat2 = vh;\n    var bh = Ah(Qc);\n    ru.vec2 = bh;\n    var _h = Ah(Fu);\n    t.N = ru.vec3 = _h;\n    var wh = Ah(Qu);\n    function Mh(t) {\n      if (\"function\" != typeof WeakMap) return null;\n      var e = new WeakMap(),\n        r = new WeakMap();\n      return (Mh = function (t) {\n        return t ? r : e;\n      })(t);\n    }\n    function Ah(t, e) {\n      if (!e && t && t.__esModule) return t;\n      if (null === t || \"object\" !== ph(t) && \"function\" != typeof t) return {\n        default: t\n      };\n      var r = Mh(e);\n      if (r && r.has(t)) return r.get(t);\n      var n = {},\n        i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var a in t) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(t, a)) {\n        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;\n        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];\n      }\n      return n.default = t, r && r.set(t, n), n;\n    }\n    t.a7 = ru.vec4 = wh;\n    class Sh {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n      intersectsPlane(e, r, n) {\n        const i = t.N.dot(r, this.dir);\n        if (Math.abs(i) < 1e-6) return !1;\n        const a = ((e[0] - this.pos[0]) * r[0] + (e[1] - this.pos[1]) * r[1] + (e[2] - this.pos[2]) * r[2]) / i;\n        return n[0] = this.pos[0] + this.dir[0] * a, n[1] = this.pos[1] + this.dir[1] * a, n[2] = this.pos[2] + this.dir[2] * a, !0;\n      }\n      closestPointOnSphere(e, r, n) {\n        if (t.N.equals(this.pos, e) || 0 === r) return n[0] = n[1] = n[2] = 0, !1;\n        const [i, a, s] = this.dir,\n          o = this.pos[0] - e[0],\n          l = this.pos[1] - e[1],\n          u = this.pos[2] - e[2],\n          c = i * i + a * a + s * s,\n          h = 2 * (o * i + l * a + u * s),\n          p = h * h - 4 * c * (o * o + l * l + u * u - r * r);\n        if (p < 0) {\n          const t = Math.max(-h / 2, 0),\n            e = o + i * t,\n            c = l + a * t,\n            p = u + s * t,\n            f = Math.hypot(e, c, p);\n          return n[0] = e * r / f, n[1] = c * r / f, n[2] = p * r / f, !1;\n        }\n        {\n          const t = (-h - Math.sqrt(p)) / (2 * c);\n          if (t < 0) {\n            const t = Math.hypot(o, l, u);\n            return n[0] = o * r / t, n[1] = l * r / t, n[2] = u * r / t, !1;\n          }\n          return n[0] = o + i * t, n[1] = l + a * t, n[2] = u + s * t, !0;\n        }\n      }\n    }\n    class Ih {\n      constructor(t, e, r, n, i) {\n        this.TL = t, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;\n      }\n      static fromInvProjectionMatrix(e, r, n) {\n        const i = [-1, 1, 1],\n          a = [1, 1, 1],\n          s = [1, -1, 1],\n          o = [-1, -1, 1],\n          l = t.N.transformMat4(i, i, e),\n          u = t.N.transformMat4(a, a, e),\n          c = t.N.transformMat4(s, s, e),\n          h = t.N.transformMat4(o, o, e);\n        return new Ih(l, u, c, h, r / n);\n      }\n    }\n    function kh(e, r, n) {\n      let i = 1 / 0,\n        a = -1 / 0;\n      const s = [];\n      for (const o of e) {\n        t.N.sub(s, o, r);\n        const e = t.N.dot(s, n);\n        i = Math.min(i, e), a = Math.max(a, e);\n      }\n      return [i, a];\n    }\n    function Ph(e, r) {\n      let n = !0;\n      for (let i = 0; i < e.planes.length; i++) {\n        const a = e.planes[i];\n        let s = 0;\n        for (let e = 0; e < r.length; e++) s += t.N.dot(a, r[e]) + a[3] >= 0;\n        if (0 === s) return 0;\n        s !== r.length && (n = !1);\n      }\n      return n ? 2 : 1;\n    }\n    function Eh(t, e) {\n      for (const r of t.projections) {\n        const n = kh(e, t.points[0], r.axis);\n        if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;\n      }\n      return 1;\n    }\n    function zh(e, r) {\n      let n = 0;\n      const i = [0, 0, 0, 0];\n      for (let a = 0; a < e.length; a++) i[0] = e[a][0], i[1] = e[a][1], i[2] = e[a][2], i[3] = 1, t.a7.dot(i, r) >= 0 && n++;\n      return n;\n    }\n    class Th {\n      constructor(e, r) {\n        this.points = e || new Array(8).fill([0, 0, 0]), this.planes = r || new Array(6).fill([0, 0, 0, 0]), this.bounds = Bh.fromPoints(this.points), this.projections = [], this.frustumEdges = [t.N.sub([], this.points[2], this.points[3]), t.N.sub([], this.points[0], this.points[3]), t.N.sub([], this.points[4], this.points[0]), t.N.sub([], this.points[5], this.points[1]), t.N.sub([], this.points[6], this.points[2]), t.N.sub([], this.points[7], this.points[3])];\n        for (const t of this.frustumEdges) {\n          const e = [0, -t[2], t[1]],\n            r = [t[2], 0, -t[0]];\n          this.projections.push({\n            axis: e,\n            projection: kh(this.points, this.points[0], e)\n          }), this.projections.push({\n            axis: r,\n            projection: kh(this.points, this.points[0], r)\n          });\n        }\n      }\n      static fromInvProjectionMatrix(e, r, n, i) {\n        const a = Math.pow(2, n),\n          s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(n => {\n            const s = t.a7.transformMat4([], n, e),\n              o = 1 / s[3] / r * a;\n            return t.a7.mul(s, s, [o, o, i ? 1 / s[3] : o, o]);\n          }),\n          o = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(e => {\n            const r = t.N.sub([], s[e[0]], s[e[1]]),\n              n = t.N.sub([], s[e[2]], s[e[1]]),\n              i = t.N.normalize([], t.N.cross([], r, n)),\n              a = -t.N.dot(i, s[e[1]]);\n            return i.concat(a);\n          }),\n          l = [];\n        for (let t = 0; t < s.length; t++) l.push([s[t][0], s[t][1], s[t][2]]);\n        return new Th(l, o);\n      }\n      intersectsPrecise(e, r, n) {\n        for (let t = 0; t < r.length; t++) if (!zh(e, r[t])) return 0;\n        for (let t = 0; t < this.planes.length; t++) if (!zh(e, this.planes[t])) return 0;\n        for (const r of n) for (const n of this.frustumEdges) {\n          const i = t.N.cross([], r, n),\n            a = t.N.length(i);\n          if (0 === a) continue;\n          t.N.scale(i, i, 1 / a);\n          const s = kh(this.points, this.points[0], i),\n            o = kh(e, this.points[0], i);\n          if (s[0] > o[1] || o[0] > s[1]) return 0;\n        }\n        return 1;\n      }\n    }\n    class Bh {\n      static fromPoints(e) {\n        const r = [1 / 0, 1 / 0, 1 / 0],\n          n = [-1 / 0, -1 / 0, -1 / 0];\n        for (const i of e) t.N.min(r, r, i), t.N.max(n, n, i);\n        return new Bh(r, n);\n      }\n      static fromTileIdAndHeight(t, e, r) {\n        const n = 1 << t.canonical.z,\n          i = t.canonical.x,\n          a = t.canonical.y;\n        return new Bh([i / n, a / n, e], [(i + 1) / n, (a + 1) / n, r]);\n      }\n      static applyTransform(e, r) {\n        const n = e.getCorners();\n        for (let e = 0; e < n.length; ++e) t.N.transformMat4(n[e], n[e], r);\n        return Bh.fromPoints(n);\n      }\n      static projectAabbCorners(e, r) {\n        const n = e.getCorners();\n        for (let e = 0; e < n.length; ++e) t.N.transformMat4(n[e], n[e], r);\n        return n;\n      }\n      constructor(e, r) {\n        this.min = e, this.max = r, this.center = t.N.scale([], t.N.add([], this.min, this.max), .5);\n      }\n      quadrant(e) {\n        const r = [e % 2 == 0, e < 2],\n          n = t.N.clone(this.min),\n          i = t.N.clone(this.max);\n        for (let t = 0; t < r.length; t++) n[t] = r[t] ? this.min[t] : this.center[t], i[t] = r[t] ? this.center[t] : this.max[t];\n        return i[2] = this.max[2], new Bh(n, i);\n      }\n      distanceX(t) {\n        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n      }\n      distanceY(t) {\n        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n      }\n      distanceZ(t) {\n        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];\n      }\n      getCorners() {\n        const t = this.min,\n          e = this.max;\n        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];\n      }\n      intersects(t) {\n        return this.intersectsAabb(t.bounds) ? Ph(t, this.getCorners()) : 0;\n      }\n      intersectsFlat(t) {\n        return this.intersectsAabb(t.bounds) ? Ph(t, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;\n      }\n      intersectsPrecise(t, e) {\n        return e || this.intersects(t) ? Eh(t, this.getCorners()) : 0;\n      }\n      intersectsPreciseFlat(t, e) {\n        return e || this.intersectsFlat(t) ? Eh(t, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;\n      }\n      intersectsAabb(t) {\n        for (let e = 0; e < 3; ++e) if (this.min[e] > t.max[e] || t.min[e] > this.max[e]) return !1;\n        return !0;\n      }\n      intersectsAabbXY(t) {\n        return !(this.min[0] > t.max[0] || t.min[0] > this.max[0] || this.min[1] > t.max[1] || t.min[1] > this.max[1]);\n      }\n      encapsulate(t) {\n        for (let e = 0; e < 3; e++) this.min[e] = Math.min(this.min[e], t.min[e]), this.max[e] = Math.max(this.max[e], t.max[e]);\n      }\n      encapsulatePoint(t) {\n        for (let e = 0; e < 3; e++) this.min[e] = Math.min(this.min[e], t[e]), this.max[e] = Math.max(this.max[e], t[e]);\n      }\n      closestPoint(t) {\n        return [Math.max(Math.min(this.max[0], t[0]), this.min[0]), Math.max(Math.min(this.max[1], t[1]), this.min[1]), Math.max(Math.min(this.max[2], t[2]), this.min[2])];\n      }\n    }\n    ra(Bh, \"Aabb\");\n    const Ch = cs([{\n        type: \"Float32\",\n        name: \"a_globe_pos\",\n        components: 3\n      }, {\n        type: \"Float32\",\n        name: \"a_uv\",\n        components: 2\n      }]),\n      {\n        members: Rh\n      } = Ch,\n      Dh = cs([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    var Vh = cs([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    function Lh(t) {\n      return t * jo / Jo;\n    }\n    const Fh = [new Bh([Zo, Zo, Zo], [Ko, Ko, Ko]), new Bh([Zo, Zo, Zo], [0, 0, Ko]), new Bh([0, Zo, Zo], [Ko, 0, Ko]), new Bh([Zo, 0, Zo], [0, Ko, Ko]), new Bh([0, 0, Zo], [Ko, Ko, Ko])];\n    function Nh(e, r, n, i = !0) {\n      const a = t.N.scale([], e._camera.position, e.worldSize),\n        s = [r, n, 1, 1];\n      t.a7.transformMat4(s, s, e.pixelMatrixInverse), t.a7.scale(s, s, 1 / s[3]);\n      const o = t.N.sub([], s, a),\n        l = t.N.normalize([], o),\n        u = e.globeMatrix,\n        c = [u[12], u[13], u[14]],\n        h = t.N.sub([], c, a),\n        p = t.N.length(h),\n        f = t.N.normalize([], h),\n        d = e.worldSize / (2 * Math.PI),\n        m = t.N.dot(f, l),\n        y = Math.asin(d / p);\n      if (y < Math.acos(m)) {\n        if (!i) return null;\n        const e = [],\n          r = [];\n        t.N.scale(e, l, p / m), t.N.normalize(r, t.N.sub(r, e, h)), t.N.normalize(l, t.N.add(l, h, t.N.scale(l, r, Math.tan(y) * p)));\n      }\n      const g = [];\n      new Sh(a, l).closestPointOnSphere(c, d, g);\n      const x = t.N.normalize([], rt(u, 0)),\n        v = t.N.normalize([], rt(u, 1)),\n        b = t.N.normalize([], rt(u, 2)),\n        w = t.N.dot(x, g),\n        M = t.N.dot(v, g),\n        A = t.N.dot(b, g),\n        S = _(Math.asin(-M / d));\n      let k = _(Math.atan2(w, A));\n      k = e.center.lng + function (t, e) {\n        const r = (e - t + 180) % 360 - 180;\n        return r < -180 ? r + 360 : r;\n      }(e.center.lng, k);\n      const P = pl(k),\n        E = I(fl(S), 0, 1);\n      return new Ml(P, E);\n    }\n    class Oh {\n      constructor(e, r, n) {\n        this.a = t.N.sub([], e, n), this.b = t.N.sub([], r, n), this.center = n;\n        const i = t.N.normalize([], this.a),\n          a = t.N.normalize([], this.b);\n        this.angle = Math.acos(t.N.dot(i, a));\n      }\n    }\n    function Uh(t, e) {\n      if (0 === t.angle) return null;\n      let r;\n      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {\n        const i = Math.sin(r);\n        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);\n      }(t.a[e], t.b[e], t.angle, I(r, 0, 1)) + t.center[e];\n    }\n    function jh(t) {\n      if (t.z <= 1) return Fh[t.z + 2 * t.y + t.x];\n      const e = Xh(Yh(t));\n      return Bh.fromPoints(e);\n    }\n    function qh(e, r, n) {\n      return t.N.scale(e, e, 1 - n), t.N.scaleAndAdd(e, e, r, n);\n    }\n    function $h(e, r, n) {\n      for (const i of e) t.N.transformMat4(i, i, r), t.N.scale(i, i, n);\n    }\n    function Gh(e, r, n, i) {\n      const a = r / e.worldSize,\n        s = e.globeMatrix;\n      if (n.z <= 1) {\n        const t = jh(n).getCorners();\n        return $h(t, s, a), Bh.fromPoints(t);\n      }\n      const o = Yh(n, i),\n        l = Xh(o, jo + Lh(e._tileCoverLift));\n      $h(l, s, a);\n      const u = Number.MAX_VALUE,\n        c = [-u, -u, -u],\n        h = [u, u, u];\n      if (o.contains(e.center)) {\n        for (const e of l) t.N.min(h, h, e), t.N.max(c, c, e);\n        c[2] = 0;\n        const r = e.point,\n          n = [r.x * a, r.y * a, 0];\n        return t.N.min(h, h, n), t.N.max(c, c, n), new Bh(h, c);\n      }\n      if (e._tileCoverLift > 0) {\n        for (const e of l) t.N.min(h, h, e), t.N.max(c, c, e);\n        return new Bh(h, c);\n      }\n      const p = [s[12] * a, s[13] * a, s[14] * a],\n        f = o.getCenter(),\n        d = I(e.center.lat, -xl, xl),\n        m = I(f.lat, -xl, xl),\n        y = pl(e.center.lng),\n        g = fl(d);\n      let x = y - pl(f.lng);\n      const v = g - fl(m);\n      x > .5 ? x -= 1 : x < -.5 && (x += 1);\n      let _ = 0;\n      if (Math.abs(x) > Math.abs(v)) _ = x >= 0 ? 1 : 3;else {\n        _ = v >= 0 ? 0 : 2;\n        const e = [s[4] * a, s[5] * a, s[6] * a],\n          r = -Math.sin(b(v >= 0 ? o.getSouth() : o.getNorth())) * jo;\n        t.N.scaleAndAdd(p, p, e, r);\n      }\n      const w = l[_],\n        M = l[(_ + 1) % 4],\n        A = new Oh(w, M, p),\n        S = [Uh(A, 0) || w[0], Uh(A, 1) || w[1], Uh(A, 2) || w[2]],\n        k = rp(e.zoom);\n      if (k > 0) {\n        const i = function ({\n          x: t,\n          y: e,\n          z: r\n        }, n, i, a, s) {\n          const o = 1 / (1 << r);\n          let l = t * o,\n            u = l + o,\n            c = e * o,\n            h = c + o,\n            p = 0;\n          const f = (l + u) / 2 - a;\n          return f > .5 ? p = -1 : f < -.5 && (p = 1), l = ((l + p) * n - (a *= n)) * i + a, u = ((u + p) * n - a) * i + a, c = (c * n - (s *= n)) * i + s, h = (h * n - s) * i + s, [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]];\n        }(n, r, e._pixelsPerMercatorPixel, y, g);\n        for (let t = 0; t < l.length; t++) qh(l[t], i[t], k);\n        const a = t.N.add([], i[_], i[(_ + 1) % 4]);\n        t.N.scale(a, a, .5), qh(S, a, k);\n      }\n      for (const e of l) t.N.min(h, h, e), t.N.max(c, c, e);\n      return h[2] = Math.min(w[2], M[2]), t.N.min(h, h, S), t.N.max(c, c, S), new Bh(h, c);\n    }\n    function Yh({\n      x: t,\n      y: e,\n      z: r\n    }, n = !1) {\n      const i = 1 / (1 << r),\n        a = new tl(ml(t * i), e === (1 << r) - 1 && n ? -90 : yl((e + 1) * i)),\n        s = new tl(ml((t + 1) * i), 0 === e && n ? 90 : yl(e * i));\n      return new el(a, s);\n    }\n    function Xh(t, e = jo) {\n      const r = b(t.getNorth()),\n        n = b(t.getSouth()),\n        i = Math.cos(r),\n        a = Math.cos(n),\n        s = Math.sin(r),\n        o = Math.sin(n),\n        l = t.getWest(),\n        u = t.getEast();\n      return [Ho(a, o, l, e), Ho(a, o, u, e), Ho(i, s, u, e), Ho(i, s, l, e)];\n    }\n    function Zh(t, e, r, n) {\n      const i = 1 << r.z,\n        a = (t / Tr + r.x) / i;\n      return Wo(yl((e / Tr + r.y) / i), ml(a), n);\n    }\n    function Kh({\n      min: t,\n      max: e\n    }) {\n      return Go / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n    }\n    const Hh = new Float64Array(16);\n    function Wh(e) {\n      const r = Kh(e),\n        n = t.a6.fromScaling(Hh, [r, r, r]);\n      return t.a6.translate(n, n, t.N.negate([], e.min));\n    }\n    function Jh(e) {\n      const r = t.a6.fromTranslation(Hh, e.min),\n        n = 1 / Kh(e);\n      return t.a6.scale(r, r, [n, n, n]);\n    }\n    function Qh(t) {\n      const e = Tr / (2 * Math.PI);\n      return t / (2 * Math.PI) / e;\n    }\n    function tp(t, e) {\n      return Tr / (512 * Math.pow(2, t)) * Kh(jh(e));\n    }\n    function ep(e, r, n, i, a) {\n      const s = Qh(n),\n        o = [e, r, -n / (2 * Math.PI)],\n        l = t.a6.identity(new Float64Array(16));\n      return t.a6.translate(l, l, o), t.a6.scale(l, l, [s, s, s]), t.a6.rotateX(l, l, b(-a)), t.a6.rotateY(l, l, b(-i)), l;\n    }\n    function rp(t) {\n      return k(qo, $o, t);\n    }\n    function np(e, r) {\n      const n = Wo(r.lat, r.lng),\n        i = function (e) {\n          const r = Wo(e._center.lat, e._center.lng),\n            n = t.N.fromValues(0, 1, 0);\n          let i = t.N.cross([], n, r);\n          const a = t.a6.fromRotation([], -e.angle, r);\n          i = t.N.transformMat4(i, i, a), t.a6.fromRotation(a, -e._pitch, i);\n          const s = t.N.normalize([], r);\n          return t.N.scale(s, s, Lh(e.cameraToCenterDistance / e.pixelsPerMeter)), t.N.transformMat4(s, s, a), t.N.add([], r, s);\n        }(e),\n        a = t.N.subtract([], i, n);\n      return t.N.angle(a, n);\n    }\n    function ip(t, e) {\n      return np(t, e) > Math.PI / 2 * 1.01;\n    }\n    const ap = b(85),\n      sp = Math.cos(ap),\n      op = Math.sin(ap),\n      lp = t.a6.create(),\n      up = t => {\n        const e = [];\n        return \"map\" === t.paint.get(\"circle-pitch-alignment\") && e.push(\"PITCH_WITH_MAP\"), \"map\" === t.paint.get(\"circle-pitch-scale\") && e.push(\"SCALE_WITH_MAP\"), e;\n      };\n    function cp(e, r, n, i, a, s, o, l, u) {\n      if (s && e.queryGeometry.isAboveHorizon) return !1;\n      s && (u *= e.pixelToTileUnitsFactor);\n      const c = e.tileID.canonical,\n        h = n.projection.upVectorScale(c, n.center.lat, n.worldSize).metersToTile;\n      for (const p of r) for (const r of p) {\n        const p = r.add(l),\n          f = a && n.elevation ? n.elevation.exaggeration() * a.getElevationAt(p.x, p.y, !0) : 0,\n          d = n.projection.projectTilePoint(p.x, p.y, c);\n        if (f > 0) {\n          const t = n.projection.upVector(c, p.x, p.y);\n          d.x += t[0] * h * f, d.y += t[1] * h * f, d.z += t[2] * h * f;\n        }\n        const m = s ? p : hp(d.x, d.y, d.z, i),\n          y = s ? e.tilespaceRays.map(t => dp(t, f)) : e.queryGeometry.screenGeometry,\n          g = t.a7.transformMat4([], [d.x, d.y, d.z, 1], i);\n        if (!o && s ? u *= g[3] / n.cameraToCenterDistance : o && !s && (u *= n.cameraToCenterDistance / g[3]), s) {\n          const t = yl((r.y / Tr + c.y) / (1 << c.z));\n          u /= n.projection.pixelsPerMeter(t, 1) / dl(1, t);\n        }\n        if (Ll(y, m, u)) return !0;\n      }\n      return !1;\n    }\n    function hp(e, r, n, i) {\n      const a = t.a7.transformMat4([], [e, r, n, 1], i);\n      return new g(a[0] / a[3], a[1] / a[3]);\n    }\n    const pp = t.N.fromValues(0, 0, 0),\n      fp = t.N.fromValues(0, 0, 1);\n    function dp(e, r) {\n      const n = t.N.create();\n      return pp[2] = r, e.intersectsPlane(pp, fp, n), new g(n[0], n[1]);\n    }\n    class mp extends Dl {}\n    function yp(t, {\n      width: e,\n      height: r\n    }, n, i) {\n      if (i) {\n        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(\"mismatched image size\");\n      } else i = new Uint8Array(e * r * n);\n      return t.width = e, t.height = r, t.data = i, t;\n    }\n    function gp(t, e, r) {\n      const {\n        width: n,\n        height: i\n      } = e;\n      n === t.width && i === t.height || (xp(t, e, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        width: Math.min(t.width, n),\n        height: Math.min(t.height, i)\n      }, r), t.width = n, t.height = i, t.data = e.data);\n    }\n    function xp(t, e, r, n, i, a, s) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n      const o = t.data,\n        l = e.data,\n        u = 4 === a && s;\n      for (let s = 0; s < i.height; s++) {\n        const c = ((r.y + s) * t.width + r.x) * a,\n          h = ((n.y + s) * e.width + n.x) * a;\n        if (u) for (let t = 0; t < i.width; t++) {\n          const e = c + t * a + 3,\n            r = h + t * a;\n          l[r + 0] = 255, l[r + 1] = 255, l[r + 2] = 255, l[r + 3] = o[e];\n        } else for (let t = 0; t < i.width * a; t++) l[h + t] = o[c + t];\n      }\n      return e;\n    }\n    ra(mp, \"HeatmapBucket\", {\n      omit: [\"layers\"]\n    });\n    class vp {\n      constructor(t, e) {\n        yp(this, t, 1, e);\n      }\n      resize(t) {\n        gp(this, new vp(t), 1);\n      }\n      clone() {\n        return new vp({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i) {\n        xp(t, e, r, n, i, 1);\n      }\n    }\n    class bp {\n      constructor(t, e) {\n        yp(this, t, 4, e);\n      }\n      resize(t) {\n        gp(this, new bp(t), 4);\n      }\n      replace(t, e) {\n        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n      }\n      clone() {\n        return new bp({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i, a) {\n        xp(t, e, r, n, i, 4, a);\n      }\n    }\n    class _p {\n      constructor(t, e) {\n        this.width = t.width, this.height = t.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;\n      }\n    }\n    ra(vp, \"AlphaImage\"), ra(bp, \"RGBAImage\");\n    const wp = new Oa({\n      visibility: new La(qa.layout_heatmap.visibility)\n    });\n    var Mp = {\n      paint: new Oa({\n        \"heatmap-radius\": new Fa(qa.paint_heatmap[\"heatmap-radius\"]),\n        \"heatmap-weight\": new Fa(qa.paint_heatmap[\"heatmap-weight\"]),\n        \"heatmap-intensity\": new La(qa.paint_heatmap[\"heatmap-intensity\"]),\n        \"heatmap-color\": new Na(qa.paint_heatmap[\"heatmap-color\"]),\n        \"heatmap-opacity\": new La(qa.paint_heatmap[\"heatmap-opacity\"])\n      }),\n      layout: wp\n    };\n    function Ap(t) {\n      const e = {},\n        r = t.resolution || 256,\n        n = t.clips ? t.clips.length : 1,\n        i = t.image || new bp({\n          width: r,\n          height: n\n        }),\n        a = (r, n, a) => {\n          e[t.evaluationKey] = a;\n          const s = t.expression.evaluate(e);\n          s && (i.data[r + n + 0] = Math.floor(255 * s.r / s.a), i.data[r + n + 1] = Math.floor(255 * s.g / s.a), i.data[r + n + 2] = Math.floor(255 * s.b / s.a), i.data[r + n + 3] = Math.floor(255 * s.a));\n        };\n      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, s = 0; n < r; n++, s += 4) {\n        const o = n / (r - 1),\n          {\n            start: l,\n            end: u\n          } = t.clips[e];\n        a(i, s, l * (1 - o) + u * o);\n      } else for (let t = 0, e = 0; t < r; t++, e += 4) a(0, e, t / (r - 1));\n      return i;\n    }\n    const Sp = new Oa({\n      visibility: new La(qa.layout_hillshade.visibility)\n    });\n    var Ip = {\n      paint: new Oa({\n        \"hillshade-illumination-direction\": new La(qa.paint_hillshade[\"hillshade-illumination-direction\"]),\n        \"hillshade-illumination-anchor\": new La(qa.paint_hillshade[\"hillshade-illumination-anchor\"]),\n        \"hillshade-exaggeration\": new La(qa.paint_hillshade[\"hillshade-exaggeration\"]),\n        \"hillshade-shadow-color\": new La(qa.paint_hillshade[\"hillshade-shadow-color\"]),\n        \"hillshade-highlight-color\": new La(qa.paint_hillshade[\"hillshade-highlight-color\"]),\n        \"hillshade-accent-color\": new La(qa.paint_hillshade[\"hillshade-accent-color\"]),\n        \"hillshade-emissive-strength\": new La(qa.paint_hillshade[\"hillshade-emissive-strength\"])\n      }),\n      layout: Sp\n    };\n    const kp = cs([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      {\n        members: Pp\n      } = kp;\n    var Ep = {\n      exports: {}\n    };\n    function zp(t, e, r) {\n      r = r || 2;\n      var n,\n        i,\n        a,\n        s,\n        o,\n        l,\n        u,\n        c = e && e.length,\n        h = c ? e[0] * r : t.length,\n        p = Tp(t, 0, h, r, !0),\n        f = [];\n      if (!p || p.next === p.prev) return f;\n      if (c && (p = function (t, e, r, n) {\n        var i,\n          a,\n          s,\n          o = [];\n        for (i = 0, a = e.length; i < a; i++) (s = Tp(t, e[i] * n, i < a - 1 ? e[i + 1] * n : t.length, n, !1)) === s.next && (s.steiner = !0), o.push(jp(s));\n        for (o.sort(Fp), i = 0; i < o.length; i++) r = Np(o[i], r);\n        return r;\n      }(t, e, p, r)), t.length > 80 * r) {\n        n = a = t[0], i = s = t[1];\n        for (var d = r; d < h; d += r) (o = t[d]) < n && (n = o), (l = t[d + 1]) < i && (i = l), o > a && (a = o), l > s && (s = l);\n        u = 0 !== (u = Math.max(a - n, s - i)) ? 32767 / u : 0;\n      }\n      return Cp(p, f, r, n, i, u, 0), f;\n    }\n    function Tp(t, e, r, n, i) {\n      var a, s;\n      if (i === ef(t, e, r, n) > 0) for (a = e; a < r; a += n) s = Jp(a, t[a], t[a + 1], s);else for (a = r - n; a >= e; a -= n) s = Jp(a, t[a], t[a + 1], s);\n      return s && Yp(s, s.next) && (Qp(s), s = s.next), s;\n    }\n    function Bp(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n        n = t;\n      do {\n        if (r = !1, n.steiner || !Yp(n, n.next) && 0 !== Gp(n.prev, n, n.next)) n = n.next;else {\n          if (Qp(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n      return e;\n    }\n    function Cp(t, e, r, n, i, a, s) {\n      if (t) {\n        !s && a && function (t, e, r, n) {\n          var i = t;\n          do {\n            0 === i.z && (i.z = Up(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n              r,\n              n,\n              i,\n              a,\n              s,\n              o,\n              l,\n              u = 1;\n            do {\n              for (r = t, t = null, a = null, s = 0; r;) {\n                for (s++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);\n                for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), a ? a.nextZ = i : t = i, i.prevZ = a, a = i;\n                r = n;\n              }\n              a.nextZ = null, u *= 2;\n            } while (s > 1);\n          }(i);\n        }(t, n, i, a);\n        for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, a ? Dp(t, n, i, a) : Rp(t)) e.push(o.i / r | 0), e.push(t.i / r | 0), e.push(l.i / r | 0), Qp(t), t = l.next, u = l.next;else if ((t = l) === u) {\n          s ? 1 === s ? Cp(t = Vp(Bp(t), e, r), e, r, n, i, a, 2) : 2 === s && Lp(t, e, r, n, i, a) : Cp(Bp(t), e, r, n, i, a, 1);\n          break;\n        }\n      }\n    }\n    function Rp(t) {\n      var e = t.prev,\n        r = t,\n        n = t.next;\n      if (Gp(e, r, n) >= 0) return !1;\n      for (var i = e.x, a = r.x, s = n.x, o = e.y, l = r.y, u = n.y, c = i < a ? i < s ? i : s : a < s ? a : s, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > a ? i > s ? i : s : a > s ? a : s, f = o > l ? o > u ? o : u : l > u ? l : u, d = n.next; d !== e;) {\n        if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && qp(i, o, a, l, s, u, d.x, d.y) && Gp(d.prev, d, d.next) >= 0) return !1;\n        d = d.next;\n      }\n      return !0;\n    }\n    function Dp(t, e, r, n) {\n      var i = t.prev,\n        a = t,\n        s = t.next;\n      if (Gp(i, a, s) >= 0) return !1;\n      for (var o = i.x, l = a.x, u = s.x, c = i.y, h = a.y, p = s.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, m = o > l ? o > u ? o : u : l > u ? l : u, y = c > h ? c > p ? c : p : h > p ? h : p, g = Up(f, d, e, r, n), x = Up(m, y, e, r, n), v = t.prevZ, b = t.nextZ; v && v.z >= g && b && b.z <= x;) {\n        if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== s && qp(o, c, l, h, u, p, v.x, v.y) && Gp(v.prev, v, v.next) >= 0) return !1;\n        if (v = v.prevZ, b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== s && qp(o, c, l, h, u, p, b.x, b.y) && Gp(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      for (; v && v.z >= g;) {\n        if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== s && qp(o, c, l, h, u, p, v.x, v.y) && Gp(v.prev, v, v.next) >= 0) return !1;\n        v = v.prevZ;\n      }\n      for (; b && b.z <= x;) {\n        if (b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== s && qp(o, c, l, h, u, p, b.x, b.y) && Gp(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      return !0;\n    }\n    function Vp(t, e, r) {\n      var n = t;\n      do {\n        var i = n.prev,\n          a = n.next.next;\n        !Yp(i, a) && Xp(i, n, n.next, a) && Hp(i, a) && Hp(a, i) && (e.push(i.i / r | 0), e.push(n.i / r | 0), e.push(a.i / r | 0), Qp(n), Qp(n.next), n = t = a), n = n.next;\n      } while (n !== t);\n      return Bp(n);\n    }\n    function Lp(t, e, r, n, i, a) {\n      var s = t;\n      do {\n        for (var o = s.next.next; o !== s.prev;) {\n          if (s.i !== o.i && $p(s, o)) {\n            var l = Wp(s, o);\n            return s = Bp(s, s.next), l = Bp(l, l.next), Cp(s, e, r, n, i, a, 0), void Cp(l, e, r, n, i, a, 0);\n          }\n          o = o.next;\n        }\n        s = s.next;\n      } while (s !== t);\n    }\n    function Fp(t, e) {\n      return t.x - e.x;\n    }\n    function Np(t, e) {\n      var r = function (t, e) {\n        var r,\n          n = e,\n          i = t.x,\n          a = t.y,\n          s = -1 / 0;\n        do {\n          if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {\n            var o = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n            if (o <= i && o > s && (s = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;\n          }\n          n = n.next;\n        } while (n !== e);\n        if (!r) return null;\n        var l,\n          u = r,\n          c = r.x,\n          h = r.y,\n          p = 1 / 0;\n        n = r;\n        do {\n          i >= n.x && n.x >= c && i !== n.x && qp(a < h ? i : s, a, c, h, a < h ? s : i, a, n.x, n.y) && (l = Math.abs(a - n.y) / (i - n.x), Hp(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && Op(r, n))) && (r = n, p = l)), n = n.next;\n        } while (n !== u);\n        return r;\n      }(t, e);\n      if (!r) return e;\n      var n = Wp(r, t);\n      return Bp(n, n.next), Bp(r, r.next);\n    }\n    function Op(t, e) {\n      return Gp(t.prev, t, e.prev) < 0 && Gp(e.next, t, t.next) < 0;\n    }\n    function Up(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n    function jp(t) {\n      var e = t,\n        r = t;\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n      return r;\n    }\n    function qp(t, e, r, n, i, a, s, o) {\n      return (i - s) * (e - o) >= (t - s) * (a - o) && (t - s) * (n - o) >= (r - s) * (e - o) && (r - s) * (a - o) >= (i - s) * (n - o);\n    }\n    function $p(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Xp(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n        return !1;\n      }(t, e) && (Hp(t, e) && Hp(e, t) && function (t, e) {\n        var r = t,\n          n = !1,\n          i = (t.x + e.x) / 2,\n          a = (t.y + e.y) / 2;\n        do {\n          r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n        return n;\n      }(t, e) && (Gp(t.prev, t, e.prev) || Gp(t, e.prev, e)) || Yp(t, e) && Gp(t.prev, t, t.next) > 0 && Gp(e.prev, e, e.next) > 0);\n    }\n    function Gp(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n    function Yp(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n    function Xp(t, e, r, n) {\n      var i = Kp(Gp(t, e, r)),\n        a = Kp(Gp(t, e, n)),\n        s = Kp(Gp(r, n, t)),\n        o = Kp(Gp(r, n, e));\n      return i !== a && s !== o || !(0 !== i || !Zp(t, r, e)) || !(0 !== a || !Zp(t, n, e)) || !(0 !== s || !Zp(r, t, n)) || !(0 !== o || !Zp(r, e, n));\n    }\n    function Zp(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n    function Kp(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n    function Hp(t, e) {\n      return Gp(t.prev, t, t.next) < 0 ? Gp(t, e, t.next) >= 0 && Gp(t, t.prev, e) >= 0 : Gp(t, e, t.prev) < 0 || Gp(t, t.next, e) < 0;\n    }\n    function Wp(t, e) {\n      var r = new tf(t.i, t.x, t.y),\n        n = new tf(e.i, e.x, e.y),\n        i = t.next,\n        a = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;\n    }\n    function Jp(t, e, r, n) {\n      var i = new tf(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n    function Qp(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n    function tf(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n    function ef(t, e, r, n) {\n      for (var i = 0, a = e, s = r - n; a < r; a += n) i += (t[s] - t[a]) * (t[a + 1] + t[s + 1]), s = a;\n      return i;\n    }\n    Ep.exports = zp, Ep.exports.default = zp, zp.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n        a = Math.abs(ef(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var s = 0, o = e.length; s < o; s++) a -= Math.abs(ef(t, e[s] * r, s < o - 1 ? e[s + 1] * r : t.length, r));\n      var l = 0;\n      for (s = 0; s < n.length; s += 3) {\n        var u = n[s] * r,\n          c = n[s + 1] * r,\n          h = n[s + 2] * r;\n        l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));\n      }\n      return 0 === a && 0 === l ? 0 : Math.abs((l - a) / a);\n    }, zp.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n          vertices: [],\n          holes: [],\n          dimensions: e\n        }, n = 0, i = 0; i < t.length; i++) {\n        for (var a = 0; a < t[i].length; a++) for (var s = 0; s < e; s++) r.vertices.push(t[i][a][s]);\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n      return r;\n    };\n    var rf = h(Ep.exports);\n    function nf(t, e) {\n      const r = t.length;\n      if (r <= 1) return [t];\n      const n = [];\n      let i, a;\n      for (let e = 0; e < r; e++) {\n        const r = $(t[e]);\n        0 !== r && (t[e].area = Math.abs(r), void 0 === a && (a = r < 0), a === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n      }\n      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (sr(n[t], e, 1, n[t].length - 1, af), n[t] = n[t].slice(0, e));\n      return n;\n    }\n    function af(t, e) {\n      return e.area - t.area;\n    }\n    function sf(t, e, r) {\n      const n = r.patternDependencies;\n      let i = !1;\n      for (const r of e) {\n        const e = r.paint.get(`${t}-pattern`);\n        e.isConstant() || (i = !0);\n        const a = e.constantOr(null);\n        a && (i = !0, n[a] = !0);\n      }\n      return i;\n    }\n    function of(t, e, r, n, i) {\n      const a = i.patternDependencies;\n      for (const s of e) {\n        const e = s.paint.get(`${t}-pattern`).value;\n        if (\"constant\" !== e.kind) {\n          let t = e.evaluate({\n            zoom: n\n          }, r, {}, i.availableImages);\n          t = t && t.name ? t.name : t, a[t] = !0, r.patterns[s.id] = t;\n        }\n      }\n      return r;\n    }\n    class lf {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new ps(), this.indexArray = new Es(), this.indexArray2 = new As(), this.programConfigurations = new Vo(t.layers, t.zoom), this.segments = new eo(), this.segments2 = new eo(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection;\n      }\n      populate(t, e, r, n) {\n        this.hasPattern = sf(\"fill\", this.layers, e);\n        const i = this.layers[0].layout.get(\"fill-sort-key\"),\n          a = [];\n        for (const {\n          feature: s,\n          id: o,\n          index: l,\n          sourceLayerIndex: u\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            c = Bl(s, t);\n          if (!this.layers[0]._featureFilter.filter(new Pa(this.zoom), c, r)) continue;\n          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,\n            p = {\n              id: o,\n              properties: s.properties,\n              type: s.type,\n              sourceLayerIndex: u,\n              index: l,\n              geometry: t ? c.geometry : Tl(s, r, n),\n              patterns: {},\n              sortKey: h\n            };\n          a.push(p);\n        }\n        i && a.sort((t, e) => t.sortKey - e.sortKey);\n        for (const n of a) {\n          const {\n            geometry: i,\n            index: a,\n            sourceLayerIndex: s\n          } = n;\n          if (this.hasPattern) {\n            const t = of(\"fill\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, a, r, {}, e.availableImages, e.brightness);\n          e.featureIndex.insert(t[a].feature, i, a, s, this.index);\n        }\n      }\n      update(t, e, r, n, i) {\n        const a = 0 !== Object.keys(t).length;\n        a && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t, e, a ? this.stateDependentLayers : this.layers, r, n, i);\n      }\n      addFeatures(t, e, r, n, i, a) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n, a);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Pp), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n      }\n      addFeature(t, e, r, n, i, a = [], s) {\n        for (const t of nf(e, 500)) {\n          let e = 0;\n          for (const r of t) e += r.length;\n          const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),\n            n = r.vertexLength,\n            i = [],\n            a = [];\n          for (const e of t) {\n            if (0 === e.length) continue;\n            e !== t[0] && a.push(i.length / 2);\n            const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),\n              n = r.vertexLength;\n            this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);\n            for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);\n            r.vertexLength += e.length, r.primitiveLength += e.length;\n          }\n          const s = rf(i, a);\n          for (let t = 0; t < s.length; t += 3) this.indexArray.emplaceBack(n + s[t], n + s[t + 1], n + s[t + 2]);\n          r.vertexLength += e, r.primitiveLength += s.length / 3;\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, a, n, s);\n      }\n    }\n    ra(lf, \"FillBucket\", {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const uf = new Oa({\n      \"fill-sort-key\": new Fa(qa.layout_fill[\"fill-sort-key\"]),\n      visibility: new La(qa.layout_fill.visibility)\n    });\n    var cf = {\n      paint: new Oa({\n        \"fill-antialias\": new La(qa.paint_fill[\"fill-antialias\"]),\n        \"fill-opacity\": new Fa(qa.paint_fill[\"fill-opacity\"]),\n        \"fill-color\": new Fa(qa.paint_fill[\"fill-color\"]),\n        \"fill-outline-color\": new Fa(qa.paint_fill[\"fill-outline-color\"]),\n        \"fill-translate\": new La(qa.paint_fill[\"fill-translate\"]),\n        \"fill-translate-anchor\": new La(qa.paint_fill[\"fill-translate-anchor\"]),\n        \"fill-pattern\": new Fa(qa.paint_fill[\"fill-pattern\"]),\n        \"fill-emissive-strength\": new La(qa.paint_fill[\"fill-emissive-strength\"])\n      }),\n      layout: uf\n    };\n    const hf = cs([{\n        name: \"a_pos_normal_ed\",\n        components: 4,\n        type: \"Int16\"\n      }]),\n      pf = cs([{\n        name: \"a_pos_end\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_angular_offset_factor\",\n        components: 1,\n        type: \"Int16\"\n      }]),\n      ff = cs([{\n        name: \"a_centroid_pos\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      df = cs([{\n        name: \"a_hidden_by_landmark\",\n        components: 1,\n        type: \"Uint8\"\n      }]),\n      mf = cs([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      {\n        members: yf\n      } = hf;\n    var gf = {},\n      xf = m,\n      vf = bf;\n    function bf(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(_f, this, e);\n    }\n    function _f(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n            i = e._values[t.readVarint()];\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n    function wf(t) {\n      for (var e, r, n = 0, i = 0, a = t.length, s = a - 1; i < a; s = i++) n += ((r = t[s]).x - (e = t[i]).x) * (e.y + r.y);\n      return n;\n    }\n    bf.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], bf.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n      for (var e, r = t.readVarint() + t.pos, n = 1, i = 0, a = 0, s = 0, o = []; t.pos < r;) {\n        if (i <= 0) {\n          var l = t.readVarint();\n          n = 7 & l, i = l >> 3;\n        }\n        if (i--, 1 === n || 2 === n) a += t.readSVarint(), s += t.readSVarint(), 1 === n && (e && o.push(e), e = []), e.push(new xf(a, s));else {\n          if (7 !== n) throw new Error(\"unknown command \" + n);\n          e && e.push(e[0].clone());\n        }\n      }\n      return e && o.push(e), o;\n    }, bf.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, a = 0, s = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var c = t.readVarint();\n          r = 7 & c, n = c >> 3;\n        }\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < s && (s = i), i > o && (o = i), (a += t.readSVarint()) < l && (l = a), a > u && (u = a);else if (7 !== r) throw new Error(\"unknown command \" + r);\n      }\n      return [s, l, o, u];\n    }, bf.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n        i,\n        a = this.extent * Math.pow(2, r),\n        s = this.extent * t,\n        o = this.extent * e,\n        l = this.loadGeometry(),\n        u = bf.types[this.type];\n      function c(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + s) / a - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / a) * Math.PI / 180)) - 90];\n        }\n      }\n      switch (this.type) {\n        case 1:\n          var h = [];\n          for (n = 0; n < l.length; n++) h[n] = l[n][0];\n          c(l = h);\n          break;\n        case 2:\n          for (n = 0; n < l.length; n++) c(l[n]);\n          break;\n        case 3:\n          for (l = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n            for (var r, n, i = [], a = 0; a < e; a++) {\n              var s = wf(t[a]);\n              0 !== s && (void 0 === n && (n = s < 0), n === s < 0 ? (r && i.push(r), r = [t[a]]) : r.push(t[a]));\n            }\n            return r && i.push(r), i;\n          }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);\n      }\n      1 === l.length ? l = l[0] : u = \"Multi\" + u;\n      var p = {\n        type: \"Feature\",\n        geometry: {\n          type: u,\n          coordinates: l\n        },\n        properties: this.properties\n      };\n      return \"id\" in this && (p.id = this.id), p;\n    };\n    var Mf = vf,\n      Af = Sf;\n    function Sf(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(If, this, e), this.length = this._features.length;\n    }\n    function If(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n        return e;\n      }(r));\n    }\n    Sf.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n      this._pbf.pos = this._features[t];\n      var e = this._pbf.readVarint() + this._pbf.pos;\n      return new Mf(this._pbf, e, this.extent, this._keys, this._values);\n    };\n    var kf = Af;\n    function Pf(t, e, r) {\n      if (3 === t) {\n        var n = new kf(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n    var Ef = gf.VectorTile = function (t, e) {\n        this.layers = t.readFields(Pf, {}, e);\n      },\n      zf = gf.VectorTileFeature = vf;\n    function Tf(t, e, r, n) {\n      const i = [],\n        a = 0 === n ? (t, e, r, n, i, a) => {\n          t.push(new g(a, r + (a - e) / (n - e) * (i - r)));\n        } : (t, e, r, n, i, a) => {\n          t.push(new g(e + (a - r) / (i - r) * (n - e), a));\n        };\n      for (const s of t) {\n        const t = [];\n        for (const i of s) {\n          if (i.length <= 2) continue;\n          const s = [];\n          for (let t = 0; t < i.length - 1; t++) {\n            const o = i[t].x,\n              l = i[t].y,\n              u = i[t + 1].x,\n              c = i[t + 1].y,\n              h = 0 === n ? o : l,\n              p = 0 === n ? u : c;\n            h < e ? p > e && a(s, o, l, u, c, e) : h > r ? p < r && a(s, o, l, u, c, r) : s.push(i[t]), p < e && h >= e && a(s, o, l, u, c, e), p > r && h <= r && a(s, o, l, u, c, r);\n          }\n          let o = i[i.length - 1];\n          const l = 0 === n ? o.x : o.y;\n          l >= e && l <= r && s.push(o), s.length && (o = s[s.length - 1], s[0].x === o.x && s[0].y === o.y || s.push(s[0]), t.push(s));\n        }\n        t.length && i.push(t);\n      }\n      return i;\n    }\n    function Bf(t, e) {\n      return t.x - e.x || t.y - e.y;\n    }\n    function Cf(t, e) {\n      return 0 === Bf(t.min, e.min) && 0 === Bf(t.max, e.max);\n    }\n    function Rf(t, e) {\n      return !(t.min.x > e.max.x || t.max.x < e.min.x || t.min.y > e.max.y || t.max.y < e.min.y);\n    }\n    function Df(t, e, r) {\n      const n = 1 / Tr,\n        i = 1 / (1 << r.canonical.z),\n        a = (e.x * n + r.canonical.x) * i + r.wrap,\n        s = (e.y * n + r.canonical.y) * i;\n      return {\n        min: new g((t.x * n + r.canonical.x) * i + r.wrap, (t.y * n + r.canonical.y) * i),\n        max: new g(a, s)\n      };\n    }\n    function Vf(t, e, r) {\n      const n = 1 << r.canonical.z,\n        i = ((e.x - r.wrap) * n - r.canonical.x) * Tr,\n        a = (e.y * n - r.canonical.y) * Tr;\n      return {\n        min: new g(((t.x - r.wrap) * n - r.canonical.x) * Tr, (t.y * n - r.canonical.y) * Tr),\n        max: new g(i, a)\n      };\n    }\n    function Lf(t, e, r, n, i, a, s) {\n      const o = t.indices,\n        l = t.vertices,\n        u = [];\n      for (let c = n; c < n + i; c += 3) {\n        const n = e[r[c + 0] + a],\n          i = e[r[c + 1] + a],\n          h = e[r[c + 2] + a],\n          p = Math.min(n.x, i.x, h.x),\n          f = Math.max(n.x, i.x, h.x),\n          d = Math.min(n.y, i.y, h.y),\n          m = Math.max(n.y, i.y, h.y);\n        u.length = 0, t.grid.query(new g(p, d), new g(f, m), u);\n        for (let t = 0; t < u.length; t++) {\n          const e = u[t];\n          if (Kl(l[o[3 * e + 0]], l[o[3 * e + 1]], l[o[3 * e + 2]], n, i, h, s)) return !0;\n        }\n      }\n      return !1;\n    }\n    function Ff(t, e, r, n) {\n      if (!t || !r) return !1;\n      let i = t.vertices;\n      if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {\n        if (r.vertices.length < t.vertices.length) return Ff(r, n, t, e);\n        const a = e.canonical,\n          s = n.canonical,\n          o = Math.pow(2, s.z - a.z);\n        i = t.vertices.map(t => new g(t.x * a.x * Tr * o - s.x * Tr, t.y * a.y * Tr * o - s.y * Tr));\n      }\n      return Lf(r, i, t.indices, 0, t.indices.length, 0, 0);\n    }\n    gf.VectorTileLayer = Af;\n    class Nf {\n      constructor(t) {\n        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];\n      }\n      getElevation(t, e) {\n        const r = this.toIdx(t, e);\n        return {\n          min: this.minimums[r],\n          max: this.maximums[r]\n        };\n      }\n      isLeaf(t, e) {\n        return this.leaves[this.toIdx(t, e)];\n      }\n      toIdx(t, e) {\n        return e * this.size + t;\n      }\n    }\n    function Of(t, e, r, n) {\n      let i = 0,\n        a = Number.MAX_VALUE;\n      for (let s = 0; s < 3; s++) if (Math.abs(n[s]) < 1e-15) {\n        if (r[s] < t[s] || r[s] > e[s]) return null;\n      } else {\n        const o = 1 / n[s];\n        let l = (t[s] - r[s]) * o,\n          u = (e[s] - r[s]) * o;\n        if (l > u) {\n          const t = l;\n          l = u, u = t;\n        }\n        if (l > i && (i = l), u < a && (a = u), i > a) return null;\n      }\n      return i;\n    }\n    function Uf(t, e, r, n, i, a, s, o, l, u, c) {\n      const h = n - t,\n        p = i - e,\n        f = a - r,\n        d = s - t,\n        m = o - e,\n        y = l - r,\n        g = c[1] * y - c[2] * m,\n        x = c[2] * d - c[0] * y,\n        v = c[0] * m - c[1] * d,\n        b = h * g + p * x + f * v;\n      if (Math.abs(b) < 1e-15) return null;\n      const _ = 1 / b,\n        w = u[0] - t,\n        M = u[1] - e,\n        A = u[2] - r,\n        S = (w * g + M * x + A * v) * _;\n      if (S < 0 || S > 1) return null;\n      const I = M * f - A * p,\n        k = A * h - w * f,\n        P = w * p - M * h,\n        E = (c[0] * I + c[1] * k + c[2] * P) * _;\n      return E < 0 || S + E > 1 ? null : (d * I + m * k + y * P) * _;\n    }\n    function jf(t, e, r) {\n      return (t - e) / (r - e);\n    }\n    function qf(t, e, r, n, i, a, s, o, l) {\n      const u = 1 << r,\n        c = a - n,\n        h = s - i,\n        p = (t + 1) / u * c + n,\n        f = (e + 0) / u * h + i,\n        d = (e + 1) / u * h + i;\n      o[0] = (t + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;\n    }\n    class $f {\n      constructor(t) {\n        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;\n        const e = function (t) {\n            const e = Math.ceil(Math.log2(t.dim / 8)),\n              r = [];\n            let n = Math.ceil(Math.pow(2, e));\n            const i = 1 / n,\n              a = (t, e, r, n, i) => {\n                const a = n ? 1 : 0,\n                  s = (t + 1) * r - a,\n                  o = e * r,\n                  l = (e + 1) * r - a;\n                i[0] = t * r, i[1] = o, i[2] = s, i[3] = l;\n              };\n            let s = new Nf(n);\n            const o = [];\n            for (let e = 0; e < n * n; e++) {\n              a(e % n, Math.floor(e / n), i, !1, o);\n              const r = Yf(o[0], o[1], t),\n                l = Yf(o[2], o[1], t),\n                u = Yf(o[2], o[3], t),\n                c = Yf(o[0], o[3], t);\n              s.minimums.push(Math.min(r, l, u, c)), s.maximums.push(Math.max(r, l, u, c)), s.leaves.push(1);\n            }\n            for (r.push(s), n /= 2; n >= 1; n /= 2) {\n              const t = r[r.length - 1];\n              s = new Nf(n);\n              for (let e = 0; e < n * n; e++) {\n                a(e % n, Math.floor(e / n), 2, !0, o);\n                const r = t.getElevation(o[0], o[1]),\n                  i = t.getElevation(o[2], o[1]),\n                  l = t.getElevation(o[2], o[3]),\n                  u = t.getElevation(o[0], o[3]),\n                  c = t.isLeaf(o[0], o[1]),\n                  h = t.isLeaf(o[2], o[1]),\n                  p = t.isLeaf(o[2], o[3]),\n                  f = t.isLeaf(o[0], o[3]),\n                  d = Math.min(r.min, i.min, l.min, u.min),\n                  m = Math.max(r.max, i.max, l.max, u.max),\n                  y = c && h && p && f;\n                s.maximums.push(m), s.minimums.push(d), s.leaves.push(m - d <= 5 && y ? 1 : 0);\n              }\n              r.push(s);\n            }\n            return r;\n          }(this.dem),\n          r = e.length - 1,\n          n = e[r];\n        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);\n      }\n      raycastRoot(t, e, r, n, i, a, s = 1) {\n        return Of([t, e, -100], [r, n, this.maximums[0] * s], i, a);\n      }\n      raycast(e, r, n, i, a, s, o = 1) {\n        if (!this.nodeCount) return null;\n        const l = this.raycastRoot(e, r, n, i, a, s, o);\n        if (null == l) return null;\n        const u = [],\n          c = [],\n          h = [],\n          p = [],\n          f = [{\n            idx: 0,\n            t: l,\n            nodex: 0,\n            nodey: 0,\n            depth: 0\n          }];\n        for (; f.length > 0;) {\n          const {\n            idx: l,\n            t: d,\n            nodex: m,\n            nodey: y,\n            depth: g\n          } = f.pop();\n          if (this.leaves[l]) {\n            qf(m, y, g, e, r, n, i, h, p);\n            const l = 1 << g,\n              u = (m + 0) / l,\n              c = (m + 1) / l,\n              f = (y + 0) / l,\n              x = (y + 1) / l,\n              v = Yf(u, f, this.dem) * o,\n              b = Yf(c, f, this.dem) * o,\n              _ = Yf(c, x, this.dem) * o,\n              w = Yf(u, x, this.dem) * o,\n              M = Uf(h[0], h[1], v, p[0], h[1], b, p[0], p[1], _, a, s),\n              A = Uf(p[0], p[1], _, h[0], p[1], w, h[0], h[1], v, a, s),\n              S = Math.min(null !== M ? M : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);\n            if (S !== Number.MAX_VALUE) return S;\n            {\n              const e = t.N.scaleAndAdd([], a, s, d);\n              if (Gf(v, b, w, _, jf(e[0], h[0], p[0]), jf(e[1], h[1], p[1])) >= e[2]) return d;\n            }\n            continue;\n          }\n          let x = 0;\n          for (let t = 0; t < this._siblingOffset.length; t++) {\n            qf((m << 1) + this._siblingOffset[t][0], (y << 1) + this._siblingOffset[t][1], g + 1, e, r, n, i, h, p), h[2] = -100, p[2] = this.maximums[this.childOffsets[l] + t] * o;\n            const f = Of(h, p, a, s);\n            if (null != f) {\n              const e = f;\n              u[t] = e;\n              let r = !1;\n              for (let n = 0; n < x && !r; n++) e >= u[c[n]] && (c.splice(n, 0, t), r = !0);\n              r || (c[x] = t), x++;\n            }\n          }\n          for (let t = 0; t < x; t++) {\n            const e = c[t];\n            f.push({\n              idx: this.childOffsets[l] + e,\n              t: u[e],\n              nodex: (m << 1) + this._siblingOffset[e][0],\n              nodey: (y << 1) + this._siblingOffset[e][1],\n              depth: g + 1\n            });\n          }\n        }\n        return null;\n      }\n      _addNode(t, e, r) {\n        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;\n      }\n      _construct(t, e, r, n, i) {\n        if (1 === t[n].isLeaf(e, r)) return;\n        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);\n        const a = n - 1,\n          s = t[a];\n        let o = 0,\n          l = 0;\n        for (let t = 0; t < this._siblingOffset.length; t++) {\n          const n = 2 * e + this._siblingOffset[t][0],\n            i = 2 * r + this._siblingOffset[t][1],\n            a = s.getElevation(n, i),\n            u = s.isLeaf(n, i),\n            c = this._addNode(a.min, a.max, u);\n          u && (o |= 1 << t), l || (l = c);\n        }\n        for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], a, l + n);\n      }\n    }\n    function Gf(t, e, r, n, i, a) {\n      return ue(ue(t, r, a), ue(e, n, a), i);\n    }\n    function Yf(t, e, r) {\n      const n = r.dim,\n        i = I(t * n - .5, 0, n - 1),\n        a = I(e * n - .5, 0, n - 1),\n        s = Math.floor(i),\n        o = Math.floor(a),\n        l = Math.min(s + 1, n - 1),\n        u = Math.min(o + 1, n - 1);\n      return Gf(r.get(s, o), r.get(l, o), r.get(s, u), r.get(l, u), i - s, a - o);\n    }\n    const Xf = {\n      mapbox: [6553.6, 25.6, .1, 1e4],\n      terrarium: [256, 1, 1 / 256, 32768]\n    };\n    function Zf(t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }\n    function Kf(t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }\n    class Hf {\n      get tree() {\n        return this._tree || this._buildQuadTree(), this._tree;\n      }\n      constructor(t, e, r, n = !1) {\n        if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n        if (r && \"mapbox\" !== r && \"terrarium\" !== r) return j(`\"${r}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`);\n        this.stride = e.height;\n        const i = this.dim = e.height - 2,\n          a = new Uint32Array(e.data.buffer);\n        if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {\n          for (let t = 0; t < i; t++) a[this._idx(-1, t)] = a[this._idx(0, t)], a[this._idx(i, t)] = a[this._idx(i - 1, t)], a[this._idx(t, -1)] = a[this._idx(t, 0)], a[this._idx(t, i)] = a[this._idx(t, i - 1)];\n          a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(i, -1)] = a[this._idx(i - 1, 0)], a[this._idx(-1, i)] = a[this._idx(0, i - 1)], a[this._idx(i, i)] = a[this._idx(i - 1, i - 1)];\n        }\n        const s = \"terrarium\" === r ? Kf : Zf;\n        for (let t = 0; t < a.length; ++t) {\n          const e = 4 * t;\n          this.floatView[t] = s(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);\n        }\n        this._timestamp = st.now();\n      }\n      _buildQuadTree() {\n        this._tree = new $f(this);\n      }\n      get(t, e, r = !1) {\n        r && (t = I(t, -1, this.dim), e = I(e, -1, this.dim));\n        const n = this._idx(t, e);\n        return this.floatView[n];\n      }\n      set(t, e, r) {\n        const n = this._idx(t, e),\n          i = this.floatView[n];\n        return this.floatView[n] = r, r - i;\n      }\n      static getUnpackVector(t) {\n        return Xf[t];\n      }\n      _idx(t, e) {\n        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n        return (e + 1) * this.stride + (t + 1);\n      }\n      static pack(t, e) {\n        const r = [0, 0, 0, 0],\n          n = Hf.getUnpackVector(e);\n        let i = Math.floor((t + n[3]) / n[2]);\n        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;\n      }\n      getPixels() {\n        return new _p({\n          width: this.stride,\n          height: this.stride\n        }, this.pixels);\n      }\n      backfillBorder(t, e, r) {\n        if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n        let n = e * this.dim,\n          i = e * this.dim + this.dim,\n          a = r * this.dim,\n          s = r * this.dim + this.dim;\n        switch (e) {\n          case -1:\n            n = i - 1;\n            break;\n          case 1:\n            i = n + 1;\n        }\n        switch (r) {\n          case -1:\n            a = s - 1;\n            break;\n          case 1:\n            s = a + 1;\n        }\n        const o = -e * this.dim,\n          l = -r * this.dim;\n        for (let e = a; e < s; e++) for (let r = n; r < i; r++) {\n          const n = 4 * this._idx(r, e),\n            i = 4 * this._idx(r + o, e + l);\n          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];\n        }\n      }\n      onDeserialize() {\n        this._tree && (this._tree.dem = this);\n      }\n    }\n    ra(Hf, \"DEMData\"), ra($f, \"DemMinMaxQuadTree\", {\n      omit: [\"dem\"]\n    });\n    class Wf {\n      constructor(t, e, r) {\n        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;\n      }\n      static create(t, e, r) {\n        const n = r || t.findDEMTileFor(e);\n        if (!n || !n.dem) return;\n        const i = n.dem,\n          a = n.tileID,\n          s = 1 << e.canonical.z - a.canonical.z;\n        return new Wf(n, i.dim / Tr / s, [(e.canonical.x / s - a.canonical.x) * i.dim, (e.canonical.y / s - a.canonical.y) * i.dim]);\n      }\n      tileCoordToPixel(t, e) {\n        const r = e * this._scale + this._offset[1],\n          n = Math.floor(t * this._scale + this._offset[0]),\n          i = Math.floor(r);\n        return new g(n, i);\n      }\n      getElevationAt(t, e, r, n) {\n        const i = t * this._scale + this._offset[0],\n          a = e * this._scale + this._offset[1],\n          s = Math.floor(i),\n          o = Math.floor(a),\n          l = this._dem;\n        return n = !!n, r ? ue(ue(l.get(s, o, n), l.get(s, o + 1, n), a - o), ue(l.get(s + 1, o, n), l.get(s + 1, o + 1, n), a - o), i - s) : l.get(s, o, n);\n      }\n      getElevationAtPixel(t, e, r) {\n        return this._dem.get(t, e, !!r);\n      }\n      getMeterToDEM(t) {\n        return (1 << this._demTile.tileID.canonical.z) * dl(1, t) * this._dem.stride;\n      }\n    }\n    const Jf = zf.types,\n      Qf = [\"fill-extrusion-base\", \"fill-extrusion-height\", \"fill-extrusion-color\", \"fill-extrusion-pattern\", \"fill-extrusion-flood-light-wall-radius\"],\n      td = [\"fill-extrusion-flood-light-ground-radius\"],\n      ed = Math.pow(2, 13),\n      rd = Math.pow(2, 15) - 1,\n      nd = new g(0, 1),\n      id = 2147483648;\n    function ad(t, e, r, n, i, a, s, o) {\n      t.emplaceBack((e << 1) + s, (r << 1) + a, (Math.floor(n * ed) << 1) + i, Math.round(o));\n    }\n    function sd(t, e, r, n, i, a) {\n      t.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, a);\n    }\n    function od(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class ld {\n      constructor() {\n        this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;\n      }\n    }\n    class ud {\n      constructor() {\n        this.centroidXY = new g(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new g(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new g(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;\n      }\n      span() {\n        return new g(this.max.x - this.min.x, this.max.y - this.min.y);\n      }\n    }\n    class cd {\n      constructor() {\n        this.acc = new g(0, 0), this.accCount = 0, this.centroidDataIndex = 0;\n      }\n      startRing(t, e) {\n        t.min.x === Number.MAX_VALUE && (t.min.x = t.max.x = e.x, t.min.y = t.max.y = e.y);\n      }\n      appendEdge(t, e, r) {\n        this.accCount++, this.acc._add(e);\n        let n = !!this.borders;\n        e.x < t.min.x ? (t.min.x = e.x, n = !0) : e.x > t.max.x && (t.max.x = e.x, n = !0), e.y < t.min.y ? (t.min.y = e.y, n = !0) : e.y > t.max.y && (t.max.y = e.y, n = !0), ((0 === e.x || e.x === Tr) && e.x === r.x) != ((0 === e.y || e.y === Tr) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);\n      }\n      checkBorderIntersection(t, e) {\n        e.x < 0 != t.x < 0 && this.addBorderIntersection(0, ue(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > Tr != t.x > Tr && this.addBorderIntersection(1, ue(e.y, t.y, (Tr - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, ue(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > Tr != t.y > Tr && this.addBorderIntersection(3, ue(e.x, t.x, (Tr - e.y) / (t.y - e.y)));\n      }\n      addBorderIntersection(t, e) {\n        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);\n        const r = this.borders[t];\n        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);\n      }\n      processBorderOverlap(t, e) {\n        if (t.x === e.x) {\n          if (t.y === e.y) return;\n          const r = 0 === t.x ? 0 : 1;\n          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);\n        } else {\n          const r = 0 === t.y ? 2 : 3;\n          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);\n        }\n      }\n      centroid() {\n        return 0 === this.accCount ? new g(0, 0) : new g(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));\n      }\n      intersectsCount() {\n        return this.borders ? this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0) : 0;\n      }\n    }\n    function hd(t, e) {\n      const r = t.add(e)._unit(),\n        n = I(t.x * r.x + t.y * r.y, -1, 1);\n      var i, a, s;\n      return i = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(i))) / 4 * rd * ((a = t).x * (s = e).y - a.y * s.x < 0 ? -1 : 1);\n    }\n    const pd = [t => t.x < 0, t => t.x > Tr, t => t.y < 0, t => t.y > Tr];\n    function fd(t, e, r, n) {\n      const i = [4];\n      if (0 === n) return i;\n      r._mult(n);\n      const a = t.sub(r),\n        s = e.sub(r),\n        o = [t, e, a, s];\n      for (let t = 0; t < 4; t++) for (const e of o) if (pd[t](e)) {\n        i.push(t);\n        break;\n      }\n      return i;\n    }\n    class dd {\n      constructor(t) {\n        this.vertexArray = new ms(), this.indexArray = new Es(), this.programConfigurations = new Vo(t.layers, t.zoom, t => td.includes(t)), this._segments = new eo(), this.hiddenByLandmarkVertexArray = new Us(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new eo();\n      }\n      getDefaultSegment() {\n        return this.regionSegments[4];\n      }\n      hasData() {\n        return 0 !== this.vertexArray.length;\n      }\n      addData(t, e, r, n = !1) {\n        const i = t.length;\n        if (i > 2) {\n          let a = Math.max(0, this._segments.get().length - 1);\n          const s = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[a].length);\n          let o;\n          a !== this._segments.get().length - 1 && (a++, this._segmentToGroundQuads[a] = [], this._segmentToRegionTriCounts[a] = [0, 0, 0, 0, 0]);\n          {\n            const e = t[0],\n              r = t[1];\n            o = hd(e.sub(t[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());\n          }\n          for (let l = 0; l < i; l++) {\n            const u = l === i - 1 ? 0 : l + 1,\n              c = t[l],\n              h = t[u],\n              p = t[u === i - 1 ? 0 : u + 1],\n              f = h.sub(c)._perp()._unit(),\n              d = hd(f, p.sub(h)._perp()._unit()),\n              m = o,\n              y = d;\n            if (vd(c, h, e) || n && bd(c, e) && bd(h, e)) {\n              o = d;\n              continue;\n            }\n            const g = s.vertexLength;\n            sd(this.vertexArray, c, h, 1, 1, m), sd(this.vertexArray, c, h, 1, 0, m), sd(this.vertexArray, c, h, 0, 1, y), sd(this.vertexArray, c, h, 0, 0, y), s.vertexLength += 4;\n            const x = fd(c, h, f, r);\n            for (const t of x) this._segmentToGroundQuads[a].push({\n              id: g,\n              region: t\n            }), this._segmentToRegionTriCounts[a][t] += 2, s.primitiveLength += 2;\n            o = d;\n          }\n        }\n      }\n      prepareBorderSegments() {\n        if (!this.hasData()) return;\n        const t = this._segments.get(),\n          e = t.length;\n        for (let t = 0; t < e; t++) this._segmentToGroundQuads[t].sort((t, e) => t.region - e.region);\n        for (let r = 0; r < e; r++) {\n          const e = this._segmentToGroundQuads[r],\n            n = t[r],\n            i = this._segmentToRegionTriCounts[r];\n          i.reduce((t, e) => t + e, 0);\n          let a = 0;\n          for (let t = 0; t <= 4; t++) {\n            const e = i[t];\n            if (0 !== e) {\n              let r = this.regionSegments[t];\n              r || (r = this.regionSegments[t] = new eo());\n              const i = {\n                vertexOffset: n.vertexOffset,\n                primitiveOffset: n.primitiveOffset + a,\n                vertexLength: n.vertexLength,\n                primitiveLength: e\n              };\n              r.get().push(i);\n            }\n            a += e;\n          }\n          for (let t = 0; t < e.length; t++) {\n            const r = e[t].id;\n            this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);\n          }\n        }\n        this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;\n      }\n      addPaintPropertiesData(t, e, r, n, i, a) {\n        this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t, e, r, n, i, a);\n      }\n      upload(t) {\n        this.hasData() && (this.vertexBuffer = t.createVertexBuffer(this.vertexArray, pf.members), this.indexBuffer = t.createIndexBuffer(this.indexArray));\n      }\n      uploadPaintProperties(t) {\n        this.hasData() && this.programConfigurations.upload(t);\n      }\n      update(t, e, r, n, i, a) {\n        this.hasData() && this.programConfigurations.updatePaintArrays(t, e, r, n, i, a);\n      }\n      updateHiddenByLandmark(t) {\n        if (!this.hasData()) return;\n        const e = t.groundVertexCount + t.groundVertexArrayOffset;\n        if (0 === t.groundVertexCount) return;\n        const r = t.flags & id ? 1 : 0;\n        for (let n = t.groundVertexArrayOffset; n < e; ++n) this.hiddenByLandmarkVertexArray.emplace(n, r);\n        this._needsHiddenByLandmarkUpdate = !0;\n      }\n      uploadHiddenByLandmark(t) {\n        this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t.createVertexBuffer(this.hiddenByLandmarkVertexArray, df.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);\n      }\n      destroy() {\n        if (this.vertexBuffer) {\n          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();\n          for (let t = 0; t <= 4; t++) {\n            const e = this.regionSegments[t];\n            e && e.destroy();\n          }\n        }\n      }\n    }\n    class md {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Es(), this.footprintVertices = new ps(), this.footprintSegments = [], this.layoutVertexArray = new ds(), this.centroidVertexArray = new Js(), this.indexArray = new Es(), this.programConfigurations = new Vo(t.layers, t.zoom, t => Qf.includes(t)), this.segments = new eo(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.groundEffect = new dd(t), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];\n      }\n      populate(t, e, r, n) {\n        this.features = [], this.hasPattern = sf(\"fill-extrusion\", this.layers, e), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = wl(r), this.edgeRadius = this.layers[0].layout.get(\"fill-extrusion-edge-radius\") / this.tileToMeter;\n        for (const {\n          feature: i,\n          id: a,\n          index: s,\n          sourceLayerIndex: o\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = Bl(i, t);\n          if (!this.layers[0]._featureFilter.filter(new Pa(this.zoom), l, r)) continue;\n          const u = {\n              id: a,\n              sourceLayerIndex: o,\n              index: s,\n              geometry: t ? l.geometry : Tl(i, r, n),\n              properties: i.properties,\n              type: i.type,\n              patterns: {}\n            },\n            c = this.layoutVertexArray.length;\n          this.hasPattern ? this.features.push(of(\"fill-extrusion\", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, s, r, {}, e.availableImages, n, e.brightness), e.featureIndex.insert(i, u.geometry, s, o, this.index, c);\n        }\n        this.sortBorders(), \"mercator\" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;\n      }\n      addFeatures(t, e, r, n, i, a) {\n        for (const t of this.features) {\n          const {\n            geometry: s\n          } = t;\n          this.addFeature(t, s, t.index, e, r, n, i, a);\n        }\n        this.sortBorders(), \"mercator\" === this.projection.name && this.splitToSubtiles();\n      }\n      update(t, e, r, n, i) {\n        const a = 0 !== Object.keys(t).length;\n        if (a && !this.stateDependentLayers.length) return;\n        const s = a ? this.stateDependentLayers : this.layers;\n        this.programConfigurations.updatePaintArrays(t, e, s, r, n, i), this.groundEffect.update(t, e, s, r, n, i);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, yf), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, mf.members, !0)), this.groundEffect.upload(t)), this.groundEffect.uploadPaintProperties(t), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      uploadCentroid(t) {\n        this.groundEffect.uploadHiddenByLandmark(t), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, ff.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      addFeature(t, e, r, n, i, a, s, o) {\n        const l = this.layers[0].paint.get(\"fill-extrusion-flood-light-ground-radius\").evaluate(t, {}) / this.tileToMeter,\n          u = [new g(0, 0), new g(Tr, Tr)],\n          c = s.projection,\n          h = \"globe\" === c.name,\n          p = \"Polygon\" === Jf[t.type],\n          f = new cd();\n        f.centroidDataIndex = this.centroidData.length;\n        const d = new ud(),\n          m = this.layers[0].paint.get(\"fill-extrusion-base\").evaluate(t, {}, n) <= 0,\n          y = this.layers[0].paint.get(\"fill-extrusion-height\").evaluate(t, {}, n);\n        d.height = y, d.vertexArrayOffset = this.layoutVertexArray.length, d.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new bs());\n        const x = nf(e, 500);\n        for (let t = x.length - 1; t >= 0; t--) {\n          const e = x[t];\n          (0 === e.length || (v = e[0]).every(t => t.x <= 0) || v.every(t => t.x >= Tr) || v.every(t => t.y <= 0) || v.every(t => t.y >= Tr)) && x.splice(t, 1);\n        }\n        var v;\n        let b;\n        if (h) b = Ad(x, u, n);else {\n          b = [];\n          for (const t of x) b.push({\n            polygon: t,\n            bounds: u\n          });\n        }\n        const _ = p ? this.edgeRadius : 0,\n          w = _ > 0 && this.zoom < 17,\n          M = (t, e) => {\n            if (0 === t.length) return !1;\n            const r = t[t.length - 1];\n            return e.x === r.x && e.y === r.y;\n          };\n        for (const {\n          polygon: t,\n          bounds: e\n        } of b) {\n          let r = 0,\n            i = 0;\n          for (const e of t) p && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += p ? e.length - 1 : e.length;\n          const a = this.segments.prepareSegment((p ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);\n          d.footprintSegIdx < 0 && (d.footprintSegIdx = this.footprintSegments.length), d.polygonSegIdx < 0 && (d.polygonSegIdx = this.polygonSegments.length);\n          const s = {\n              triangleArrayOffset: this.indexArray.length,\n              triangleCount: 0,\n              triangleSegIdx: this.segments.segments.length - 1\n            },\n            o = new ld();\n          if (o.vertexOffset = this.footprintVertices.length, o.indexOffset = 3 * this.footprintIndices.length, o.ringIndices = [], p) {\n            const i = [],\n              s = [];\n            r = a.vertexLength;\n            for (let r = 0; r < t.length; r++) {\n              const u = t[r];\n              u.length && 0 !== r && s.push(i.length / 2);\n              const p = [];\n              let f, d;\n              f = u[1].sub(u[0])._perp()._unit(), o.ringIndices.push(u.length - 1);\n              for (let t = 1; t < u.length; t++) {\n                const e = u[t],\n                  r = u[t === u.length - 1 ? 1 : t + 1],\n                  s = e.clone();\n                if (_) {\n                  d = r.sub(e)._perp()._unit();\n                  const t = f.add(d)._unit(),\n                    n = _ * Math.min(4, 1 / (f.x * t.x + f.y * t.y));\n                  s.x += n * t.x, s.y += n * t.y, s.x = Math.round(s.x), s.y = Math.round(s.y), f = d;\n                }\n                !m || 0 !== _ && !w || M(p, s) || p.push(s), ad(this.layoutVertexArray, s.x, s.y, 0, 0, 1, 1, 0), a.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), i.push(e.x, e.y), h && od(this.layoutVertexExtArray, c.projectTilePoint(s.x, s.y, n), c.upVector(n, s.x, s.y));\n              }\n              m && (0 === _ || w) && (0 !== p.length && M(p, p[0]) && p.pop(), this.groundEffect.addData(p, e, l));\n            }\n            const u = rf(i, s);\n            for (let t = 0; t < u.length; t += 3) this.footprintIndices.emplaceBack(o.vertexOffset + u[t + 0], o.vertexOffset + u[t + 1], o.vertexOffset + u[t + 2]), this.indexArray.emplaceBack(r + u[t], r + u[t + 2], r + u[t + 1]), a.primitiveLength++;\n            o.indexCount += u.length, o.vertexCount += this.footprintVertices.length - o.vertexOffset;\n          }\n          for (let i = 0; i < t.length; i++) {\n            const s = t[i];\n            f.startRing(d, s[0]);\n            let o = s.length > 4 && _d(s[s.length - 2], s[0], s[1]),\n              u = _ ? gd(s[s.length - 2], s[0], s[1], _) : 0;\n            const y = [];\n            let g, x, v;\n            x = s[1].sub(s[0])._perp()._unit();\n            let b = !0;\n            for (let t = 1, i = 0; t < s.length; t++) {\n              let l = s[t - 1],\n                p = s[t];\n              const w = s[t === s.length - 1 ? 1 : t + 1];\n              if (f.appendEdge(d, p, l), vd(p, l, e)) {\n                _ && (x = w.sub(p)._perp()._unit(), b = !b);\n                continue;\n              }\n              const A = p.sub(l)._perp(),\n                S = A.x / (Math.abs(A.x) + Math.abs(A.y)),\n                I = A.y > 0 ? 1 : 0,\n                k = l.dist(p);\n              if (i + k > 32768 && (i = 0), _) {\n                v = w.sub(p)._perp()._unit();\n                let t = xd(l, p, w, yd(x, v), _);\n                isNaN(t) && (t = 0);\n                const e = p.sub(l)._unit();\n                l = l.add(e.mult(u))._round(), p = p.add(e.mult(-t))._round(), u = t, x = v, m && this.zoom >= 17 && (M(y, l) || y.push(l), M(y, p) || y.push(p));\n              }\n              const P = a.vertexLength,\n                E = s.length > 4 && _d(l, p, w);\n              let z = wd(i, o, b);\n              if (ad(this.layoutVertexArray, l.x, l.y, S, I, 0, 0, z), ad(this.layoutVertexArray, l.x, l.y, S, I, 0, 1, z), i += k, z = wd(i, E, !b), o = E, ad(this.layoutVertexArray, p.x, p.y, S, I, 0, 0, z), ad(this.layoutVertexArray, p.x, p.y, S, I, 0, 1, z), a.vertexLength += 4, this.indexArray.emplaceBack(P + 0, P + 1, P + 2), this.indexArray.emplaceBack(P + 1, P + 3, P + 2), a.primitiveLength += 2, _) {\n                const n = r + (1 === t ? s.length - 2 : t - 2),\n                  i = 1 === t ? r : n + 1;\n                if (this.indexArray.emplaceBack(P + 1, n, P + 3), this.indexArray.emplaceBack(n, i, P + 3), a.primitiveLength += 2, void 0 === g && (g = P), !vd(w, s[t], e)) {\n                  const e = t === s.length - 1 ? g : a.vertexLength;\n                  this.indexArray.emplaceBack(P + 2, P + 3, e), this.indexArray.emplaceBack(P + 3, e + 1, e), this.indexArray.emplaceBack(P + 3, i, e + 1), a.primitiveLength += 3;\n                }\n                b = !b;\n              }\n              if (h) {\n                const t = this.layoutVertexExtArray,\n                  e = c.projectTilePoint(l.x, l.y, n),\n                  r = c.projectTilePoint(p.x, p.y, n),\n                  i = c.upVector(n, l.x, l.y),\n                  a = c.upVector(n, p.x, p.y);\n                od(t, e, i), od(t, e, i), od(t, r, a), od(t, r, a);\n              }\n            }\n            p && (r += s.length - 1), m && _ && this.zoom >= 17 && (0 !== y.length && M(y, y[0]) && y.pop(), this.groundEffect.addData(y, e, l, _ > 0));\n          }\n          this.footprintSegments.push(o), s.triangleCount = this.indexArray.length - s.triangleArrayOffset, this.polygonSegments.push(s), ++d.footprintSegLen, ++d.polygonSegLen;\n        }\n        if (d.vertexCount = this.layoutVertexArray.length - d.vertexArrayOffset, d.groundVertexCount = this.groundEffect.vertexArray.length - d.groundVertexArrayOffset, 0 !== d.vertexCount) {\n          if (d.centroidXY = f.borders ? nd : this.encodeCentroid(f, d), this.centroidData.push(d), f.borders) {\n            this.featuresOnBorder.push(f);\n            const t = this.featuresOnBorder.length - 1;\n            for (let e = 0; e < f.borders.length; e++) f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t);\n          }\n          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, a, n, o), this.groundEffect.addPaintPropertiesData(t, r, i, a, n, o), this.maxHeight = Math.max(this.maxHeight, y);\n        }\n      }\n      sortBorders() {\n        for (let t = 0; t < this.borderFeatureIndices.length; t++) this.borderFeatureIndices[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);\n      }\n      splitToSubtiles() {\n        const t = [];\n        for (let e = 0; e < this.centroidData.length; e++) {\n          const r = this.centroidData[e],\n            n = +(r.min.y + r.max.y > Tr),\n            i = 2 * n + (+(r.min.x + r.max.x > Tr) ^ n);\n          for (let n = 0; n < r.polygonSegLen; n++) {\n            const a = r.polygonSegIdx + n;\n            t.push({\n              centroidIdx: e,\n              subtile: i,\n              polygonSegmentIdx: a,\n              triangleSegmentIdx: this.polygonSegments[a].triangleSegIdx\n            });\n          }\n        }\n        const e = new Es();\n        t.sort((t, e) => t.triangleSegmentIdx === e.triangleSegmentIdx ? t.subtile - e.subtile : t.triangleSegmentIdx - e.triangleSegmentIdx);\n        let r = 0,\n          n = 0,\n          i = 0;\n        for (const e of t) {\n          if (e.triangleSegmentIdx !== r) break;\n          i++;\n        }\n        const a = t.length;\n        for (; n !== t.length;) {\n          r = t[n].triangleSegmentIdx;\n          let s = 0,\n            o = n,\n            l = n;\n          for (let e = o; e < i && t[e].subtile === s; e++) l++;\n          for (; o !== i;) {\n            const n = t[o];\n            s = n.subtile;\n            const a = this.centroidData[n.centroidIdx].min.clone(),\n              u = this.centroidData[n.centroidIdx].max.clone(),\n              c = {\n                vertexOffset: this.segments.segments[r].vertexOffset,\n                primitiveOffset: e.length,\n                vertexLength: this.segments.segments[r].vertexLength,\n                primitiveLength: 0,\n                sortKey: void 0,\n                vaos: {}\n              };\n            for (let r = o; r < l; r++) {\n              const n = t[r],\n                i = this.polygonSegments[n.polygonSegmentIdx],\n                s = this.centroidData[n.centroidIdx].min,\n                o = this.centroidData[n.centroidIdx].max,\n                l = this.indexArray.uint16;\n              for (let t = i.triangleArrayOffset; t < i.triangleArrayOffset + i.triangleCount; t++) e.emplaceBack(l[3 * t], l[3 * t + 1], l[3 * t + 2]);\n              c.primitiveLength += i.triangleCount, a.x = Math.min(a.x, s.x), a.y = Math.min(a.y, s.y), u.x = Math.max(u.x, o.x), u.y = Math.max(u.y, o.y);\n            }\n            c.primitiveLength > 0 && this.triangleSubSegments.push({\n              segment: c,\n              min: a,\n              max: u\n            }), o = l;\n            for (let e = o; e < i && t[e].subtile === t[o].subtile; e++) l++;\n          }\n          n = i;\n          for (let e = n; e < a && t[e].triangleSegmentIdx === t[n].triangleSegmentIdx; e++) i++;\n        }\n        e._trim(), this.indexArray = e;\n      }\n      getVisibleSegments(t, e, r) {\n        let n = 0,\n          i = 0;\n        const a = 1 << t.canonical.z;\n        if (e) {\n          const r = e.getMinMaxForTile(t);\n          r && (n = r.min, i = r.max);\n        }\n        i += this.maxHeight;\n        const s = t.toUnwrapped();\n        let o;\n        const l = [s.canonical.x / a + s.wrap, s.canonical.y / a],\n          u = [(s.canonical.x + 1) / a + s.wrap, (s.canonical.y + 1) / a],\n          c = new eo(),\n          h = (t, e, r) => [t[0] * (1 - r[0]) + e[0] * r[0], t[1] * (1 - r[1]) + e[1] * r[1]],\n          p = [],\n          f = [];\n        for (const t of this.triangleSubSegments) {\n          p[0] = t.min.x / Tr, p[1] = t.min.y / Tr, f[0] = t.max.x / Tr, f[1] = t.max.y / Tr;\n          const e = h(l, u, p),\n            a = h(l, u, f);\n          if (0 === new Bh([e[0], e[1], n], [a[0], a[1], i]).intersectsPrecise(r)) {\n            o && (c.segments.push(o), o = void 0);\n            continue;\n          }\n          const s = t.segment;\n          o && o.vertexOffset !== s.vertexOffset && (c.segments.push(o), o = void 0), o ? (o.vertexLength += s.vertexLength, o.primitiveLength += s.primitiveLength) : o = {\n            vertexOffset: s.vertexOffset,\n            primitiveLength: s.primitiveLength,\n            vertexLength: s.vertexLength,\n            primitiveOffset: s.primitiveOffset,\n            sortKey: void 0,\n            vaos: {}\n          };\n        }\n        return o && c.segments.push(o), c;\n      }\n      encodeCentroid(t, e) {\n        const r = t.centroid(),\n          n = e.span(),\n          i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)),\n          a = Math.min(7, Math.round(n.y * this.tileToMeter / 10));\n        return new g(I(r.x, 1, Tr - 1) << 3 | i, I(r.y, 1, Tr - 1) << 3 | a);\n      }\n      encodeBorderCentroid(t) {\n        if (!t.borders) return new g(0, 0);\n        const e = t.borders,\n          r = Number.MAX_VALUE;\n        if (e[0][0] !== r || e[1][0] !== r) {\n          const t = e[0][0] !== r ? 0 : 1;\n          return new g(6 | (e[0][0] !== r ? 0 : 65528), (e[t][0] + e[t][1]) / 2 << 3 | 6);\n        }\n        {\n          const t = e[2][0] !== r ? 2 : 3;\n          return new g((e[t][0] + e[t][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));\n        }\n      }\n      showCentroid(t) {\n        const e = this.centroidData[t.centroidDataIndex];\n        e.flags &= id, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);\n      }\n      writeCentroidToBuffer(t) {\n        this.groundEffect.updateHiddenByLandmark(t);\n        const e = t.vertexArrayOffset,\n          r = t.vertexCount + t.vertexArrayOffset,\n          n = t.flags & id ? nd : t.centroidXY,\n          i = this.centroidVertexArray.geta_centroid_pos0(e);\n        if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {\n          for (let t = e; t < r; ++t) this.centroidVertexArray.emplace(t, n.x, n.y);\n          this.needsCentroidUpdate = !0;\n        }\n      }\n      createCentroidsBuffer() {\n        this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);\n        for (const t of this.centroidData) this.writeCentroidToBuffer(t);\n      }\n      updateReplacement(t, e) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const r = e.getReplacementRegionsForTile(t.toUnwrapped());\n        if (function (t, e) {\n          if (t.length !== e.length) return !1;\n          for (let r = 0; r < t.length; r++) if (t[r].sourceId !== e[r].sourceId || !Cf(t[r], e[r])) return !1;\n          return !0;\n        }(this.activeReplacements, r)) return;\n        if (this.activeReplacements = r, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();else for (const t of this.centroidData) t.flags &= 2147483647;\n        const n = [];\n        for (const e of this.activeReplacements) {\n          const r = Math.pow(2, e.footprintTileId.canonical.z - t.canonical.z);\n          for (const i of this.centroidData) if (!(i.flags & id || e.min.x > i.max.x || i.min.x > e.max.x || e.min.y > i.max.y || i.min.y > e.max.y)) for (let a = 0; a < i.footprintSegLen; a++) {\n            const s = this.footprintSegments[i.footprintSegIdx + a];\n            if (n.length = 0, Sd(this.footprintVertices, s.vertexOffset, s.vertexCount, e.footprintTileId.canonical, t.canonical, n), Lf(e.footprint, n, this.footprintIndices.uint16, s.indexOffset, s.indexCount, -s.vertexOffset, -r)) {\n              i.flags |= id;\n              break;\n            }\n          }\n        }\n        for (const t of this.centroidData) this.writeCentroidToBuffer(t);\n        this.borderDoneWithNeighborZ = [-1, -1, -1, -1];\n      }\n      footprintContainsPoint(t, e, r) {\n        let n = !1;\n        for (let i = 0; i < r.footprintSegLen; i++) {\n          const a = this.footprintSegments[r.footprintSegIdx + i];\n          let s = 0;\n          for (const r of a.ringIndices) {\n            for (let i = s, o = r + s - 1; i < r + s; o = i++) {\n              const r = this.footprintVertices.int16[2 * (i + a.vertexOffset) + 0],\n                s = this.footprintVertices.int16[2 * (i + a.vertexOffset) + 1],\n                l = this.footprintVertices.int16[2 * (o + a.vertexOffset) + 1];\n              s > e != l > e && t < (this.footprintVertices.int16[2 * (o + a.vertexOffset) + 0] - r) * (e - s) / (l - s) + r && (n = !n);\n            }\n            s = r;\n          }\n        }\n        return n;\n      }\n      getHeightAtTileCoord(t, e) {\n        let r = Number.NEGATIVE_INFINITY,\n          n = !0;\n        const i = 4 * (t + Tr) * Tr + (e + Tr);\n        if (this.partLookup.hasOwnProperty(i)) {\n          const t = this.partLookup[i];\n          return t ? {\n            height: t.height,\n            hidden: !!(t.flags & id)\n          } : void 0;\n        }\n        for (const a of this.centroidData) t > a.max.x || a.min.x > t || e > a.max.y || a.min.y > e || this.footprintContainsPoint(t, e, a) && a && a.height > r && (r = a.height, this.partLookup[i] = a, n = !!(a.flags & id));\n        if (r !== Number.NEGATIVE_INFINITY) return {\n          height: r,\n          hidden: n\n        };\n        this.partLookup[i] = void 0;\n      }\n    }\n    function yd(t, e) {\n      const r = t.add(e)._unit();\n      return t.x * r.x + t.y * r.y;\n    }\n    function gd(t, e, r, n) {\n      const i = e.sub(t)._perp()._unit(),\n        a = r.sub(e)._perp()._unit();\n      return xd(t, e, r, yd(i, a), n);\n    }\n    function xd(t, e, r, n, i) {\n      const a = Math.sqrt(1 - n * n);\n      return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * a / n);\n    }\n    function vd(t, e, r) {\n      return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y;\n    }\n    function bd(t, e) {\n      return t.x < e[0].x || t.x > e[1].x || t.y < e[0].y || t.y > e[1].y;\n    }\n    function _d(t, e, r) {\n      if (t.x < 0 || t.x >= Tr || e.x < 0 || e.x >= Tr || r.x < 0 || r.x >= Tr) return !1;\n      const n = r.sub(e),\n        i = n.perp(),\n        a = t.sub(e);\n      return (n.x * a.x + n.y * a.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (a.x * a.x + a.y * a.y)) > -.866 && i.x * a.x + i.y * a.y < 0;\n    }\n    function wd(t, e, r) {\n      const n = e ? 2 | t : -3 & t;\n      return r ? 1 | n : -2 & n;\n    }\n    function Md() {\n      const t = Math.PI / 32,\n        e = Math.tan(t),\n        r = Jo;\n      return r * Math.sqrt(1 + 2 * e * e) - r;\n    }\n    function Ad(t, e, r) {\n      const n = 1 << r.z,\n        i = ml(r.x / n),\n        a = ml((r.x + 1) / n),\n        s = yl(r.y / n),\n        o = yl((r.y + 1) / n);\n      return function (t, e, r, n, i = 0, a) {\n        const s = [];\n        if (!t.length || !r || !n) return s;\n        const o = (t, e) => {\n            for (const r of t) s.push({\n              polygon: r,\n              bounds: e\n            });\n          },\n          l = Math.ceil(Math.log2(r)),\n          u = Math.ceil(Math.log2(n)),\n          c = l - u,\n          h = [];\n        for (let t = 0; t < Math.abs(c); t++) h.push(c > 0 ? 0 : 1);\n        for (let t = 0; t < Math.min(l, u); t++) h.push(0), h.push(1);\n        let p = t;\n        if (p = Tf(p, e[0].y - i, e[1].y + i, 1), p = Tf(p, e[0].x - i, e[1].x + i, 0), !p.length) return s;\n        const f = [];\n        for (h.length ? f.push({\n          polygons: p,\n          bounds: e,\n          depth: 0\n        }) : o(p, e); f.length;) {\n          const t = f.pop(),\n            e = t.depth,\n            r = h[e],\n            n = t.bounds[0],\n            s = t.bounds[1],\n            l = 0 === r ? n.x : n.y,\n            u = 0 === r ? s.x : s.y,\n            c = a ? a(r, l, u) : .5 * (l + u),\n            p = Tf(t.polygons, l - i, c + i, r),\n            d = Tf(t.polygons, c - i, u + i, r);\n          if (p.length) {\n            const t = [n, new g(0 === r ? c : s.x, 1 === r ? c : s.y)];\n            h.length > e + 1 ? f.push({\n              polygons: p,\n              bounds: t,\n              depth: e + 1\n            }) : o(p, t);\n          }\n          if (d.length) {\n            const t = [new g(0 === r ? c : n.x, 1 === r ? c : n.y), s];\n            h.length > e + 1 ? f.push({\n              polygons: d,\n              bounds: t,\n              depth: e + 1\n            }) : o(d, t);\n          }\n        }\n        return s;\n      }(t, e, Math.ceil((a - i) / 11.25), Math.ceil((s - o) / 11.25), 1, (t, e, i) => {\n        if (0 === t) return .5 * (e + i);\n        {\n          const t = yl((r.y + e / Tr) / n);\n          return (fl(.5 * (yl((r.y + i / Tr) / n) + t)) * n - r.y) * Tr;\n        }\n      });\n    }\n    function Sd(t, e, r, n, i, a) {\n      const s = Math.pow(2, n.z - i.z);\n      for (let o = 0; o < r; o++) {\n        let r = t.int16[2 * (o + e) + 0],\n          l = t.int16[2 * (o + e) + 1];\n        r = (r + i.x * Tr) * s - n.x * Tr, l = (l + i.y * Tr) * s - n.y * Tr, a.push(new g(r, l));\n      }\n    }\n    ra(md, \"FillExtrusionBucket\", {\n      omit: [\"layers\", \"features\"]\n    }), ra(ud, \"PartData\"), ra(ld, \"FootprintSegment\"), ra(cd, \"BorderCentroidData\"), ra(dd, \"GroundEffect\");\n    const Id = new Oa({\n      visibility: new La(qa[\"layout_fill-extrusion\"].visibility),\n      \"fill-extrusion-edge-radius\": new La(qa[\"layout_fill-extrusion\"][\"fill-extrusion-edge-radius\"])\n    });\n    var kd = {\n      paint: new Oa({\n        \"fill-extrusion-opacity\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n        \"fill-extrusion-color\": new Fa(qa[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n        \"fill-extrusion-translate\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n        \"fill-extrusion-translate-anchor\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n        \"fill-extrusion-pattern\": new Fa(qa[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n        \"fill-extrusion-height\": new Fa(qa[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n        \"fill-extrusion-base\": new Fa(qa[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n        \"fill-extrusion-vertical-gradient\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"]),\n        \"fill-extrusion-ambient-occlusion-intensity\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-intensity\"]),\n        \"fill-extrusion-ambient-occlusion-radius\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-radius\"]),\n        \"fill-extrusion-ambient-occlusion-wall-radius\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-wall-radius\"]),\n        \"fill-extrusion-ambient-occlusion-ground-radius\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-ground-radius\"]),\n        \"fill-extrusion-ambient-occlusion-ground-attenuation\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-ground-attenuation\"]),\n        \"fill-extrusion-flood-light-color\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-color\"]),\n        \"fill-extrusion-flood-light-intensity\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-intensity\"]),\n        \"fill-extrusion-flood-light-wall-radius\": new Fa(qa[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-wall-radius\"]),\n        \"fill-extrusion-flood-light-ground-radius\": new Fa(qa[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-ground-radius\"]),\n        \"fill-extrusion-flood-light-ground-attenuation\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-ground-attenuation\"]),\n        \"fill-extrusion-vertical-scale\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-scale\"]),\n        \"fill-extrusion-rounded-roof\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-rounded-roof\"]),\n        \"fill-extrusion-cutoff-fade-range\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-cutoff-fade-range\"]),\n        \"fill-extrusion-emissive-strength\": new La(qa[\"paint_fill-extrusion\"][\"fill-extrusion-emissive-strength\"])\n      }),\n      layout: Id\n    };\n    class Pd extends g {\n      constructor(t, e, r) {\n        super(t, e), this.z = r;\n      }\n    }\n    function Ed(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n    function zd(t, e) {\n      if (1 === t.length) {\n        let r = 0;\n        const n = e[r++];\n        let i;\n        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n        for (; r < e.length; r++) {\n          const a = e[r],\n            s = t[0],\n            o = i.sub(n),\n            l = a.sub(n),\n            u = s.sub(n),\n            c = Ed(o, o),\n            h = Ed(o, l),\n            p = Ed(l, l),\n            f = Ed(u, o),\n            d = Ed(u, l),\n            m = c * p - h * h,\n            y = (p * f - h * d) / m,\n            g = (c * d - h * f) / m,\n            x = n.z * (1 - y - g) + i.z * y + a.z * g;\n          if (isFinite(x)) return x;\n        }\n        return 1 / 0;\n      }\n      {\n        let t = 1 / 0;\n        for (const r of e) t = Math.min(t, r.z);\n        return t;\n      }\n    }\n    function Td(t, e, r, n, i, a, s, o) {\n      const l = s * i.getElevationAt(t, e, !0, !0),\n        u = 0 !== a[0],\n        c = u ? 0 === a[1] ? s * (a[0] / 7 - 450) : s * function (t, e, r) {\n          const n = Math.floor(e[0] / 8),\n            i = Math.floor(e[1] / 8),\n            a = 10 * (e[0] - 8 * n),\n            s = 10 * (e[1] - 8 * i),\n            o = t.getElevationAt(n, i, !0, !0),\n            l = t.getMeterToDEM(r),\n            u = Math.floor(.5 * (a * l - 1)),\n            c = Math.floor(.5 * (s * l - 1)),\n            h = t.tileCoordToPixel(n, i),\n            p = 2 * u + 1,\n            f = 2 * c + 1,\n            d = function (t, e, r, n, i) {\n              return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];\n            }(t, h.x - u, h.y - c, p, f),\n            m = Math.abs(d[0] - d[1]),\n            y = Math.abs(d[2] - d[3]),\n            g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),\n            x = Math.min(.25, .5 * l * (m + y) / p),\n            v = Math.min(.25, .5 * l * g / f);\n          return o + Math.max(x * a, v * s);\n        }(i, a, o) : l;\n      return {\n        base: l + (0 === r) ? -1 : r,\n        top: u ? Math.max(c + n, l + r + 2) : l + n\n      };\n    }\n    const Bd = cs([{\n        name: \"a_pos_normal\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_data\",\n        components: 4,\n        type: \"Uint8\"\n      }, {\n        name: \"a_linesofar\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      {\n        members: Cd\n      } = Bd,\n      Rd = cs([{\n        name: \"a_packed\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      {\n        members: Dd\n      } = Rd;\n    class Vd {\n      constructor(t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.image = new vp({\n          width: t,\n          height: e\n        }), this.positions = {}, this.uploaded = !1;\n      }\n      getDash(t, e) {\n        const r = this.getKey(t, e);\n        return this.positions[r];\n      }\n      trim() {\n        const t = this.width,\n          e = this.height = R(this.nextRow);\n        this.image.resize({\n          width: t,\n          height: e\n        });\n      }\n      getKey(t, e) {\n        return t.join(\",\") + e;\n      }\n      getDashRanges(t, e, r) {\n        const n = [];\n        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,\n          a = t[0] * r,\n          s = !0;\n        n.push({\n          left: i,\n          right: a,\n          isDash: s,\n          zeroLength: 0 === t[0]\n        });\n        let o = t[0];\n        for (let e = 1; e < t.length; e++) {\n          s = !s;\n          const l = t[e];\n          i = o * r, o += l, a = o * r, n.push({\n            left: i,\n            right: a,\n            isDash: s,\n            zeroLength: 0 === l\n          });\n        }\n        return n;\n      }\n      addRoundDash(t, e, r) {\n        const n = e / 2;\n        for (let e = -r; e <= r; e++) {\n          const i = this.width * (this.nextRow + r + e);\n          let a = 0,\n            s = t[a];\n          for (let o = 0; o < this.width; o++) {\n            o / s.right > 1 && (s = t[++a]);\n            const l = Math.abs(o - s.left),\n              u = Math.abs(o - s.right),\n              c = Math.min(l, u);\n            let h;\n            const p = e / r * (n + 1);\n            if (s.isDash) {\n              const t = n - Math.abs(p);\n              h = Math.sqrt(c * c + t * t);\n            } else h = n - Math.sqrt(c * c + p * p);\n            this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));\n          }\n        }\n      }\n      addRegularDash(t, e) {\n        for (let e = t.length - 1; e >= 0; --e) {\n          const r = t[e],\n            n = t[e + 1];\n          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));\n        }\n        const r = t[0],\n          n = t[t.length - 1];\n        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);\n        const i = this.width * this.nextRow;\n        let a = 0,\n          s = t[a];\n        for (let r = 0; r < this.width; r++) {\n          r / s.right > 1 && (s = t[++a]);\n          const n = Math.abs(r - s.left),\n            o = Math.abs(r - s.right),\n            l = Math.min(n, o);\n          this.image.data[i + r] = Math.max(0, Math.min(255, (s.isDash ? l : -l) + e + 128));\n        }\n      }\n      addDash(t, e) {\n        const r = this.getKey(t, e);\n        if (this.positions[r]) return this.positions[r];\n        const n = \"round\" === e,\n          i = n ? 7 : 0,\n          a = 2 * i + 1;\n        if (this.nextRow + a > this.height) return j(\"LineAtlas out of space\"), null;\n        0 === t.length && t.push(1);\n        let s = 0;\n        for (let e = 0; e < t.length; e++) t[e] < 0 && (j(\"Negative value is found in line dasharray, replacing values with 0\"), t[e] = 0), s += t[e];\n        if (0 !== s) {\n          const r = this.width / s,\n            a = this.getDashRanges(t, this.width, r);\n          n ? this.addRoundDash(a, r, i) : this.addRegularDash(a, \"square\" === e ? .5 * r : 0);\n        }\n        const o = this.nextRow + i;\n        this.nextRow += a;\n        const l = {\n          tl: [o, i],\n          br: [s, 0]\n        };\n        return this.positions[r] = l, l;\n      }\n    }\n    ra(Vd, \"LineAtlas\");\n    const Ld = zf.types,\n      Fd = Math.cos(Math.PI / 180 * 37.5);\n    class Nd {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n          this.gradients[t.id] = {};\n        }), this.layoutVertexArray = new ys(), this.layoutVertexArray2 = new gs(), this.indexArray = new Es(), this.programConfigurations = new Vo(t.layers, t.zoom), this.segments = new eo(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n      populate(t, e, r, n) {\n        this.hasPattern = sf(\"line\", this.layers, e);\n        const i = this.layers[0].layout.get(\"line-sort-key\"),\n          a = [];\n        for (const {\n          feature: e,\n          id: s,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = Bl(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Pa(this.zoom), u, r)) continue;\n          const c = i ? i.evaluate(u, {}, r) : void 0,\n            h = {\n              id: s,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: t ? u.geometry : Tl(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          a.push(h);\n        }\n        i && a.sort((t, e) => t.sortKey - e.sortKey);\n        const {\n            lineAtlas: s,\n            featureIndex: o\n          } = e,\n          l = this.addConstantDashes(s);\n        for (const n of a) {\n          const {\n            geometry: i,\n            index: a,\n            sourceLayerIndex: u\n          } = n;\n          if (l && this.addFeatureDashes(n, s), this.hasPattern) {\n            const t = of(\"line\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, a, r, s.positions, e.availableImages, e.brightness);\n          o.insert(t[a].feature, i, a, u, this.index);\n        }\n      }\n      addConstantDashes(t) {\n        let e = !1;\n        for (const r of this.layers) {\n          const n = r.paint.get(\"line-dasharray\").value,\n            i = r.layout.get(\"line-cap\").value;\n          if (\"constant\" !== n.kind || \"constant\" !== i.kind) e = !0;else {\n            const e = i.value,\n              r = n.value;\n            if (!r) continue;\n            t.addDash(r, e);\n          }\n        }\n        return e;\n      }\n      addFeatureDashes(t, e) {\n        const r = this.zoom;\n        for (const n of this.layers) {\n          const i = n.paint.get(\"line-dasharray\").value,\n            a = n.layout.get(\"line-cap\").value;\n          if (\"constant\" === i.kind && \"constant\" === a.kind) continue;\n          let s, o;\n          if (\"constant\" === i.kind) {\n            if (s = i.value, !s) continue;\n          } else s = i.evaluate({\n            zoom: r\n          }, t);\n          o = \"constant\" === a.kind ? a.value : a.evaluate({\n            zoom: r\n          }, t), e.addDash(s, o), t.patterns[n.id] = e.getKey(s, o);\n        }\n      }\n      update(t, e, r, n, i) {\n        const a = 0 !== Object.keys(t).length;\n        a && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t, e, a ? this.stateDependentLayers : this.layers, r, n, i);\n      }\n      addFeatures(t, e, r, n, i, a) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n, a);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Dd)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Cd), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      lineFeatureClips(t) {\n        if (t.properties && t.properties.hasOwnProperty(\"mapbox_clip_start\") && t.properties.hasOwnProperty(\"mapbox_clip_end\")) return {\n          start: +t.properties.mapbox_clip_start,\n          end: +t.properties.mapbox_clip_end\n        };\n      }\n      addFeature(t, e, r, n, i, a, s) {\n        const o = this.layers[0].layout,\n          l = o.get(\"line-join\").evaluate(t, {}),\n          u = o.get(\"line-cap\").evaluate(t, {}),\n          c = o.get(\"line-miter-limit\"),\n          h = o.get(\"line-round-limit\");\n        this.lineClips = this.lineFeatureClips(t);\n        for (const r of e) this.addLine(r, t, l, u, c, h);\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, a, n, s);\n      }\n      addLine(t, e, r, n, i, a) {\n        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {\n          this.lineClipsArray.push(this.lineClips);\n          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n        }\n        const s = \"Polygon\" === Ld[e.type];\n        let o = t.length;\n        for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;\n        let l = 0;\n        for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;\n        if (o < (s ? 3 : 2)) return;\n        \"bevel\" === r && (i = 1.05);\n        const u = this.overscaling <= 16 ? 15 * Tr / (512 * this.overscaling) : 0,\n          c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);\n        let h, p, f, d, m;\n        this.e1 = this.e2 = -1, s && (h = t[o - 2], m = t[l].sub(h)._unit()._perp());\n        for (let e = l; e < o; e++) {\n          if (f = e === o - 1 ? s ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;\n          m && (d = m), h && (p = h), h = t[e], m = f ? f.sub(h)._unit()._perp() : d, d = d || m;\n          let y = d.add(m);\n          0 === y.x && 0 === y.y || y._unit();\n          const g = d.x * m.x + d.y * m.y,\n            x = y.x * m.x + y.y * m.y,\n            v = 0 !== x ? 1 / x : 1 / 0,\n            b = 2 * Math.sqrt(2 - 2 * x),\n            _ = x < Fd && p && f,\n            w = d.x * m.y - d.y * m.x > 0;\n          if (_ && e > l) {\n            const t = h.dist(p);\n            if (t > 2 * u) {\n              const e = h.sub(h.sub(p)._mult(u / t)._round());\n              this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;\n            }\n          }\n          const M = p && f;\n          let A = M ? r : s ? \"butt\" : n;\n          if (M && \"round\" === A && (v < a ? A = \"miter\" : v <= 2 && (A = \"fakeround\")), \"miter\" === A && v > i && (A = \"bevel\"), \"bevel\" === A && (v > 2 && (A = \"flipbevel\"), v < i && (A = \"miter\")), p && this.updateDistance(p, h), \"miter\" === A) y._mult(v), this.addCurrentVertex(h, y, 0, 0, c);else if (\"flipbevel\" === A) {\n            if (v > 100) y = m.mult(-1);else {\n              const t = v * d.add(m).mag() / d.sub(m).mag();\n              y._perp()._mult(t * (w ? -1 : 1));\n            }\n            this.addCurrentVertex(h, y, 0, 0, c), this.addCurrentVertex(h, y.mult(-1), 0, 0, c);\n          } else if (\"bevel\" === A || \"fakeround\" === A) {\n            const t = -Math.sqrt(v * v - 1),\n              e = w ? t : 0,\n              r = w ? 0 : t;\n            if (p && this.addCurrentVertex(h, d, e, r, c), \"fakeround\" === A) {\n              const t = Math.round(180 * b / Math.PI / 20);\n              for (let e = 1; e < t; e++) {\n                let r = e / t;\n                if (.5 !== r) {\n                  const t = r - .5;\n                  r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));\n                }\n                const n = m.sub(d)._mult(r)._add(d)._unit()._mult(w ? -1 : 1);\n                this.addHalfVertex(h, n.x, n.y, !1, w, 0, c);\n              }\n            }\n            f && this.addCurrentVertex(h, m, -e, -r, c);\n          } else if (\"butt\" === A) this.addCurrentVertex(h, y, 0, 0, c);else if (\"square\" === A) {\n            const t = p ? 1 : -1;\n            p || this.addCurrentVertex(h, y, t, t, c), this.addCurrentVertex(h, y, 0, 0, c), p && this.addCurrentVertex(h, y, t, t, c);\n          } else \"round\" === A && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, m, -1, -1, c, !0), this.addCurrentVertex(h, m, 0, 0, c)));\n          if (_ && e < o - 1) {\n            const t = h.dist(f);\n            if (t > 2 * u) {\n              const e = h.add(f.sub(h)._mult(u / t)._round());\n              this.updateDistance(h, e), this.addCurrentVertex(e, m, 0, 0, c), h = e;\n            }\n          }\n        }\n      }\n      addCurrentVertex(t, e, r, n, i, a = !1) {\n        const s = e.y * n - e.x,\n          o = -e.y - e.x * n;\n        this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, a, !1, r, i), this.addHalfVertex(t, s, o, a, !0, -n, i);\n      }\n      addHalfVertex({\n        x: t,\n        y: e\n      }, r, n, i, a, s, o) {\n        this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (a ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === s ? 0 : s < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);\n        const l = o.vertexLength++;\n        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), a ? this.e2 = l : this.e1 = l;\n      }\n      updateScaledDistance() {\n        if (this.lineClips) {\n          const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);\n          this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;\n        } else this.lineSoFar = this.distance;\n      }\n      updateDistance(t, e) {\n        this.distance += t.dist(e), this.updateScaledDistance();\n      }\n    }\n    ra(Nd, \"LineBucket\", {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const Od = new Oa({\n      \"line-cap\": new Fa(qa.layout_line[\"line-cap\"]),\n      \"line-join\": new Fa(qa.layout_line[\"line-join\"]),\n      \"line-miter-limit\": new La(qa.layout_line[\"line-miter-limit\"]),\n      \"line-round-limit\": new La(qa.layout_line[\"line-round-limit\"]),\n      \"line-sort-key\": new Fa(qa.layout_line[\"line-sort-key\"]),\n      visibility: new La(qa.layout_line.visibility)\n    });\n    var Ud = {\n      paint: new Oa({\n        \"line-opacity\": new Fa(qa.paint_line[\"line-opacity\"]),\n        \"line-color\": new Fa(qa.paint_line[\"line-color\"]),\n        \"line-translate\": new La(qa.paint_line[\"line-translate\"]),\n        \"line-translate-anchor\": new La(qa.paint_line[\"line-translate-anchor\"]),\n        \"line-width\": new Fa(qa.paint_line[\"line-width\"]),\n        \"line-gap-width\": new Fa(qa.paint_line[\"line-gap-width\"]),\n        \"line-offset\": new Fa(qa.paint_line[\"line-offset\"]),\n        \"line-blur\": new Fa(qa.paint_line[\"line-blur\"]),\n        \"line-dasharray\": new Fa(qa.paint_line[\"line-dasharray\"]),\n        \"line-pattern\": new Fa(qa.paint_line[\"line-pattern\"]),\n        \"line-gradient\": new Na(qa.paint_line[\"line-gradient\"]),\n        \"line-trim-offset\": new La(qa.paint_line[\"line-trim-offset\"]),\n        \"line-emissive-strength\": new La(qa.paint_line[\"line-emissive-strength\"]),\n        \"line-border-width\": new Fa(qa.paint_line[\"line-border-width\"]),\n        \"line-border-color\": new Fa(qa.paint_line[\"line-border-color\"])\n      }),\n      layout: Od\n    };\n    function jd(t, e, r) {\n      return e * (Tr / (t.tileSize * Math.pow(2, r - t.tileID.overscaledZ)));\n    }\n    function qd(t, e) {\n      return 1 / jd(t, 1, e.tileZoom);\n    }\n    function $d(t, e, r, n) {\n      return t.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get(\"line-translate\"), r.paint.get(\"line-translate-anchor\"));\n    }\n    const Gd = t => {\n      const e = [];\n      Yd(t) && e.push(\"RENDER_LINE_DASH\"), t.paint.get(\"line-gradient\") && e.push(\"RENDER_LINE_GRADIENT\");\n      const r = t.paint.get(\"line-trim-offset\");\n      return 0 === r[0] && 0 === r[1] || e.push(\"RENDER_LINE_TRIM_OFFSET\"), 0 !== t.paint.get(\"line-border-width\").constantOr(1) && e.push(\"RENDER_LINE_BORDER\"), e;\n    };\n    function Yd(t) {\n      const e = t.paint.get(\"line-dasharray\").value;\n      return e.value || \"constant\" !== e.kind;\n    }\n    const Xd = new class extends Fa {\n      possiblyEvaluate(t, e) {\n        return e = new Pa(Math.floor(e.zoom), {\n          now: e.now,\n          fadeDuration: e.fadeDuration,\n          transition: e.transition\n        }), super.possiblyEvaluate(t, e);\n      }\n      evaluate(t, e, r, n) {\n        return e = z({}, e, {\n          zoom: Math.floor(e.zoom)\n        }), super.evaluate(t, e, r, n);\n      }\n    }(Ud.paint.properties[\"line-width\"].specification);\n    function Zd(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n    Xd.useIntegerZoom = !0;\n    const Kd = cs([{\n        name: \"a_pos_offset\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_tex_size\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixeloffset\",\n        components: 4,\n        type: \"Int16\"\n      }], 4),\n      Hd = cs([{\n        name: \"a_globe_anchor\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_globe_normal\",\n        components: 3,\n        type: \"Float32\"\n      }], 4),\n      Wd = cs([{\n        name: \"a_projected_pos\",\n        components: 4,\n        type: \"Float32\"\n      }], 4);\n    cs([{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint32\"\n    }], 4);\n    const Jd = cs([{\n        name: \"a_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      Qd = cs([{\n        name: \"a_texb\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      tm = cs([{\n        name: \"a_placed\",\n        components: 2,\n        type: \"Uint8\"\n      }, {\n        name: \"a_shift\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      em = cs([{\n        name: \"a_size_scale\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_padding\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }]);\n    cs([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Float32\",\n      name: \"x1\"\n    }, {\n      type: \"Float32\",\n      name: \"y1\"\n    }, {\n      type: \"Float32\",\n      name: \"x2\"\n    }, {\n      type: \"Float32\",\n      name: \"y2\"\n    }, {\n      type: \"Int16\",\n      name: \"padding\"\n    }, {\n      type: \"Uint32\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"sourceLayerIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"bucketIndex\"\n    }]);\n    const rm = cs([{\n        name: \"a_pos\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_anchor_pos\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_extrude\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      nm = cs([{\n        name: \"a_pos_2f\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_radius\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_flags\",\n        components: 2,\n        type: \"Int16\"\n      }], 4);\n    cs([{\n      name: \"triangle\",\n      components: 3,\n      type: \"Uint16\"\n    }]), cs([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Uint16\",\n      name: \"glyphStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numGlyphs\"\n    }, {\n      type: \"Uint32\",\n      name: \"vertexStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineLength\"\n    }, {\n      type: \"Uint16\",\n      name: \"segment\"\n    }, {\n      type: \"Uint16\",\n      name: \"lowerSize\"\n    }, {\n      type: \"Uint16\",\n      name: \"upperSize\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetX\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetY\"\n    }, {\n      type: \"Uint8\",\n      name: \"writingMode\"\n    }, {\n      type: \"Uint8\",\n      name: \"placedOrientation\"\n    }, {\n      type: \"Uint8\",\n      name: \"hidden\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Int16\",\n      name: \"associatedIconIndex\"\n    }, {\n      type: \"Uint8\",\n      name: \"flipState\"\n    }]), cs([{\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"rightJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"centerJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"leftJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"placedIconSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedIconSymbolIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"key\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numHorizontalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"useRuntimeCollisionCircles\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Float32\",\n      components: 2,\n      name: \"textOffset\"\n    }, {\n      type: \"Float32\",\n      name: \"collisionCircleDiameter\"\n    }, {\n      type: \"Float32\",\n      name: \"zOffset\"\n    }, {\n      type: \"Uint8\",\n      name: \"hasIconTextFit\"\n    }]), cs([{\n      type: \"Float32\",\n      name: \"offsetX\"\n    }]), cs([{\n      type: \"Int16\",\n      name: \"x\"\n    }, {\n      type: \"Int16\",\n      name: \"y\"\n    }]);\n    var im = 24;\n    const am = 128;\n    function sm(t, e) {\n      const {\n        expression: r\n      } = e;\n      if (\"constant\" === r.kind) return {\n        kind: \"constant\",\n        layoutSize: r.evaluate(new Pa(t + 1))\n      };\n      if (\"source\" === r.kind) return {\n        kind: \"source\"\n      };\n      {\n        const {\n          zoomStops: e,\n          interpolationType: n\n        } = r;\n        let i = 0;\n        for (; i < e.length && e[i] <= t;) i++;\n        i = Math.max(0, i - 1);\n        let a = i;\n        for (; a < e.length && e[a] < t + 1;) a++;\n        a = Math.min(e.length - 1, a);\n        const s = e[i],\n          o = e[a];\n        return \"composite\" === r.kind ? {\n          kind: \"composite\",\n          minZoom: s,\n          maxZoom: o,\n          interpolationType: n\n        } : {\n          kind: \"camera\",\n          minZoom: s,\n          maxZoom: o,\n          minSize: r.evaluate(new Pa(s)),\n          maxSize: r.evaluate(new Pa(o)),\n          interpolationType: n\n        };\n      }\n    }\n    function om(t, {\n      uSize: e,\n      uSizeT: r\n    }, {\n      lowerSize: n,\n      upperSize: i\n    }) {\n      return \"source\" === t.kind ? n / am : \"composite\" === t.kind ? ue(n / am, i / am, r) : e;\n    }\n    function lm(t, e) {\n      let r = 0,\n        n = 0;\n      if (\"constant\" === t.kind) n = t.layoutSize;else if (\"source\" !== t.kind) {\n        const {\n            interpolationType: i,\n            minZoom: a,\n            maxZoom: s\n          } = t,\n          o = i ? I(Yn.interpolationFactor(i, e, a, s), 0, 1) : 0;\n        \"camera\" === t.kind ? n = ue(t.minSize, t.maxSize, o) : r = o;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n    var um = Object.freeze({\n      __proto__: null,\n      SIZE_PACK_FACTOR: am,\n      evaluateSizeForFeature: om,\n      evaluateSizeForZoom: lm,\n      getSizeData: sm\n    });\n    function cm(t, e, r) {\n      return t.sections.forEach(t => {\n        t.text = function (t, e, r) {\n          const n = e.layout.get(\"text-transform\").evaluate(r, {});\n          return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), ka.applyArabicShaping && (t = ka.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n    const hm = {\n      \"!\": \"ï¸\",\n      \"#\": \"ï¼\",\n      $: \"ï¼\",\n      \"%\": \"ï¼\",\n      \"&\": \"ï¼\",\n      \"(\": \"ï¸µ\",\n      \")\": \"ï¸¶\",\n      \"*\": \"ï¼\",\n      \"+\": \"ï¼\",\n      \",\": \"ï¸\",\n      \"-\": \"ï¸²\",\n      \".\": \"ã»\",\n      \"/\": \"ï¼\",\n      \":\": \"ï¸\",\n      \";\": \"ï¸\",\n      \"<\": \"ï¸¿\",\n      \"=\": \"ï¼\",\n      \">\": \"ï¹\",\n      \"?\": \"ï¸\",\n      \"@\": \"ï¼ \",\n      \"[\": \"ï¹\",\n      \"\\\\\": \"ï¼¼\",\n      \"]\": \"ï¹\",\n      \"^\": \"ï¼¾\",\n      _: \"ï¸³\",\n      \"`\": \"ï½\",\n      \"{\": \"ï¸·\",\n      \"|\": \"â\",\n      \"}\": \"ï¸¸\",\n      \"~\": \"ï½\",\n      \"Â¢\": \"ï¿ \",\n      \"Â£\": \"ï¿¡\",\n      \"Â¥\": \"ï¿¥\",\n      \"Â¦\": \"ï¿¤\",\n      \"Â¬\": \"ï¿¢\",\n      \"Â¯\": \"ï¿£\",\n      \"â\": \"ï¸²\",\n      \"â\": \"ï¸±\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â¦\": \"ï¸\",\n      \"â§\": \"ã»\",\n      \"â©\": \"ï¿¦\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸¿\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸½\",\n      \"ã\": \"ï¸¾\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸»\",\n      \"ã\": \"ï¸¼\",\n      \"ã\": \"ï¸¹\",\n      \"ã\": \"ï¸º\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸µ\",\n      \"ï¼\": \"ï¸¶\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸²\",\n      \"ï¼\": \"ã»\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸¿\",\n      \"ï¼\": \"ï¹\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼»\": \"ï¹\",\n      \"ï¼½\": \"ï¹\",\n      \"ï¼¿\": \"ï¸³\",\n      \"ï½\": \"ï¸·\",\n      \"ï½\": \"â\",\n      \"ï½\": \"ï¸¸\",\n      \"ï½\": \"ï¸µ\",\n      \"ï½ \": \"ï¸¶\",\n      \"ï½¡\": \"ï¸\",\n      \"ï½¢\": \"ï¹\",\n      \"ï½£\": \"ï¹\",\n      \"â\": \"â\",\n      \"â\": \"â\"\n    };\n    function pm(t) {\n      return \"ï¸¶\" === t || \"ï¹\" === t || \"ï¸¸\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸¾\" === t || \"ï¸¼\" === t || \"ï¸º\" === t || \"ï¸\" === t || \"ï¹\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï½\" === t || \"ï¿£\" === t || \"ï¸\" === t || \"ï¸\" === t;\n    }\n    function fm(t) {\n      return \"ï¸µ\" === t || \"ï¹\" === t || \"ï¸·\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸½\" === t || \"ï¸»\" === t || \"ï¸¹\" === t || \"ï¸\" === t || \"ï¸¿\" === t;\n    }\n    var dm = {\n        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n        read: function (t, e, r, n, i) {\n          var a,\n            s,\n            o = 8 * i - n - 1,\n            l = (1 << o) - 1,\n            u = l >> 1,\n            c = -7,\n            h = r ? i - 1 : 0,\n            p = r ? -1 : 1,\n            f = t[e + h];\n          for (h += p, a = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);\n          for (s = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);\n          if (0 === a) a = 1 - u;else {\n            if (a === l) return s ? NaN : 1 / 0 * (f ? -1 : 1);\n            s += Math.pow(2, n), a -= u;\n          }\n          return (f ? -1 : 1) * s * Math.pow(2, a - n);\n        },\n        write: function (t, e, r, n, i, a) {\n          var s,\n            o,\n            l,\n            u = 8 * a - i - 1,\n            c = (1 << u) - 1,\n            h = c >> 1,\n            p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n            f = n ? 0 : a - 1,\n            d = n ? 1 : -1,\n            m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n          for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = c) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (e += s + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (s++, l /= 2), s + h >= c ? (o = 0, s = c) : s + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), s += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);\n          for (s = s << i | o, u += i; u > 0; t[r + f] = 255 & s, f += d, s /= 256, u -= 8);\n          t[r + f - d] |= 128 * m;\n        }\n      },\n      mm = gm,\n      ym = dm;\n    function gm(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n    gm.Varint = 0, gm.Fixed64 = 1, gm.Bytes = 2, gm.Fixed32 = 5;\n    var xm = 4294967296,\n      vm = 1 / xm,\n      bm = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf8\");\n    function _m(t) {\n      return t.type === gm.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n    function wm(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n    function Mm(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n    }\n    function Am(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n    }\n    function Sm(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n    }\n    function Im(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n    }\n    function km(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n    }\n    function Pm(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n    }\n    function Em(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n    }\n    function zm(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n    }\n    function Tm(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n    }\n    function Bm(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n    }\n    function Cm(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n    function Rm(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n    function Dm(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n    gm.prototype = {\n      destroy: function () {\n        this.buf = null;\n      },\n      readFields: function (t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n            i = n >> 3,\n            a = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === a && this.skip(n);\n        }\n        return e;\n      },\n      readMessage: function (t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function () {\n        var t = Cm(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readSFixed32: function () {\n        var t = Dm(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function () {\n        var t = Cm(this.buf, this.pos) + Cm(this.buf, this.pos + 4) * xm;\n        return this.pos += 8, t;\n      },\n      readSFixed64: function () {\n        var t = Cm(this.buf, this.pos) + Dm(this.buf, this.pos + 4) * xm;\n        return this.pos += 8, t;\n      },\n      readFloat: function () {\n        var t = ym.read(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function () {\n        var t = ym.read(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function (t) {\n        var e,\n          r,\n          n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n            i,\n            a = r.buf;\n          if (n = (112 & (i = a[r.pos++])) >> 4, i < 128) return wm(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 3, i < 128) return wm(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 10, i < 128) return wm(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 17, i < 128) return wm(t, n, e);\n          if (n |= (127 & (i = a[r.pos++])) << 24, i < 128) return wm(t, n, e);\n          if (n |= (1 & (i = a[r.pos++])) << 31, i < 128) return wm(t, n, e);\n          throw new Error(\"Expected varint not more than 10 bytes\");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function () {\n        return this.readVarint(!0);\n      },\n      readSVarint: function () {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function () {\n        return Boolean(this.readVarint());\n      },\n      readString: function () {\n        var t = this.readVarint() + this.pos,\n          e = this.pos;\n        return this.pos = t, t - e >= 12 && bm ? function (t, e, r) {\n          return bm.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = \"\", i = e; i < r;) {\n            var a,\n              s,\n              o,\n              l = t[i],\n              u = null,\n              c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n            if (i + c > r) break;\n            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (a = t[i + 1])) && (u = (31 & l) << 6 | 63 & a) <= 127 && (u = null) : 3 === c ? (s = t[i + 2], 128 == (192 & (a = t[i + 1])) && 128 == (192 & s) && ((u = (15 & l) << 12 | (63 & a) << 6 | 63 & s) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (s = t[i + 2], o = t[i + 3], 128 == (192 & (a = t[i + 1])) && 128 == (192 & s) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & a) << 12 | (63 & s) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;\n          }\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function () {\n        var t = this.readVarint() + this.pos,\n          e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function (t, e) {\n        if (this.type !== gm.Bytes) return t.push(this.readVarint(e));\n        var r = _m(this);\n        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));\n        return t;\n      },\n      readPackedSVarint: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readSVarint());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSVarint());\n        return t;\n      },\n      readPackedBoolean: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readBoolean());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readBoolean());\n        return t;\n      },\n      readPackedFloat: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readFloat());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFloat());\n        return t;\n      },\n      readPackedDouble: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readDouble());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readDouble());\n        return t;\n      },\n      readPackedFixed32: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readFixed32());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFixed32());\n        return t;\n      },\n      readPackedSFixed32: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readSFixed32());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());\n        return t;\n      },\n      readPackedFixed64: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readFixed64());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFixed64());\n        return t;\n      },\n      readPackedSFixed64: function (t) {\n        if (this.type !== gm.Bytes) return t.push(this.readSFixed64());\n        var e = _m(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());\n        return t;\n      },\n      skip: function (t) {\n        var e = 7 & t;\n        if (e === gm.Varint) for (; this.buf[this.pos++] > 127;);else if (e === gm.Bytes) this.pos = this.readVarint() + this.pos;else if (e === gm.Fixed32) this.pos += 4;else {\n          if (e !== gm.Fixed64) throw new Error(\"Unimplemented type: \" + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function (t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function (t) {\n        for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function () {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function (t) {\n        this.realloc(4), Rm(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function (t) {\n        this.realloc(4), Rm(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function (t) {\n        this.realloc(8), Rm(this.buf, -1 & t, this.pos), Rm(this.buf, Math.floor(t * vm), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function (t) {\n        this.realloc(8), Rm(this.buf, -1 & t, this.pos), Rm(this.buf, Math.floor(t * vm), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function (t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function (t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function (t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function (t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n        this.pos = function (t, e, r) {\n          for (var n, i, a = 0; a < e.length; a++) {\n            if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || a + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n          return r;\n        }(this.buf, t, this.pos);\n        var r = this.pos - e;\n        r >= 128 && Mm(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function (t) {\n        this.realloc(4), ym.write(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function (t) {\n        this.realloc(8), ym.write(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function (t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n      },\n      writeRawMessage: function (t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && Mm(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function (t, e, r) {\n        this.writeTag(t, gm.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function (t, e) {\n        e.length && this.writeMessage(t, Am, e);\n      },\n      writePackedSVarint: function (t, e) {\n        e.length && this.writeMessage(t, Sm, e);\n      },\n      writePackedBoolean: function (t, e) {\n        e.length && this.writeMessage(t, Pm, e);\n      },\n      writePackedFloat: function (t, e) {\n        e.length && this.writeMessage(t, Im, e);\n      },\n      writePackedDouble: function (t, e) {\n        e.length && this.writeMessage(t, km, e);\n      },\n      writePackedFixed32: function (t, e) {\n        e.length && this.writeMessage(t, Em, e);\n      },\n      writePackedSFixed32: function (t, e) {\n        e.length && this.writeMessage(t, zm, e);\n      },\n      writePackedFixed64: function (t, e) {\n        e.length && this.writeMessage(t, Tm, e);\n      },\n      writePackedSFixed64: function (t, e) {\n        e.length && this.writeMessage(t, Bm, e);\n      },\n      writeBytesField: function (t, e) {\n        this.writeTag(t, gm.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function (t, e) {\n        this.writeTag(t, gm.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function (t, e) {\n        this.writeTag(t, gm.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function (t, e) {\n        this.writeTag(t, gm.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function (t, e) {\n        this.writeTag(t, gm.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function (t, e) {\n        this.writeTag(t, gm.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function (t, e) {\n        this.writeTag(t, gm.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function (t, e) {\n        this.writeTag(t, gm.Bytes), this.writeString(e);\n      },\n      writeFloatField: function (t, e) {\n        this.writeTag(t, gm.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function (t, e) {\n        this.writeTag(t, gm.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function (t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n    var Vm = h(mm);\n    const Lm = 3;\n    function Fm(t, e, r) {\n      e.glyphs = [], 1 === t && r.readMessage(Nm, e);\n    }\n    function Nm(t, e, r) {\n      if (3 === t) {\n        const {\n          id: t,\n          bitmap: n,\n          width: i,\n          height: a,\n          left: s,\n          top: o,\n          advance: l\n        } = r.readMessage(Om, {});\n        e.glyphs.push({\n          id: t,\n          bitmap: new vp({\n            width: i + 2 * Lm,\n            height: a + 2 * Lm\n          }, n),\n          metrics: {\n            width: i,\n            height: a,\n            left: s,\n            top: o,\n            advance: l\n          }\n        });\n      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());\n    }\n    function Om(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n    const Um = Lm,\n      jm = {\n        horizontal: 1,\n        vertical: 2,\n        horizontalOnly: 3\n      };\n    class qm {\n      constructor() {\n        this.scale = 1, this.fontStack = \"\", this.imageName = null;\n      }\n      static forText(t, e) {\n        const r = new qm();\n        return r.scale = t || 1, r.fontStack = e, r;\n      }\n      static forImage(t) {\n        const e = new qm();\n        return e.imageName = t, e;\n      }\n    }\n    class $m {\n      constructor() {\n        this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n      }\n      static fromFeature(t, e) {\n        const r = new $m();\n        for (let n = 0; n < t.sections.length; n++) {\n          const i = t.sections[n];\n          i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n        }\n        return r;\n      }\n      length() {\n        return this.text.length;\n      }\n      getSection(t) {\n        return this.sections[this.sectionIndex[t]];\n      }\n      getSections() {\n        return this.sections;\n      }\n      getSectionIndex(t) {\n        return this.sectionIndex[t];\n      }\n      getCodePoint(t) {\n        return this.text.codePointAt(t);\n      }\n      verticalizePunctuation(t) {\n        this.text = function (t, e) {\n          let r = \"\";\n          for (let n = 0; n < t.length; n++) {\n            const i = t.charCodeAt(n + 1) || null,\n              a = t.charCodeAt(n - 1) || null;\n            r += !e && (i && pa(i) && !hm[t[n + 1]] || a && pa(a) && !hm[t[n - 1]]) || !hm[t[n]] ? t[n] : hm[t[n]];\n          }\n          return r;\n        }(this.text, t);\n      }\n      trim() {\n        let t = 0;\n        for (let e = 0; e < this.text.length && Ym[this.text.charCodeAt(e)]; e++) t++;\n        let e = this.text.length;\n        for (let r = this.text.length - 1; r >= 0 && r >= t && Ym[this.text.charCodeAt(r)]; r--) e--;\n        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n      }\n      substring(t, e) {\n        const r = new $m();\n        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n      }\n      toString() {\n        return this.text;\n      }\n      getMaxScale() {\n        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n      }\n      addTextSection(t, e) {\n        this.text += t.text, this.sections.push(qm.forText(t.scale, t.fontStack || e));\n        const r = this.sections.length - 1;\n        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n      }\n      addImageSection(t) {\n        const e = t.image ? t.image.namePrimary : \"\";\n        if (0 === e.length) return void j(\"Can't add FormattedSection with an empty image.\");\n        const r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCodePoint(r), this.sections.push(qm.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : j(\"Reached maximum number of images 6401\");\n      }\n      getNextImageSectionCharCode() {\n        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n      }\n    }\n    function Gm(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d) {\n      const m = $m.fromFeature(t, i);\n      h === jm.vertical && m.verticalizePunctuation(p);\n      let y = [];\n      const g = function (t, e, r, n, i, a) {\n          if (!t) return [];\n          const s = [],\n            o = function (t, e, r, n, i, a) {\n              let s = 0;\n              for (let r = 0; r < t.length(); r++) {\n                const o = t.getSection(r);\n                s += Zm(t.getCodePoint(r), o, n, i, e, a);\n              }\n              return s / Math.max(1, Math.ceil(s / r));\n            }(t, e, r, n, i, a),\n            l = t.text.indexOf(\"â\") >= 0;\n          let u = 0;\n          for (let r = 0; r < t.length(); r++) {\n            const h = t.getSection(r),\n              p = t.getCodePoint(r);\n            if (Ym[p] || (u += Zm(p, h, n, i, e, a)), r < t.length() - 1) {\n              const e = !((c = p) < 11904 || !(oa[\"Bopomofo Extended\"](c) || oa.Bopomofo(c) || oa[\"CJK Compatibility Forms\"](c) || oa[\"CJK Compatibility Ideographs\"](c) || oa[\"CJK Compatibility\"](c) || oa[\"CJK Radicals Supplement\"](c) || oa[\"CJK Strokes\"](c) || oa[\"CJK Symbols and Punctuation\"](c) || oa[\"CJK Unified Ideographs Extension A\"](c) || oa[\"CJK Unified Ideographs\"](c) || oa[\"Enclosed CJK Letters and Months\"](c) || oa[\"Halfwidth and Fullwidth Forms\"](c) || oa.Hiragana(c) || oa[\"Ideographic Description Characters\"](c) || oa[\"Kangxi Radicals\"](c) || oa[\"Katakana Phonetic Extensions\"](c) || oa.Katakana(c) || oa[\"Vertical Forms\"](c) || oa[\"Yi Radicals\"](c) || oa[\"Yi Syllables\"](c)));\n              (Xm[p] || e || h.imageName) && s.push(Wm(r + 1, u, o, s, Hm(p, t.getCodePoint(r + 1), e && l), !1));\n            }\n          }\n          var c;\n          return Jm(Wm(t.length(), u, o, s, 0, !0));\n        }(m, u, a, e, n, f),\n        {\n          processBidirectionalText: x,\n          processStyledBidirectionalText: v\n        } = ka;\n      if (x && 1 === m.sections.length) {\n        const t = x(m.toString(), g);\n        for (const e of t) {\n          const t = new $m();\n          t.text = e, t.sections = m.sections;\n          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n          y.push(t);\n        }\n      } else if (v) {\n        const t = v(m.text, m.sectionIndex, g);\n        for (const e of t) {\n          const t = new $m();\n          t.text = e[0], t.sectionIndex = e[1], t.sections = m.sections, y.push(t);\n        }\n      } else y = function (t, e) {\n        const r = [],\n          n = t.text;\n        let i = 0;\n        for (const n of e) r.push(t.substring(i, n)), i = n;\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(m, g);\n      const b = [],\n        _ = {\n          positionedLines: b,\n          text: m.toString(),\n          top: c[1],\n          bottom: c[1],\n          left: c[0],\n          right: c[0],\n          writingMode: h,\n          iconsInText: !1,\n          verticalizable: !1,\n          hasBaseline: !1\n        };\n      return function (t, e, r, n, i, a, s, o, l, u, c, h) {\n        let p = 0,\n          f = 0,\n          d = 0;\n        const m = \"right\" === o ? 1 : \"left\" === o ? 0 : .5;\n        let y = !1;\n        for (const t of i) {\n          const r = t.getSections();\n          for (const t of r) {\n            if (t.imageName) continue;\n            const r = e[t.fontStack];\n            if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;\n          }\n          if (!y) break;\n        }\n        let g = 0;\n        for (const s of i) {\n          s.trim();\n          const i = s.getMaxScale(),\n            o = (i - 1) * im,\n            v = {\n              positionedGlyphs: [],\n              lineOffset: 0\n            };\n          t.positionedLines[g] = v;\n          const b = v.positionedGlyphs;\n          let _ = 0;\n          if (!s.length()) {\n            f += a, ++g;\n            continue;\n          }\n          let w = 0,\n            M = 0;\n          for (let a = 0; a < s.length(); a++) {\n            const o = s.getSection(a),\n              d = s.getSectionIndex(a),\n              m = s.getCodePoint(a);\n            let g = o.scale,\n              v = null,\n              A = null,\n              S = null,\n              I = im,\n              k = 0;\n            const P = !(l === jm.horizontal || !c && !ha(m) || c && (Ym[m] || (x = m, oa.Arabic(x) || oa[\"Arabic Supplement\"](x) || oa[\"Arabic Extended-A\"](x) || oa[\"Arabic Presentation Forms-A\"](x) || oa[\"Arabic Presentation Forms-B\"](x))));\n            if (o.imageName) {\n              const e = n[o.imageName];\n              if (!e) continue;\n              S = o.imageName, t.iconsInText = t.iconsInText || !0, A = e.paddedRect;\n              const r = e.displaySize;\n              g = g * im / h, v = {\n                width: r[0],\n                height: r[1],\n                left: 0,\n                top: -Um,\n                advance: P ? r[1] : r[0],\n                localGlyph: !1\n              }, k = y ? -v.height * g : i * im - 17 - r[1] * g, I = v.advance;\n              const a = (P ? r[0] : r[1]) * g - im * i;\n              a > 0 && a > _ && (_ = a);\n            } else {\n              const t = r[o.fontStack];\n              if (!t) continue;\n              t[m] && (A = t[m]);\n              const n = e[o.fontStack];\n              if (!n) continue;\n              const a = n.glyphs[m];\n              if (!a) continue;\n              if (v = a.metrics, I = 8203 !== m ? im : 0, y) {\n                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,\n                  e = void 0 !== n.descender ? Math.abs(n.descender) : 0,\n                  r = (t + e) * g;\n                w < r && (w = r, M = (t - e) / 2 * g), k = -t * g;\n              } else k = (i - g) * im - 17;\n            }\n            P ? (t.verticalizable = !0, b.push({\n              glyph: m,\n              imageName: S,\n              x: p,\n              y: f + k,\n              vertical: P,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: d,\n              metrics: v,\n              rect: A\n            }), p += I * g + u) : (b.push({\n              glyph: m,\n              imageName: S,\n              x: p,\n              y: f + k,\n              vertical: P,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: d,\n              metrics: v,\n              rect: A\n            }), p += v.advance * g + u);\n          }\n          0 !== b.length && (d = Math.max(p - u, d), y ? ty(b, m, _, M, a * i / 2) : ty(b, m, _, 0, a / 2)), p = 0;\n          const A = a * i + _;\n          v.lineOffset = Math.max(_, o), f += A, ++g;\n        }\n        var x;\n        const v = f,\n          {\n            horizontalAlign: b,\n            verticalAlign: _\n          } = Qm(s);\n        (function (t, e, r, n, i, a) {\n          const s = (e - r) * i,\n            o = -a * n;\n          for (const e of t) for (const t of e.positionedGlyphs) t.x += s, t.y += o;\n        })(t.positionedLines, m, b, _, d, v), t.top += -_ * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d, t.hasBaseline = y;\n      }(_, e, r, n, y, s, o, l, h, u, p, d), !function (t) {\n        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n        return !0;\n      }(b) && _;\n    }\n    const Ym = {\n        9: !0,\n        10: !0,\n        11: !0,\n        12: !0,\n        13: !0,\n        32: !0\n      },\n      Xm = {\n        10: !0,\n        32: !0,\n        38: !0,\n        40: !0,\n        41: !0,\n        43: !0,\n        45: !0,\n        47: !0,\n        173: !0,\n        183: !0,\n        8203: !0,\n        8208: !0,\n        8211: !0,\n        8231: !0\n      };\n    function Zm(t, e, r, n, i, a) {\n      if (e.imageName) {\n        const t = n[e.imageName];\n        return t ? t.displaySize[0] * e.scale * im / a + i : 0;\n      }\n      {\n        const n = r[e.fontStack],\n          a = n && n.glyphs[t];\n        return a ? a.metrics.advance * e.scale + i : 0;\n      }\n    }\n    function Km(t, e, r, n) {\n      const i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n    function Hm(t, e, r) {\n      let n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n    function Wm(t, e, r, n, i, a) {\n      let s = null,\n        o = Km(e, r, i, a);\n      for (const t of n) {\n        const n = Km(e - t.x, r, i, a) + t.badness;\n        n <= o && (s = t, o = n);\n      }\n      return {\n        index: t,\n        x: e,\n        priorBreak: s,\n        badness: o\n      };\n    }\n    function Jm(t) {\n      return t ? Jm(t.priorBreak).concat(t.index) : [];\n    }\n    function Qm(t) {\n      let e = .5,\n        r = .5;\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          e = 1;\n          break;\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          e = 0;\n      }\n      switch (t) {\n        case \"bottom\":\n        case \"bottom-right\":\n        case \"bottom-left\":\n          r = 1;\n          break;\n        case \"top\":\n        case \"top-right\":\n        case \"top-left\":\n          r = 0;\n      }\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n    function ty(t, e, r, n, i) {\n      if (!(e || r || n || i)) return;\n      const a = t.length - 1,\n        s = t[a],\n        o = (s.x + s.metrics.advance * s.scale) * e;\n      for (let e = 0; e <= a; e++) t[e].x -= o, t[e].y += r + n + i;\n    }\n    function ey(t, e, r, n) {\n      const {\n          horizontalAlign: i,\n          verticalAlign: a\n        } = Qm(n),\n        s = r[0] - t.displaySize[0] * i,\n        o = r[1] - t.displaySize[1] * a;\n      return {\n        imagePrimary: t,\n        imageSecondary: e,\n        top: o,\n        bottom: o + t.displaySize[1],\n        left: s,\n        right: s + t.displaySize[0]\n      };\n    }\n    function ry(t, e, r, n, i, a) {\n      const s = t.imagePrimary;\n      let o;\n      if (s.content) {\n        const t = s.content,\n          e = s.pixelRatio || 1;\n        o = [t[0] / e, t[1] / e, s.displaySize[0] - t[2] / e, s.displaySize[1] - t[3] / e];\n      }\n      const l = e.left * a,\n        u = e.right * a;\n      let c, h, p, f;\n      \"width\" === r || \"both\" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - s.displaySize[0]) / 2, h = f + s.displaySize[0]);\n      const d = e.top * a,\n        m = e.bottom * a;\n      return \"height\" === r || \"both\" === r ? (c = i[1] + d - n[0], p = i[1] + m + n[2]) : (c = i[1] + (d + m - s.displaySize[1]) / 2, p = c + s.displaySize[1]), {\n        imagePrimary: s,\n        imageSecondary: void 0,\n        top: c,\n        right: h,\n        bottom: p,\n        left: f,\n        collisionPadding: o\n      };\n    }\n    class ny extends g {\n      constructor(t, e, r, n, i) {\n        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);\n      }\n      clone() {\n        return new ny(this.x, this.y, this.z, this.angle, this.segment);\n      }\n    }\n    function iy(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      let a = e,\n        s = e.segment + 1,\n        o = 0;\n      for (; o > -r / 2;) {\n        if (s--, s < 0) return !1;\n        o -= t[s].dist(a), a = t[s];\n      }\n      o += t[s].dist(t[s + 1]), s++;\n      const l = [];\n      let u = 0;\n      for (; o < r / 2;) {\n        const e = t[s],\n          r = t[s + 1];\n        if (!r) return !1;\n        let a = t[s - 1].angleTo(e) - e.angleTo(r);\n        for (a = Math.abs((a + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n          distance: o,\n          angleDelta: a\n        }), u += a; o - l[0].distance > n;) u -= l.shift().angleDelta;\n        if (u > i) return !1;\n        s++, o += e.dist(r);\n      }\n      return !0;\n    }\n    function ay(t) {\n      let e = 0;\n      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n      return e;\n    }\n    function sy(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n    function oy(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n    function ly(t, e, r, n, i, a) {\n      const s = sy(r, i, a),\n        o = oy(r, n) * a;\n      let l = 0;\n      const u = ay(t) / 2;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1],\n          a = n.dist(i);\n        if (l + a > u) {\n          const c = (u - l) / a,\n            h = ue(n.x, i.x, c),\n            p = ue(n.y, i.y, c),\n            f = new ny(h, p, 0, i.angleTo(n), r);\n          return !s || iy(t, f, o, s, e) ? f : void 0;\n        }\n        l += a;\n      }\n    }\n    function uy(t, e, r, n, i, a, s, o, l) {\n      const u = sy(n, a, s),\n        c = oy(n, i),\n        h = c * s,\n        p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n      return e - h < e / 4 && (e = h + e / 4), cy(t, p ? e / 2 * o % e : (c / 2 + 2 * a) * s * o % e, e, u, r, h, p, !1, l);\n    }\n    function cy(t, e, r, n, i, a, s, o, l) {\n      const u = a / 2,\n        c = ay(t);\n      let h = 0,\n        p = e - r,\n        f = [];\n      for (let e = 0; e < t.length - 1; e++) {\n        const s = t[e],\n          o = t[e + 1],\n          d = s.dist(o),\n          m = o.angleTo(s);\n        for (; p + r < h + d;) {\n          p += r;\n          const y = (p - h) / d,\n            g = ue(s.x, o.x, y),\n            x = ue(s.y, o.y, y);\n          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {\n            const r = new ny(g, x, 0, m, e);\n            n && !iy(t, r, a, n, i) || f.push(r);\n          }\n        }\n        h += d;\n      }\n      return o || f.length || s || (f = cy(t, h / 2, r, n, i, a, s, !0, l)), f;\n    }\n    function hy(t, e, r, n, i) {\n      const a = [];\n      for (let s = 0; s < t.length; s++) {\n        const o = t[s];\n        let l;\n        for (let t = 0; t < o.length - 1; t++) {\n          let s = o[t],\n            u = o[t + 1];\n          s.x < e && u.x < e || (s.x < e ? s = new g(e, s.y + (e - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x < e && (u = new g(e, s.y + (e - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y < r && u.y < r || (s.y < r ? s = new g(s.x + (r - s.y) / (u.y - s.y) * (u.x - s.x), r)._round() : u.y < r && (u = new g(s.x + (r - s.y) / (u.y - s.y) * (u.x - s.x), r)._round()), s.x >= n && u.x >= n || (s.x >= n ? s = new g(n, s.y + (n - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x >= n && (u = new g(n, s.y + (n - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y >= i && u.y >= i || (s.y >= i ? s = new g(s.x + (i - s.y) / (u.y - s.y) * (u.x - s.x), i)._round() : u.y >= i && (u = new g(s.x + (i - s.y) / (u.y - s.y) * (u.x - s.x), i)._round()), l && s.equals(l[l.length - 1]) || (l = [s], a.push(l)), l.push(u)))));\n        }\n      }\n      return a;\n    }\n    function py(t) {\n      let e = 0,\n        r = 0;\n      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n      t.sort((t, e) => e.h - t.h);\n      const n = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }];\n      let i = 0,\n        a = 0;\n      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n        const r = n[t];\n        if (!(e.w > r.w || e.h > r.h)) {\n          if (e.x = r.x, e.y = r.y, a = Math.max(a, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n            const e = n.pop();\n            t < n.length && (n[t] = e);\n          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n            x: r.x + e.w,\n            y: r.y,\n            w: r.w - e.w,\n            h: e.h\n          }), r.y += e.h, r.h -= e.h);\n          break;\n        }\n      }\n      return {\n        w: i,\n        h: a,\n        fill: e / (i * a) || 0\n      };\n    }\n    ra(ny, \"Anchor\");\n    const fy = 1;\n    class dy {\n      constructor(t, {\n        pixelRatio: e,\n        version: r,\n        stretchX: n,\n        stretchY: i,\n        content: a\n      }) {\n        this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = a, this.version = r;\n      }\n      get tl() {\n        return [this.paddedRect.x + fy, this.paddedRect.y + fy];\n      }\n      get br() {\n        return [this.paddedRect.x + this.paddedRect.w - fy, this.paddedRect.y + this.paddedRect.h - fy];\n      }\n      get displaySize() {\n        return [(this.paddedRect.w - 2 * fy) / this.pixelRatio, (this.paddedRect.h - 2 * fy) / this.pixelRatio];\n      }\n    }\n    class my {\n      constructor(t, e) {\n        const r = {},\n          n = {};\n        this.haveRenderCallbacks = [];\n        const i = [];\n        this.addImages(t, r, i), this.addImages(e, n, i);\n        const {\n            w: a,\n            h: s\n          } = py(i),\n          o = new bp({\n            width: a || 1,\n            height: s || 1\n          });\n        for (const e in t) {\n          const n = t[e],\n            i = r[e].paddedRect;\n          bp.copy(n.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: i.x + fy,\n            y: i.y + fy\n          }, n.data, n.sdf);\n        }\n        for (const t in e) {\n          const r = e[t],\n            i = n[t].paddedRect,\n            a = i.x + fy,\n            s = i.y + fy,\n            l = r.data.width,\n            u = r.data.height;\n          bp.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: a,\n            y: s\n          }, r.data), bp.copy(r.data, o, {\n            x: 0,\n            y: u - 1\n          }, {\n            x: a,\n            y: s - 1\n          }, {\n            width: l,\n            height: 1\n          }), bp.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: a,\n            y: s + u\n          }, {\n            width: l,\n            height: 1\n          }), bp.copy(r.data, o, {\n            x: l - 1,\n            y: 0\n          }, {\n            x: a - 1,\n            y: s\n          }, {\n            width: 1,\n            height: u\n          }), bp.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: a + l,\n            y: s\n          }, {\n            width: 1,\n            height: u\n          });\n        }\n        this.image = o, this.iconPositions = r, this.patternPositions = n;\n      }\n      addImages(t, e, r) {\n        for (const n in t) {\n          const i = t[n],\n            a = {\n              x: 0,\n              y: 0,\n              w: i.data.width + 2 * fy,\n              h: i.data.height + 2 * fy\n            };\n          r.push(a), e[n] = new dy(a, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n        }\n      }\n      patchUpdatedImages(t, e, r) {\n        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e, r)), t.dispatchRenderCallbacks(this.haveRenderCallbacks, r);\n        for (const n in t.getUpdatedImages(r)) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n, r), e), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n, r), e);\n      }\n      patchUpdatedImage(t, e, r) {\n        if (!t || !e) return;\n        if (t.version === e.version) return;\n        t.version = e.version;\n        const [n, i] = t.tl,\n          a = !!Object.keys(this.patternPositions).length;\n        r.update(e.data, {\n          useMipmap: a\n        }, {\n          x: n,\n          y: i\n        });\n      }\n    }\n    ra(dy, \"ImagePosition\"), ra(my, \"ImageAtlas\");\n    const yy = 1e20;\n    function gy(t, e, r, n, i, a, s, o, l) {\n      for (let u = e; u < e + n; u++) xy(t, r * a + u, a, i, s, o, l);\n      for (let u = r; u < r + i; u++) xy(t, u * a + e, 1, n, s, o, l);\n    }\n    function xy(t, e, r, n, i, a, s) {\n      a[0] = 0, s[0] = -yy, s[1] = yy, i[0] = t[e];\n      for (let o = 1, l = 0, u = 0; o < n; o++) {\n        i[o] = t[e + o * r];\n        const n = o * o;\n        do {\n          const t = a[l];\n          u = (i[o] - i[t] + n - t * t) / (o - t) / 2;\n        } while (u <= s[l] && --l > -1);\n        l++, a[l] = o, s[l] = u, s[l + 1] = yy;\n      }\n      for (let o = 0, l = 0; o < n; o++) {\n        for (; s[l + 1] < o;) l++;\n        const n = a[l],\n          u = o - n;\n        t[e + o * r] = i[n] + u * u;\n      }\n    }\n    const vy = 2,\n      by = {\n        none: 0,\n        ideographs: 1,\n        all: 2\n      };\n    class _y {\n      constructor(t, e, r) {\n        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.urls = {}, this.entries = {}, this.localGlyphs = {\n          200: {},\n          400: {},\n          500: {},\n          900: {}\n        };\n      }\n      setURL(t, e) {\n        this.urls[e] = t;\n      }\n      getGlyphs(t, e, r) {\n        const i = [],\n          a = this.urls[e] || n.GLYPHS_URL;\n        for (const e in t) for (const r of t[e]) i.push({\n          stack: e,\n          id: r\n        });\n        E(i, ({\n          stack: t,\n          id: e\n        }, r) => {\n          let n = this.entries[t];\n          n || (n = this.entries[t] = {\n            glyphs: {},\n            requests: {},\n            ranges: {},\n            ascender: void 0,\n            descender: void 0\n          });\n          let i = n.glyphs[e];\n          if (void 0 !== i) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          if (i = this._tinySDF(n, t, e), i) return n.glyphs[e] = i, void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          const s = Math.floor(e / 256);\n          if (256 * s > 65535) return void r(new Error(\"glyphs > 65535 not supported\"));\n          if (n.ranges[s]) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          let o = n.requests[s];\n          o || (o = n.requests[s] = [], _y.loadGlyphRange(t, s, a, this.requestManager, (t, e) => {\n            if (e) {\n              n.ascender = e.ascender, n.descender = e.descender;\n              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);\n              n.ranges[s] = !0;\n            }\n            for (const r of o) r(t, e);\n            delete n.requests[s];\n          })), o.push((n, i) => {\n            n ? r(n) : i && r(null, {\n              stack: t,\n              id: e,\n              glyph: i.glyphs[e] || null\n            });\n          });\n        }, (t, e) => {\n          if (t) r(t);else if (e) {\n            const t = {};\n            for (const {\n              stack: r,\n              id: n,\n              glyph: i\n            } of e) void 0 === t[r] && (t[r] = {}), void 0 === t[r].glyphs && (t[r].glyphs = {}), t[r].glyphs[n] = i && {\n              id: i.id,\n              bitmap: i.bitmap.clone(),\n              metrics: i.metrics\n            }, t[r].ascender = this.entries[r].ascender, t[r].descender = this.entries[r].descender;\n            r(null, t);\n          }\n        });\n      }\n      _doesCharSupportLocalGlyph(t) {\n        return this.localGlyphMode !== by.none && (this.localGlyphMode === by.all ? !!this.localFontFamily : !!this.localFontFamily && (oa[\"CJK Unified Ideographs\"](t) || oa[\"Hangul Syllables\"](t) || oa.Hiragana(t) || oa.Katakana(t) || oa[\"CJK Symbols and Punctuation\"](t) || oa[\"CJK Unified Ideographs Extension A\"](t) || oa[\"CJK Unified Ideographs Extension B\"](t)));\n      }\n      _tinySDF(t, e, r) {\n        const n = this.localFontFamily;\n        if (!n || !this._doesCharSupportLocalGlyph(r)) return;\n        let i = t.tinySDF;\n        if (!i) {\n          let r = \"400\";\n          /bold/i.test(e) ? r = \"900\" : /medium/i.test(e) ? r = \"500\" : /light/i.test(e) && (r = \"200\"), i = t.tinySDF = new _y.TinySDF({\n            fontFamily: n,\n            fontWeight: r,\n            fontSize: 24 * vy,\n            buffer: 3 * vy,\n            radius: 8 * vy\n          }), i.fontWeight = r;\n        }\n        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];\n        const a = String.fromCodePoint(r),\n          {\n            data: s,\n            width: o,\n            height: l,\n            glyphWidth: u,\n            glyphHeight: c,\n            glyphLeft: h,\n            glyphTop: p,\n            glyphAdvance: f\n          } = i.draw(a);\n        return this.localGlyphs[i.fontWeight][r] = {\n          id: r,\n          bitmap: new vp({\n            width: o,\n            height: l\n          }, s),\n          metrics: {\n            width: u / vy,\n            height: c / vy,\n            left: h / vy,\n            top: p / vy - 27,\n            advance: f / vy,\n            localGlyph: !0\n          }\n        };\n      }\n    }\n    _y.loadGlyphRange = function (t, e, r, n, i) {\n      const a = 256 * e,\n        s = a + 255,\n        o = n.transformRequest(n.normalizeGlyphsURL(r).replace(\"{fontstack}\", t).replace(\"{range}\", `${a}-${s}`), At.Glyphs);\n      Pt(o, (t, e) => {\n        if (t) i(t);else if (e) {\n          const t = {},\n            r = function (t) {\n              return new Vm(t).readFields(Fm, {});\n            }(e);\n          for (const e of r.glyphs) t[e.id] = e;\n          i(null, {\n            glyphs: t,\n            ascender: r.ascender,\n            descender: r.descender\n          });\n        }\n      });\n    }, _y.TinySDF = class {\n      constructor({\n        fontSize: t = 24,\n        buffer: e = 3,\n        radius: r = 8,\n        cutoff: n = .25,\n        fontFamily: i = \"sans-serif\",\n        fontWeight: a = \"normal\",\n        fontStyle: s = \"normal\"\n      } = {}) {\n        this.buffer = e, this.cutoff = n, this.radius = r;\n        const o = this.size = t + 4 * e,\n          l = this._createCanvas(o),\n          u = this.ctx = l.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n        u.font = `${s} ${a} ${t}px ${i}`, u.textBaseline = \"alphabetic\", u.textAlign = \"left\", u.fillStyle = \"black\", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);\n      }\n      _createCanvas(t) {\n        const e = document.createElement(\"canvas\");\n        return e.width = e.height = t, e;\n      }\n      draw(t) {\n        const {\n            width: e,\n            actualBoundingBoxAscent: r,\n            actualBoundingBoxDescent: n,\n            actualBoundingBoxLeft: i,\n            actualBoundingBoxRight: a\n          } = this.ctx.measureText(t),\n          s = Math.ceil(r),\n          o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - i))),\n          l = Math.min(this.size - this.buffer, s + Math.ceil(n)),\n          u = o + 2 * this.buffer,\n          c = l + 2 * this.buffer,\n          h = Math.max(u * c, 0),\n          p = new Uint8ClampedArray(h),\n          f = {\n            data: p,\n            width: u,\n            height: c,\n            glyphWidth: o,\n            glyphHeight: l,\n            glyphTop: s,\n            glyphLeft: 0,\n            glyphAdvance: e\n          };\n        if (0 === o || 0 === l) return f;\n        const {\n          ctx: d,\n          buffer: m,\n          gridInner: y,\n          gridOuter: g\n        } = this;\n        d.clearRect(m, m, o, l), d.fillText(t, m, m + s);\n        const x = d.getImageData(m, m, o, l);\n        g.fill(yy, 0, h), y.fill(0, 0, h);\n        for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {\n          const r = x.data[4 * (t * o + e) + 3] / 255;\n          if (0 === r) continue;\n          const n = (t + m) * u + e + m;\n          if (1 === r) g[n] = 0, y[n] = yy;else {\n            const t = .5 - r;\n            g[n] = t > 0 ? t * t : 0, y[n] = t < 0 ? t * t : 0;\n          }\n        }\n        gy(g, 0, 0, u, c, u, this.f, this.v, this.z), gy(y, m, m, o, l, u, this.f, this.v, this.z);\n        for (let t = 0; t < h; t++) {\n          const e = Math.sqrt(g[t]) - Math.sqrt(y[t]);\n          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));\n        }\n        return f;\n      }\n    };\n    const wy = fy;\n    function My(t, e, r, n) {\n      const i = [],\n        a = t.imagePrimary,\n        s = a.pixelRatio,\n        o = a.paddedRect.w - 2 * wy,\n        l = a.paddedRect.h - 2 * wy,\n        u = t.right - t.left,\n        c = t.bottom - t.top,\n        h = a.stretchX || [[0, o]],\n        p = a.stretchY || [[0, l]],\n        f = (t, e) => t + e[1] - e[0],\n        d = h.reduce(f, 0),\n        m = p.reduce(f, 0),\n        y = o - d,\n        x = l - m;\n      let v = 0,\n        b = d,\n        _ = 0,\n        w = m,\n        M = 0,\n        A = y,\n        S = 0,\n        I = x;\n      if (a.content && n) {\n        const t = a.content;\n        v = Ay(h, 0, t[0]), _ = Ay(p, 0, t[1]), b = Ay(h, t[0], t[2]), w = Ay(p, t[1], t[3]), M = t[0] - v, S = t[1] - _, A = t[2] - t[0] - b, I = t[3] - t[1] - w;\n      }\n      const k = (n, i, o, l) => {\n        const h = Iy(n.stretch - v, b, u, t.left),\n          p = ky(n.fixed - M, A, n.stretch, d),\n          f = Iy(i.stretch - _, w, c, t.top),\n          y = ky(i.fixed - S, I, i.stretch, m),\n          x = Iy(o.stretch - v, b, u, t.left),\n          k = ky(o.fixed - M, A, o.stretch, d),\n          P = Iy(l.stretch - _, w, c, t.top),\n          E = ky(l.fixed - S, I, l.stretch, m),\n          z = new g(h, f),\n          T = new g(x, f),\n          B = new g(x, P),\n          C = new g(h, P),\n          R = new g(p / s, y / s),\n          D = new g(k / s, E / s),\n          V = e * Math.PI / 180;\n        if (V) {\n          const t = Math.sin(V),\n            e = Math.cos(V),\n            r = [e, -t, t, e];\n          z._matMult(r), T._matMult(r), C._matMult(r), B._matMult(r);\n        }\n        const L = n.stretch + n.fixed,\n          F = o.stretch + o.fixed,\n          N = i.stretch + i.fixed,\n          O = l.stretch + l.fixed,\n          U = t.imageSecondary;\n        return {\n          tl: z,\n          tr: T,\n          bl: C,\n          br: B,\n          texPrimary: {\n            x: a.paddedRect.x + wy + L,\n            y: a.paddedRect.y + wy + N,\n            w: F - L,\n            h: O - N\n          },\n          texSecondary: U ? {\n            x: U.paddedRect.x + wy + L,\n            y: U.paddedRect.y + wy + N,\n            w: F - L,\n            h: O - N\n          } : void 0,\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: R,\n          pixelOffsetBR: D,\n          minFontScaleX: A / s / u,\n          minFontScaleY: I / s / c,\n          isSDF: r\n        };\n      };\n      if (n && (a.stretchX || a.stretchY)) {\n        const t = Sy(h, y, d),\n          e = Sy(p, x, m);\n        for (let r = 0; r < t.length - 1; r++) {\n          const n = t[r],\n            a = t[r + 1];\n          for (let t = 0; t < e.length - 1; t++) i.push(k(n, e[t], a, e[t + 1]));\n        }\n      } else i.push(k({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: o + 1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }));\n      return i;\n    }\n    function Ay(t, e, r) {\n      let n = 0;\n      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n      return n;\n    }\n    function Sy(t, e, r) {\n      const n = [{\n        fixed: -wy,\n        stretch: 0\n      }];\n      for (const [e, r] of t) {\n        const t = n[n.length - 1];\n        n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch\n        }), n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch + (r - e)\n        });\n      }\n      return n.push({\n        fixed: e + wy,\n        stretch: r\n      }), n;\n    }\n    function Iy(t, e, r, n) {\n      return t / e * r + n;\n    }\n    function ky(t, e, r, n) {\n      return t - e * r / n;\n    }\n    function Py(t, e, r, n) {\n      const i = e + t.positionedLines[n].lineOffset;\n      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;\n    }\n    function Ey(t, e = 1, r = !1) {\n      let n = 1 / 0,\n        i = 1 / 0,\n        a = -1 / 0,\n        s = -1 / 0;\n      const o = t[0];\n      for (let t = 0; t < o.length; t++) {\n        const e = o[t];\n        (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > a) && (a = e.x), (!t || e.y > s) && (s = e.y);\n      }\n      const l = Math.min(a - n, s - i);\n      let u = l / 2;\n      const c = new zr([], zy);\n      if (0 === l) return new g(n, i);\n      for (let e = n; e < a; e += l) for (let r = i; r < s; r += l) c.push(new Ty(e + u, r + u, u, t));\n      let h = function (t) {\n          let e = 0,\n            r = 0,\n            n = 0;\n          const i = t[0];\n          for (let t = 0, a = i.length, s = a - 1; t < a; s = t++) {\n            const a = i[t],\n              o = i[s],\n              l = a.x * o.y - o.x * a.y;\n            r += (a.x + o.x) * l, n += (a.y + o.y) * l, e += 3 * l;\n          }\n          return new Ty(r / e, n / e, 0, t);\n        }(t),\n        p = c.length;\n      for (; c.length;) {\n        const n = c.pop();\n        (n.d > h.d || !h.d) && (h = n, r && console.log(\"found best %d after %d probes\", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new Ty(n.p.x - u, n.p.y - u, u, t)), c.push(new Ty(n.p.x + u, n.p.y - u, u, t)), c.push(new Ty(n.p.x - u, n.p.y + u, u, t)), c.push(new Ty(n.p.x + u, n.p.y + u, u, t)), p += 4);\n      }\n      return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;\n    }\n    function zy(t, e) {\n      return e.max - t.max;\n    }\n    class Ty {\n      constructor(t, e, r, n) {\n        this.p = new g(t, e), this.h = r, this.d = function (t, e) {\n          let r = !1,\n            n = 1 / 0;\n          for (let i = 0; i < e.length; i++) {\n            const a = e[i];\n            for (let e = 0, i = a.length, s = i - 1; e < i; s = e++) {\n              const i = a[e],\n                o = a[s];\n              i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, ql(t, i, o));\n            }\n          }\n          return (r ? 1 : -1) * Math.sqrt(n);\n        }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n      }\n    }\n    const By = Number.POSITIVE_INFINITY,\n      Cy = Math.sqrt(2);\n    function Ry(t, [e, r]) {\n      let n = 0,\n        i = 0;\n      if (r === By) {\n        e < 0 && (e = 0);\n        const r = e / Cy;\n        switch (t) {\n          case \"top-right\":\n          case \"top-left\":\n            i = r - 7;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n            i = 7 - r;\n            break;\n          case \"bottom\":\n            i = 7 - e;\n            break;\n          case \"top\":\n            i = e - 7;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n            n = -r;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n            n = r;\n            break;\n          case \"left\":\n            n = e;\n            break;\n          case \"right\":\n            n = -e;\n        }\n      } else {\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case \"top-right\":\n          case \"top-left\":\n          case \"top\":\n            i = r - 7;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n          case \"bottom\":\n            i = 7 - r;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n          case \"right\":\n            n = -e;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n          case \"left\":\n            n = e;\n        }\n      }\n      return [n, i];\n    }\n    function Dy(t) {\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          return \"right\";\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          return \"left\";\n      }\n      return \"center\";\n    }\n    function Vy(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d) {\n      let m = a.textMaxSize.evaluate(e, {}, h);\n      void 0 === m && (m = s);\n      const y = t.layers[0].layout,\n        g = y.get(\"icon-offset\").evaluate(e, {}, h),\n        x = Oy(r.horizontal) || r.vertical,\n        v = \"globe\" === p.name,\n        _ = im,\n        w = s / _,\n        M = t.tilePixelRatio * m / _,\n        A = (B = t.overscaling, t.zoom > 18 && B > 2 && (B >>= 1), Math.max(Tr / (512 * B), 1) * y.get(\"symbol-spacing\")),\n        S = y.get(\"text-padding\") * t.tilePixelRatio,\n        I = y.get(\"icon-padding\") * t.tilePixelRatio,\n        k = b(y.get(\"text-max-angle\")),\n        P = \"map\" === y.get(\"text-rotation-alignment\") && \"point\" !== y.get(\"symbol-placement\"),\n        E = \"map\" === y.get(\"icon-rotation-alignment\") && \"point\" !== y.get(\"symbol-placement\"),\n        z = y.get(\"symbol-placement\"),\n        T = A / 2;\n      var B;\n      const C = y.get(\"icon-text-fit\").evaluate(e, {}, h),\n        R = y.get(\"icon-text-fit-padding\").evaluate(e, {}, h),\n        D = \"none\" !== C;\n      let V;\n      !1 === t.hasAnyIconTextFit && D && (t.hasAnyIconTextFit = !0), n && D && (t.allowVerticalPlacement && r.vertical && (V = ry(n, r.vertical, C, R, g, w)), x && (n = ry(n, x, C, R, g, w)));\n      const L = (s, o, m) => {\n        if (o.x < 0 || o.x >= Tr || o.y < 0 || o.y >= Tr) return;\n        let y = null;\n        if (v) {\n          const {\n            x: t,\n            y: e,\n            z: r\n          } = p.projectTilePoint(o.x, o.y, m);\n          y = {\n            anchor: new ny(t, e, r, 0, void 0),\n            up: p.upVector(m, o.x, o.y)\n          };\n        }\n        !function (t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I) {\n          const k = t.addToLineVertexArray(e, n);\n          let P,\n            E,\n            z,\n            T,\n            B,\n            C,\n            R,\n            D = 0,\n            V = 0,\n            L = 0,\n            F = 0,\n            N = -1,\n            O = -1;\n          const U = {};\n          let q = ho(\"\");\n          const $ = r ? r.anchor : e,\n            G = \"none\" !== l.layout.get(\"icon-text-fit\").evaluate(b, {}, A);\n          let Y = 0,\n            X = 0;\n          if (void 0 === l._unevaluatedLayout.getValue(\"text-radial-offset\") ? [Y, X] = l.layout.get(\"text-offset\").evaluate(b, {}, A).map(t => t * im) : (Y = l.layout.get(\"text-radial-offset\").evaluate(b, {}, A) * im, X = By), t.allowVerticalPlacement && i.vertical) {\n            const t = i.vertical;\n            if (d) C = jy(t), o && (R = jy(o));else {\n              const r = l.layout.get(\"text-rotate\").evaluate(b, {}, A) + 90;\n              z = Uy(u, $, e, c, h, p, t, f, r, m), o && (T = Uy(u, $, e, c, h, p, o, g, r));\n            }\n          }\n          if (a) {\n            const n = l.layout.get(\"icon-rotate\").evaluate(b, {}, A),\n              i = My(a, n, w, G),\n              s = o ? My(o, n, w, G) : void 0;\n            E = Uy(u, $, e, c, h, p, a, g, n), D = 4 * i.length;\n            const f = t.iconSizeData;\n            let d = null;\n            \"source\" === f.kind ? (d = [am * l.layout.get(\"icon-size\").evaluate(b, {}, A)], d[0] > Fy && j(`${t.layerIds[0]}: Value for \"icon-size\" is >= ${Ly}. Reduce your \"icon-size\".`)) : \"composite\" === f.kind && (d = [am * _.compositeIconSizes[0].evaluate(b, {}, A), am * _.compositeIconSizes[1].evaluate(b, {}, A)], (d[0] > Fy || d[1] > Fy) && j(`${t.layerIds[0]}: Value for \"icon-size\" is >= ${Ly}. Reduce your \"icon-size\".`)), t.addSymbols(t.icon, i, d, v, x, b, !1, r, e, k.lineStartIndex, k.lineLength, -1, M, A, S, I), N = t.icon.placedSymbolArray.length - 1, s && (V = 4 * s.length, t.addSymbols(t.icon, s, d, v, x, b, jm.vertical, r, e, k.lineStartIndex, k.lineLength, -1, M, A, S, I), O = t.icon.placedSymbolArray.length - 1);\n          }\n          for (const n in i.horizontal) {\n            const a = i.horizontal[n];\n            P || (q = ho(a.text), d ? B = jy(a) : P = Uy(u, $, e, c, h, p, a, f, l.layout.get(\"text-rotate\").evaluate(b, {}, A), m));\n            const o = 1 === a.positionedLines.length;\n            if (L += Ny(t, r, e, a, s, l, d, b, m, k, i.vertical ? jm.horizontal : jm.horizontalOnly, o ? Object.keys(i.horizontal) : [n], U, N, _, M, A, S), o) break;\n          }\n          i.vertical && (F += Ny(t, r, e, i.vertical, s, l, d, b, m, k, jm.vertical, [\"vertical\"], U, O, _, M, A, S));\n          let Z = -1;\n          const K = (t, e) => t ? Math.max(t, e) : e;\n          Z = K(B, Z), Z = K(C, Z), Z = K(R, Z);\n          const H = Z > -1 ? 1 : 0;\n          t.glyphOffsetArray.length >= 65535 && j(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, $.x, $.y, $.z, U.right >= 0 ? U.right : -1, U.center >= 0 ? U.center : -1, U.left >= 0 ? U.left : -1, U.vertical >= 0 ? U.vertical : -1, N, O, q, void 0 !== P ? P : t.collisionBoxArray.length, void 0 !== P ? P + 1 : t.collisionBoxArray.length, void 0 !== z ? z : t.collisionBoxArray.length, void 0 !== z ? z + 1 : t.collisionBoxArray.length, void 0 !== E ? E : t.collisionBoxArray.length, void 0 !== E ? E + 1 : t.collisionBoxArray.length, T || t.collisionBoxArray.length, T ? T + 1 : t.collisionBoxArray.length, c, L, F, D, V, H, 0, Y, X, Z, 0, G ? 1 : 0);\n        }(t, o, y, s, r, n, i, V, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, S, P, l, 0, I, E, g, e, a, u, c, h, f, d);\n      };\n      if (\"line\" === z) for (const i of hy(e.geometry, 0, 0, Tr, Tr)) {\n        const e = uy(i, A, k, r.vertical || x, n, _, M, t.overscaling, Tr);\n        for (const r of e) x && qy(t, x.text, T, r) || L(i, r, h);\n      } else if (\"line-center\" === z) {\n        for (const t of e.geometry) if (t.length > 1) {\n          const e = ly(t, k, r.vertical || x, n, _, M);\n          e && L(t, e, h);\n        }\n      } else if (\"Polygon\" === e.type) for (const t of nf(e.geometry, 0)) {\n        const e = Ey(t, 16);\n        L(t[0], new ny(e.x, e.y, 0, 0, void 0), h);\n      } else if (\"LineString\" === e.type) for (const t of e.geometry) L(t, new ny(t[0].x, t[0].y, 0, 0, void 0), h);else if (\"Point\" === e.type) for (const t of e.geometry) for (const e of t) L([e], new ny(e.x, e.y, 0, 0, void 0), h);\n    }\n    const Ly = 255,\n      Fy = Ly * am;\n    function Ny(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, x) {\n      const v = function (t, e, r, n, i, a, s, o) {\n          const l = [];\n          if (0 === e.positionedLines.length) return l;\n          const u = n.layout.get(\"text-rotate\").evaluate(a, {}) * Math.PI / 180,\n            c = function (t) {\n              const e = t[0],\n                r = t[1],\n                n = e * r;\n              return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];\n            }(r);\n          let h = Math.abs(e.top - e.bottom);\n          for (const t of e.positionedLines) h -= t.lineOffset;\n          const p = e.positionedLines.length,\n            f = h / p;\n          let d = e.top - r[1];\n          for (let t = 0; t < p; ++t) {\n            const n = e.positionedLines[t];\n            d = Py(e, f, d, t);\n            for (const t of n.positionedGlyphs) {\n              if (!t.rect) continue;\n              const n = t.rect || {};\n              let a = Um + 1,\n                h = !0,\n                p = 1,\n                f = 0;\n              if (t.imageName) {\n                const e = s[t.imageName];\n                if (!e) continue;\n                if (e.sdf) {\n                  j(\"SDF images are not supported in formatted text and will be ignored.\");\n                  continue;\n                }\n                h = !1, p = e.pixelRatio, a = fy / p;\n              }\n              const m = (i || o) && t.vertical,\n                y = t.metrics.advance * t.scale / 2,\n                x = t.metrics,\n                v = t.rect;\n              if (null === v) continue;\n              o && e.verticalizable && (f = t.imageName ? y - t.metrics.width * t.scale / 2 : 0);\n              const b = i ? [t.x + y, t.y] : [0, 0];\n              let _ = [0, 0],\n                w = [0, 0],\n                M = !1;\n              i || (m ? (w = [t.x + y + c[0], t.y + c[1] - f], M = !0) : _ = [t.x + y + r[0], t.y + r[1] - f]);\n              const A = v.w * t.scale / (p * (t.localGlyph ? vy : 1)),\n                S = v.h * t.scale / (p * (t.localGlyph ? vy : 1));\n              let I, k, P, E;\n              if (m) {\n                const e = t.y - d,\n                  r = new g(-y, y - e),\n                  n = -Math.PI / 2,\n                  i = new g(...w);\n                I = new g(-y + _[0], _[1]), I._rotateAround(n, r)._add(i), I.x += -e + y, I.y -= (x.left - a) * t.scale;\n                const s = t.imageName ? x.advance * t.scale : im * t.scale,\n                  o = String.fromCodePoint(t.glyph);\n                pm(o) ? I.x += (1 - a) * t.scale : fm(o) ? I.x += s - x.height * t.scale + (-a - 1) * t.scale : I.x += t.imageName || x.width + 2 * a === v.w && x.height + 2 * a === v.h ? (s - S) / 2 : (s - (x.height + 2 * a) * t.scale) / 2, k = new g(I.x, I.y - A), P = new g(I.x + S, I.y), E = new g(I.x + S, I.y - A);\n              } else {\n                const e = (x.left - a) * t.scale - y + _[0],\n                  r = (-x.top - a) * t.scale + _[1],\n                  n = e + A,\n                  i = r + S;\n                I = new g(e, r), k = new g(n, r), P = new g(e, i), E = new g(n, i);\n              }\n              if (u) {\n                let t;\n                t = i ? new g(0, 0) : M ? new g(c[0], c[1]) : new g(r[0], r[1]), I._rotateAround(u, t), k._rotateAround(u, t), P._rotateAround(u, t), E._rotateAround(u, t);\n              }\n              const z = new g(0, 0),\n                T = new g(0, 0);\n              l.push({\n                tl: I,\n                tr: k,\n                bl: P,\n                br: E,\n                texPrimary: n,\n                texSecondary: void 0,\n                writingMode: e.writingMode,\n                glyphOffset: b,\n                sectionIndex: t.sectionIndex,\n                isSDF: h,\n                pixelOffsetTL: z,\n                pixelOffsetBR: T,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n          return l;\n        }(0, n, l, a, s, o, i, t.allowVerticalPlacement),\n        b = t.textSizeData;\n      let _ = null;\n      \"source\" === b.kind ? (_ = [am * a.layout.get(\"text-size\").evaluate(o, {}, y)], _[0] > Fy && j(`${t.layerIds[0]}: Value for \"text-size\" is >= ${Ly}. Reduce your \"text-size\".`)) : \"composite\" === b.kind && (_ = [am * d.compositeTextSizes[0].evaluate(o, {}, y), am * d.compositeTextSizes[1].evaluate(o, {}, y)], (_[0] > Fy || _[1] > Fy) && j(`${t.layerIds[0]}: Value for \"text-size\" is >= ${Ly}. Reduce your \"text-size\".`)), t.addSymbols(t.text, v, _, l, s, o, c, e, r, u.lineStartIndex, u.lineLength, f, m, y, x, !1);\n      for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;\n      return 4 * v.length;\n    }\n    function Oy(t) {\n      for (const e in t) return t[e];\n      return null;\n    }\n    function Uy(t, e, r, n, i, a, s, o, l, u) {\n      let c = s.top,\n        h = s.bottom,\n        p = s.left,\n        f = s.right;\n      const d = s.collisionPadding;\n      if (d && (p -= d[0], c -= d[1], f += d[2], h += d[3]), l) {\n        const t = new g(p, c),\n          e = new g(f, c),\n          r = new g(p, h),\n          n = new g(f, h),\n          i = b(l);\n        let a = new g(0, 0);\n        u && (a = new g(u[0], u[1])), t._rotateAround(i, a), e._rotateAround(i, a), r._rotateAround(i, a), n._rotateAround(i, a), p = Math.min(t.x, e.x, r.x, n.x), f = Math.max(t.x, e.x, r.x, n.x), c = Math.min(t.y, e.y, r.y, n.y), h = Math.max(t.y, e.y, r.y, n.y);\n      }\n      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, f, h, o, n, i, a), t.length - 1;\n    }\n    function jy(t) {\n      t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);\n      const e = t.bottom - t.top;\n      return e > 0 ? Math.max(10, e) : null;\n    }\n    function qy(t, e, r, n) {\n      const i = t.compareText;\n      if (e in i) {\n        const t = i[e];\n        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n      } else i[e] = [];\n      return i[e].push(n), !1;\n    }\n    function $y(t, e) {\n      const r = t.fovAboveCenter,\n        n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,\n        i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),\n        a = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01)),\n        s = Math.sin(t._pitch) * a + i;\n      return Math.min(1.01 * s, i * (1 / t._horizonShift));\n    }\n    function Gy(t, e) {\n      if (!e.isReprojectedInTileSpace) return {\n        scale: 1 << t.z,\n        x: t.x,\n        y: t.y,\n        x2: t.x + 1,\n        y2: t.y + 1,\n        projection: e\n      };\n      const r = Math.pow(2, -t.z),\n        n = t.x * r,\n        i = (t.x + 1) * r,\n        a = t.y * r,\n        s = (t.y + 1) * r,\n        o = ml(n),\n        l = ml(i),\n        u = yl(a),\n        c = yl(s),\n        h = e.project(o, u),\n        p = e.project(l, u),\n        f = e.project(l, c),\n        d = e.project(o, c);\n      let m = Math.min(h.x, p.x, f.x, d.x),\n        y = Math.min(h.y, p.y, f.y, d.y),\n        g = Math.max(h.x, p.x, f.x, d.x),\n        x = Math.max(h.y, p.y, f.y, d.y);\n      const v = r / 16;\n      function b(t, r, n, i, a, s) {\n        const o = (n + a) / 2,\n          l = (i + s) / 2,\n          u = e.project(ml(o), yl(l)),\n          c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);\n        m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, a, s));\n      }\n      b(h, p, n, a, i, a), b(p, f, i, a, i, s), b(f, d, i, s, n, s), b(d, h, n, s, n, a), m -= v, y -= v, g += v, x += v;\n      const _ = 1 / Math.max(g - m, x - y);\n      return {\n        scale: _,\n        x: m * _,\n        y: y * _,\n        x2: g * _,\n        y2: x * _,\n        projection: e\n      };\n    }\n    function Yy(t, {\n      x: e,\n      y: r\n    }, n = 0) {\n      return new g(((e - n) * t.scale - t.x) * Tr, (r * t.scale - t.y) * Tr);\n    }\n    const Xy = t.a6.identity(new Float32Array(16));\n    class Zy {\n      constructor(t) {\n        this.spec = t, this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = \"meters\", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [\"custom\"], this.center = [0, 0], this.range = [3.5, 7];\n      }\n      project(t, e) {\n        return {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        return new tl(0, 0);\n      }\n      projectTilePoint(t, e, r) {\n        return {\n          x: t,\n          y: e,\n          z: 0\n        };\n      }\n      locationPoint(t, e, r = !0) {\n        return t._coordinatePoint(t.locationCoordinate(e), r);\n      }\n      pixelsPerMeter(t, e) {\n        return dl(1, t) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        return 1;\n      }\n      farthestPixelDistance(t) {\n        return $y(t, t.pixelsPerMeter);\n      }\n      pointCoordinate(t, e, r, n) {\n        const i = t.horizonLineFromTop(!1),\n          a = new g(e, Math.max(i, r));\n        return t.rayIntersectionCoordinate(t.pointRayIntersection(a, n));\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = new g(e, r);\n        if (t.elevation) return t.elevation.pointCoordinate(n);\n        {\n          const e = this.pointCoordinate(t, n.x, n.y, 0);\n          return [e.x, e.y, e.z];\n        }\n      }\n      isPointAboveHorizon(t, e) {\n        if (t.elevation) return !this.pointCoordinate3D(t, e.x, e.y);\n        const r = t.horizonLineFromTop();\n        return e.y < r;\n      }\n      createInversionMatrix(t, e) {\n        return Xy;\n      }\n      createTileMatrix(e, r, n) {\n        let i, a, s;\n        const o = n.canonical,\n          l = t.a6.identity(new Float64Array(16));\n        if (this.isReprojectedInTileSpace) {\n          const u = Gy(o, this);\n          i = 1, a = u.x + n.wrap * u.scale, s = u.y, t.a6.scale(l, l, [i / u.scale, i / u.scale, e.pixelsPerMeter / r]);\n        } else i = r / e.zoomScale(o.z), a = (o.x + Math.pow(2, o.z) * n.wrap) * i, s = o.y * i;\n        return t.a6.translate(l, l, [a, s, 0]), t.a6.scale(l, l, [i / Tr, i / Tr, 1]), l;\n      }\n      upVector(t, e, r) {\n        return [0, 0, 1];\n      }\n      upVectorScale(t, e, r) {\n        return {\n          metersToTile: 1\n        };\n      }\n    }\n    class Ky extends Zy {\n      constructor(t) {\n        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];\n        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],\n          n = Math.sin(b(e));\n        this.n = (n + Math.sin(b(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;\n      }\n      project(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          a = b(t - this.center[0]),\n          s = b(e),\n          o = Math.sqrt(n - 2 * r * Math.sin(s)) / r;\n        return {\n          x: o * Math.sin(a * r),\n          y: o * Math.cos(a * r) - i,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          a = i + e;\n        let s = Math.atan2(t, Math.abs(a)) * Math.sign(a);\n        a * r < 0 && (s -= Math.PI * Math.sign(t) * Math.sign(a));\n        const o = b(this.center[0]) * r;\n        s = P(s, -Math.PI - o, Math.PI - o);\n        const l = I(_(s / r) + this.center[0], -180, 180),\n          u = Math.asin(I((n - (t * t + a * a) * r * r) / (2 * r), -1, 1)),\n          c = I(_(u), -xl, xl);\n        return new tl(l, c);\n      }\n    }\n    const Hy = 1.340264,\n      Wy = -.081106,\n      Jy = 893e-6,\n      Qy = .003796,\n      tg = Math.sqrt(3) / 2;\n    class eg extends Zy {\n      project(t, e) {\n        e = e / 180 * Math.PI, t = t / 180 * Math.PI;\n        const r = Math.asin(tg * Math.sin(e)),\n          n = r * r,\n          i = n * n * n;\n        return {\n          x: .5 * (t * Math.cos(r) / (tg * (Hy + 3 * Wy * n + i * (7 * Jy + 9 * Qy * n))) / Math.PI + .5),\n          y: 1 - .5 * (r * (Hy + Wy * n + i * (Jy + Qy * n)) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = r * r,\n          i = n * n * n;\n        for (let t, a, s, o = 0; o < 12 && (a = r * (Hy + Wy * n + i * (Jy + Qy * n)) - e, s = Hy + 3 * Wy * n + i * (7 * Jy + 9 * Qy * n), t = a / s, r = I(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);\n        const a = tg * t * (Hy + 3 * Wy * n + i * (7 * Jy + 9 * Qy * n)) / Math.cos(r),\n          s = Math.asin(Math.sin(r) / tg),\n          o = I(180 * a / Math.PI, -180, 180),\n          l = I(180 * s / Math.PI, -xl, xl);\n        return new tl(o, l);\n      }\n    }\n    class rg extends Zy {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        return {\n          x: .5 + t / 360,\n          y: .5 - e / 360,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = 360 * (t - .5),\n          n = I(360 * (.5 - e), -xl, xl);\n        return new tl(r, n);\n      }\n    }\n    const ng = Math.PI / 2;\n    function ig(t) {\n      return Math.tan((ng + t) / 2);\n    }\n    class ag extends Zy {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 30];\n        const [e, r] = this.parallels = t.parallels || [30, 30];\n        let n = b(e),\n          i = b(r);\n        this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);\n        const a = Math.cos(n),\n          s = ig(n);\n        this.n = n === i ? Math.sin(n) : Math.log(a / Math.cos(i)) / Math.log(ig(i) / s), this.f = a * Math.pow(ig(n), this.n) / this.n;\n      }\n      project(t, e) {\n        e = b(e), this.southernCenter && (e = -e), t = b(t - this.center[0]);\n        const r = 1e-6,\n          {\n            n: n,\n            f: i\n          } = this;\n        i > 0 ? e < -ng + r && (e = -ng + r) : e > ng - r && (e = ng - r);\n        const a = i / Math.pow(ig(e), n);\n        let s = a * Math.sin(n * t),\n          o = i - a * Math.cos(n * t);\n        return s = .5 * (s / Math.PI + .5), o = .5 * (o / Math.PI + .5), {\n          x: s,\n          y: this.southernCenter ? o : 1 - o,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;\n        const {\n            n: r,\n            f: n\n          } = this,\n          i = n - e,\n          a = Math.sign(i),\n          s = Math.sign(r) * Math.sqrt(t * t + i * i);\n        let o = Math.atan2(t, Math.abs(i)) * a;\n        i * r < 0 && (o -= Math.PI * Math.sign(t) * a);\n        const l = I(_(o / r) + this.center[0], -180, 180),\n          u = I(_(2 * Math.atan(Math.pow(n / s, 1 / r)) - ng), -xl, xl);\n        return new tl(l, this.southernCenter ? -u : u);\n      }\n    }\n    class sg extends Zy {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;\n      }\n      project(t, e) {\n        return {\n          x: pl(t),\n          y: fl(e),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = ml(t),\n          n = yl(e);\n        return new tl(r, n);\n      }\n    }\n    const og = b(xl);\n    class lg extends Zy {\n      project(t, e) {\n        const r = (e = b(e)) * e,\n          n = r * r;\n        return {\n          x: .5 * ((t = b(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),\n          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = 25,\n          i = 0,\n          a = r * r;\n        do {\n          a = r * r;\n          const t = a * a;\n          i = (r * (1.007226 + a * (.015085 + t * (.028874 * a - .044475 - .005916 * t))) - e) / (1.007226 + a * (.045255 + t * (.259866 * a - .311325 - .005916 * 11 * t))), r = I(r - i, -og, og);\n        } while (Math.abs(i) > 1e-6 && --n > 0);\n        a = r * r;\n        const s = I(_(t / (.8707 + a * (a * (a * a * a * (.003971 - .001529 * a) - .013791) - .131979))), -180, 180),\n          o = _(r);\n        return new tl(s, o);\n      }\n    }\n    const ug = b(xl);\n    class cg extends Zy {\n      project(t, e) {\n        e = b(e), t = b(t);\n        const r = Math.cos(e),\n          n = 2 / Math.PI,\n          i = Math.acos(r * Math.cos(t / 2)),\n          a = Math.sin(i) / i,\n          s = .5 * (t * n + 2 * r * Math.sin(t / 2) / a) || 0,\n          o = .5 * (e + Math.sin(e) / a) || 0;\n        return {\n          x: .5 * (s / Math.PI + .5),\n          y: 1 - .5 * (o / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        let r = t = (2 * t - .5) * Math.PI,\n          n = e = (2 * (1 - e) - 1) * Math.PI,\n          i = 25;\n        const a = 1e-6;\n        let s = 0,\n          o = 0;\n        do {\n          const i = Math.cos(n),\n            a = Math.sin(n),\n            l = 2 * a * i,\n            u = a * a,\n            c = i * i,\n            h = Math.cos(r / 2),\n            p = Math.sin(r / 2),\n            f = 2 * h * p,\n            d = p * p,\n            m = 1 - c * h * h,\n            y = m ? 1 / m : 0,\n            g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0,\n            x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t,\n            v = .5 * (g * a + n) - e,\n            b = .5 * y * (c * d + g * i * h * u) + 1 / Math.PI,\n            _ = y * (f * l / 4 - g * a * p),\n            w = .125 * y * (l * p - g * a * c * f),\n            M = .5 * y * (u * h + g * d * i) + .5,\n            A = _ * w - M * b;\n          s = (v * _ - x * M) / A, o = (x * w - v * b) / A, r = I(r - s, -Math.PI, Math.PI), n = I(n - o, -ug, ug);\n        } while ((Math.abs(s) > a || Math.abs(o) > a) && --i > 0);\n        return new tl(_(r), _(n));\n      }\n    }\n    class hg extends Zy {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(b(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        const {\n          scale: r,\n          cosPhi: n\n        } = this;\n        return {\n          x: b(t) * n * r + .5,\n          y: -Math.sin(b(e)) / n * r + .5,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            scale: r,\n            cosPhi: n\n          } = this,\n          i = -(e - .5) / r,\n          a = I(_((t - .5) / r) / n, -180, 180),\n          s = Math.asin(I(i * n, -1, 1)),\n          o = I(_(s), -xl, xl);\n        return new tl(a, o);\n      }\n    }\n    class pg extends sg {\n      constructor(t) {\n        super(t), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = \"pixels\", this.unsupportedLayers = [\"debug\"], this.range = [3, 5];\n      }\n      projectTilePoint(e, r, n) {\n        const i = Zh(e, r, n),\n          a = Wh(jh(n));\n        return t.N.transformMat4(i, i, a), {\n          x: i[0],\n          y: i[1],\n          z: i[2]\n        };\n      }\n      locationPoint(e, r) {\n        const n = Wo(r.lat, r.lng),\n          i = t.N.normalize([], n),\n          a = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(r), e._centerAltitude) : e._centerAltitude,\n          s = dl(1, 0) * Tr * a;\n        t.N.scaleAndAdd(n, n, i, s);\n        const o = t.a6.identity(new Float64Array(16));\n        return t.a6.multiply(o, e.pixelMatrix, e.globeMatrix), t.N.transformMat4(n, n, o), new g(n[0], n[1]);\n      }\n      pixelsPerMeter(t, e) {\n        return dl(1, 0) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        const n = dl(1, t) * e,\n          i = ue(dl(1, 45) * e, n, r);\n        return this.pixelsPerMeter(t, e) / i;\n      }\n      createTileMatrix(e, r, n) {\n        const i = Jh(jh(n.canonical));\n        return t.a6.multiply(new Float64Array(16), e.globeMatrix, i);\n      }\n      createInversionMatrix(e, r) {\n        const {\n            center: n\n          } = e,\n          i = Wh(jh(r));\n        return t.a6.rotateY(i, i, b(n.lng)), t.a6.rotateX(i, i, b(n.lat)), t.a6.scale(i, i, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(i);\n      }\n      pointCoordinate(t, e, r, n) {\n        return Nh(t, e, r, !0) || new Ml(0, 0);\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = this.pointCoordinate(t, e, r, 0);\n        return [n.x, n.y, n.z];\n      }\n      isPointAboveHorizon(t, e) {\n        return !Nh(t, e.x, e.y, !1);\n      }\n      farthestPixelDistance(e) {\n        const r = function (e, r) {\n            const n = e.cameraToCenterDistance,\n              i = e._centerAltitude * r,\n              a = e._camera,\n              s = e._camera.forward(),\n              o = t.N.add([], t.N.scale([], s, -n), [0, 0, i]),\n              l = e.worldSize / (2 * Math.PI),\n              u = [0, 0, -l],\n              c = e.width / e.height,\n              h = Math.tan(e.fovAboveCenter),\n              p = t.N.scale([], a.up(), h),\n              f = t.N.scale([], a.right(), h * c),\n              d = t.N.normalize([], t.N.add([], t.N.add([], s, p), f)),\n              m = [];\n            let y;\n            if (new Sh(o, d).closestPointOnSphere(u, l, m)) {\n              const r = t.N.add([], m, u),\n                n = t.N.sub([], r, o);\n              y = Math.cos(e.fovAboveCenter) * t.N.length(n);\n            } else {\n              const e = t.N.sub([], o, u),\n                r = t.N.sub([], u, o);\n              t.N.normalize(r, r);\n              const n = t.N.length(e) - l;\n              y = Math.sqrt(n * (n + 2 * l));\n              const i = Math.acos(y / (l + n)) - Math.acos(t.N.dot(s, r));\n              y *= Math.cos(i);\n            }\n            return 1.01 * y;\n          }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)),\n          n = rp(e.zoom);\n        if (n > 0) {\n          const t = $y(e, dl(1, e.center.lat) * e.worldSize),\n            i = e.worldSize / (2 * Math.PI),\n            a = Math.max(e.width, e.height) / e.worldSize * Math.PI;\n          return ue(r, t + i * (1 - Math.cos(a)), Math.pow(n, 10));\n        }\n        return r;\n      }\n      upVector(t, e, r) {\n        return Zh(e, r, t, 1);\n      }\n      upVectorScale(t) {\n        return {\n          metersToTile: Lh(Kh(jh(t)))\n        };\n      }\n    }\n    function fg(t) {\n      const e = t.parallels,\n        r = !!e && Math.abs(e[0] + e[1]) < .01;\n      switch (t.name) {\n        case \"mercator\":\n          return new sg(t);\n        case \"equirectangular\":\n          return new rg(t);\n        case \"naturalEarth\":\n          return new lg(t);\n        case \"equalEarth\":\n          return new eg(t);\n        case \"winkelTripel\":\n          return new cg(t);\n        case \"albers\":\n          return r ? new hg(t) : new Ky(t);\n        case \"lambertConformalConic\":\n          return r ? new hg(t) : new ag(t);\n        case \"globe\":\n          return new pg(t);\n      }\n      throw new Error(`Invalid projection name: ${t.name}`);\n    }\n    const dg = zf.types,\n      mg = [{\n        name: \"a_fade_opacity\",\n        components: 1,\n        type: \"Uint8\",\n        offset: 0\n      }];\n    function yg(t, e, r, n, i, a, s, o, l, u, c, h, p) {\n      const f = o ? Math.min(Fy, Math.round(o[0])) : 0,\n        d = o ? Math.min(Fy, Math.round(o[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), a, s, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);\n    }\n    function gg(t, e, r) {\n      t.emplaceBack(e, r);\n    }\n    function xg(t, e, r, n, i, a, s) {\n      t.emplaceBack(e, r, n, i, a, s);\n    }\n    function vg(t, e, r, n, i) {\n      t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i);\n    }\n    function bg(t) {\n      for (const e of t.sections) if (ma(e.text)) return !0;\n      return !1;\n    }\n    class _g {\n      constructor(t) {\n        this.layoutVertexArray = new _s(), this.indexArray = new Es(), this.programConfigurations = t, this.segments = new eo(), this.dynamicLayoutVertexArray = new gs(), this.opacityVertexArray = new Ms(), this.placedSymbolArray = new Gs(), this.iconTransitioningVertexArray = new As(), this.globeExtVertexArray = new ws(), this.zOffsetVertexArray = new Bs();\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;\n      }\n      upload(t, e, r, n, i) {\n        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Kd.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Wd.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, mg, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t.createVertexBuffer(this.iconTransitioningVertexArray, Qd.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Hd.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t.createVertexBuffer(this.zOffsetVertexArray, Jd.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());\n      }\n    }\n    ra(_g, \"SymbolBuffers\");\n    class wg {\n      constructor(t, e, r) {\n        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new eo(), this.collisionVertexArray = new Ps(), this.collisionVertexArrayExt = new gs();\n      }\n      upload(t) {\n        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, tm.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, em.members, !0);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());\n      }\n    }\n    ra(wg, \"CollisionBuffers\");\n    class Mg {\n      constructor(e) {\n        this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = t.a6.identity([]), this.placementViewportMatrix = t.a6.identity([]);\n        const r = this.layers[0]._unevaluatedLayout._values;\n        this.textSizeData = sm(this.zoom, r[\"text-size\"]), this.iconSizeData = sm(this.zoom, r[\"icon-size\"]);\n        const n = this.layers[0].layout,\n          i = n.get(\"symbol-sort-key\"),\n          a = n.get(\"symbol-z-order\");\n        this.canOverlap = n.get(\"text-allow-overlap\") || n.get(\"icon-allow-overlap\") || n.get(\"text-ignore-placement\") || n.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== a && void 0 !== i.constantOr(1), this.sortFeaturesByY = (\"viewport-y\" === a || \"auto\" === a && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n.get(\"text-writing-mode\").map(t => jm[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = n.get(\"symbol-z-elevate\");\n      }\n      createArrays() {\n        this.text = new _g(new Vo(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new _g(new Vo(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new Zs(), this.lineVertexArray = new Ks(), this.symbolInstances = new Xs();\n      }\n      calculateGlyphDependencies(t, e, r, n, i) {\n        for (let r = 0; r < t.length; r++) {\n          const a = t.codePointAt(r);\n          if (void 0 === a) break;\n          if (e[a] = !0, n && i && a <= 65535) {\n            const n = hm[t.charAt(r)];\n            n && (e[n.charCodeAt(0)] = !0);\n          }\n        }\n      }\n      populate(e, r, n, i) {\n        const a = this.layers[0],\n          s = a.layout,\n          o = \"globe\" === this.projection.name,\n          l = s.get(\"text-font\"),\n          u = s.get(\"text-field\"),\n          c = s.get(\"icon-image\"),\n          h = (\"constant\" !== u.value.kind || u.value.value instanceof De && !u.value.value.isEmpty() || u.value.value.toString().length > 0) && (\"constant\" !== l.value.kind || l.value.value.length > 0),\n          p = \"constant\" !== c.value.kind || !!c.value.value || Object.keys(c.parameters).length > 0,\n          f = s.get(\"symbol-sort-key\");\n        if (this.features = [], !h && !p) return;\n        const d = r.iconDependencies,\n          m = r.glyphDependencies,\n          y = r.availableImages,\n          g = new Pa(this.zoom);\n        for (const {\n          feature: r,\n          id: u,\n          index: c,\n          sourceLayerIndex: x\n        } of e) {\n          const e = a._featureFilter.needGeometry,\n            v = Bl(r, e);\n          if (!a._featureFilter.filter(g, v, n)) continue;\n          if (e || (v.geometry = Tl(r, n, i)), o && 1 !== r.type && n.z <= 5) {\n            const e = v.geometry,\n              r = .98078528056,\n              i = (e, i) => {\n                const a = Zh(e.x, e.y, n, 1),\n                  s = Zh(i.x, i.y, n, 1);\n                return t.N.dot(a, s) < r;\n              };\n            for (let t = 0; t < e.length; t++) e[t] = kl(e[t], i);\n          }\n          let b, _;\n          if (h) {\n            const t = a.getValueAndResolveTokens(\"text-field\", v, n, y),\n              e = De.factory(t);\n            bg(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === Sa() || this.hasRTLText && ka.isParsed()) && (b = cm(e, a, v));\n          }\n          if (p) {\n            const t = a.getValueAndResolveTokens(\"icon-image\", v, n, y);\n            _ = t instanceof Ve ? t : Ve.fromString(t);\n          }\n          if (!b && !_) continue;\n          const w = this.sortFeaturesByKey ? f.evaluate(v, {}, n) : void 0;\n          if (this.features.push({\n            id: u,\n            text: b,\n            icon: _,\n            index: c,\n            sourceLayerIndex: x,\n            geometry: v.geometry,\n            properties: r.properties,\n            type: dg[r.type],\n            sortKey: w\n          }), _ && (d[_.namePrimary] = !0, _.nameSecondary && (d[_.nameSecondary] = !0)), b) {\n            const t = l.evaluate(v, {}, n).join(\",\"),\n              e = \"map\" === s.get(\"text-rotation-alignment\") && \"point\" !== s.get(\"symbol-placement\");\n            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(jm.vertical) >= 0;\n            for (const r of b.sections) if (r.image) d[r.image.namePrimary] = !0;else {\n              const n = la(b.toString()),\n                i = r.fontStack || t,\n                a = m[i] = m[i] || {};\n              this.calculateGlyphDependencies(r.text, a, e, this.allowVerticalPlacement, n);\n            }\n          }\n        }\n        \"line\" === s.get(\"symbol-placement\") && (this.features = function (t) {\n          const e = {},\n            r = {},\n            n = [];\n          let i = 0;\n          function a(e) {\n            n.push(t[e]), i++;\n          }\n          function s(t, e, i) {\n            const a = r[t];\n            return delete r[t], r[e] = a, n[a].geometry[0].pop(), n[a].geometry[0] = n[a].geometry[0].concat(i[0]), a;\n          }\n          function o(t, r, i) {\n            const a = e[r];\n            return delete e[r], e[t] = a, n[a].geometry[0].shift(), n[a].geometry[0] = i[0].concat(n[a].geometry[0]), a;\n          }\n          function l(t, e, r) {\n            const n = r ? e[0][e[0].length - 1] : e[0][0];\n            return `${t}:${n.x}:${n.y}`;\n          }\n          for (let u = 0; u < t.length; u++) {\n            const c = t[u],\n              h = c.geometry,\n              p = c.text ? c.text.toString() : null;\n            if (!p) {\n              a(u);\n              continue;\n            }\n            const f = l(p, h),\n              d = l(p, h, !0);\n            if (f in r && d in e && r[f] !== e[d]) {\n              const t = o(f, d, h),\n                i = s(f, d, n[t].geometry);\n              delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n            } else f in r ? s(f, d, h) : d in e ? o(f, d, h) : (a(u), e[f] = i - 1, r[d] = i - 1);\n          }\n          return n.filter(t => t.geometry);\n        }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n      }\n      update(t, e, r, n, i) {\n        const a = 0 !== Object.keys(t).length;\n        if (a && !this.stateDependentLayers.length) return;\n        const s = a ? this.stateDependentLayers : this.layers;\n        this.text.programConfigurations.updatePaintArrays(t, e, s, r, n, i), this.icon.programConfigurations.updatePaintArrays(t, e, s, r, n, i);\n      }\n      updateZOffset() {\n        const t = (t, e, n) => {\n            r += e, r > t.length && t.resize(r);\n            for (let i = -e; i < 0; i++) t.emplace(i + r, n);\n          },\n          e = (t, e, r) => {\n            n += e, n > t.length && t.resize(n);\n            for (let i = -e; i < 0; i++) t.emplace(i + n, r);\n          };\n        if (!this.zOffsetBuffersNeedUpload) return;\n        this.zOffsetBuffersNeedUpload = !1;\n        let r = 0,\n          n = 0;\n        for (let r = 0; r < this.symbolInstances.length; r++) {\n          const n = this.symbolInstances.get(r),\n            {\n              numHorizontalGlyphVertices: i,\n              numVerticalGlyphVertices: a,\n              numIconVertices: s\n            } = n,\n            o = n.zOffset,\n            l = s > 0;\n          if ((i > 0 || a > 0) && (t(this.text.zOffsetVertexArray, i, o), t(this.text.zOffsetVertexArray, a, o)), l) {\n            const {\n              placedIconSymbolIndex: t,\n              verticalPlacedIconSymbolIndex: r\n            } = n;\n            t >= 0 && e(this.icon.zOffsetVertexArray, s, o), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, o);\n          }\n        }\n        this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);\n      }\n      isEmpty() {\n        return 0 === this.symbolInstances.length && !this.hasRTLText;\n      }\n      uploadPending() {\n        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;\n      }\n      destroyDebugData() {\n        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n      }\n      getProjection() {\n        return this.projectionInstance || (this.projectionInstance = fg(this.projection)), this.projectionInstance;\n      }\n      destroy() {\n        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n      }\n      addToLineVertexArray(t, e) {\n        const r = this.lineVertexArray.length;\n        if (void 0 !== t.segment) for (const {\n          x: t,\n          y: r\n        } of e) this.lineVertexArray.emplaceBack(t, r);\n        return {\n          lineStartIndex: r,\n          lineLength: this.lineVertexArray.length - r\n        };\n      }\n      addSymbols(t, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m) {\n        const y = t.indexArray,\n          g = t.layoutVertexArray,\n          x = t.globeExtVertexArray,\n          v = t.segments.prepareSegment(4 * e.length, g, y, this.canOverlap ? a.sortKey : void 0),\n          b = this.glyphOffsetArray.length,\n          _ = v.vertexLength,\n          w = this.allowVerticalPlacement && s === jm.vertical ? Math.PI / 2 : 0,\n          M = a.text && a.text.sections;\n        for (let n = 0; n < e.length; n++) {\n          const {\n              tl: i,\n              tr: s,\n              bl: u,\n              br: c,\n              texPrimary: h,\n              texSecondary: b,\n              pixelOffsetTL: _,\n              pixelOffsetBR: A,\n              minFontScaleX: S,\n              minFontScaleY: I,\n              glyphOffset: k,\n              isSDF: P,\n              sectionIndex: E\n            } = e[n],\n            z = v.vertexLength,\n            T = k[1];\n          if (yg(g, l.x, l.y, i.x, T + i.y, h.x, h.y, r, P, _.x, _.y, S, I), yg(g, l.x, l.y, s.x, T + s.y, h.x + h.w, h.y, r, P, A.x, _.y, S, I), yg(g, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, P, _.x, A.y, S, I), yg(g, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, P, A.x, A.y, S, I), o) {\n            const {\n                x: e,\n                y: r,\n                z: n\n              } = o.anchor,\n              [i, a, s] = o.up;\n            xg(x, e, r, n, i, a, s), xg(x, e, r, n, i, a, s), xg(x, e, r, n, i, a, s), xg(x, e, r, n, i, a, s), vg(t.dynamicLayoutVertexArray, e, r, n, w);\n          } else vg(t.dynamicLayoutVertexArray, l.x, l.y, l.z, w);\n          if (m) {\n            const e = b || h;\n            gg(t.iconTransitioningVertexArray, e.x, e.y), gg(t.iconTransitioningVertexArray, e.x + e.w, e.y), gg(t.iconTransitioningVertexArray, e.x, e.y + e.h), gg(t.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);\n          }\n          y.emplaceBack(z, z + 1, z + 2), y.emplaceBack(z + 1, z + 2, z + 3), v.vertexLength += 4, v.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(k[0]), n !== e.length - 1 && E === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(g.length, a, a.index, {}, p, f, d, M && M[E]);\n        }\n        const A = o ? o.anchor : l;\n        t.placedSymbolArray.emplaceBack(A.x, A.y, A.z, l.x, l.y, b, this.glyphOffsetArray.length - b, _, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], s, 0, !1, 0, h, 0);\n      }\n      _commitLayoutVertex(t, e, r, n, i, a, s) {\n        t.emplaceBack(e, r, n, i, a, Math.round(s.x), Math.round(s.y));\n      }\n      _addCollisionDebugVertices(t, e, r, n, i, a, s) {\n        const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),\n          l = o.vertexLength,\n          u = s.tileAnchorX,\n          c = s.tileAnchorY;\n        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);\n        this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t.padding, s.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new g(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new g(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new g(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new g(t.x1, t.y2)), o.vertexLength += 4;\n        const h = r.indexArray;\n        h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;\n      }\n      _addTextDebugCollisionBoxes(t, e, r, n, i, a) {\n        for (let s = n; s < i; s++) {\n          const n = r.get(s),\n            i = this.getSymbolInstanceTextSize(t, a, e, s);\n          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, a);\n        }\n      }\n      _addIconDebugCollisionBoxes(t, e, r, n, i, a) {\n        for (let s = n; s < i; s++) {\n          const n = r.get(s),\n            i = this.getSymbolInstanceIconSize(t, e, a.placedIconSymbolIndex);\n          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, a);\n        }\n      }\n      generateCollisionDebugBuffers(t, e) {\n        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new wg(Is, rm.members, As), this.iconCollisionBox = new wg(Is, rm.members, As);\n        const r = lm(this.iconSizeData, t),\n          n = lm(this.textSizeData, t);\n        for (let i = 0; i < this.symbolInstances.length; i++) {\n          const a = this.symbolInstances.get(i);\n          this._addTextDebugCollisionBoxes(n, t, e, a.textBoxStartIndex, a.textBoxEndIndex, a), this._addTextDebugCollisionBoxes(n, t, e, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a), this._addIconDebugCollisionBoxes(r, t, e, a.iconBoxStartIndex, a.iconBoxEndIndex, a), this._addIconDebugCollisionBoxes(r, t, e, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex, a);\n        }\n      }\n      getSymbolInstanceTextSize(t, e, r, n) {\n        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),\n          a = om(this.textSizeData, t, i) / im;\n        return this.tilePixelRatio * a;\n      }\n      getSymbolInstanceIconSize(t, e, r) {\n        const n = this.icon.placedSymbolArray.get(r),\n          i = om(this.iconSizeData, t, n);\n        return this.tilePixelRatio * i;\n      }\n      _commitDebugCollisionVertexUpdate(t, e, r, n) {\n        t.emplaceBack(e, -r, -r, n), t.emplaceBack(e, r, -r, n), t.emplaceBack(e, r, r, n), t.emplaceBack(e, -r, r, n);\n      }\n      _updateTextDebugCollisionBoxes(t, e, r, n, i, a) {\n        for (let s = n; s < i; s++) {\n          const n = r.get(s),\n            i = this.getSymbolInstanceTextSize(t, a, e, s);\n          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, a.zOffset);\n        }\n      }\n      _updateIconDebugCollisionBoxes(t, e, r, n, i, a) {\n        for (let s = n; s < i; s++) {\n          const n = r.get(s),\n            i = this.getSymbolInstanceIconSize(t, e, a.placedIconSymbolIndex);\n          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, a.zOffset);\n        }\n      }\n      updateCollisionDebugBuffers(t, e) {\n        if (!this.hasDebugData()) return;\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();\n        const r = lm(this.iconSizeData, t),\n          n = lm(this.textSizeData, t);\n        for (let i = 0; i < this.symbolInstances.length; i++) {\n          const a = this.symbolInstances.get(i);\n          this._updateTextDebugCollisionBoxes(n, t, e, a.textBoxStartIndex, a.textBoxEndIndex, a), this._updateTextDebugCollisionBoxes(n, t, e, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a), this._updateIconDebugCollisionBoxes(r, t, e, a.iconBoxStartIndex, a.iconBoxEndIndex, a), this._updateIconDebugCollisionBoxes(r, t, e, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex, a);\n        }\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);\n      }\n      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, a, s, o, l) {\n        const u = {};\n        if (e < r) {\n          const {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: a,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(e);\n          u.textBox = {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: a,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.textFeatureIndex = f;\n        }\n        if (n < i) {\n          const {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: a,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(n);\n          u.verticalTextBox = {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: a,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalTextFeatureIndex = f;\n        }\n        if (a < s) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(a);\n          u.iconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.iconFeatureIndex = f;\n        }\n        if (o < l) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: a,\n            projectedAnchorX: s,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(o);\n          u.verticalIconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: a,\n            projectedAnchorX: s,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalIconFeatureIndex = f;\n        }\n        return u;\n      }\n      deserializeCollisionBoxes(t) {\n        this.collisionArrays = [];\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n        }\n      }\n      hasTextData() {\n        return this.text.segments.get().length > 0;\n      }\n      hasIconData() {\n        return this.icon.segments.get().length > 0;\n      }\n      hasDebugData() {\n        return this.textCollisionBox && this.iconCollisionBox;\n      }\n      hasTextCollisionBoxData() {\n        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n      }\n      hasIconCollisionBoxData() {\n        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n      }\n      hasIconTextFit() {\n        return this.hasAnyIconTextFit;\n      }\n      addIndicesForPlacedSymbol(t, e) {\n        const r = t.placedSymbolArray.get(e),\n          n = r.vertexStartIndex + 4 * r.numGlyphs;\n        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n      }\n      getSortedSymbolIndexes(t) {\n        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n        const e = Math.sin(t),\n          r = Math.cos(t),\n          n = [],\n          i = [],\n          a = [];\n        for (let t = 0; t < this.symbolInstances.length; ++t) {\n          a.push(t);\n          const s = this.symbolInstances.get(t);\n          n.push(0 | Math.round(e * s.tileAnchorX + r * s.tileAnchorY)), i.push(s.featureIndex);\n        }\n        return a.sort((t, e) => n[t] - n[e] || i[e] - i[t]), a;\n      }\n      getSortedIndexesByZOffset() {\n        if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;\n        if (!this.symbolInstanceIndexesSortedZOffset) {\n          this.symbolInstanceIndexesSortedZOffset = [];\n          for (let t = 0; t < this.symbolInstances.length; ++t) this.symbolInstanceIndexesSortedZOffset.push(t);\n        }\n        return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t, e) => this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t).zOffset);\n      }\n      addToSortKeyRanges(t, e) {\n        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n          sortKey: e,\n          symbolInstanceStart: t,\n          symbolInstanceEnd: t + 1\n        });\n      }\n      sortFeatures(t) {\n        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n          for (const t of this.symbolInstanceIndexes) {\n            const e = this.symbolInstances.get(t);\n            this.featureSortOrder.push(e.featureIndex);\n            const {\n              rightJustifiedTextSymbolIndex: r,\n              centerJustifiedTextSymbolIndex: n,\n              leftJustifiedTextSymbolIndex: i,\n              verticalPlacedTextSymbolIndex: a,\n              placedIconSymbolIndex: s,\n              verticalPlacedIconSymbolIndex: o\n            } = e;\n            r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), a >= 0 && this.addIndicesForPlacedSymbol(this.text, a), s >= 0 && this.addIndicesForPlacedSymbol(this.icon, s), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);\n          }\n          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n        }\n      }\n    }\n    ra(Mg, \"SymbolBucket\", {\n      omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n    }), Mg.addDynamicAttributes = vg;\n    const Ag = new Oa({\n      \"symbol-placement\": new La(qa.layout_symbol[\"symbol-placement\"]),\n      \"symbol-spacing\": new La(qa.layout_symbol[\"symbol-spacing\"]),\n      \"symbol-avoid-edges\": new La(qa.layout_symbol[\"symbol-avoid-edges\"]),\n      \"symbol-sort-key\": new Fa(qa.layout_symbol[\"symbol-sort-key\"]),\n      \"symbol-z-order\": new La(qa.layout_symbol[\"symbol-z-order\"]),\n      \"symbol-z-elevate\": new La(qa.layout_symbol[\"symbol-z-elevate\"]),\n      \"icon-allow-overlap\": new La(qa.layout_symbol[\"icon-allow-overlap\"]),\n      \"icon-ignore-placement\": new La(qa.layout_symbol[\"icon-ignore-placement\"]),\n      \"icon-optional\": new La(qa.layout_symbol[\"icon-optional\"]),\n      \"icon-rotation-alignment\": new La(qa.layout_symbol[\"icon-rotation-alignment\"]),\n      \"icon-size\": new Fa(qa.layout_symbol[\"icon-size\"]),\n      \"icon-text-fit\": new Fa(qa.layout_symbol[\"icon-text-fit\"]),\n      \"icon-text-fit-padding\": new Fa(qa.layout_symbol[\"icon-text-fit-padding\"]),\n      \"icon-image\": new Fa(qa.layout_symbol[\"icon-image\"]),\n      \"icon-rotate\": new Fa(qa.layout_symbol[\"icon-rotate\"]),\n      \"icon-padding\": new La(qa.layout_symbol[\"icon-padding\"]),\n      \"icon-keep-upright\": new La(qa.layout_symbol[\"icon-keep-upright\"]),\n      \"icon-offset\": new Fa(qa.layout_symbol[\"icon-offset\"]),\n      \"icon-anchor\": new Fa(qa.layout_symbol[\"icon-anchor\"]),\n      \"icon-pitch-alignment\": new La(qa.layout_symbol[\"icon-pitch-alignment\"]),\n      \"text-pitch-alignment\": new La(qa.layout_symbol[\"text-pitch-alignment\"]),\n      \"text-rotation-alignment\": new La(qa.layout_symbol[\"text-rotation-alignment\"]),\n      \"text-field\": new Fa(qa.layout_symbol[\"text-field\"]),\n      \"text-font\": new Fa(qa.layout_symbol[\"text-font\"]),\n      \"text-size\": new Fa(qa.layout_symbol[\"text-size\"]),\n      \"text-max-width\": new Fa(qa.layout_symbol[\"text-max-width\"]),\n      \"text-line-height\": new Fa(qa.layout_symbol[\"text-line-height\"]),\n      \"text-letter-spacing\": new Fa(qa.layout_symbol[\"text-letter-spacing\"]),\n      \"text-justify\": new Fa(qa.layout_symbol[\"text-justify\"]),\n      \"text-radial-offset\": new Fa(qa.layout_symbol[\"text-radial-offset\"]),\n      \"text-variable-anchor\": new La(qa.layout_symbol[\"text-variable-anchor\"]),\n      \"text-anchor\": new Fa(qa.layout_symbol[\"text-anchor\"]),\n      \"text-max-angle\": new La(qa.layout_symbol[\"text-max-angle\"]),\n      \"text-writing-mode\": new La(qa.layout_symbol[\"text-writing-mode\"]),\n      \"text-rotate\": new Fa(qa.layout_symbol[\"text-rotate\"]),\n      \"text-padding\": new La(qa.layout_symbol[\"text-padding\"]),\n      \"text-keep-upright\": new La(qa.layout_symbol[\"text-keep-upright\"]),\n      \"text-transform\": new Fa(qa.layout_symbol[\"text-transform\"]),\n      \"text-offset\": new Fa(qa.layout_symbol[\"text-offset\"]),\n      \"text-allow-overlap\": new La(qa.layout_symbol[\"text-allow-overlap\"]),\n      \"text-ignore-placement\": new La(qa.layout_symbol[\"text-ignore-placement\"]),\n      \"text-optional\": new La(qa.layout_symbol[\"text-optional\"]),\n      visibility: new La(qa.layout_symbol.visibility)\n    });\n    var Sg = {\n      paint: new Oa({\n        \"icon-opacity\": new Fa(qa.paint_symbol[\"icon-opacity\"]),\n        \"icon-emissive-strength\": new Fa(qa.paint_symbol[\"icon-emissive-strength\"]),\n        \"text-emissive-strength\": new Fa(qa.paint_symbol[\"text-emissive-strength\"]),\n        \"icon-color\": new Fa(qa.paint_symbol[\"icon-color\"]),\n        \"icon-halo-color\": new Fa(qa.paint_symbol[\"icon-halo-color\"]),\n        \"icon-halo-width\": new Fa(qa.paint_symbol[\"icon-halo-width\"]),\n        \"icon-halo-blur\": new Fa(qa.paint_symbol[\"icon-halo-blur\"]),\n        \"icon-translate\": new La(qa.paint_symbol[\"icon-translate\"]),\n        \"icon-translate-anchor\": new La(qa.paint_symbol[\"icon-translate-anchor\"]),\n        \"icon-image-cross-fade\": new Fa(qa.paint_symbol[\"icon-image-cross-fade\"]),\n        \"text-opacity\": new Fa(qa.paint_symbol[\"text-opacity\"]),\n        \"text-color\": new Fa(qa.paint_symbol[\"text-color\"], {\n          runtimeType: _e,\n          getOverride: t => t.textColor,\n          hasOverride: t => !!t.textColor\n        }),\n        \"text-halo-color\": new Fa(qa.paint_symbol[\"text-halo-color\"]),\n        \"text-halo-width\": new Fa(qa.paint_symbol[\"text-halo-width\"]),\n        \"text-halo-blur\": new Fa(qa.paint_symbol[\"text-halo-blur\"]),\n        \"text-translate\": new La(qa.paint_symbol[\"text-translate\"]),\n        \"text-translate-anchor\": new La(qa.paint_symbol[\"text-translate-anchor\"]),\n        \"icon-color-saturation\": new La(qa.paint_symbol[\"icon-color-saturation\"])\n      }),\n      layout: Ag\n    };\n    class Ig {\n      constructor(t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : ge, this.defaultValue = t;\n      }\n      evaluate(t) {\n        if (t.formattedSection) {\n          const e = this.defaultValue.property.overrides;\n          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n        }\n        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n      }\n      eachChild(t) {\n        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return null;\n      }\n    }\n    ra(Ig, \"FormatSectionOverride\", {\n      omit: [\"defaultValue\"]\n    });\n    class kg extends ss {\n      constructor(t, e, r) {\n        super(t, Sg, e, r);\n      }\n      recalculate(t, e) {\n        super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\"));\n        const r = this.layout.get(\"text-writing-mode\");\n        if (r) {\n          const t = [];\n          for (const e of r) t.indexOf(e) < 0 && t.push(e);\n          this.layout._values[\"text-writing-mode\"] = t;\n        } else this.layout._values[\"text-writing-mode\"] = \"point\" === this.layout.get(\"symbol-placement\") ? [\"horizontal\"] : [\"horizontal\", \"vertical\"];\n        this._setPaintOverrides();\n      }\n      getValueAndResolveTokens(t, e, r, n) {\n        const i = this.layout.get(t).evaluate(e, {}, r, n),\n          a = this._unevaluatedLayout._values[t];\n        return a.isDataDriven() || $i(a.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n        }(e.properties, i);\n      }\n      createBucket(t) {\n        return new Mg(t);\n      }\n      queryRadius() {\n        return 0;\n      }\n      queryIntersectsFeature() {\n        return !1;\n      }\n      _setPaintOverrides() {\n        for (const t of Sg.paint.overridableProperties) {\n          if (!kg.hasPaintOverride(this.layout, t)) continue;\n          const e = this.paint.get(t),\n            r = new Ig(e),\n            n = new qi(r, e.property.specification, this.scope, this.options);\n          let i = null;\n          i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new Yi(\"source\", n) : new Xi(\"composite\", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new Da(e.property, i, e.parameters);\n        }\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && kg.hasPaintOverride(this.layout, t);\n      }\n      static hasPaintOverride(t, e) {\n        const r = t.get(\"text-field\"),\n          n = Sg.paint.properties[e];\n        let i = !1;\n        const a = t => {\n          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n        };\n        if (\"constant\" === r.value.kind && r.value.value instanceof De) a(r.value.value.sections);else if (\"source\" === r.value.kind) {\n          const t = e => {\n              i || (e instanceof je && Ne(e.value) === Se ? a(e.value.sections) : e instanceof Xe ? a(e.sections) : e.eachChild(t));\n            },\n            e = r.value;\n          e._styleExpression && t(e._styleExpression.expression);\n        }\n        return i;\n      }\n      getProgramIds() {\n        const t = 0 !== this.paint.get(\"icon-opacity\").constantOr(1),\n          e = 0 !== this.paint.get(\"text-opacity\").constantOr(1),\n          r = [];\n        return t && r.push(\"symbolIcon\"), e && r.push(\"symbolSDF\"), r;\n      }\n      getDefaultProgramParams(t, e) {\n        return {\n          config: new Do(this, e),\n          overrideFog: !1\n        };\n      }\n    }\n    const Pg = new Oa({\n      visibility: new La(qa.layout_background.visibility)\n    });\n    var Eg = {\n      paint: new Oa({\n        \"background-color\": new La(qa.paint_background[\"background-color\"]),\n        \"background-pattern\": new La(qa.paint_background[\"background-pattern\"]),\n        \"background-opacity\": new La(qa.paint_background[\"background-opacity\"]),\n        \"background-emissive-strength\": new La(qa.paint_background[\"background-emissive-strength\"])\n      }),\n      layout: Pg\n    };\n    const zg = new Oa({\n      visibility: new La(qa.layout_raster.visibility)\n    });\n    var Tg = {\n        paint: new Oa({\n          \"raster-opacity\": new La(qa.paint_raster[\"raster-opacity\"]),\n          \"raster-color\": new Na(qa.paint_raster[\"raster-color\"]),\n          \"raster-color-mix\": new La(qa.paint_raster[\"raster-color-mix\"]),\n          \"raster-color-range\": new La(qa.paint_raster[\"raster-color-range\"]),\n          \"raster-hue-rotate\": new La(qa.paint_raster[\"raster-hue-rotate\"]),\n          \"raster-brightness-min\": new La(qa.paint_raster[\"raster-brightness-min\"]),\n          \"raster-brightness-max\": new La(qa.paint_raster[\"raster-brightness-max\"]),\n          \"raster-saturation\": new La(qa.paint_raster[\"raster-saturation\"]),\n          \"raster-contrast\": new La(qa.paint_raster[\"raster-contrast\"]),\n          \"raster-resampling\": new La(qa.paint_raster[\"raster-resampling\"]),\n          \"raster-fade-duration\": new La(qa.paint_raster[\"raster-fade-duration\"]),\n          \"raster-emissive-strength\": new La(qa.paint_raster[\"raster-emissive-strength\"]),\n          \"raster-array-band\": new La(qa.paint_raster[\"raster-array-band\"]),\n          \"raster-elevation\": new La(qa.paint_raster[\"raster-elevation\"])\n        }),\n        layout: zg\n      },\n      Bg = cs([{\n        name: \"a_pos\",\n        type: \"Int16\",\n        components: 2\n      }, {\n        name: \"a_texture_pos\",\n        type: \"Int16\",\n        components: 2\n      }]);\n    class Cg {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);\n      }\n      update(t, e, r) {\n        const {\n            width: n,\n            height: i\n          } = t,\n          {\n            context: a\n          } = this,\n          {\n            gl: s\n          } = a;\n        if (s.bindTexture(s.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA && (!e || !1 !== e.premultiply)), r || this.size && this.size[0] === n && this.size[1] === i) {\n          const {\n            x: e,\n            y: a\n          } = r || {\n            x: 0,\n            y: 0\n          };\n          if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ImageBitmap && t instanceof ImageBitmap) s.texSubImage2D(s.TEXTURE_2D, 0, e, a, s.RGBA, s.UNSIGNED_BYTE, t);else {\n            let r = this.format,\n              o = s.UNSIGNED_BYTE;\n            this.format === s.R32F && (r = s.RED, o = s.FLOAT), s.texSubImage2D(s.TEXTURE_2D, 0, e, a, n, i, r, o, t.data);\n          }\n        } else if (this.size = [n, i], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ImageBitmap && t instanceof ImageBitmap) {\n          let e = this.format;\n          this.format === s.R8 && (e = s.RED), s.texImage2D(s.TEXTURE_2D, 0, this.format, e, s.UNSIGNED_BYTE, t);\n        } else {\n          let e = this.format,\n            r = this.format,\n            a = s.UNSIGNED_BYTE;\n          this.format === s.DEPTH_COMPONENT && (e = s.DEPTH_COMPONENT16, a = s.UNSIGNED_SHORT), this.format === s.R8 && (r = s.RED), this.format === s.R32F && (a = s.FLOAT, r = s.RED), s.texImage2D(s.TEXTURE_2D, 0, e, n, i, 0, r, a, t.data);\n        }\n        this.useMipmap = Boolean(e && e.useMipmap), this.useMipmap && s.generateMipmap(s.TEXTURE_2D);\n      }\n      bind(t, e, r = !1) {\n        const {\n            context: n\n          } = this,\n          {\n            gl: i\n          } = n;\n        i.bindTexture(i.TEXTURE_2D, this.texture), t !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t), this.minFilter = t), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n      bindExtraParam(t, e, r, n) {\n        const {\n            context: i\n          } = this,\n          {\n            gl: a\n          } = i;\n        a.bindTexture(a.TEXTURE_2D, this.texture), e !== this.magFilter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e), this.magFilter = e), t !== this.minFilter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, this.useMipmap ? t === a.NEAREST ? a.NEAREST_MIPMAP_NEAREST : a.LINEAR_MIPMAP_LINEAR : t), this.minFilter = t), r !== this.wrapS && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, n), this.wrapT = n);\n      }\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n    }\n    class Rg {\n      constructor(t, e) {\n        this.context = t, this.texture = e;\n      }\n      bind(t, e) {\n        const {\n            context: r\n          } = this,\n          {\n            gl: n\n          } = r;\n        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t), this.minFilter = t), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n    }\n    function Dg(e, r, n, i, a, s, o, l) {\n      const u = [e, r, 1, n, i, 1, a, s, 1],\n        c = [o, l, 1],\n        h = t.co.adjoint([], u),\n        [p, f, d] = t.N.transformMat3(c, c, h);\n      return t.co.multiply(u, u, [p, 0, 0, 0, f, 0, 0, 0, d]);\n    }\n    function Vg(e, r, n, i, a, s, o, l) {\n      const u = function (e, r, n, i, a, s, o, l) {\n        const u = Dg(0, 0, 1, 0, 1, 1, 0, 1),\n          c = Dg(e, r, n, i, a, s, o, l),\n          h = t.co.adjoint([], u);\n        return t.co.multiply(c, c, h);\n      }(e, r, n, i, a, s, o, l);\n      return [u[2] / u[8] / Tr, u[5] / u[8] / Tr];\n    }\n    function Lg(t) {\n      return [t[0], Math.min(Math.max(t[1], -xl), xl)];\n    }\n    class Fg extends ee {\n      constructor(t, e, r, n) {\n        super(), this.id = t, this.dispatcher = r, this.coordinates = e.coordinates, this.type = \"image\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;\n      }\n      load(t, e) {\n        if (this._loaded = e || !1, this.fire(new Qt(\"dataloading\", {\n          dataType: \"source\"\n        })), this.url = this.options.url, !this.url) return t && (this.coordinates = t), this._loaded = !0, void this._finishLoading();\n        this._imageRequest = Ct(this.map._requestManager.transformRequest(this.url, At.Image), (e, r) => {\n          this._imageRequest = null, this._loaded = !0, e ? this.fire(new te(e)) : r && (this.image = r instanceof HTMLImageElement ? st.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading());\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      updateImage(t) {\n        return t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t.url, this.load(t.coordinates, this._loaded), this) : this;\n      }\n      setTexture(t) {\n        if (!(t.handle instanceof WebGLTexture)) throw new Error(\"The provided handle is not a WebGLTexture instance\");\n        return this.texture = new Rg(this.map.painter.context, t.handle), this.width = t.dimensions[0], this.height = t.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;\n      }\n      _finishLoading() {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new Qt(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"metadata\"\n        })));\n      }\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n      onRemove() {\n        this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Rg || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());\n      }\n      setCoordinates(t) {\n        if (this.coordinates = t, this._boundsArray = void 0, this._unsupportedCoords = !1, !t.length) return this;\n        this.onNorthPole = !1, this.onSouthPole = !1;\n        let e = t[0][1],\n          r = t[0][1];\n        for (const n of t) n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);\n        const n = (r + e) / 2;\n        if (n > xl ? this.onNorthPole = !0 : n < -xl && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {\n          const e = t.map(Ml.fromLngLat);\n          this.tileID = function (t) {\n            let e = 1 / 0,\n              r = 1 / 0,\n              n = -1 / 0,\n              i = -1 / 0;\n            for (const a of t) e = Math.min(e, a.x), r = Math.min(r, a.y), n = Math.max(n, a.x), i = Math.max(i, a.y);\n            const a = Math.max(n - e, i - r),\n              s = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)),\n              o = Math.pow(2, s);\n            let l = Math.floor((e + n) / 2 * o);\n            return l > 1 && (l -= 1), new il(s, l, Math.floor((r + i) / 2 * o));\n          }(e), this.minzoom = this.maxzoom = this.tileID.z;\n        }\n        return this.fire(new Qt(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"content\"\n        })), this;\n      }\n      _clear() {\n        this._boundsArray = void 0, this._unsupportedCoords = !1;\n      }\n      _prepareData(e) {\n        for (const t in this.tiles) {\n          const e = this.tiles[t];\n          \"loaded\" !== e.state && (e.state = \"loaded\", e.texture = this.texture);\n        }\n        if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;\n        const r = Gy(new il(0, 0, 0), this.map.transform.projection),\n          n = [r.projection.project(this.coordinates[0][0], this.coordinates[0][1]), r.projection.project(this.coordinates[1][0], this.coordinates[1][1]), r.projection.project(this.coordinates[2][0], this.coordinates[2][1]), r.projection.project(this.coordinates[3][0], this.coordinates[3][1])];\n        if (!function (t) {\n          const e = t[1].x - t[0].x,\n            r = t[1].y - t[0].y,\n            n = t[2].x - t[1].x,\n            i = t[2].y - t[1].y,\n            a = t[3].x - t[2].x,\n            s = t[3].y - t[2].y,\n            o = t[0].x - t[3].x,\n            l = t[0].y - t[3].y,\n            u = e * i - n * r,\n            c = n * s - a * i,\n            h = a * l - o * s,\n            p = o * r - e * l;\n          return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;\n        }(n)) return console.warn(\"Image source coordinates are defining non-convex area in the Mercator projection\"), void (this._unsupportedCoords = !0);\n        const i = Gy(this.tileID, this.map.transform.projection),\n          [a, s, o, l] = this.coordinates.map(t => {\n            const e = i.projection.project(t[0], t[1]);\n            return Yy(i, e)._round();\n          });\n        this.perspectiveTransform = Vg(a.x, a.y, s.x, s.y, o.x, o.y, l.x, l.y);\n        const u = this._boundsArray = new ds();\n        u.emplaceBack(a.x, a.y, 0, 0), u.emplaceBack(s.x, s.y, Tr, 0), u.emplaceBack(l.x, l.y, 0, Tr), u.emplaceBack(o.x, o.y, Tr, Tr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(u, Bg.members), this.boundsSegments = eo.simpleSegment(0, 0, 4, 2);\n        const c = [],\n          h = [Lg((p = this.coordinates)[0]), Lg(p[1]), Lg(p[2]), Lg(p[3])];\n        var p;\n        const [f, d, m, y] = function (t) {\n          let e = t[0][0],\n            r = e,\n            n = t[0][1],\n            i = n;\n          for (let a = 1; a < t.length; a++) t[a][0] < e ? e = t[a][0] : t[a][0] > r && (r = t[a][0]), t[a][1] < n ? n = t[a][1] : t[a][1] > i && (i = t[a][1]);\n          return [e, n, r - e, i - n];\n        }(h);\n        {\n          const i = new ds(),\n            [a, s, o, l] = function (t) {\n              let e = t[0].x,\n                r = e,\n                n = t[0].y,\n                i = n;\n              for (let a = 1; a < t.length; a++) t[a].x < e ? e = t[a].x : t[a].x > r && (r = t[a].x), t[a].y < n ? n = t[a].y : t[a].y > i && (i = t[a].y);\n              return [e, n, r - e, i - n];\n            }(n),\n            u = t => [(t.x - a) / o, (t.y - s) / l],\n            [h, p, g, x] = n.map(u),\n            v = function (e, r, n, i, a, s, o, l) {\n              const u = Dg(0, 0, 1, 0, 1, 1, 0, 1),\n                c = Dg(e, r, n, i, a, s, o, l),\n                h = t.co.adjoint([], c);\n              return t.co.multiply(u, u, h);\n            }(h[0], h[1], p[0], p[1], g[0], g[1], x[0], x[1]);\n          this.elevatedGlobePerspectiveTransform = Vg(h[0], h[1], p[0], p[1], g[0], g[1], x[0], x[1]);\n          const b = (e, r) => {\n              c.push(e.lng);\n              const n = Math.round((e.lng - f) / m * Tr),\n                a = Math.round((e.lat - d) / y * Tr),\n                s = u(r),\n                o = t.N.transformMat3([], [s[0], s[1], 1], v),\n                l = Math.round(o[0] / o[2] * Tr),\n                h = Math.round(o[1] / o[2] * Tr);\n              i.emplaceBack(n, a, l, h);\n            },\n            _ = n[3].x - n[0].x,\n            w = n[3].y - n[0].y,\n            M = n[2].x - n[1].x,\n            A = n[2].y - n[1].y;\n          for (let t = 0; t < 65; t++) {\n            const e = t / 64,\n              i = [n[0].x + e * _, n[0].y + e * w],\n              a = [n[1].x + e * M, n[1].y + e * A],\n              s = a[0] - i[0],\n              o = a[1] - i[1];\n            for (let t = 0; t < 65; t++) {\n              const e = t / 64,\n                n = {\n                  x: i[0] + s * e,\n                  y: i[1] + o * e,\n                  z: 0\n                };\n              b(r.projection.unproject(n.x, n.y), n);\n            }\n          }\n          this.elevatedGlobeVertexBuffer = e.createVertexBuffer(i, Bg.members);\n        }\n        {\n          this.maxLongitudeTriangleSize = 0;\n          let t = [],\n            r = new Es();\n          const n = (e, n, i) => {\n            r.emplaceBack(e, n, i);\n            const a = c[e],\n              s = c[n],\n              o = c[i],\n              l = Math.min(Math.min(a, s), o),\n              u = Math.max(Math.max(a, s), o) - l;\n            u > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u), t.push(l + u / 2);\n          };\n          for (let t = 0; t < 64; t++) for (let e = 0; e < 64; e++) {\n            const r = 65 * t + e,\n              i = r + 1,\n              a = r + 65,\n              s = a + 1;\n            n(r, a, i), n(i, a, s);\n          }\n          [t, r] = function (t, e) {\n            const r = Array.from({\n              length: t.length\n            }, (t, e) => e);\n            r.sort((e, r) => t[e] - t[r]);\n            const n = [],\n              i = new Es();\n            for (let a = 0; a < r.length; a++) {\n              const s = r[a];\n              n.push(t[s]);\n              const o = 3 * s,\n                l = o + 1;\n              i.emplaceBack(e.uint16[o], e.uint16[l], e.uint16[l + 1]);\n            }\n            return [n, i];\n          }(t, r), this.elevatedGlobeTrianglesCenterLongitudes = t, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(r);\n        }\n        this.elevatedGlobeSegments = eo.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, m / Tr, 0, y / Tr, 0, 0, d, f, 0]);\n      }\n      prepare() {\n        const t = 0 !== Object.keys(this.tiles).length;\n        if (this.tileID && !t) return;\n        const e = this.map.painter.context,\n          r = e.gl;\n        !this._dirty || this.texture instanceof Rg || (this.texture ? this.texture.update(this.image) : (this.texture = new Cg(e, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t && this._prepareData(e);\n      }\n      loadTile(t, e) {\n        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = \"errored\", e(null));\n      }\n      serialize() {\n        return {\n          type: \"image\",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }\n      hasTransition() {\n        return !1;\n      }\n      getSegmentsForLongitude(t) {\n        const e = this.elevatedGlobeSegments;\n        if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;\n        const r = this.elevatedGlobeTrianglesCenterLongitudes;\n        let n = ((t, e) => t + 360 * Math.round((e - t) / 360))(t + 180, r[0]);\n        const i = new eo(),\n          a = (t, r) => {\n            i.segments.push({\n              vertexOffset: 0,\n              primitiveOffset: t,\n              vertexLength: e.segments[0].vertexLength,\n              primitiveLength: r,\n              sortKey: void 0,\n              vaos: {}\n            });\n          },\n          s = .51 * this.maxLongitudeTriangleSize;\n        if (Math.abs(r[0] - n) <= s) {\n          const t = it(r, 0, r.length, n + s);\n          return t === r.length || a(t, nt(r, t + 1, r.length, n + 360 - s) - t), i;\n        }\n        n < r[0] && (n += 360);\n        const o = nt(r, 0, r.length, n - s);\n        if (o === r.length) return a(0, r.length), i;\n        a(0, o - 0);\n        const l = it(r, o + 1, r.length, n + s);\n        return l !== r.length && a(l, r.length - l), i;\n      }\n    }\n    const Ng = (Math.pow(256, 2) - 1) / 16907520;\n    class Og extends ss {\n      constructor(t, e, r) {\n        super(t, Tg, e, r), this.updateColorRamp(), this._curRampRange = [NaN, NaN];\n      }\n      getProgramIds() {\n        return [\"raster\"];\n      }\n      hasColorMap() {\n        return !!this._transitionablePaint._values[\"raster-color\"].value.value;\n      }\n      tileCoverLift() {\n        return this.paint.get(\"raster-elevation\");\n      }\n      isLayerDraped(t) {\n        return !(t && t._source instanceof Fg && (t._source.onNorthPole || t._source.onSouthPole)) && 0 === this.paint.get(\"raster-elevation\");\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"raster-color\" !== t && \"raster-color-range\" !== t || (this._curRampRange = [NaN, NaN], this.updateColorRamp());\n      }\n      updateColorRamp(t) {\n        if (!this.hasColorMap()) return;\n        if (!this._curRampRange) return;\n        const e = this._transitionablePaint._values[\"raster-color\"].value.expression,\n          [r, n] = t || this._transitionablePaint._values[\"raster-color-range\"].value.expression.evaluate({\n            zoom: 0\n          }) || [NaN, NaN];\n        isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = Ap({\n          expression: e,\n          evaluationKey: \"rasterValue\",\n          image: this.colorRamp,\n          clips: [{\n            start: r,\n            end: n\n          }],\n          resolution: 256\n        }), this.colorRampTexture = null, this._curRampRange = [r, n]);\n      }\n    }\n    const Ug = new Oa({\n      visibility: new La(qa[\"layout_raster-particle\"].visibility)\n    });\n    var jg = {\n      paint: new Oa({\n        \"raster-particle-array-band\": new La(qa[\"paint_raster-particle\"][\"raster-particle-array-band\"]),\n        \"raster-particle-count\": new La(qa[\"paint_raster-particle\"][\"raster-particle-count\"]),\n        \"raster-particle-color\": new Na(qa[\"paint_raster-particle\"][\"raster-particle-color\"]),\n        \"raster-particle-max-speed\": new La(qa[\"paint_raster-particle\"][\"raster-particle-max-speed\"]),\n        \"raster-particle-speed-factor\": new La(qa[\"paint_raster-particle\"][\"raster-particle-speed-factor\"]),\n        \"raster-particle-fade-opacity-factor\": new La(qa[\"paint_raster-particle\"][\"raster-particle-fade-opacity-factor\"]),\n        \"raster-particle-reset-rate-factor\": new La(qa[\"paint_raster-particle\"][\"raster-particle-reset-rate-factor\"])\n      }),\n      layout: Ug\n    };\n    class qg extends ss {\n      constructor(t, e, r) {\n        super(t, jg, e, r), this._updateColorRamp(), this.onRemove = t => {\n          this.colorRampTexture && this.colorRampTexture.destroy(), this.transformFeedbackObject && t.painter.context.gl.deleteTransformFeedback(this.transformFeedbackObject), this.tileFramebuffer && this.tileFramebuffer.destroy();\n        }, this.lastInvalidatedAt = st.now();\n      }\n      hasColorMap() {\n        return !!this._transitionablePaint._values[\"raster-particle-color\"].value.value;\n      }\n      getProgramIds() {\n        return [\"rasterParticle\"];\n      }\n      hasOffscreenPass() {\n        return \"none\" !== this.visibility;\n      }\n      isLayerDraped(t) {\n        return !1;\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"raster-particle-color\" !== t && \"raster-particle-max-speed\" !== t || (this._updateColorRamp(), this._invalidateAnimationState()), \"raster-particle-count\" === t && this._invalidateAnimationState();\n      }\n      _updateColorRamp() {\n        if (!this.hasColorMap()) return;\n        const t = this._transitionablePaint._values[\"raster-particle-color\"].value.expression,\n          e = this._transitionablePaint._values[\"raster-particle-max-speed\"].value.expression.evaluate({\n            zoom: 0\n          });\n        this.colorRamp = Ap({\n          expression: t,\n          evaluationKey: \"rasterParticleSpeed\",\n          image: this.colorRamp,\n          clips: [{\n            start: 0,\n            end: e\n          }],\n          resolution: 256\n        }), this.colorRampTexture = null;\n      }\n      _invalidateAnimationState() {\n        this.lastInvalidatedAt = st.now();\n      }\n    }\n    class $g extends ss {\n      constructor(t, e) {\n        super(t, {}, e), this.implementation = t, t.slot && (this.slot = t.slot);\n      }\n      is3D() {\n        return \"3d\" === this.implementation.renderingMode;\n      }\n      hasOffscreenPass() {\n        return void 0 !== this.implementation.prerender;\n      }\n      isLayerDraped(t) {\n        return void 0 !== this.implementation.renderToTile;\n      }\n      shouldRedrape() {\n        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();\n      }\n      recalculate() {}\n      updateTransitions() {}\n      hasTransition() {\n        return !1;\n      }\n      serialize() {}\n      onAdd(t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }\n      onRemove(t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }\n    }\n    const Gg = new Oa({\n      visibility: new La(qa.layout_sky.visibility)\n    });\n    var Yg = {\n      paint: new Oa({\n        \"sky-type\": new La(qa.paint_sky[\"sky-type\"]),\n        \"sky-atmosphere-sun\": new La(qa.paint_sky[\"sky-atmosphere-sun\"]),\n        \"sky-atmosphere-sun-intensity\": new La(qa.paint_sky[\"sky-atmosphere-sun-intensity\"]),\n        \"sky-gradient-center\": new La(qa.paint_sky[\"sky-gradient-center\"]),\n        \"sky-gradient-radius\": new La(qa.paint_sky[\"sky-gradient-radius\"]),\n        \"sky-gradient\": new Na(qa.paint_sky[\"sky-gradient\"]),\n        \"sky-atmosphere-halo-color\": new La(qa.paint_sky[\"sky-atmosphere-halo-color\"]),\n        \"sky-atmosphere-color\": new La(qa.paint_sky[\"sky-atmosphere-color\"]),\n        \"sky-opacity\": new La(qa.paint_sky[\"sky-opacity\"])\n      }),\n      layout: Gg\n    };\n    function Xg(e, r, n) {\n      const i = [0, 0, 1],\n        a = t.bi.identity([]);\n      return t.bi.rotateY(a, a, n ? -b(e) + Math.PI : b(e)), t.bi.rotateX(a, a, -b(r)), t.N.transformQuat(i, i, a), t.N.normalize(i, i);\n    }\n    var Zg = {\n      paint: new Oa({})\n    };\n    function Kg(e, r) {\n      const n = Wg(e.projection, e.zoom, e.width, e.height),\n        i = function (e, r, n, i, a) {\n          const s = new tl(n.lng - 180 * Jg, n.lat),\n            o = new tl(n.lng + 180 * Jg, n.lat),\n            l = e.project(s.lng, s.lat),\n            u = e.project(o.lng, o.lat),\n            c = -Math.atan2(u.y - l.y, u.x - l.x),\n            h = Ml.fromLngLat(n);\n          h.y = I(h.y, -1 + Jg, 1 - Jg);\n          const p = h.toLngLat(),\n            f = e.project(p.lng, p.lat),\n            d = Ml.fromLngLat(p);\n          d.x += Jg;\n          const m = d.toLngLat(),\n            y = e.project(m.lng, m.lat),\n            g = tx(y.x - f.x, y.y - f.y, c),\n            x = Ml.fromLngLat(p);\n          x.y += Jg;\n          const v = x.toLngLat(),\n            b = e.project(v.lng, v.lat),\n            _ = tx(b.x - f.x, b.y - f.y, c),\n            w = Math.abs(g.x) / Math.abs(_.y),\n            M = t.a6.identity([]);\n          t.a6.rotateZ(M, M, -c * (1 - (a ? 0 : i)));\n          const A = t.a6.identity([]);\n          return t.a6.scale(A, A, [1, 1 - (1 - w) * i, 1]), A[4] = -_.x / _.y * i, t.a6.rotateZ(A, A, c), t.a6.multiply(A, M, A), A;\n        }(e.projection, 0, e.center, n, r),\n        a = Hg(e);\n      return t.a6.scale(i, i, [a, a, 1]), i;\n    }\n    function Hg(t) {\n      const e = t.projection,\n        r = Wg(t.projection, t.zoom, t.width, t.height),\n        n = Qg(e, t.center),\n        i = Qg(e, tl.convert(e.center));\n      return Math.pow(2, n * r + (1 - r) * i);\n    }\n    function Wg(t, e, r, n, i = 1 / 0) {\n      const a = t.range;\n      if (!a) return 0;\n      const s = Math.min(i, Math.max(r, n)),\n        o = Math.log(s / 1024) / Math.LN2;\n      return k(a[0] + o, a[1] + o, e);\n    }\n    const Jg = 1 / 4e4;\n    function Qg(t, e) {\n      const r = I(e.lat, -xl, xl),\n        n = new tl(e.lng - 180 * Jg, r),\n        i = new tl(e.lng + 180 * Jg, r),\n        a = t.project(n.lng, r),\n        s = t.project(i.lng, r),\n        o = Ml.fromLngLat(n),\n        l = Ml.fromLngLat(i),\n        u = s.x - a.x,\n        c = s.y - a.y,\n        h = l.x - o.x,\n        p = l.y - o.y,\n        f = Math.sqrt((h * h + p * p) / (u * u + c * c));\n      return Math.log(f) / Math.LN2;\n    }\n    function tx(t, e, r) {\n      const n = Math.cos(r),\n        i = Math.sin(r);\n      return {\n        x: t * n - e * i,\n        y: t * i + e * n\n      };\n    }\n    function ex(e, r, n) {\n      t.a6.identity(e), t.a6.rotateZ(e, e, b(r[2])), t.a6.rotateX(e, e, b(r[0])), t.a6.rotateY(e, e, b(r[1])), t.a6.scale(e, e, n), t.a6.multiply(e, e, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\n    }\n    function rx(e, r, n, i, a, s, o, l) {\n      const u = [n[0] - r[0], n[1] - r[1], 0],\n        c = [i[0] - r[0], i[1] - r[1], 0];\n      if (t.N.length(u) < 1e-12 || t.N.length(c) < 1e-12) return t.bi.identity(e);\n      const h = t.N.cross([], u, c);\n      t.N.normalize(h, h), t.N.subtract(c, i, r), u[2] = (s - a) * l, c[2] = (o - a) * l;\n      const p = u;\n      return t.N.cross(p, u, c), t.N.normalize(p, p), t.bi.rotationTo(e, h, p);\n    }\n    function nx(e, r, n = !1) {\n      const i = rp(r.zoom),\n        a = function (e, r, n) {\n          const i = r.worldSize,\n            a = [e[12], e[13], e[14]],\n            s = yl(a[1] / i),\n            o = ml(a[0] / i),\n            l = t.a6.identity([]),\n            u = dl(1, s) * i,\n            c = dl(1, 0) * i * bl(s, r.zoom),\n            h = 1 / Qh(i);\n          let p = c * h;\n          if (n) {\n            const t = Wg(r.projection, r.zoom, r.width, r.height, 1024);\n            p = h * r.projection.pixelSpaceConversion(r.center.lat, i, t);\n          }\n          const f = Wo(s, o);\n          t.N.add(f, f, t.N.scale([], t.N.normalize([], f), u * p * a[2]));\n          const d = function (e) {\n            const r = [e[0], e[1], e[2]];\n            let n = [0, 1, 0];\n            const i = t.N.cross([], n, r);\n            return t.N.cross(n, r, i), 0 === t.N.squaredLength(n) && (n = [0, 1, 0], t.N.cross(i, r, n)), t.N.normalize(i, i), t.N.normalize(n, n), t.N.normalize(r, r), [i[0], i[1], i[2], 0, n[0], n[1], n[2], 0, r[0], r[1], r[2], 0, e[0], e[1], e[2], 1];\n          }(f);\n          t.a6.scale(l, l, [p, p, p * u]), t.a6.translate(l, l, [-a[0], -a[1], -a[2]]);\n          const m = t.a6.multiply([], r.globeMatrix, d);\n          return t.a6.multiply(m, m, l), t.a6.multiply(m, m, e), m;\n        }(e, r, n);\n      if (i > 0) {\n        const n = function (e, r) {\n          const n = r.worldSize,\n            i = dl(1, 0) * n * bl(r.center.lat, r.zoom) / Qh(n),\n            a = dl(1, r.center.lat) * n,\n            s = t.a6.identity([]);\n          return t.a6.rotateY(s, s, b(r.center.lng)), t.a6.rotateX(s, s, b(r.center.lat)), t.a6.translate(s, s, [0, 0, jo]), t.a6.scale(s, s, [i, i, i * a]), t.a6.translate(s, s, [r.point.x - .5 * n, r.point.y - .5 * n, 0]), t.a6.multiply(s, s, e), t.a6.multiply(s, r.globeMatrix, s);\n        }(e, r);\n        return function (e, r, n) {\n          const i = (e, r, n) => {\n              const i = t.N.length(e),\n                a = t.N.length(r),\n                s = qh(e, r, n);\n              return t.N.scale(s, s, 1 / t.N.length(s) * ue(i, a, n));\n            },\n            a = i([e[0], e[1], e[2]], [r[0], r[1], r[2]], n),\n            s = i([e[4], e[5], e[6]], [r[4], r[5], r[6]], n),\n            o = i([e[8], e[9], e[10]], [r[8], r[9], r[10]], n),\n            l = qh([e[12], e[13], e[14]], [r[12], r[13], r[14]], n);\n          return [a[0], a[1], a[2], 0, s[0], s[1], s[2], 0, o[0], o[1], o[2], 0, l[0], l[1], l[2], 1];\n        }(a, n, i);\n      }\n      return a;\n    }\n    function ix(t, e, r, n) {\n      const i = Bh.projectAabbCorners(n, r);\n      let a = Number.MAX_VALUE,\n        s = -1;\n      for (let t = 0; t < i.length; ++t) {\n        const r = i[t];\n        r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < a && (s = t, a = r[2]);\n      }\n      const o = t => new g(i[t][0], i[t][1]);\n      let l;\n      switch (s) {\n        case 0:\n        case 6:\n          l = [o(1), o(5), o(4), o(7), o(3), o(2), o(1)];\n          break;\n        case 1:\n        case 7:\n          l = [o(0), o(4), o(5), o(6), o(2), o(3), o(0)];\n          break;\n        case 3:\n        case 5:\n          l = [o(1), o(0), o(4), o(7), o(6), o(2), o(1)];\n          break;\n        default:\n          l = [o(1), o(5), o(6), o(7), o(3), o(0), o(1)];\n      }\n      if (Vl(t, l)) return a;\n    }\n    const ax = cs([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      sx = cs([{\n        name: \"a_color_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      ox = cs([{\n        name: \"a_color_4f\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      lx = cs([{\n        name: \"a_uv_2f\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      ux = cs([{\n        name: \"a_normal_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      cx = cs([{\n        name: \"a_normal_matrix0\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix1\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix2\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix3\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      hx = cs([{\n        name: \"a_pbr\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_heightBasedEmissiveStrength\",\n        components: 3,\n        type: \"Float32\"\n      }]);\n    class px {\n      constructor(t, e) {\n        this.feature = t, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];\n      }\n    }\n    class fx {\n      constructor() {\n        this.instancedDataArray = new Ns(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};\n      }\n    }\n    class dx {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.projection = t.projection, this.index = t.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {\n          id: null,\n          timestamp: 0\n        };\n      }\n      populate(t, e, r, n) {\n        this.tileToMeter = wl(r);\n        const i = this.layers[0]._featureFilter.needGeometry;\n        this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);\n        for (const {\n          feature: a,\n          id: s,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = Bl(a, i);\n          if (!this.layers[0]._featureFilter.filter(new Pa(this.zoom), t, r)) continue;\n          const u = {\n              id: s,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: i ? t.geometry : Tl(a, r, n),\n              properties: a.properties,\n              type: a.type,\n              patterns: {}\n            },\n            c = this.addFeature(u, u.geometry, t);\n          c && e.featureIndex.insert(a, u.geometry, o, l, this.index, this.instancesPerModel[c].instancedDataArray.length, Tr / 32);\n        }\n        this.lookup = null;\n      }\n      update(t, e, r, n) {\n        for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          for (const e in t) r.idToFeaturesIndex.hasOwnProperty(e) && this.evaluate(r.features[r.idToFeaturesIndex[e]], t[e], r, !0);\n        }\n        this.maxHeight = 0;\n      }\n      updateZoomBasedPaintProperties() {\n        if (!this.hasZoomDependentProperties) return !1;\n        let e = !1;\n        for (const r in this.instancesPerModel) {\n          const n = this.instancesPerModel[r];\n          for (const r of n.features) {\n            const i = this.layers[0],\n              a = r.feature,\n              s = this.canonical,\n              o = i.paint.get(\"model-rotation\").evaluate(a, {}, s),\n              l = i.paint.get(\"model-scale\").evaluate(a, {}, s),\n              u = i.paint.get(\"model-translation\").evaluate(a, {}, s);\n            t.N.exactEquals(r.rotation, o) && t.N.exactEquals(r.scale, l) && t.N.exactEquals(r.translation, u) || (this.evaluate(r, r.featureStates, n, !0), e = !0);\n          }\n        }\n        return e;\n      }\n      isEmpty() {\n        for (const t in this.instancesPerModel) if (0 !== this.instancesPerModel[t].instancedDataArray.length) return !1;\n        return !0;\n      }\n      uploadPending() {\n        return !this.uploaded;\n      }\n      upload(t) {\n        if (!this.uploaded) for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t.createVertexBuffer(r.instancedDataArray, cx.members, !0, void 0, this.instanceCount));\n        }\n        this.uploaded = !0;\n      }\n      destroy() {\n        for (const t in this.instancesPerModel) {\n          const e = this.instancesPerModel[t];\n          0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();\n        }\n      }\n      addFeature(t, e, r) {\n        const n = this.layers[0],\n          i = n.layout.get(\"model-id\").evaluate(r, {}, this.canonical);\n        if (!i) return j(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), i;\n        this.instancesPerModel[i] || (this.instancesPerModel[i] = new fx());\n        const a = this.instancesPerModel[i],\n          s = a.instancedDataArray,\n          o = new px(r, s.length);\n        for (const t of e) for (const e of t) {\n          if (e.x < 0 || e.x >= Tr || e.y < 0 || e.y >= Tr) continue;\n          const t = (this.lookupDim - 1) / Tr,\n            r = this.lookupDim * (e.y * t | 0) + e.x * t | 0;\n          if (this.lookup) {\n            if (0 !== this.lookup[r]) continue;\n            this.lookup[r] = 1;\n          }\n          this.instanceCount++;\n          const n = s.length;\n          s.resize(n + 1), a.instancesEvaluatedElevation.push(0), s.float32[16 * n] = e.x, s.float32[16 * n + 1] = e.y;\n        }\n        return o.instancedDataCount = a.instancedDataArray.length - o.instancedDataOffset, o.instancedDataCount > 0 && (t.id && (a.idToFeaturesIndex[t.id] = a.features.length), a.features.push(o), this.evaluate(o, {}, a, !1)), i;\n      }\n      evaluate(t, e, r, n) {\n        const i = this.layers[0],\n          a = t.feature,\n          s = this.canonical,\n          o = t.rotation = i.paint.get(\"model-rotation\").evaluate(a, e, s),\n          l = t.scale = i.paint.get(\"model-scale\").evaluate(a, e, s),\n          u = t.translation = i.paint.get(\"model-translation\").evaluate(a, e, s),\n          c = i.paint.get(\"model-color\").evaluate(a, e, s);\n        c.a = i.paint.get(\"model-color-mix-intensity\").evaluate(a, e, s);\n        const h = [];\n        this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), ex(h, o, l);\n        const p = Math.round(100 * c.a) + c.b / 1.05;\n        for (let e = 0; e < t.instancedDataCount; ++e) {\n          const i = t.instancedDataOffset + e,\n            a = 16 * i,\n            o = r.instancedDataArray.float32;\n          let l = 0;\n          n && (l = o[a + 6] - r.instancesEvaluatedElevation[i]);\n          const f = 0 | o[a + 1];\n          o[a] = (0 | o[a]) + c.r / 1.05, o[a + 1] = f + c.g / 1.05, o[a + 2] = p, o[a + 3] = 1 / (s.z > 10 ? this.tileToMeter : wl(s, f)), o[a + 4] = u[0], o[a + 5] = u[1], o[a + 6] = u[2] + l, o[a + 7] = h[0], o[a + 8] = h[1], o[a + 9] = h[2], o[a + 10] = h[4], o[a + 11] = h[5], o[a + 12] = h[6], o[a + 13] = h[8], o[a + 14] = h[9], o[a + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];\n        }\n      }\n    }\n    ra(dx, \"ModelBucket\", {\n      omit: [\"layers\"]\n    }), ra(fx, \"PerModelAttributes\"), ra(px, \"ModelFeature\");\n    const mx = new Oa({\n      visibility: new La(qa.layout_model.visibility),\n      \"model-id\": new Fa(qa.layout_model[\"model-id\"])\n    });\n    var yx = {\n      paint: new Oa({\n        \"model-opacity\": new La(qa.paint_model[\"model-opacity\"]),\n        \"model-rotation\": new Fa(qa.paint_model[\"model-rotation\"]),\n        \"model-scale\": new Fa(qa.paint_model[\"model-scale\"]),\n        \"model-translation\": new Fa(qa.paint_model[\"model-translation\"]),\n        \"model-color\": new Fa(qa.paint_model[\"model-color\"]),\n        \"model-color-mix-intensity\": new Fa(qa.paint_model[\"model-color-mix-intensity\"]),\n        \"model-type\": new La(qa.paint_model[\"model-type\"]),\n        \"model-cast-shadows\": new La(qa.paint_model[\"model-cast-shadows\"]),\n        \"model-receive-shadows\": new La(qa.paint_model[\"model-receive-shadows\"]),\n        \"model-ambient-occlusion-intensity\": new La(qa.paint_model[\"model-ambient-occlusion-intensity\"]),\n        \"model-emissive-strength\": new Fa(qa.paint_model[\"model-emissive-strength\"]),\n        \"model-roughness\": new Fa(qa.paint_model[\"model-roughness\"]),\n        \"model-height-based-emissive-strength-multiplier\": new Fa(qa.paint_model[\"model-height-based-emissive-strength-multiplier\"]),\n        \"model-cutoff-fade-range\": new La(qa.paint_model[\"model-cutoff-fade-range\"])\n      }),\n      layout: mx\n    };\n    const gx = 64,\n      xx = {\n        CoordinateSpaceTile: 1,\n        CoordinateSpaceYUp: 2,\n        HasMapboxMeshFeatures: 4,\n        HasMeshoptCompression: 8\n      };\n    function vx(e, r, n, i, a, s, o, l, u, c = !1) {\n      const h = n.zoom,\n        p = n.project(i),\n        f = bl(i.lat, h),\n        d = 1 / f;\n      t.a6.identity(e), t.a6.translate(e, e, [p.x + o[0] * d, p.y + o[1] * d, o[2]]);\n      let m = 1,\n        y = 1;\n      const g = n.worldSize;\n      if (c) {\n        if (\"mercator\" === n.projection.name) {\n          let e = 0;\n          n.elevation && (e = n.elevation.getAtPointOrZero(new Ml(p.x / g, p.y / g), 0));\n          const r = t.a7.transformMat4([], [p.x, p.y, e, 1], n.projMatrix)[3] / n.cameraToCenterDistance;\n          m = r, y = r * bl(n.center.lat, h);\n        } else if (\"globe\" === n.projection.name) {\n          const r = nx(e, n),\n            a = t.a6.multiply([], n.projMatrix, r),\n            s = [0, 0, 0, 1];\n          t.a7.transformMat4(s, s, a);\n          const o = s[3] / n.cameraToCenterDistance,\n            l = rp(h),\n            u = n.projection.pixelsPerMeter(i.lat, g) * bl(i.lat, h),\n            c = n.projection.pixelsPerMeter(n.center.lat, g) * bl(n.center.lat, h);\n          m = o / ue(u, vl(n.center.lat), l), y = o * f / u, m *= c, y *= c;\n        }\n      } else m = d;\n      t.a6.scale(e, e, [m, m, y]);\n      const x = [...e],\n        v = r.orientation,\n        b = [];\n      if (ex(b, [v[0] + a[0], v[1] + a[1], v[2] + a[2]], s), t.a6.multiply(e, x, b), l && n.elevation) {\n        let a = 0;\n        const s = [];\n        if (u && n.elevation) {\n          a = function (e, r, n, i, a) {\n            const s = r.elevation;\n            if (!s) return 0;\n            const o = Bh.projectAabbCorners(n, i),\n              l = dl(1, a.lat) * r.worldSize,\n              u = function (e, r) {\n                const n = [0, 0, 1],\n                  i = [{\n                    corners: [0, 1, 3, 2],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [1, 5, 2, 6],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [0, 4, 1, 5],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [2, 6, 3, 7],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [4, 7, 5, 6],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [0, 3, 4, 7],\n                    dotProductWithUp: 0\n                  }];\n                for (const a of i) {\n                  const i = e[a.corners[0]],\n                    s = e[a.corners[1]],\n                    o = e[a.corners[2]],\n                    l = [s[0] - i[0], s[1] - i[1], r * (s[2] - i[2])],\n                    u = t.N.cross(l, l, [o[0] - i[0], o[1] - i[1], r * (o[2] - i[2])]);\n                  t.N.normalize(u, u), a.dotProductWithUp = t.N.dot(u, n);\n                }\n                return i.sort((t, e) => t.dotProductWithUp - e.dotProductWithUp), i[0].corners;\n              }(o, l),\n              c = o[u[0]],\n              h = o[u[1]],\n              p = o[u[2]],\n              f = o[u[3]],\n              d = s.getAtPointOrZero(new Ml(c[0] / r.worldSize, c[1] / r.worldSize), 0),\n              m = s.getAtPointOrZero(new Ml(h[0] / r.worldSize, h[1] / r.worldSize), 0),\n              y = s.getAtPointOrZero(new Ml(p[0] / r.worldSize, p[1] / r.worldSize), 0),\n              g = s.getAtPointOrZero(new Ml(f[0] / r.worldSize, f[1] / r.worldSize), 0),\n              x = (d + g) / 2,\n              v = (m + y) / 2;\n            return x > v ? m < y ? rx(e, h, f, c, m, g, d, l) : rx(e, p, c, f, y, d, g, l) : d < g ? rx(e, c, h, p, d, m, y, l) : rx(e, f, p, h, g, y, m, l), Math.max(x, v);\n          }(s, n, r.aabb, e, i);\n          const o = t.a6.fromQuat([], s),\n            l = t.a6.multiply([], o, b);\n          t.a6.multiply(e, x, l);\n        } else a = n.elevation.getAtPointOrZero(new Ml(p.x / g, p.y / g), 0);\n        0 !== a && (e[14] += a);\n      }\n    }\n    function bx(t, e, r = !1) {\n      t.uploaded || (t.gfxTexture = new Cg(e, t.image, r ? e.gl.R8 : e.gl.RGBA, {\n        useMipmap: t.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST\n      }), t.uploaded = !0, t.image = null);\n    }\n    function _x(t, e, r) {\n      t.indexBuffer = e.createIndexBuffer(t.indexArray, !1, !0), t.vertexBuffer = e.createVertexBuffer(t.vertexArray, ax.members, !1, !0), t.normalArray && (t.normalBuffer = e.createVertexBuffer(t.normalArray, ux.members, !1, !0)), t.texcoordArray && (t.texcoordBuffer = e.createVertexBuffer(t.texcoordArray, lx.members, !1, !0)), t.colorArray && (t.colorBuffer = e.createVertexBuffer(t.colorArray, (12 === t.colorArray.bytesPerElement ? sx : ox).members, !1, !0)), t.featureArray && (t.pbrBuffer = e.createVertexBuffer(t.featureArray, hx.members, !0)), t.segments = eo.simpleSegment(0, 0, t.vertexArray.length, t.indexArray.length);\n      const n = t.material;\n      n.pbrMetallicRoughness.baseColorTexture && bx(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && bx(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && bx(n.normalTexture, e), n.occlusionTexture && bx(n.occlusionTexture, e, r), n.emissionTexture && bx(n.emissionTexture, e);\n    }\n    function wx(t, e, r) {\n      if (t.meshes) for (const n of t.meshes) _x(n, e, r);\n      if (t.children) for (const n of t.children) wx(n, e, r);\n    }\n    function Mx(t) {\n      if (t.meshes) for (const e of t.meshes) e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();\n      if (t.children) for (const e of t.children) Mx(e);\n    }\n    function Ax(t) {\n      if (t.meshes) for (const r of t.meshes) r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));\n      var e;\n      if (t.children) for (const e of t.children) Ax(e);\n    }\n    class Sx {\n      constructor(t) {\n        this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n          this._triggered = !1, this._callback();\n        });\n      }\n      trigger() {\n        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n          this._triggered = !1, this._callback();\n        }, 0));\n      }\n      remove() {\n        this._channel = void 0, this._callback = () => {};\n      }\n    }\n    class Ix {\n      constructor() {\n        this.tasks = {}, this.taskQueue = [], V([\"process\"], this), this.invoker = new Sx(this.process), this.nextId = 0;\n      }\n      add(t, e) {\n        const r = this.nextId++,\n          n = function ({\n            type: t,\n            isSymbolTile: e,\n            zoom: r\n          }) {\n            return r = r || 0, \"message\" === t ? 0 : \"maybePrepare\" !== t || e ? \"parseTile\" !== t || e ? \"parseTile\" === t && e ? 300 - r : \"maybePrepare\" === t && e ? 400 - r : 500 : 200 - r : 100 - r;\n          }(e);\n        if (0 === n) {\n          Y();\n          try {\n            t();\n          } finally {}\n          return null;\n        }\n        return this.tasks[r] = {\n          fn: t,\n          metadata: e,\n          priority: n,\n          id: r\n        }, this.taskQueue.push(r), this.invoker.trigger(), {\n          cancel: () => {\n            delete this.tasks[r];\n          }\n        };\n      }\n      process() {\n        Y();\n        try {\n          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;\n          const t = this.pick();\n          if (null === t) return;\n          const e = this.tasks[t];\n          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;\n          e.fn();\n        } finally {}\n      }\n      pick() {\n        let t = null,\n          e = 1 / 0;\n        for (let r = 0; r < this.taskQueue.length; r++) {\n          const n = this.tasks[this.taskQueue[r]];\n          n.priority < e && (e = n.priority, t = r);\n        }\n        if (null === t) return null;\n        const r = this.taskQueue[t];\n        return this.taskQueue.splice(t, 1), r;\n      }\n      remove() {\n        this.invoker.remove();\n      }\n    }\n    class kx {\n      constructor(t, e, r) {\n        this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, V([\"receive\"], this), this.target.addEventListener(\"message\", this.receive, !1), this.scheduler = new Ix();\n      }\n      send(t, e, r, n, i = !1, a) {\n        const s = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n        r && (r.metadata = a, this.callbacks[s] = r);\n        const o = new Set();\n        return this.target.postMessage({\n          id: s,\n          type: t,\n          hasCallback: !!r,\n          targetMapId: n,\n          mustQueue: i,\n          sourceMapId: this.mapId,\n          data: aa(e, o)\n        }, o), {\n          cancel: () => {\n            r && delete this.callbacks[s], this.target.postMessage({\n              id: s,\n              type: \"<cancel>\",\n              targetMapId: n,\n              sourceMapId: this.mapId\n            });\n          }\n        };\n      }\n      receive(t) {\n        const e = t.data,\n          r = e.id;\n        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n          const t = this.cancelCallbacks[r];\n          delete this.cancelCallbacks[r], t && t.cancel();\n        } else if (e.mustQueue || Y()) {\n          const t = this.callbacks[r],\n            n = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {\n              type: \"message\"\n            });\n          n && (this.cancelCallbacks[r] = n);\n        } else this.processTask(r, e);\n      }\n      processTask(t, e) {\n        if (delete this.cancelCallbacks[t], \"<response>\" === e.type) {\n          const r = this.callbacks[t];\n          delete this.callbacks[t], r && (e.error ? r(sa(e.error)) : r(null, sa(e.data)));\n        } else {\n          const r = new Set(),\n            n = e.hasCallback ? (e, n) => {\n              this.target.postMessage({\n                id: t,\n                type: \"<response>\",\n                sourceMapId: this.mapId,\n                error: e ? aa(e) : null,\n                data: aa(n, r)\n              }, r);\n            } : t => {},\n            i = sa(e.data);\n          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {\n            const t = e.type.split(\".\");\n            this.parent.getWorkerSource(e.sourceMapId, t[0], i.source, i.scope)[t[1]](i, n);\n          } else n(new Error(`Could not find function ${e.type}`));\n        }\n      }\n      remove() {\n        this.scheduler.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n      }\n    }\n    class Px {\n      constructor(t, e) {\n        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = B();\n        const r = this.workerPool.acquire(this.id);\n        for (let t = 0; t < r.length; t++) {\n          const n = new Px.Actor(r[t], e, this.id);\n          n.name = `Worker ${t}`, this.actors.push(n);\n        }\n        this.ready = !1, this.broadcast(\"checkIfReady\", null, () => {\n          this.ready = !0;\n        });\n      }\n      broadcast(t, e, r) {\n        E(this.actors, (r, n) => {\n          r.send(t, e, n);\n        }, r = r || function () {});\n      }\n      getActor() {\n        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n      }\n      remove() {\n        this.actors.forEach(t => {\n          t.remove();\n        }), this.actors = [], this.workerPool.release(this.id);\n      }\n    }\n    Px.Actor = kx;\n    var Ex = {\n      workerUrl: \"\",\n      workerClass: null,\n      workerParams: void 0\n    };\n    function zx() {\n      return null != Ex.workerClass ? new Ex.workerClass() : new self.Worker(Ex.workerUrl, Ex.workerParams);\n    }\n    const Tx = \"mapboxgl_preloaded_worker_pool\";\n    class Bx {\n      constructor() {\n        this.active = {};\n      }\n      acquire(t) {\n        if (!this.workers) for (this.workers = []; this.workers.length < Bx.workerCount;) this.workers.push(new zx());\n        return this.active[t] = !0, this.workers.slice();\n      }\n      release(t) {\n        delete this.active[t], this.workers && 0 === this.numActive() && (this.workers.forEach(t => {\n          t.terminate();\n        }), this.workers = null);\n      }\n      isPreloaded() {\n        return !!this.active[Tx];\n      }\n      numActive() {\n        return Object.keys(this.active).length;\n      }\n    }\n    let Cx;\n    function Rx() {\n      return Cx || (Cx = new Bx()), Cx;\n    }\n    Bx.workerCount = 2;\n    let Dx,\n      Vx,\n      Lx,\n      Fx,\n      Nx,\n      Ox = null;\n    function Ux() {\n      return Y() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : Vx || n.DRACO_URL;\n    }\n    function jx() {\n      if (Y() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;\n      if (Fx) return Fx;\n      const t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);\n      if (\"object\" != typeof WebAssembly) throw new Error(\"WebAssembly not supported, cannot instantiate meshoptimizer\");\n      return Fx = WebAssembly.validate(t) ? n.MESHOPT_SIMD_URL : n.MESHOPT_URL, Fx;\n    }\n    const qx = {\n        5120: Int8Array,\n        5121: Uint8Array,\n        5122: Int16Array,\n        5123: Uint16Array,\n        5125: Uint32Array,\n        5126: Float32Array\n      },\n      $x = {\n        5120: \"DT_INT8\",\n        5121: \"DT_UINT8\",\n        5122: \"DT_INT16\",\n        5123: \"DT_UINT16\",\n        5125: \"DT_UINT32\",\n        5126: \"DT_FLOAT32\"\n      },\n      Gx = {\n        SCALAR: 1,\n        VEC2: 2,\n        VEC3: 3,\n        VEC4: 4,\n        MAT2: 4,\n        MAT3: 9,\n        MAT4: 16\n      };\n    function Yx(t, e, r) {\n      const n = r.json.bufferViews.length,\n        i = r.buffers.length;\n      e.bufferView = n, r.json.bufferViews[n] = {\n        buffer: i,\n        byteLength: t.byteLength\n      }, r.buffers[i] = t;\n    }\n    const Xx = \"KHR_draco_mesh_compression\";\n    function Zx(t, e) {\n      const r = t.extensions && t.extensions[Xx];\n      if (!r) return;\n      const n = new Lx.Decoder(),\n        i = ev(e, r.bufferView),\n        a = new Lx.Mesh();\n      if (!n.DecodeArrayToMesh(i, i.byteLength, a)) throw new Error(\"Failed to decode Draco mesh\");\n      const s = e.json.accessors[t.indices],\n        o = qx[s.componentType],\n        l = s.count * o.BYTES_PER_ELEMENT,\n        u = Lx._malloc(l);\n      o === Uint16Array ? n.GetTrianglesUInt16Array(a, l, u) : n.GetTrianglesUInt32Array(a, l, u), Yx(Lx.memory.buffer.slice(u, u + l), s, e), Lx._free(u);\n      for (const i of Object.keys(r.attributes)) {\n        const s = n.GetAttributeByUniqueId(a, r.attributes[i]),\n          o = e.json.accessors[t.attributes[i]],\n          l = $x[o.componentType],\n          u = o.count * Gx[o.type] * qx[o.componentType].BYTES_PER_ELEMENT,\n          c = Lx._malloc(u);\n        n.GetAttributeDataArrayForAllPoints(a, s, Lx[l], u, c), Yx(Lx.memory.buffer.slice(c, c + u), o, e), Lx._free(c);\n      }\n      n.destroy(), a.destroy(), delete t.extensions[Xx];\n    }\n    const Kx = \"EXT_meshopt_compression\";\n    function Hx(t, e) {\n      if (!t.extensions || !t.extensions[Kx]) return;\n      const r = t.extensions[Kx],\n        n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0),\n        i = new Uint8Array(r.count * r.byteStride);\n      Nx.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t.buffer = e.buffers.length, t.byteOffset = 0, e.buffers[t.buffer] = i.buffer, delete t.extensions[Kx];\n    }\n    const Wx = 1179937895,\n      Jx = new TextDecoder(\"utf8\");\n    function Qx(t, e) {\n      return new URL(t, e).href;\n    }\n    function tv(t, e, r, n) {\n      return fetch(Qx(t.uri, n)).then(t => t.arrayBuffer()).then(t => {\n        e.buffers[r] = t;\n      });\n    }\n    function ev(t, e) {\n      const r = t.json.bufferViews[e];\n      return new Uint8Array(t.buffers[r.buffer], r.byteOffset || 0, r.byteLength);\n    }\n    function rv(t, e, r, n) {\n      if (t.uri) {\n        const i = Qx(t.uri, n);\n        return fetch(i).then(t => t.blob()).then(t => createImageBitmap(t)).then(t => {\n          e.images[r] = t;\n        });\n      }\n      if (void 0 !== t.bufferView) {\n        const n = ev(e, t.bufferView),\n          i = new Blob([n], {\n            type: t.mimeType\n          });\n        return createImageBitmap(i).then(t => {\n          e.images[r] = t;\n        });\n      }\n    }\n    function nv(t, e = 0, r) {\n      const n = {\n        json: null,\n        images: [],\n        buffers: []\n      };\n      if (new Uint32Array(t, e, 1)[0] === Wx) {\n        const r = new Uint32Array(t, e);\n        let i = 2;\n        const a = (r[i++] >> 2) - 3,\n          s = r[i++] >> 2;\n        if (i++, n.json = JSON.parse(Jx.decode(r.subarray(i, i + s))), i += s, i < a) {\n          const a = r[i++];\n          i++;\n          const s = e + (i << 2);\n          n.buffers[0] = t.slice(s, s + a);\n        }\n      } else n.json = JSON.parse(Jx.decode(new Uint8Array(t, e)));\n      const {\n        buffers: i,\n        images: a,\n        meshes: s,\n        extensionsUsed: o,\n        bufferViews: l\n      } = n.json;\n      let u = Promise.resolve();\n      if (i) {\n        const t = [];\n        for (let e = 0; e < i.length; e++) {\n          const a = i[e];\n          a.uri ? t.push(tv(a, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);\n        }\n        u = Promise.all(t);\n      }\n      return u.then(() => {\n        const t = [],\n          e = o && o.includes(Xx),\n          i = o && o.includes(Kx);\n        if (e && t.push(function () {\n          if (!Lx) return Dx || (Dx = function (t) {\n            let e,\n              r = null;\n            function n() {\n              e = new Uint8Array(r.buffer);\n            }\n            function i() {\n              throw new Error(\"Unexpected Draco error.\");\n            }\n            const a = {\n              a: {\n                a: i,\n                d: function (t, r, n) {\n                  return e.copyWithin(t, r, r + n);\n                },\n                c: function (t) {\n                  const i = e.length,\n                    a = Math.max(t >>> 0, Math.ceil(1.2 * i)),\n                    s = Math.ceil((a - i) / 65536);\n                  try {\n                    return r.grow(s), n(), !0;\n                  } catch (t) {\n                    return !1;\n                  }\n                },\n                b: i\n              }\n            };\n            return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t, a) : t.then(t => t.arrayBuffer()).then(t => WebAssembly.instantiate(t, a))).then(t => {\n              const {\n                Rb: i,\n                Qb: a,\n                P: s,\n                T: o,\n                X: l,\n                Ja: u,\n                La: c,\n                Qa: h,\n                Va: p,\n                Wa: f,\n                eb: d,\n                jb: m,\n                f: y,\n                e: g,\n                yb: x,\n                zb: v,\n                Ab: b,\n                Bb: _,\n                Db: w,\n                Gb: M\n              } = t.instance.exports;\n              r = g;\n              const A = (() => {\n                let t = 0,\n                  r = 0,\n                  n = 0,\n                  s = 0;\n                return o => {\n                  n && (i(s), i(t), r += n, n = t = 0), t || (r += 128, t = a(r));\n                  const l = o.length + 7 & -8;\n                  let u = t;\n                  l >= r && (n = l, u = s = a(l));\n                  for (let t = 0; t < o.length; t++) e[u + t] = o[t];\n                  return u;\n                };\n              })();\n              return n(), y(), {\n                memory: g,\n                _free: i,\n                _malloc: a,\n                Mesh: class {\n                  constructor() {\n                    this.ptr = s();\n                  }\n                  destroy() {\n                    o(this.ptr);\n                  }\n                },\n                Decoder: class {\n                  constructor() {\n                    this.ptr = u();\n                  }\n                  destroy() {\n                    m(this.ptr);\n                  }\n                  DecodeArrayToMesh(t, e, r) {\n                    const n = A(t),\n                      i = c(this.ptr, n, e, r.ptr);\n                    return !!l(i);\n                  }\n                  GetAttributeByUniqueId(t, e) {\n                    return {\n                      ptr: h(this.ptr, t.ptr, e)\n                    };\n                  }\n                  GetTrianglesUInt16Array(t, e, r) {\n                    p(this.ptr, t.ptr, e, r);\n                  }\n                  GetTrianglesUInt32Array(t, e, r) {\n                    f(this.ptr, t.ptr, e, r);\n                  }\n                  GetAttributeDataArrayForAllPoints(t, e, r, n, i) {\n                    d(this.ptr, t.ptr, e.ptr, r, n, i);\n                  }\n                },\n                DT_INT8: x(),\n                DT_UINT8: v(),\n                DT_INT16: b(),\n                DT_UINT16: _(),\n                DT_UINT32: w(),\n                DT_FLOAT32: M()\n              };\n            });\n          }(fetch(Ux())), Dx.then(t => {\n            Lx = t, Dx = void 0;\n          }));\n        }()), i && t.push(function () {\n          if (Nx) return;\n          const t = function (t) {\n            let e;\n            const r = WebAssembly.instantiateStreaming(t, {}).then(t => {\n                e = t.instance, e.exports.__wasm_call_ctors();\n              }),\n              n = {\n                NONE: \"\",\n                OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n                QUATERNION: \"meshopt_decodeFilterQuat\",\n                EXPONENTIAL: \"meshopt_decodeFilterExp\"\n              },\n              i = {\n                ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n                TRIANGLES: \"meshopt_decodeIndexBuffer\",\n                INDICES: \"meshopt_decodeIndexSequence\"\n              };\n            return {\n              ready: r,\n              supported: !0,\n              decodeGltfBuffer(t, r, a, s, o, l) {\n                !function (t, e, r, n, i, a, s) {\n                  const o = t.exports.sbrk,\n                    l = n + 3 & -4,\n                    u = o(l * i),\n                    c = o(a.length),\n                    h = new Uint8Array(t.exports.memory.buffer);\n                  h.set(a, c);\n                  const p = e(u, n, i, c, a.length);\n                  if (0 === p && s && s(u, l, i), r.set(h.subarray(u, u + n * i)), o(u - o(0)), 0 !== p) throw new Error(`Malformed buffer data: ${p}`);\n                }(e, e.exports[i[o]], t, r, a, s, e.exports[n[l]]);\n              }\n            };\n          }(fetch(jx()));\n          return t.ready.then(() => {\n            Nx = t;\n          });\n        }()), a) for (let e = 0; e < a.length; e++) t.push(rv(a[e], n, e, r));\n        return (t.length ? Promise.all(t) : Promise.resolve()).then(() => {\n          if (e && s) for (const {\n            primitives: t\n          } of s) for (const e of t) Zx(e, n);\n          if (i && s && l) for (const t of l) Hx(t, n);\n          return n;\n        });\n      });\n    }\n    class iv {\n      constructor(t, e, r) {\n        if (this.triangleCount = e.length / 3, this.min = new g(0, 0), this.max = new g(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t.length || 0 === r) return;\n        const n = t.map(t => t.x),\n          i = t.map(t => t.y);\n        this.min = new g(Math.min(...n), Math.min(...i)), this.max = new g(Math.max(...n), Math.max(...i));\n        const a = this.max.sub(this.min);\n        a.x = Math.max(a.x, 1), a.y = Math.max(a.y, 1);\n        const s = Math.max(a.x, a.y) / r;\n        this.cellsX = Math.max(1, Math.ceil(a.x / s)), this.cellsY = Math.max(1, Math.ceil(a.y / s)), this.xScale = 1 / s, this.yScale = 1 / s;\n        const o = [];\n        for (let r = 0; r < this.triangleCount; r++) {\n          const n = t[e[3 * r + 0]].sub(this.min),\n            i = t[e[3 * r + 1]].sub(this.min),\n            a = t[e[3 * r + 2]].sub(this.min),\n            l = av(Math.floor(Math.min(n.x, i.x, a.x)), this.xScale, this.cellsX),\n            u = av(Math.floor(Math.max(n.x, i.x, a.x)), this.xScale, this.cellsX),\n            c = av(Math.floor(Math.min(n.y, i.y, a.y)), this.yScale, this.cellsY),\n            h = av(Math.floor(Math.max(n.y, i.y, a.y)), this.yScale, this.cellsY),\n            p = new g(0, 0),\n            f = new g(0, 0),\n            d = new g(0, 0),\n            m = new g(0, 0);\n          for (let t = c; t <= h; ++t) {\n            p.y = f.y = t * s, d.y = m.y = (t + 1) * s;\n            for (let e = l; e <= u; ++e) p.x = d.x = e * s, f.x = m.x = (e + 1) * s, (Kl(n, i, a, p, f, m) || Kl(n, i, a, p, m, d)) && o.push({\n              cellIdx: t * this.cellsX + e,\n              triIdx: r\n            });\n          }\n        }\n        if (0 === o.length) return;\n        o.sort((t, e) => t.cellIdx - e.cellIdx || t.triIdx - e.triIdx);\n        let l = 0;\n        for (; l < o.length;) {\n          const t = o[l].cellIdx,\n            e = {\n              start: this.payload.length,\n              len: 0\n            };\n          for (; l < o.length && o[l].cellIdx === t;) ++e.len, this.payload.push(o[l++].triIdx);\n          this.cells[t] = e;\n        }\n      }\n      query(t, e, r) {\n        if (0 === this.triangleCount || 0 === this.cells.length) return;\n        if (t.x > this.max.x || this.min.x > e.x) return;\n        if (t.y > this.max.y || this.min.y > e.y) return;\n        this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8)));\n        for (let t = 0; t < this.lookup.length; t++) this.lookup[t] = 0;\n        const n = av(t.x - this.min.x, this.xScale, this.cellsX),\n          i = av(e.x - this.min.x, this.xScale, this.cellsX),\n          a = av(t.y - this.min.y, this.yScale, this.cellsY),\n          s = av(e.y - this.min.y, this.yScale, this.cellsY);\n        for (let t = a; t <= s; t++) for (let e = n; e <= i; e++) {\n          const n = this.cells[t * this.cellsX + e];\n          if (n) for (let t = 0; t < n.len; t++) {\n            const e = this.payload[n.start + t],\n              i = Math.floor(e / 8),\n              a = 1 << e % 8;\n            if (!(this.lookup[i] & a) && (this.lookup[i] |= a, r.push(e), r.length === this.triangleCount)) return;\n          }\n        }\n      }\n    }\n    function av(t, e, r) {\n      return Math.max(0, Math.min(r - 1, Math.floor(t * e)));\n    }\n    function sv(t, e) {\n      const r = t.json.bufferViews[e.bufferView],\n        n = qx[e.componentType];\n      return new n(t.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== Gx[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : Gx[e.type]));\n    }\n    function ov(t, e, r, n) {\n      const i = qx[e.componentType],\n        a = function (t) {\n          switch (t) {\n            case Int8Array:\n              return 1 / 127;\n            case Uint8Array:\n              return 1 / 255;\n            case Int16Array:\n              return 1 / 32767;\n            case Uint16Array:\n              return 1 / 65535;\n            default:\n              return 1;\n          }\n        }(i),\n        s = t.json.bufferViews[e.bufferView],\n        o = s.byteStride ? s.byteStride / i.BYTES_PER_ELEMENT : Gx[e.type],\n        l = r.float32,\n        u = l.length / r.capacity;\n      for (let t = 0, r = 0; t < e.count * o; t += o, r += u) for (let e = 0; e < u; e++) l[r + e] = n[t + e] * a;\n      r._trim();\n    }\n    function lv(t, e, r) {\n      const n = t.indices,\n        i = t.attributes,\n        a = {};\n      a.indexArray = new Es();\n      const s = e.json.accessors[n],\n        o = s.count / 3;\n      a.indexArray.reserve(o);\n      const l = sv(e, s);\n      for (let t = 0; t < o; t++) a.indexArray.emplaceBack(l[3 * t], l[3 * t + 1], l[3 * t + 2]);\n      a.indexArray._trim(), a.vertexArray = new Ls();\n      const u = e.json.accessors[i.POSITION];\n      a.vertexArray.reserve(u.count);\n      const c = sv(e, u);\n      for (let t = 0; t < u.count; t++) a.vertexArray.emplaceBack(c[3 * t], c[3 * t + 1], c[3 * t + 2]);\n      if (a.vertexArray._trim(), a.aabb = new Bh(u.min, u.max), a.centroid = function (t, e) {\n        const r = [0, 0, 0],\n          n = t.length;\n        if (n > 0) {\n          for (let i = 0; i < n; i++) {\n            const n = 3 * t[i];\n            r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];\n          }\n          r[0] /= n, r[1] /= n, r[2] /= n;\n        }\n        return r;\n      }(l, c), void 0 !== i.COLOR_0) {\n        const t = e.json.accessors[i.COLOR_0],\n          r = Gx[t.type],\n          n = sv(e, t);\n        a.colorArray = 3 === r ? new Ls() : new gs(), a.colorArray.resize(t.count), ov(e, t, a.colorArray, n);\n      }\n      if (void 0 !== i.NORMAL) {\n        a.normalArray = new Ls();\n        const t = e.json.accessors[i.NORMAL];\n        a.normalArray.resize(t.count);\n        const r = sv(e, t);\n        ov(e, t, a.normalArray, r);\n      }\n      if (void 0 !== i.TEXCOORD_0 && r.length > 0) {\n        a.texcoordArray = new Fs();\n        const t = e.json.accessors[i.TEXCOORD_0];\n        a.texcoordArray.resize(t.count);\n        const r = sv(e, t);\n        ov(e, t, a.texcoordArray, r);\n      }\n      if (void 0 !== i._FEATURE_ID_RGBA4444) {\n        const t = e.json.accessors[i._FEATURE_ID_RGBA4444];\n        e.json.extensionsUsed && e.json.extensionsUsed.includes(\"EXT_meshopt_compression\") && (a.featureData = sv(e, t));\n      }\n      void 0 !== i._FEATURE_RGBA4444 && (a.featureData = new Uint32Array(sv(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));\n      const h = t.material;\n      return a.material = function (t, e) {\n        const {\n            emissiveFactor: r = [0, 0, 0],\n            alphaMode: n = \"OPAQUE\",\n            alphaCutoff: i = .5,\n            normalTexture: a,\n            occlusionTexture: s,\n            emissiveTexture: o,\n            doubleSided: l\n          } = t,\n          {\n            baseColorFactor: u = [1, 1, 1, 1],\n            metallicFactor: c = 1,\n            roughnessFactor: h = 1,\n            baseColorTexture: p,\n            metallicRoughnessTexture: f\n          } = t.pbrMetallicRoughness || {},\n          d = s ? e[s.index] : void 0;\n        if (s && s.extensions && s.extensions.KHR_texture_transform && d) {\n          const t = s.extensions.KHR_texture_transform;\n          d.offsetScale = [t.offset[0], t.offset[1], t.scale[0], t.scale[1]];\n        }\n        return {\n          pbrMetallicRoughness: {\n            baseColorFactor: new le(...u),\n            metallicFactor: c,\n            roughnessFactor: h,\n            baseColorTexture: p ? e[p.index] : void 0,\n            metallicRoughnessTexture: f ? e[f.index] : void 0\n          },\n          doubleSided: l,\n          emissiveFactor: r,\n          alphaMode: n,\n          alphaCutoff: i,\n          normalTexture: a ? e[a.index] : void 0,\n          occlusionTexture: d,\n          emissionTexture: o ? e[o.index] : void 0,\n          defined: void 0 === t.defined\n        };\n      }(void 0 !== h ? e.json.materials[h] : {\n        defined: !1\n      }, r), a;\n    }\n    function uv(e, r, n) {\n      const {\n          matrix: i,\n          rotation: a,\n          translation: s,\n          scale: o,\n          mesh: l,\n          extras: u,\n          children: c\n        } = e,\n        h = {};\n      if (h.matrix = i || t.a6.fromRotationTranslationScale([], a || [0, 0, 0, 1], s || [0, 0, 0], o || [1, 1, 1]), void 0 !== l) {\n        h.meshes = n[l];\n        const t = h.anchor = [0, 0];\n        for (const e of h.meshes) {\n          const {\n            min: r,\n            max: n\n          } = e.aabb;\n          t[0] += r[0] + n[0], t[1] += r[1] + n[1];\n        }\n        t[0] = Math.floor(t[0] / h.meshes.length / 2), t[1] = Math.floor(t[1] / h.meshes.length / 2);\n      }\n      if (u && (u.id && (h.id = u.id), u.lights && (h.lights = function (t) {\n        if (!t.length) return [];\n        const e = function (t) {\n            const e = atob(t),\n              r = new Uint8Array(e.length);\n            for (let t = 0; t < e.length; t++) r[t] = e.codePointAt(t);\n            return r;\n          }(t),\n          r = [],\n          n = e.length / 24,\n          i = new Uint16Array(e.buffer),\n          a = new Float32Array(e.buffer);\n        for (let t = 0; t < n; t++) {\n          const e = i[2 * t * 6] / 30,\n            n = i[2 * t * 6 + 1] / 30,\n            s = i[2 * t * 6 + 10] / 100,\n            o = a[6 * t + 1],\n            l = a[6 * t + 2],\n            u = a[6 * t + 3],\n            c = a[6 * t + 4],\n            h = u - o,\n            p = c - l,\n            f = Math.hypot(h, p);\n          r.push({\n            pos: [o + .5 * h, l + .5 * p, n],\n            normal: [p / f, -h / f, 0],\n            width: f,\n            height: e,\n            depth: s,\n            points: [o, l, u, c]\n          });\n        }\n        return r;\n      }(u.lights))), c) {\n        const t = [];\n        for (const e of c) t.push(uv(r.json.nodes[e], r, n));\n        h.children = t;\n      }\n      return h;\n    }\n    function cv(t) {\n      if (0 === t.vertices.length || 0 === t.indices.length) return null;\n      const [e, r] = [t.vertices[0].clone(), t.vertices[0].clone()];\n      for (let n = 1; n < t.vertices.length; ++n) {\n        const i = t.vertices[n];\n        e.x = Math.min(e.x, i.x), e.y = Math.min(e.y, i.y), r.x = Math.max(r.x, i.x), r.y = Math.max(r.y, i.y);\n      }\n      const n = Math.ceil(Math.max(r.x - e.x, r.y - e.y) / 256),\n        i = Math.max(8, n),\n        a = new iv(t.vertices, t.indices, i);\n      return {\n        vertices: t.vertices,\n        indices: t.indices,\n        grid: a,\n        min: e,\n        max: r\n      };\n    }\n    function hv(t) {\n      if (!t.extras || !t.extras.ground) return null;\n      const e = t.extras.ground;\n      if (!e || !Array.isArray(e) || 0 === e.length) return null;\n      const r = e[0];\n      if (!r || !Array.isArray(r) || 0 === r.length) return null;\n      const n = [];\n      for (const t of r) {\n        if (!Array.isArray(t) || 2 !== t.length) continue;\n        const e = t[0],\n          r = t[1];\n        \"number\" == typeof e && \"number\" == typeof r && n.push(new g(e, r));\n      }\n      if (n.length < 3) return null;\n      n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();\n      let i = 0;\n      for (let t = 0; t < n.length; t++) {\n        const e = n[t],\n          r = n[(t + 1) % n.length],\n          a = n[(t + 2) % n.length];\n        i += (e.x - r.x) * (a.y - r.y) - (a.x - r.x) * (e.y - r.y);\n      }\n      i > 0 && n.reverse();\n      const a = rf(n.flatMap(t => [t.x, t.y]), []);\n      return 0 === a.length ? null : {\n        vertices: n,\n        indices: a\n      };\n    }\n    function pv(t) {\n      const e = [],\n        r = [];\n      let n = 0;\n      for (const i of t) {\n        n = e.length;\n        const t = i.vertexArray.float32,\n          a = i.indexArray.uint16;\n        for (let r = 0; r < i.vertexArray.length; r++) e.push(new g(t[3 * r + 0], t[3 * r + 1]));\n        for (let t = 0; t < 3 * i.indexArray.length; t++) r.push(a[t] + n);\n      }\n      if (r.length % 3 != 0) return null;\n      for (let t = 0; t < r.length; t += 3) {\n        const n = e[r[t + 0]],\n          i = e[r[t + 1]],\n          a = e[r[t + 2]];\n        (n.x - i.x) * (a.y - i.y) - (a.x - i.x) * (n.y - i.y) > 0 && ([r[t + 1], r[t + 2]] = [r[t + 2], r[t + 1]]);\n      }\n      return {\n        vertices: e,\n        indices: r\n      };\n    }\n    function fv(t) {\n      const e = function (t, e) {\n          const r = [],\n            n = WebGL2RenderingContext;\n          if (t.json.textures) for (const i of t.json.textures) {\n            const a = {\n              magFilter: n.LINEAR,\n              minFilter: n.NEAREST,\n              wrapS: n.REPEAT,\n              wrapT: n.REPEAT\n            };\n            void 0 !== i.sampler && Object.assign(a, t.json.samplers[i.sampler]), r.push({\n              image: e[i.source],\n              sampler: a,\n              uploaded: !1\n            });\n          }\n          return r;\n        }(t, t.images),\n        r = function (t, e) {\n          const r = [];\n          for (const n of t.json.meshes) {\n            const i = [];\n            for (const r of n.primitives) i.push(lv(r, t, e));\n            r.push(i);\n          }\n          return r;\n        }(t, e),\n        {\n          scenes: n,\n          scene: i,\n          nodes: a\n        } = t.json,\n        s = n ? n[i || 0].nodes : a,\n        o = [];\n      for (const e of s) o.push(uv(a[e], t, r));\n      return function (t, e, r) {\n        const n = {},\n          i = new Set();\n        for (let a = 0; a < t.length; a++) {\n          const t = r[e[a]];\n          if (!t.extras) continue;\n          const s = t.extras[\"mapbox:footprint:version\"],\n            o = t.extras[\"mapbox:footprint:id\"];\n          (s || o) && i.add(a), \"1.0.0\" === s && o && (n[o] = a);\n        }\n        for (let a = 0; a < t.length; a++) {\n          if (i.has(a)) continue;\n          const s = t[a],\n            o = r[e[a]];\n          if (!o.extras) continue;\n          let l = null;\n          s.id in n && (l = pv(t[n[s.id]].meshes)), l || (l = hv(o)), l && (s.footprint = cv(l));\n        }\n        if (i.size > 0) {\n          const e = Array.from(i.values()).sort((t, e) => t - e);\n          for (let r = e.length - 1; r >= 0; r--) t.splice(e[r], 1);\n        }\n      }(o, s, t.json.nodes), o;\n    }\n    function dv(t) {\n      t.heightmap = new Float32Array(4096), t.heightmap.fill(-1);\n      const e = t.vertexArray.float32,\n        r = t.aabb.min[0] - 1,\n        n = t.aabb.min[1] - 1,\n        i = gx / (t.aabb.max[0] - r + 2),\n        a = gx / (t.aabb.max[1] - n + 2);\n      for (let s = 0; s < e.length; s += 3) {\n        const o = e[s + 2],\n          l = (e[s + 0] - r) * i | 0,\n          u = (e[s + 1] - n) * a | 0;\n        o > t.heightmap[u * gx + l] && (t.heightmap[u * gx + l] = o);\n      }\n    }\n    function mv(e, r) {\n      const n = {};\n      n.indexArray = new Es(), n.indexArray.reserve(4 * e.length), n.vertexArray = new Ls(), n.vertexArray.reserve(10 * e.length), n.colorArray = new gs(), n.vertexArray.reserve(10 * e.length);\n      let i = 0;\n      for (const a of e) {\n        const e = Math.min(10, Math.max(4, 1.3 * a.height)) * r,\n          s = [-a.normal[1], a.normal[0], 0],\n          o = Math.min(.29, .1 * a.width / a.depth),\n          l = a.width - 2 * a.depth * r * (o + .01),\n          u = t.N.scaleAndAdd([], a.pos, s, l / 2),\n          c = t.N.scaleAndAdd([], a.pos, s, -l / 2),\n          h = [u[0], u[1], u[2] + a.height],\n          p = [c[0], c[1], c[2] + a.height],\n          f = t.N.scaleAndAdd([], a.normal, s, o);\n        t.N.scale(f, f, e);\n        const d = t.N.scaleAndAdd([], a.normal, s, -o);\n        t.N.scale(d, d, e), t.N.add(f, u, f), t.N.add(d, c, d), u[2] += .1, c[2] += .1, n.vertexArray.emplaceBack(f[0], f[1], f[2]), n.vertexArray.emplaceBack(d[0], d[1], d[2]), n.vertexArray.emplaceBack(u[0], u[1], u[2]), n.vertexArray.emplaceBack(c[0], c[1], c[2]), n.vertexArray.emplaceBack(h[0], h[1], h[2]), n.vertexArray.emplaceBack(p[0], p[1], p[2]), n.vertexArray.emplaceBack(u[0], u[1], u[2]), n.vertexArray.emplaceBack(c[0], c[1], c[2]), n.vertexArray.emplaceBack(f[0], f[1], f[2]), n.vertexArray.emplaceBack(d[0], d[1], d[2]);\n        const m = l / e / 2;\n        n.colorArray.emplaceBack(-m - o, -1, m, .8), n.colorArray.emplaceBack(m + o, -1, m, .8), n.colorArray.emplaceBack(-m, 0, m, 1.3), n.colorArray.emplaceBack(m, 0, m, 1.3), n.colorArray.emplaceBack(m + o, -.8, m, .7), n.colorArray.emplaceBack(m + o, -.8, m, .7), n.colorArray.emplaceBack(0, 0, m, 1.3), n.colorArray.emplaceBack(0, 0, m, 1.3), n.colorArray.emplaceBack(m + o, -1.2, m, .8), n.colorArray.emplaceBack(m + o, -1.2, m, .8), n.indexArray.emplaceBack(6 + i, 4 + i, 8 + i), n.indexArray.emplaceBack(7 + i, 9 + i, 5 + i), n.indexArray.emplaceBack(0 + i, 1 + i, 2 + i), n.indexArray.emplaceBack(1 + i, 3 + i, 2 + i), i += 10;\n      }\n      const a = {\n          defined: !0,\n          emissiveFactor: [0, 0, 0]\n        },\n        s = {};\n      return s.baseColorFactor = le.white, a.pbrMetallicRoughness = s, n.material = a, n.aabb = new Bh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), n;\n    }\n    ra(iv, \"TriangleGridIndex\");\n    class yv {\n      constructor(t) {\n        this._stringToNumber = {}, this._numberToString = [];\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          this._stringToNumber[r] = e, this._numberToString[e] = r;\n        }\n      }\n      encode(t) {\n        return this._stringToNumber[t];\n      }\n      decode(t) {\n        return this._numberToString[t];\n      }\n    }\n    const gv = [\"tile\", \"layer\", \"source\", \"sourceLayer\", \"state\"];\n    class xv {\n      constructor(t, e, r, n, i) {\n        this.type = \"Feature\", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;\n      }\n      get geometry() {\n        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;\n      }\n      set geometry(t) {\n        this._geometry = t;\n      }\n      toJSON() {\n        const t = {\n          type: \"Feature\",\n          state: void 0,\n          geometry: this.geometry,\n          properties: this.properties\n        };\n        void 0 !== this.id && (t.id = this.id);\n        for (const e of gv) void 0 !== this[e] && (t[e] = this[e]);\n        return t;\n      }\n    }\n    class vv {\n      constructor(t, e) {\n        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ta(Tr, 16, 0), this.featureIndexArray = new Ws(), this.promoteId = e, this.is3DTile = !1;\n      }\n      insert(t, e, r, n, i, a = 0, s = 0) {\n        const o = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(r, n, i, a);\n        const l = this.grid;\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t],\n            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n          }\n          0 !== s && (n[0] -= s, n[1] -= s, n[2] += s, n[3] += s), n[0] < Tr && n[1] < Tr && n[2] >= 0 && n[3] >= 0 && l.insert(o, n[0], n[1], n[2], n[3]);\n        }\n      }\n      loadVTLayers() {\n        if (!this.vtLayers) {\n          this.vtLayers = new Ef(new Vm(this.rawTileData)).layers, this.sourceLayerCoder = new yv(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"]), this.vtFeatures = {};\n          for (const t in this.vtLayers) this.vtFeatures[t] = [];\n        }\n        return this.vtLayers;\n      }\n      query(t, e, r, n) {\n        this.loadVTLayers();\n        const i = t.params || {},\n          a = Ga(i.filter),\n          s = t.tileResult,\n          o = t.transform,\n          l = s.bufferedTilespaceBounds,\n          u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, r, n) => Yl(s.bufferedTilespaceGeometry, t, e, r, n));\n        u.sort(_v);\n        let c = null;\n        o.elevation && u.length > 0 && (c = Wf.create(o.elevation, this.tileID));\n        const h = {};\n        let p;\n        for (let l = 0; l < u.length; l++) {\n          const f = u[l];\n          if (f === p) continue;\n          p = f;\n          const d = this.featureIndexArray.get(f);\n          let m = null;\n          if (this.is3DTile) {\n            const t = this.bucketLayerIDs[0][0],\n              r = e[t];\n            if (\"model\" !== r.type) continue;\n            const {\n              queryFeature: n,\n              intersectionZ: i\n            } = r.queryIntersectsMatchingFeature(s, d.featureIndex, a, o);\n            n && this.appendToResult(h, t, d.featureIndex, n, i);\n          } else this.loadMatchingFeature(h, d, a, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0) => (m || (m = Tl(e, this.tileID.canonical, t.tileTransform)), r.queryIntersectsFeature(s, e, n, m, this.z, t.transform, t.pixelPosMatrix, c, i)));\n        }\n        return h;\n      }\n      loadMatchingFeature(t, e, r, n, i, a, s, o, l) {\n        const {\n            featureIndex: u,\n            bucketIndex: c,\n            sourceLayerIndex: h,\n            layoutVertexArrayOffset: p\n          } = e,\n          f = this.bucketLayerIDs[c];\n        if (n && !function (t, e) {\n          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n          return !1;\n        }(n, f)) return;\n        const d = this.sourceLayerCoder.decode(h),\n          m = this.vtLayers[d].feature(u);\n        if (r.needGeometry) {\n          const t = Bl(m, !0);\n          if (!r.filter(new Pa(this.tileID.overscaledZ), t, this.tileID.canonical)) return;\n        } else if (!r.filter(new Pa(this.tileID.overscaledZ), m)) return;\n        const y = this.getId(m, d);\n        for (let e = 0; e < f.length; e++) {\n          const r = f[e];\n          if (n && n.indexOf(r) < 0) continue;\n          const c = a[r];\n          if (!c) continue;\n          let h = {};\n          void 0 !== y && o && (h = o.getState(c.sourceLayer || \"_geojsonTileLayer\", y));\n          const d = !l || l(m, c, h, p);\n          if (!d) continue;\n          const g = new xv(m, this.z, this.x, this.y, y),\n            x = z({}, s[r]);\n          x.paint = bv(x.paint, c.paint, m, h, i), x.layout = bv(x.layout, c.layout, m, h, i), g.layer = x, this.appendToResult(t, r, u, g, d);\n        }\n      }\n      appendToResult(t, e, r, n, i) {\n        let a = t[e];\n        void 0 === a && (a = t[e] = []), a.push({\n          featureIndex: r,\n          feature: n,\n          intersectionZ: i\n        });\n      }\n      lookupSymbolFeatures(t, e, r, n, i, a, s, o) {\n        const l = {};\n        this.loadVTLayers();\n        const u = Ga(i);\n        for (const i of t) this.loadMatchingFeature(l, {\n          bucketIndex: r,\n          sourceLayerIndex: n,\n          featureIndex: i,\n          layoutVertexArrayOffset: 0\n        }, u, a, s, o, e);\n        return l;\n      }\n      loadFeature(t) {\n        const {\n          featureIndex: e,\n          sourceLayerIndex: r\n        } = t;\n        this.loadVTLayers();\n        const n = this.sourceLayerCoder.decode(r),\n          i = this.vtFeatures[n];\n        if (i[e]) return i[e];\n        const a = this.vtLayers[n].feature(e);\n        return i[e] = a, a;\n      }\n      hasLayer(t) {\n        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n        return !1;\n      }\n      getId(t, e) {\n        let r = t.id;\n        if (this.promoteId) {\n          const n = \"string\" == typeof this.promoteId ? this.promoteId : this.promoteId[e];\n          null != n && (r = t.properties[n]), \"boolean\" == typeof r && (r = Number(r));\n        }\n        return r;\n      }\n    }\n    function bv(t, e, r, n, i) {\n      return F(t, (t, a) => {\n        const s = e instanceof Va ? e.get(a) : null;\n        return s && s.evaluate ? s.evaluate(r, n, i) : s;\n      });\n    }\n    function _v(t, e) {\n      return e - t;\n    }\n    ra(vv, \"FeatureIndex\", {\n      omit: [\"rawTileData\", \"sourceLayerCoder\"]\n    });\n    const wv = new Float32Array(262144),\n      Mv = new Uint8Array(262144);\n    function Av(t) {\n      let e = 0;\n      if (t.meshes) for (const r of t.meshes) e = Math.max(e, r.aabb.max[2]);\n      if (t.children) for (const r of t.children) e = Math.max(e, Av(r));\n      return e;\n    }\n    function Sv(t, e, r) {\n      if (t.meshes) for (const n of t.meshes) n.aabb.min[0] !== 1 / 0 && r.insert(e, n.aabb.min[0], n.aabb.min[1], n.aabb.max[0], n.aabb.max[1]);\n      if (t.children) for (const n of t.children) Sv(n, e, r);\n    }\n    const Iv = [\"\", \"wall\", \"door\", \"roof\", \"window\", \"lamp\", \"logo\"];\n    class kv {\n      constructor(t) {\n        this.node = t, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.feature = {\n          type: \"Point\",\n          id: t.id,\n          geometry: [],\n          properties: {\n            height: Av(t)\n          }\n        };\n      }\n      getLocalBounds() {\n        if (!this.node.meshes) return new Bh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);\n        if (!this.aabb) {\n          let t = 0;\n          const e = new Bh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);\n          for (const r of this.node.meshes) this.node.lightMeshIndex !== t && e.encapsulate(r.aabb), t++;\n          this.aabb = e;\n        }\n        return this.aabb;\n      }\n    }\n    class Pv {\n      constructor(t, e, r, n, i, a) {\n        this.id = e, this.modelTraits |= xx.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, r && (this.modelTraits |= xx.HasMapboxMeshFeatures), n && (this.modelTraits |= xx.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {\n          name: \"mercator\"\n        }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = i, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];\n        for (const e of t) this.nodesInfo.push(new kv(e)), Sv(e, a.featureIndexArray.length, a.grid), a.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, a.bucketLayerIDs.length - 1, 0);\n      }\n      update() {\n        console.log(\"Update 3D model bucket\");\n      }\n      populate() {\n        console.log(\"populate 3D model bucket\");\n      }\n      uploadPending() {\n        return !this.uploaded || this.needsUpload;\n      }\n      upload(t) {\n        if (!this.needsUpload) return;\n        const e = this.getNodesInfo();\n        for (const r of e) {\n          const e = r.node;\n          this.uploaded ? this.updatePbrBuffer(e) : wx(e, t, !0);\n        }\n        for (const t of e) Mx(t.node);\n        this.uploaded = !0, this.needsUpload = !1;\n      }\n      updatePbrBuffer(t) {\n        let e = !1;\n        if (!t.meshes) return e;\n        for (const r of t.meshes) r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);\n        return e;\n      }\n      needsReEvaluation(t, e, r) {\n        const n = t.transform.projectionOptions,\n          i = t.style.getBrightness(),\n          a = this.brightness !== i;\n        return !!(!this.uploaded || this.dirty || n.name !== this.projection.name || Ev(r.paint.get(\"model-color\").value, a) || Ev(r.paint.get(\"model-color-mix-intensity\").value, a) || Ev(r.paint.get(\"model-roughness\").value, a) || Ev(r.paint.get(\"model-emissive-strength\").value, a) || Ev(r.paint.get(\"model-height-based-emissive-strength-multiplier\").value, a)) && (this.projection = n, this.brightness = i, !0);\n      }\n      evaluateScale(t, e) {\n        if (t.transform.zoom === this.zoom) return;\n        this.zoom = t.transform.zoom;\n        const r = this.getNodesInfo(),\n          n = this.id.canonical;\n        for (const t of r) {\n          const r = t.feature;\n          t.evaluatedScale = e.paint.get(\"model-scale\").evaluate(r, {}, n);\n        }\n      }\n      evaluate(t) {\n        const e = this.getNodesInfo();\n        for (const r of e) {\n          if (!r.node.meshes) continue;\n          const e = r.feature,\n            n = r.node.meshes && r.node.meshes[0].featureData,\n            i = r.evaluatedColor[2],\n            a = r.evaluatedRMEA[2],\n            s = this.id.canonical;\n          if (r.hasTranslucentParts = !1, n) {\n            for (let n = 0; n < Iv.length; n++) {\n              const i = Iv[n];\n              i.length && (e.properties.part = i);\n              const a = t.paint.get(\"model-color\").evaluate(e, {}, s),\n                o = t.paint.get(\"model-color-mix-intensity\").evaluate(e, {}, s);\n              r.evaluatedColor[n] = [a.r, a.g, a.b, o], r.evaluatedRMEA[n][0] = t.paint.get(\"model-roughness\").evaluate(e, {}, s), r.evaluatedRMEA[n][2] = t.paint.get(\"model-emissive-strength\").evaluate(e, {}, s), r.evaluatedRMEA[n][3] = a.a, r.emissionHeightBasedParams[n] = t.paint.get(\"model-height-based-emissive-strength-multiplier\").evaluate(e, {}, s), !r.hasTranslucentParts && a.a < 1 && (r.hasTranslucentParts = !0);\n            }\n            delete e.properties.part, Tv(r, i !== r.evaluatedColor[2] || a !== r.evaluatedRMEA[2], this.modelTraits);\n          } else r.evaluatedRMEA[0][2] = t.paint.get(\"model-emissive-strength\").evaluate(e, {}, s);\n          r.evaluatedScale = t.paint.get(\"model-scale\").evaluate(e, {}, s), this.updatePbrBuffer(r.node) || (this.needsUpload = !0);\n        }\n        this.dirty = !1;\n      }\n      elevationUpdate(t, e, r, n) {\n        const i = t.findDEMTileFor(r);\n        if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {\n          if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {\n            this.elevationReadFromZ = i.tileID.overscaledZ;\n            const e = Wf.create(t, r, i);\n            if (!e) return;\n            this.modelTraits & xx.HasMapboxMeshFeatures && this.updateDEM(t, e, r, n);\n            for (const t of this.getNodesInfo()) {\n              const r = t.node;\n              if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;\n              const n = r.footprint.vertices;\n              let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);\n              for (let t = 1; t < n.length; t++) i = Math.min(i, e.getElevationAt(n[t].x, n[t].y, !0, !0));\n              r.elevation = i;\n            }\n          }\n          this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;\n        }\n      }\n      updateDEM(t, e, r, n) {\n        let i = e._dem._modifiedForSources[n];\n        if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;\n        const a = e._dem.dim;\n        i.push(r.canonical);\n        let s = !1;\n        for (const t of this.getNodesInfo()) {\n          const r = t.node;\n          if (!r.footprint || !r.footprint.grid) continue;\n          const n = r.footprint.grid,\n            i = e.tileCoordToPixel(n.min.x, n.min.y),\n            o = e.tileCoordToPixel(n.max.x, n.max.y),\n            l = Math.min(Math.min(a - o.y, i.x), Math.min(i.y, a - o.x));\n          if (l < 0) continue;\n          const u = I(l, 2, 5);\n          let c = Math.max(0, i.x - u),\n            h = Math.max(0, i.y - u),\n            p = Math.min(o.x + u, a - 1),\n            f = Math.min(o.y + u, a - 1);\n          for (let t = h; t <= f; ++t) for (let e = c; e <= p; ++e) Mv[t * a + e] = 255;\n          let d = 0,\n            m = 0;\n          for (let t = 0; t < n.cellsY; ++t) for (let r = 0; r < n.cellsX; ++r) {\n            if (!n.cells[t * n.cellsX + r]) continue;\n            const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t / n.yScale),\n              s = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t + 1) / n.yScale);\n            for (let t = i.y; t <= Math.min(s.y + 1, a - 1); ++t) for (let r = i.x; r <= Math.min(s.x + 1, a - 1); ++r) 255 === Mv[t * a + r] && (Mv[t * a + r] = 0, d += e.getElevationAtPixel(r, t), m++);\n          }\n          const y = d / m;\n          c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(o.x + u, a - 2), f = Math.min(o.y + u, a - 2), s = !0;\n          for (let t = h; t <= f; ++t) for (let r = c; r <= p; ++r) 0 === Mv[t * a + r] && (wv[t * a + r] = e._dem.set(r, t, y));\n          for (let t = 1; t < u; ++t) {\n            c = Math.max(1, i.x - t), h = Math.max(1, i.y - t), p = Math.min(o.x + t, a - 2), f = Math.min(o.y + t, a - 2);\n            for (let r = h; r <= f; ++r) for (let n = c; n <= p; ++n) {\n              const i = r * a + n;\n              if (255 === Mv[i]) {\n                let s = 0,\n                  o = 0,\n                  l = -1,\n                  c = -1;\n                for (let e = -1; e <= 1; ++e) for (let i = -1; i <= 1; ++i) {\n                  const u = (r + e) * a + n + i;\n                  if (Mv[u] >= t) continue;\n                  const h = wv[u],\n                    p = Math.abs(h);\n                  p > o && (s = h, o = p, l = i, c = e);\n                }\n                if (o > .1) {\n                  const a = 1 - (t + .5 * Math.abs(l * c)) / u;\n                  let o = e._dem.get(n, r) + s * a;\n                  const h = e._dem.get(n + l, r + c),\n                    p = e._dem.get(n - l, r - c, !0);\n                  (o - h) * (o - p) > 0 && (o = (h + p) / 2), wv[i] = e._dem.set(n, r, o), Mv[i] = t;\n                }\n              }\n            }\n          }\n        }\n        s && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = st.now());\n      }\n      getNodesInfo() {\n        return this.nodesInfo;\n      }\n      destroy() {\n        const t = this.getNodesInfo();\n        for (const e of t) Mx(e.node), Ax(e.node);\n      }\n      isEmpty() {\n        return !this.nodesInfo.length;\n      }\n      updateReplacement(t, e) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const r = e.getReplacementRegionsForTile(t.toUnwrapped()),\n          n = this.getNodesInfo();\n        for (let t = 0; t < this.nodesInfo.length; t++) {\n          const e = n[t].node;\n          n[t].hiddenByReplacement = !!e.footprint && !r.find(t => t.footprint === e.footprint);\n        }\n      }\n      getHeightAtTileCoord(t, e) {\n        const r = this.getNodesInfo(),\n          n = [];\n        for (let i = 0; i < this.nodesInfo.length; i++) {\n          const a = r[i],\n            s = a.node.meshes[0];\n          if (t < s.aabb.min[0] || e < s.aabb.min[1] || t > s.aabb.max[0] || e > s.aabb.max[1]) continue;\n          const o = (t - s.aabb.min[0]) / (s.aabb.max[0] - s.aabb.min[0]) * gx | 0,\n            l = Math.min(63, (e - s.aabb.min[1]) / (s.aabb.max[1] - s.aabb.min[1]) * gx | 0) * gx + Math.min(63, o);\n          if (!(s.heightmap[l] < 0 && a.node.footprint)) {\n            if (a.hiddenByReplacement) return;\n            return {\n              height: s.heightmap[l],\n              maxHeight: a.feature.properties.height,\n              hidden: !1,\n              verticalScale: a.evaluatedScale[2]\n            };\n          }\n          if (a.node.footprint.grid.query(new g(t, e), new g(t, e), n), n.length > 0) return {\n            height: void 0,\n            maxHeight: a.feature.properties.height,\n            hidden: a.hiddenByReplacement,\n            verticalScale: a.evaluatedScale[2]\n          };\n        }\n      }\n    }\n    function Ev(t, e) {\n      return !t.isLightConstant && e;\n    }\n    function zv(t, e, r, n, i, a, s, o) {\n      let l = (61440 & e | (61440 & e) >> 4) >> 8,\n        u = (3840 & e | (3840 & e) >> 4) >> 4,\n        c = 240 & e | (240 & e) >> 4;\n      r[3] > 0 && (l = ue(l, 255 * r[0], r[3]), u = ue(u, 255 * r[1], r[3]), c = ue(c, 255 * r[2], r[3]));\n      const h = l << 8 | u,\n        p = c << 8 | Math.floor(255 * n[3]),\n        f = function (t) {\n          const e = I(t, 0, 2);\n          return Math.min(Math.round(.5 * e * 255), 255);\n        }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1],\n        d = I(i[0], 0, 1),\n        m = I(i[1], 0, 1),\n        y = I(i[2], 0, 1),\n        g = I(i[3], 0, 1);\n      let x, v, b, _;\n      if (d !== m && s !== a && m !== d) {\n        const t = s - a;\n        v = 1 / (t * (m - d)), b = -(a + t * d) / (t * (m - d));\n        const e = I(i[4], -1, 1);\n        _ = Math.pow(10, e), x = 255 * y << 8 | 255 * g;\n      } else x = 65535, v = 0, b = 1, _ = 1;\n      if (t.emplaceBack(h, p, f, x, v, b, _), o) {\n        const t = o.length;\n        o.clear();\n        for (let e = 0; e < t; e++) o.emplaceBack(h, p, f, x, v, b, _);\n      }\n    }\n    function Tv(t, e, r) {\n      const n = t.node;\n      let i = 0;\n      const a = r & xx.HasMeshoptCompression;\n      for (const r of n.meshes) {\n        if (n.lights && n.lightMeshIndex === i) continue;\n        if (!r.featureData) continue;\n        r.featureArray = new Os(), r.featureArray.reserve(r.featureData.length);\n        let s = e;\n        for (const e of r.featureData) {\n          const i = a ? 65535 & e : e >> 16 & 65535,\n            o = a ? e >> 16 & 65535 : 65535 & e,\n            l = (15 & o) < 8 ? 15 & o : 0,\n            u = t.evaluatedRMEA[l],\n            c = t.evaluatedColor[l],\n            h = t.emissionHeightBasedParams[l];\n          let p;\n          if (s && 2 === l && n.lights && (p = new Os(), p.resize(10 * n.lights.length)), zv(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && s) {\n            s = !1;\n            const t = n.meshes[n.lightMeshIndex];\n            t.featureArray = p, t.featureArray._trim();\n          }\n        }\n        r.featureArray._trim(), i++;\n      }\n    }\n    function Bv(t, e, r, n) {\n      const i = 1 << t.z;\n      e.lat = yl((n / Tr + t.y) / i), e.lng = ml((r / Tr + t.x) / i);\n    }\n    ra(Pv, \"Tiled3dModelBucket\", {\n      omit: [\"layers\"]\n    }), ra(kv, \"Tiled3dModelFeature\");\n    const Cv = {\n        circle: class extends ss {\n          constructor(t, e, r) {\n            super(t, eu, e, r);\n          }\n          createBucket(t) {\n            return new Dl(t);\n          }\n          queryRadius(t) {\n            const e = t;\n            return Hl(\"circle-radius\", this, e) + Hl(\"circle-stroke-width\", this, e) + Wl(this.paint.get(\"circle-translate\"));\n          }\n          queryIntersectsFeature(t, e, r, n, i, a, s, o) {\n            const l = Ql(this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), a.angle, t.pixelToTileUnitsFactor),\n              u = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r);\n            return cp(t, n, a, s, o, \"map\" === this.paint.get(\"circle-pitch-alignment\"), \"map\" === this.paint.get(\"circle-pitch-scale\"), l, u);\n          }\n          getProgramIds() {\n            return [\"circle\"];\n          }\n          getDefaultProgramParams(t, e) {\n            const r = up(this);\n            return {\n              config: new Do(this, e),\n              defines: r,\n              overrideFog: !1\n            };\n          }\n        },\n        heatmap: class extends ss {\n          createBucket(t) {\n            return new mp(t);\n          }\n          constructor(t, e, r) {\n            super(t, Mp, e, r), this._updateColorRamp();\n          }\n          _handleSpecialPaintPropertyUpdate(t) {\n            \"heatmap-color\" === t && this._updateColorRamp();\n          }\n          _updateColorRamp() {\n            this.colorRamp = Ap({\n              expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n              evaluationKey: \"heatmapDensity\",\n              image: this.colorRamp\n            }), this.colorRampTexture = null;\n          }\n          resize() {\n            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n          }\n          queryRadius(t) {\n            return Hl(\"heatmap-radius\", this, t);\n          }\n          queryIntersectsFeature(t, e, r, n, i, a, s, o) {\n            const l = this.paint.get(\"heatmap-radius\").evaluate(e, r);\n            return cp(t, n, a, s, o, !0, !0, new g(0, 0), l);\n          }\n          hasOffscreenPass() {\n            return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n          }\n          getProgramIds() {\n            return [\"heatmap\", \"heatmapTexture\"];\n          }\n          getDefaultProgramParams(t, e) {\n            return \"heatmap\" === t ? {\n              config: new Do(this, e),\n              overrideFog: !1\n            } : {};\n          }\n        },\n        hillshade: class extends ss {\n          constructor(t, e, r) {\n            super(t, Ip, e, r);\n          }\n          hasOffscreenPass() {\n            return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n          }\n          getProgramIds() {\n            return [\"hillshade\", \"hillshadePrepare\"];\n          }\n          getDefaultProgramParams(t, e) {\n            return {\n              overrideFog: !1\n            };\n          }\n        },\n        fill: class extends ss {\n          constructor(t, e, r) {\n            super(t, cf, e, r);\n          }\n          getProgramIds() {\n            const t = this.paint.get(\"fill-pattern\"),\n              e = t && t.constantOr(1),\n              r = [e ? \"fillPattern\" : \"fill\"];\n            return this.paint.get(\"fill-antialias\") && r.push(e && !this.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\"), r;\n          }\n          getDefaultProgramParams(t, e) {\n            return {\n              config: new Do(this, e),\n              overrideFog: !1\n            };\n          }\n          recalculate(t, e) {\n            super.recalculate(t, e);\n            const r = this.paint._values[\"fill-outline-color\"];\n            \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n          }\n          createBucket(t) {\n            return new lf(t);\n          }\n          queryRadius() {\n            return Wl(this.paint.get(\"fill-translate\"));\n          }\n          queryIntersectsFeature(t, e, r, n, i, a) {\n            return !t.queryGeometry.isAboveHorizon && Fl(Jl(t.tilespaceGeometry, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), a.angle, t.pixelToTileUnitsFactor), n);\n          }\n          isTileClipped() {\n            return !0;\n          }\n        },\n        \"fill-extrusion\": class extends ss {\n          constructor(t, e, r) {\n            super(t, kd, e, r), this._stats = {\n              numRenderedVerticesInShadowPass: 0,\n              numRenderedVerticesInTransparentPass: 0\n            };\n          }\n          createBucket(t) {\n            return new md(t);\n          }\n          queryRadius() {\n            return Wl(this.paint.get(\"fill-extrusion-translate\"));\n          }\n          is3D() {\n            return !0;\n          }\n          hasShadowPass() {\n            return !0;\n          }\n          cutoffRange() {\n            return this.paint.get(\"fill-extrusion-cutoff-fade-range\");\n          }\n          canCastShadows() {\n            return !0;\n          }\n          getProgramIds() {\n            return [this.paint.get(\"fill-extrusion-pattern\").constantOr(1) ? \"fillExtrusionPattern\" : \"fillExtrusion\"];\n          }\n          queryIntersectsFeature(e, r, n, i, a, s, o, l, u) {\n            const c = Ql(this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), s.angle, e.pixelToTileUnitsFactor),\n              h = this.paint.get(\"fill-extrusion-height\").evaluate(r, n),\n              p = this.paint.get(\"fill-extrusion-base\").evaluate(r, n),\n              f = [0, 0],\n              d = l && s.elevation,\n              m = s.elevation ? s.elevation.exaggeration() : 1,\n              y = e.tile.getBucket(this);\n            if (d && y instanceof md) {\n              const t = y.centroidVertexArray,\n                e = u + 1;\n              e < t.length && (f[0] = t.geta_centroid_pos0(e), f[1] = t.geta_centroid_pos1(e));\n            }\n            if (0 === f[0] && 1 === f[1]) return !1;\n            \"globe\" === s.projection.name && (i = Ad([i], [new g(0, 0), new g(Tr, Tr)], e.tileID.canonical).map(t => t.polygon).flat());\n            const x = d ? l : null,\n              [v, b] = function (e, r, n, i, a, s, o, l, u, c, h) {\n                return \"globe\" === e.projection.name ? function (e, r, n, i, a, s, o, l, u, c, h) {\n                  const p = [],\n                    f = [],\n                    d = e.projection.upVectorScale(h, e.center.lat, e.worldSize).metersToTile,\n                    m = [0, 0, 0, 1],\n                    y = [0, 0, 0, 1],\n                    g = (t, e, r, n) => {\n                      t[0] = e, t[1] = r, t[2] = n, t[3] = 1;\n                    },\n                    x = Md();\n                  n > 0 && (n += x), i += x;\n                  for (const x of r) {\n                    const r = [],\n                      v = [];\n                    for (const p of x) {\n                      const f = p.x + a.x,\n                        x = p.y + a.y,\n                        b = e.projection.projectTilePoint(f, x, h),\n                        _ = e.projection.upVector(h, p.x, p.y);\n                      let w = n,\n                        M = i;\n                      if (o) {\n                        const t = Td(f, x, n, i, o, l, u, c);\n                        w += t.base, M += t.top;\n                      }\n                      0 !== n ? g(m, b.x + _[0] * d * w, b.y + _[1] * d * w, b.z + _[2] * d * w) : g(m, b.x, b.y, b.z), g(y, b.x + _[0] * d * M, b.y + _[1] * d * M, b.z + _[2] * d * M), t.N.transformMat4(m, m, s), t.N.transformMat4(y, y, s), r.push(new Pd(m[0], m[1], m[2])), v.push(new Pd(y[0], y[1], y[2]));\n                    }\n                    p.push(r), f.push(v);\n                  }\n                  return [p, f];\n                }(e, r, n, i, a, s, o, l, u, c, h) : o ? function (e, r, n, i, a, s, o, l, u) {\n                  const c = [],\n                    h = [],\n                    p = [0, 0, 0, 1];\n                  for (const f of e) {\n                    const e = [],\n                      d = [];\n                    for (const c of f) {\n                      const h = c.x + i.x,\n                        f = c.y + i.y,\n                        m = Td(h, f, r, n, s, o, l, u);\n                      p[0] = h, p[1] = f, p[2] = m.base, p[3] = 1, t.a7.transformMat4(p, p, a), p[3] = Math.max(p[3], 1e-5);\n                      const y = new Pd(p[0] / p[3], p[1] / p[3], p[2] / p[3]);\n                      p[0] = h, p[1] = f, p[2] = m.top, p[3] = 1, t.a7.transformMat4(p, p, a), p[3] = Math.max(p[3], 1e-5);\n                      const g = new Pd(p[0] / p[3], p[1] / p[3], p[2] / p[3]);\n                      e.push(y), d.push(g);\n                    }\n                    c.push(e), h.push(d);\n                  }\n                  return [c, h];\n                }(r, n, i, a, s, o, l, u, c) : function (t, e, r, n, i) {\n                  const a = [],\n                    s = [],\n                    o = i[8] * e,\n                    l = i[9] * e,\n                    u = i[10] * e,\n                    c = i[11] * e,\n                    h = i[8] * r,\n                    p = i[9] * r,\n                    f = i[10] * r,\n                    d = i[11] * r;\n                  for (const e of t) {\n                    const t = [],\n                      r = [];\n                    for (const a of e) {\n                      const e = a.x + n.x,\n                        s = a.y + n.y,\n                        m = i[0] * e + i[4] * s + i[12],\n                        y = i[1] * e + i[5] * s + i[13],\n                        g = i[2] * e + i[6] * s + i[14],\n                        x = i[3] * e + i[7] * s + i[15],\n                        v = m + o,\n                        b = y + l,\n                        _ = g + u,\n                        w = Math.max(x + c, 1e-5),\n                        M = m + h,\n                        A = y + p,\n                        S = g + f,\n                        I = Math.max(x + d, 1e-5);\n                      t.push(new Pd(v / w, b / w, _ / w)), r.push(new Pd(M / I, A / I, S / I));\n                    }\n                    a.push(t), s.push(r);\n                  }\n                  return [a, s];\n                }(r, n, i, a, s);\n              }(s, i, p, h, c, o, x, f, m, s.center.lat, e.tileID.canonical),\n              _ = e.queryGeometry;\n            return function (t, e, r) {\n              let n = 1 / 0;\n              Fl(r, e) && (n = zd(r, e[0]));\n              for (let i = 0; i < e.length; i++) {\n                const a = e[i],\n                  s = t[i];\n                for (let t = 0; t < a.length - 1; t++) {\n                  const e = a[t],\n                    i = [e, a[t + 1], s[t + 1], s[t], e];\n                  Vl(r, i) && (n = Math.min(n, zd(r, i)));\n                }\n              }\n              return n !== 1 / 0 && n;\n            }(v, b, _.isPointQuery() ? _.screenBounds : _.screenGeometry);\n          }\n        },\n        line: class extends ss {\n          constructor(t, e, r) {\n            super(t, Ud, e, r), this.gradientVersion = 0;\n          }\n          _handleSpecialPaintPropertyUpdate(t) {\n            if (\"line-gradient\" === t) {\n              const t = this._transitionablePaint._values[\"line-gradient\"].value.expression;\n              this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Sn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;\n            }\n          }\n          gradientExpression() {\n            return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n          }\n          widthExpression() {\n            return this._transitionablePaint._values[\"line-width\"].value.expression;\n          }\n          recalculate(t, e) {\n            super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = Xd.possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n          }\n          createBucket(t) {\n            return new Nd(t);\n          }\n          getProgramIds() {\n            return [this.paint.get(\"line-pattern\").constantOr(1) ? \"linePattern\" : \"line\"];\n          }\n          getDefaultProgramParams(t, e) {\n            const r = Gd(this);\n            return {\n              config: new Do(this, e),\n              defines: r,\n              overrideFog: !1\n            };\n          }\n          queryRadius(t) {\n            const e = t,\n              r = Zd(Hl(\"line-width\", this, e), Hl(\"line-gap-width\", this, e)),\n              n = Hl(\"line-offset\", this, e);\n            return r / 2 + Math.abs(n) + Wl(this.paint.get(\"line-translate\"));\n          }\n          queryIntersectsFeature(t, e, r, n, i, a) {\n            if (t.queryGeometry.isAboveHorizon) return !1;\n            const s = Jl(t.tilespaceGeometry, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), a.angle, t.pixelToTileUnitsFactor),\n              o = t.pixelToTileUnitsFactor / 2 * Zd(this.paint.get(\"line-width\").evaluate(e, r), this.paint.get(\"line-gap-width\").evaluate(e, r)),\n              l = this.paint.get(\"line-offset\").evaluate(e, r);\n            return l && (n = function (t, e) {\n              const r = [],\n                n = new g(0, 0);\n              for (let i = 0; i < t.length; i++) {\n                const a = t[i],\n                  s = [];\n                for (let t = 0; t < a.length; t++) {\n                  const r = a[t],\n                    i = a[t + 1],\n                    o = 0 === t ? n : r.sub(a[t - 1])._unit()._perp(),\n                    l = t === a.length - 1 ? n : i.sub(r)._unit()._perp(),\n                    u = o._add(l)._unit();\n                  u._mult(1 / (u.x * l.x + u.y * l.y)), s.push(u._mult(e)._add(r));\n                }\n                r.push(s);\n              }\n              return r;\n            }(n, l * t.pixelToTileUnitsFactor)), function (t, e, r) {\n              for (let n = 0; n < e.length; n++) {\n                const i = e[n];\n                if (t.length >= 3) for (let e = 0; e < i.length; e++) if (Gl(t, i[e])) return !0;\n                if (Nl(t, i, r)) return !0;\n              }\n              return !1;\n            }(s, n, o);\n          }\n          isTileClipped() {\n            return !0;\n          }\n        },\n        symbol: kg,\n        background: class extends ss {\n          constructor(t, e, r) {\n            super(t, Eg, e, r);\n          }\n          getProgramIds() {\n            return [this.paint.get(\"background-pattern\") ? \"backgroundPattern\" : \"background\"];\n          }\n          getDefaultProgramParams(t, e) {\n            return {\n              overrideFog: !1\n            };\n          }\n        },\n        raster: Og,\n        \"raster-particle\": qg,\n        sky: class extends ss {\n          constructor(t, e, r) {\n            super(t, Yg, e, r), this._updateColorRamp();\n          }\n          _handleSpecialPaintPropertyUpdate(t) {\n            \"sky-gradient\" === t ? this._updateColorRamp() : \"sky-atmosphere-sun\" !== t && \"sky-atmosphere-halo-color\" !== t && \"sky-atmosphere-color\" !== t && \"sky-atmosphere-sun-intensity\" !== t || (this._skyboxInvalidated = !0);\n          }\n          _updateColorRamp() {\n            this.colorRamp = Ap({\n              expression: this._transitionablePaint._values[\"sky-gradient\"].value.expression,\n              evaluationKey: \"skyRadialProgress\"\n            }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n          }\n          needsSkyboxCapture(t) {\n            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;\n            if (!this.paint.get(\"sky-atmosphere-sun\")) {\n              const e = t.style.light.properties.get(\"position\");\n              return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;\n            }\n            return !1;\n          }\n          getCenter(t, e) {\n            if (\"atmosphere\" === this.paint.get(\"sky-type\")) {\n              const r = this.paint.get(\"sky-atmosphere-sun\"),\n                n = !r,\n                i = t.style.light,\n                a = i.properties.get(\"position\");\n              return n && \"viewport\" === i.properties.get(\"anchor\") && j(\"The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.\"), n ? Xg(a.azimuthal, 90 - a.polar, e) : Xg(r[0], 90 - r[1], e);\n            }\n            const r = this.paint.get(\"sky-gradient-center\");\n            return Xg(r[0], 90 - r[1], e);\n          }\n          isSky() {\n            return !0;\n          }\n          markSkyboxValid(t) {\n            this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get(\"position\");\n          }\n          hasOffscreenPass() {\n            return !0;\n          }\n          getProgramIds() {\n            const t = this.paint.get(\"sky-type\");\n            return \"atmosphere\" === t ? [\"skyboxCapture\", \"skybox\"] : \"gradient\" === t ? [\"skyboxGradient\"] : null;\n          }\n        },\n        slot: class extends ss {\n          constructor(t, e, r) {\n            super(t, Zg, e);\n          }\n        },\n        model: class extends ss {\n          constructor(t, e, r) {\n            super(t, yx, e, r), this._stats = {\n              numRenderedVerticesInShadowPass: 0,\n              numRenderedVerticesInTransparentPass: 0\n            };\n          }\n          createBucket(t) {\n            return new dx(t);\n          }\n          getProgramIds() {\n            return [\"model\"];\n          }\n          is3D() {\n            return !0;\n          }\n          hasShadowPass() {\n            return !0;\n          }\n          canCastShadows() {\n            return !0;\n          }\n          hasLightBeamPass() {\n            return !0;\n          }\n          cutoffRange() {\n            return this.paint.get(\"model-cutoff-fade-range\");\n          }\n          queryRadius(t) {\n            return t instanceof Pv ? Tr - 1 : 0;\n          }\n          queryIntersectsFeature(e, r, n, i, a, s) {\n            if (!this.modelManager) return !1;\n            const o = this.modelManager,\n              l = e.tile.getBucket(this);\n            if (!(l && l instanceof dx)) return !1;\n            const u = l;\n            for (const n in u.instancesPerModel) {\n              const i = u.instancesPerModel[n];\n              if (i.idToFeaturesIndex.hasOwnProperty(r.id)) {\n                const a = i.features[i.idToFeaturesIndex[r.id]],\n                  l = o.getModel(n, this.scope);\n                if (!l) return !1;\n                let c = t.a6.create();\n                const h = new tl(0, 0),\n                  p = u.canonical;\n                let f = Number.MAX_VALUE;\n                for (let r = 0; r < a.instancedDataCount; ++r) {\n                  const n = 16 * (a.instancedDataOffset + r),\n                    o = i.instancedDataArray.float32,\n                    u = [o[n + 4], o[n + 5], o[n + 6]];\n                  Bv(p, h, o[n], 0 | o[n + 1]), vx(c, l, s, h, a.rotation, a.scale, u, !1, !1, !1), \"globe\" === s.projection.name && (c = nx(c, s));\n                  const d = t.a6.multiply([], s.projMatrix, c),\n                    m = e.queryGeometry,\n                    y = ix(m.isPointQuery() ? m.screenBounds : m.screenGeometry, s, d, l.aabb);\n                  null != y && (f = Math.min(y, f));\n                }\n                return f !== Number.MAX_VALUE && f;\n              }\n            }\n            return !1;\n          }\n          _handleOverridablePaintPropertyUpdate(t, e, r) {\n            return !(!this.layout || e.isDataDriven() || r.isDataDriven() || \"model-color\" !== t && \"model-color-mix-intensity\" !== t && \"model-rotation\" !== t && \"model-scale\" !== t && \"model-translation\" !== t && \"model-emissive-strength\" !== t);\n          }\n          _isPropertyZoomDependent(t) {\n            const e = this._transitionablePaint._values[t];\n            return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof Xi;\n          }\n          isZoomDependent() {\n            return this._isPropertyZoomDependent(\"model-scale\") || this._isPropertyZoomDependent(\"model-rotation\") || this._isPropertyZoomDependent(\"model-translation\");\n          }\n          queryIntersectsMatchingFeature(e, r, n, i) {\n            const a = e.tile,\n              s = a.getBucket(this);\n            let o = null,\n              l = Number.MAX_VALUE;\n            if (!(s && s instanceof Pv)) return {\n              queryFeature: o,\n              intersectionZ: l\n            };\n            const u = s.getNodesInfo()[r];\n            if (u.hiddenByReplacement || !u.node.meshes || !n.filter(new Pa(a.tileID.overscaledZ), u.feature, a.tileID.canonical)) return {\n              queryFeature: o,\n              intersectionZ: l\n            };\n            const c = u.node,\n              h = i.calculatePosMatrix(a.tileID.toUnwrapped(), i.worldSize),\n              p = u.evaluatedScale;\n            let f = 0;\n            i.elevation && c.elevation && (f = c.elevation * i.elevation.exaggeration()), t.a6.translate(h, h, [(c.anchor ? c.anchor[0] : 0) * (p[0] - 1), (c.anchor ? c.anchor[1] : 0) * (p[1] - 1), f]), t.a6.scale(h, h, p), t.a6.multiply(h, h, c.matrix);\n            const d = e.queryGeometry,\n              m = d.isPointQuery() ? d.screenBounds : d.screenGeometry,\n              y = function (e) {\n                const r = t.a6.multiply([], h, e.matrix),\n                  n = t.a6.multiply(r, i.expandedFarZProjMatrix, r);\n                for (let t = 0; t < e.meshes.length; ++t) {\n                  const r = e.meshes[t];\n                  if (t === e.lightMeshIndex) continue;\n                  const a = ix(m, i, n, r.aabb);\n                  null != a && (l = Math.min(a, l));\n                }\n                if (e.children) for (const t of e.children) y(t);\n              };\n            if (y(c), l === Number.MAX_VALUE) return {\n              queryFeature: o,\n              intersectionZ: l\n            };\n            const g = new tl(0, 0);\n            return Bv(a.tileID.canonical, g, u.node.anchor[0], u.node.anchor[1]), o = {\n              type: \"Feature\",\n              geometry: {\n                type: \"Point\",\n                coordinates: [g.lng, g.lat]\n              },\n              properties: u.feature.properties,\n              id: u.feature.id,\n              state: {},\n              layer: this.serialize()\n            }, {\n              queryFeature: o,\n              intersectionZ: l\n            };\n          }\n        }\n      },\n      Rv = {\n        read: function (t, e) {\n          return t.readFields(Rv._readField, {\n            header_length: 0,\n            x: 0,\n            y: 0,\n            z: 0,\n            layers: []\n          }, e);\n        },\n        _readField: function (t, e, r) {\n          1 === t ? e.header_length = r.readFixed32() : 2 === t ? e.x = r.readVarint() : 3 === t ? e.y = r.readVarint() : 4 === t ? e.z = r.readVarint() : 5 === t && e.layers.push(Rv.Layer.read(r, r.readVarint() + r.pos));\n        },\n        PixelFormat: {\n          PIXEL_FORMAT_UNKNOWN: {\n            value: 0,\n            options: {}\n          },\n          PIXEL_FORMAT_UINT32: {\n            value: 1,\n            options: {}\n          },\n          PIXEL_FORMAT_UINT16: {\n            value: 2,\n            options: {}\n          },\n          PIXEL_FORMAT_UINT8: {\n            value: 3,\n            options: {}\n          }\n        },\n        Filter: {}\n      };\n    Rv.Filter.read = function (t, e) {\n      return t.readFields(Rv.Filter._readField, {\n        delta_filter: null,\n        filter: null,\n        zigzag_filter: null,\n        bitshuffle_filter: null,\n        byteshuffle_filter: null\n      }, e);\n    }, Rv.Filter._readField = function (t, e, r) {\n      1 === t ? (e.delta_filter = Rv.Filter.Delta.read(r, r.readVarint() + r.pos), e.filter = \"delta_filter\") : 2 === t ? (e.zigzag_filter = Rv.Filter.Zigzag.read(r, r.readVarint() + r.pos), e.filter = \"zigzag_filter\") : 3 === t ? (e.bitshuffle_filter = Rv.Filter.BitShuffle.read(r, r.readVarint() + r.pos), e.filter = \"bitshuffle_filter\") : 4 === t && (e.byteshuffle_filter = Rv.Filter.ByteShuffle.read(r, r.readVarint() + r.pos), e.filter = \"byteshuffle_filter\");\n    }, Rv.Filter.Delta = {}, Rv.Filter.Delta.read = function (t, e) {\n      return t.readFields(Rv.Filter.Delta._readField, {\n        block_size: 0\n      }, e);\n    }, Rv.Filter.Delta._readField = function (t, e, r) {\n      1 === t && (e.block_size = r.readVarint());\n    }, Rv.Filter.Zigzag = {}, Rv.Filter.Zigzag.read = function (t, e) {\n      return t.readFields(Rv.Filter.Zigzag._readField, {}, e);\n    }, Rv.Filter.Zigzag._readField = function (t, e, r) {}, Rv.Filter.BitShuffle = {}, Rv.Filter.BitShuffle.read = function (t, e) {\n      return t.readFields(Rv.Filter.BitShuffle._readField, {}, e);\n    }, Rv.Filter.BitShuffle._readField = function (t, e, r) {}, Rv.Filter.ByteShuffle = {}, Rv.Filter.ByteShuffle.read = function (t, e) {\n      return t.readFields(Rv.Filter.ByteShuffle._readField, {}, e);\n    }, Rv.Filter.ByteShuffle._readField = function (t, e, r) {}, Rv.Codec = {}, Rv.Codec.read = function (t, e) {\n      return t.readFields(Rv.Codec._readField, {\n        gzip_data: null,\n        codec: null,\n        jpeg_image: null,\n        webp_image: null,\n        png_image: null\n      }, e);\n    }, Rv.Codec._readField = function (t, e, r) {\n      1 === t ? (e.gzip_data = Rv.Codec.GzipData.read(r, r.readVarint() + r.pos), e.codec = \"gzip_data\") : 2 === t ? (e.jpeg_image = Rv.Codec.JpegImage.read(r, r.readVarint() + r.pos), e.codec = \"jpeg_image\") : 3 === t ? (e.webp_image = Rv.Codec.WebpImage.read(r, r.readVarint() + r.pos), e.codec = \"webp_image\") : 4 === t && (e.png_image = Rv.Codec.PngImage.read(r, r.readVarint() + r.pos), e.codec = \"png_image\");\n    }, Rv.Codec.GzipData = {}, Rv.Codec.GzipData.read = function (t, e) {\n      return t.readFields(Rv.Codec.GzipData._readField, {}, e);\n    }, Rv.Codec.GzipData._readField = function (t, e, r) {}, Rv.Codec.JpegImage = {}, Rv.Codec.JpegImage.read = function (t, e) {\n      return t.readFields(Rv.Codec.JpegImage._readField, {}, e);\n    }, Rv.Codec.JpegImage._readField = function (t, e, r) {}, Rv.Codec.WebpImage = {}, Rv.Codec.WebpImage.read = function (t, e) {\n      return t.readFields(Rv.Codec.WebpImage._readField, {}, e);\n    }, Rv.Codec.WebpImage._readField = function (t, e, r) {}, Rv.Codec.PngImage = {}, Rv.Codec.PngImage.read = function (t, e) {\n      return t.readFields(Rv.Codec.PngImage._readField, {}, e);\n    }, Rv.Codec.PngImage._readField = function (t, e, r) {}, Rv.DataIndexEntry = {}, Rv.DataIndexEntry.read = function (t, e) {\n      return t.readFields(Rv.DataIndexEntry._readField, {\n        first_byte: 0,\n        last_byte: 0,\n        filters: [],\n        codec: null,\n        offset: 0,\n        scale: 0,\n        bands: []\n      }, e);\n    }, Rv.DataIndexEntry._readField = function (t, e, r) {\n      1 === t ? e.first_byte = r.readFixed64() : 2 === t ? e.last_byte = r.readFixed64() : 3 === t ? e.filters.push(Rv.Filter.read(r, r.readVarint() + r.pos)) : 4 === t ? e.codec = Rv.Codec.read(r, r.readVarint() + r.pos) : 5 === t ? e.offset = r.readFloat() : 6 === t ? e.scale = r.readFloat() : 7 === t && e.bands.push(r.readString());\n    }, Rv.Layer = {}, Rv.Layer.read = function (t, e) {\n      return t.readFields(Rv.Layer._readField, {\n        version: 0,\n        name: \"\",\n        units: \"\",\n        tilesize: 0,\n        buffer: 0,\n        pixel_format: 0,\n        data_index: []\n      }, e);\n    }, Rv.Layer._readField = function (t, e, r) {\n      1 === t ? e.version = r.readVarint() : 2 === t ? e.name = r.readString() : 3 === t ? e.units = r.readString() : 4 === t ? e.tilesize = r.readVarint() : 5 === t ? e.buffer = r.readVarint() : 6 === t ? e.pixel_format = r.readVarint() : 7 === t && e.data_index.push(Rv.DataIndexEntry.read(r, r.readVarint() + r.pos));\n    };\n    const Dv = {\n      read: function (t, e) {\n        return t.readFields(Dv._readField, {\n          uint32_values: null,\n          values: null,\n          fixed32_values: null\n        }, e);\n      },\n      _readField: function (t, e, r) {\n        2 === t ? (e.uint32_values = Dv.Uint32Values.read(r, r.readVarint() + r.pos), e.values = \"uint32_values\") : 3 === t && (e.fixed32_values = Dv.Fixed32Values.read(r, r.readVarint() + r.pos), e.values = \"fixed32_values\");\n      },\n      Uint32Values: {}\n    };\n    Dv.Uint32Values.read = function (t, e) {\n      return t.readFields(Dv.Uint32Values._readField, {\n        values: []\n      }, e);\n    }, Dv.Uint32Values._readField = function (t, e, r) {\n      1 === t && (e.readValuesInto = function (t) {\n        if (2 !== t.type) throw new Error(`Unsupported pbf type \"${t.type}\"`);\n        const e = function (t) {\n            return 2 === t.type ? t.readVarint() + t.pos : t.pos + 1;\n          }(t),\n          r = t.pos;\n        return t.pos = e, function (n) {\n          t.pos = r;\n          let i = 0;\n          for (; t.pos < e;) {\n            const e = t.readVarint();\n            n[i++] = e;\n          }\n          return n;\n        };\n      }(r));\n    }, Dv.Fixed32Values = {}, Dv.Fixed32Values.read = function (t, e) {\n      return t.readFields(Dv.Fixed32Values._readField, {\n        values: []\n      }, e);\n    }, Dv.Fixed32Values._readField = function (t, e, r) {\n      throw new Error(\"Not implemented\");\n    };\n    /**\n     * tiny-lru\n     *\n     * @copyright 2023 Jason Mulligan <jason.mulligan@avoidwork.com>\n     * @license BSD-3-Clause\n     * @version 11.2.5\n     */\n    class Vv {\n      constructor(t = 0, e = 0, r = !1) {\n        this.first = null, this.items = Object.create(null), this.last = null, this.max = t, this.resetTtl = r, this.size = 0, this.ttl = e;\n      }\n      clear() {\n        return this.first = null, this.items = Object.create(null), this.last = null, this.size = 0, this;\n      }\n      delete(t) {\n        if (this.has(t)) {\n          const e = this.items[t];\n          delete this.items[t], this.size--, null !== e.prev && (e.prev.next = e.next), null !== e.next && (e.next.prev = e.prev), this.first === e && (this.first = e.next), this.last === e && (this.last = e.prev);\n        }\n        return this;\n      }\n      entries(t = this.keys()) {\n        return t.map(t => [t, this.get(t)]);\n      }\n      evict(t = !1) {\n        if (t || this.size > 0) {\n          const t = this.first;\n          delete this.items[t.key], 0 == --this.size ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);\n        }\n        return this;\n      }\n      expiresAt(t) {\n        let e;\n        return this.has(t) && (e = this.items[t].expiry), e;\n      }\n      get(t) {\n        let e;\n        if (this.has(t)) {\n          const r = this.items[t];\n          this.ttl > 0 && r.expiry <= Date.now() ? this.delete(t) : (e = r.value, this.set(t, e, !0));\n        }\n        return e;\n      }\n      has(t) {\n        return t in this.items;\n      }\n      keys() {\n        const t = [];\n        let e = this.first;\n        for (; null !== e;) t.push(e.key), e = e.next;\n        return t;\n      }\n      set(t, e, r = !1, n = this.resetTtl) {\n        let i;\n        if (r || this.has(t)) {\n          if (i = this.items[t], i.value = e, !1 === r && n && (i.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.last !== i) {\n            const t = this.last,\n              e = i.next,\n              r = i.prev;\n            this.first === i && (this.first = i.next), i.next = null, i.prev = this.last, t.next = i, null !== r && (r.next = e), null !== e && (e.prev = r);\n          }\n        } else this.max > 0 && this.size === this.max && this.evict(!0), i = this.items[t] = {\n          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n          key: t,\n          prev: this.last,\n          next: null,\n          value: e\n        }, 1 == ++this.size ? this.first = i : this.last.next = i;\n        return this.last = i, this;\n      }\n      values(t = this.keys()) {\n        return t.map(t => this.get(t));\n      }\n    }\n    function Lv(t, e) {\n      if (4 !== e.length) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);\n      let r = e[3];\n      for (let n = 2; n >= 1; n--) {\n        const i = 1 === n ? 1 : 0,\n          a = 2 === n ? 1 : 0;\n        for (let n = 0; n < e[0]; n++) {\n          const s = e[1] * n;\n          for (let n = i; n < e[1]; n++) {\n            const i = e[2] * (n + s);\n            for (let n = a; n < e[2]; n++) {\n              const a = e[3] * (n + i);\n              for (let n = 0; n < e[3]; n++) {\n                const e = a + n;\n                t[e] += t[e - r];\n              }\n            }\n          }\n        }\n        r *= e[n];\n      }\n      return t;\n    }\n    function Fv(t) {\n      for (let e = 0, r = t.length; e < r; e++) t[e] = t[e] >>> 1 ^ -(1 & t[e]);\n      return t;\n    }\n    function Nv(t, e) {\n      switch (e) {\n        case \"uint32\":\n          return t;\n        case \"uint16\":\n          for (let e = 0; e < t.length; e += 2) {\n            const r = t[e],\n              n = t[e + 1];\n            t[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;\n          }\n          return t;\n        case \"uint8\":\n          for (let e = 0; e < t.length; e += 4) {\n            const r = t[e],\n              n = t[e + 1],\n              i = t[e + 2],\n              a = t[e + 3];\n            t[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & a, t[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & a) << 2, t[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & a) << 4, t[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & a) << 6;\n          }\n          return t;\n        default:\n          throw new Error(`Invalid pixel format, \"${e}\"`);\n      }\n    }\n    class Ov extends Error {\n      constructor(t) {\n        super(t), this.name = \"MRTError\";\n      }\n    }\n    var Uv = Uint8Array,\n      jv = Uint16Array,\n      qv = Int32Array,\n      $v = new Uv([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),\n      Gv = new Uv([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),\n      Yv = new Uv([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n      Xv = function (t, e) {\n        for (var r = new jv(31), n = 0; n < 31; ++n) r[n] = e += 1 << t[n - 1];\n        var i = new qv(r[30]);\n        for (n = 1; n < 30; ++n) for (var a = r[n]; a < r[n + 1]; ++a) i[a] = a - r[n] << 5 | n;\n        return {\n          b: r,\n          r: i\n        };\n      },\n      Zv = Xv($v, 2),\n      Kv = Zv.b,\n      Hv = Zv.r;\n    Kv[28] = 258, Hv[258] = 28;\n    for (var Wv = Xv(Gv, 0).b, Jv = new jv(32768), Qv = 0; Qv < 32768; ++Qv) {\n      var tb = (43690 & Qv) >> 1 | (21845 & Qv) << 1;\n      Jv[Qv] = ((65280 & (tb = (61680 & (tb = (52428 & tb) >> 2 | (13107 & tb) << 2)) >> 4 | (3855 & tb) << 4)) >> 8 | (255 & tb) << 8) >> 1;\n    }\n    var eb = function (t, e, r) {\n        for (var n = t.length, i = 0, a = new jv(e); i < n; ++i) t[i] && ++a[t[i] - 1];\n        var s,\n          o = new jv(e);\n        for (i = 1; i < e; ++i) o[i] = o[i - 1] + a[i - 1] << 1;\n        if (r) {\n          s = new jv(1 << e);\n          var l = 15 - e;\n          for (i = 0; i < n; ++i) if (t[i]) for (var u = i << 4 | t[i], c = e - t[i], h = o[t[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h) s[Jv[h] >> l] = u;\n        } else for (s = new jv(n), i = 0; i < n; ++i) t[i] && (s[i] = Jv[o[t[i] - 1]++] >> 15 - t[i]);\n        return s;\n      },\n      rb = new Uv(288);\n    for (Qv = 0; Qv < 144; ++Qv) rb[Qv] = 8;\n    for (Qv = 144; Qv < 256; ++Qv) rb[Qv] = 9;\n    for (Qv = 256; Qv < 280; ++Qv) rb[Qv] = 7;\n    for (Qv = 280; Qv < 288; ++Qv) rb[Qv] = 8;\n    var nb = new Uv(32);\n    for (Qv = 0; Qv < 32; ++Qv) nb[Qv] = 5;\n    var ib = eb(rb, 9, 1),\n      ab = eb(nb, 5, 1),\n      sb = function (t) {\n        for (var e = t[0], r = 1; r < t.length; ++r) t[r] > e && (e = t[r]);\n        return e;\n      },\n      ob = function (t, e, r) {\n        var n = e / 8 | 0;\n        return (t[n] | t[n + 1] << 8) >> (7 & e) & r;\n      },\n      lb = function (t, e) {\n        var r = e / 8 | 0;\n        return (t[r] | t[r + 1] << 8 | t[r + 2] << 16) >> (7 & e);\n      },\n      ub = [\"unexpected EOF\", \"invalid block type\", \"invalid length/literal\", \"invalid distance\", \"stream finished\", \"no stream handler\",, \"no callback\", \"invalid UTF-8 data\", \"extra field too long\", \"date not in range 1980-2099\", \"filename too long\", \"stream finishing\", \"invalid zip data\"],\n      cb = function (t, e, r) {\n        var n = new Error(e || ub[t]);\n        if (n.code = t, Error.captureStackTrace && Error.captureStackTrace(n, cb), !r) throw n;\n        return n;\n      },\n      hb = new Uv(0),\n      pb = \"undefined\" != typeof TextDecoder && new TextDecoder();\n    try {\n      pb.decode(hb, {\n        stream: !0\n      });\n    } catch (t) {}\n    const fb = {\n      gzip_data: \"gzip\"\n    };\n    const db = {\n        0: \"uint32\",\n        1: \"uint32\",\n        2: \"uint16\",\n        3: \"uint8\"\n      },\n      mb = {\n        uint32: 1,\n        uint16: 2,\n        uint8: 4\n      },\n      yb = {\n        uint32: Uint32Array,\n        uint16: Uint16Array,\n        uint8: Uint8Array\n      };\n    class gb {\n      constructor(t = 1) {\n        this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t;\n      }\n      getLayer(t) {\n        return this.layers[t];\n      }\n      getHeaderLength(t) {\n        const e = new Uint8Array(t),\n          r = new DataView(t);\n        if (13 !== e[0]) throw new Ov(\"File is not a valid MRT.\");\n        return r.getUint32(1, !0);\n      }\n      parseHeader(t) {\n        const e = new Uint8Array(t),\n          r = this.getHeaderLength(t);\n        if (e.length < r) throw new Ov(`Expected header with length >= ${r} but got buffer of length ${e.length}`);\n        const n = new Vm(e.subarray(0, r)),\n          i = Rv.read(n);\n        if (!isNaN(this.x) && (this.x !== i.x || this.y !== i.y || this.z !== i.z)) throw new Ov(`Invalid attempt to parse header ${i.z}/${i.x}/${i.y} for tile ${this.z}/${this.x}/${this.y}`);\n        this.x = i.x, this.y = i.y, this.z = i.z;\n        for (const t of i.layers) this.layers[t.name] = new xb(t, {\n          cacheSize: this._cacheSize\n        });\n        return this;\n      }\n      createDecodingTask(t) {\n        const e = [],\n          r = this.getLayer(t.layerName);\n        for (let n = 0; n < r.dataIndex.length; n++) {\n          const i = r.dataIndex[n],\n            a = i.first_byte - t.firstByte,\n            s = i.last_byte + 1 - t.firstByte;\n          if (n < t.firstBlock || n > t.lastBlock) continue;\n          if (r._blocksInProgress.has(n)) continue;\n          const o = {\n            layerName: r.name,\n            firstByte: a,\n            lastByte: s,\n            pixelFormat: r.pixelFormat,\n            blockIndex: n,\n            blockShape: [i.bands.length].concat(r.bandShape),\n            buffer: r.buffer,\n            codec: i.codec.codec,\n            filters: i.filters.map(t => t.filter)\n          };\n          r._blocksInProgress.add(n), e.push(o);\n        }\n        return new vb(e, () => {\n          e.forEach(t => r._blocksInProgress.delete(t.blockIndex));\n        }, (t, n) => {\n          if (e.forEach(t => r._blocksInProgress.delete(t.blockIndex)), t) throw t;\n          n.forEach(t => {\n            this.getLayer(t.layerName).processDecodedData(t);\n          });\n        });\n      }\n    }\n    class xb {\n      constructor({\n        version: t,\n        name: e,\n        units: r,\n        tilesize: n,\n        pixel_format: i,\n        buffer: a,\n        data_index: s\n      }, o) {\n        if (this.version = t, 1 !== this.version) throw new Ov(`Cannot parse raster layer encoded with MRT version ${t}`);\n        this.name = e, this.units = r, this.tileSize = n, this.buffer = a, this.pixelFormat = db[i], this.dataIndex = s, this.bandShape = [n + 2 * a, n + 2 * a, mb[this.pixelFormat]], this._decodedBlocks = function (t = 1e3, e = 0, r = !1) {\n          if (isNaN(t) || t < 0) throw new TypeError(\"Invalid max value\");\n          if (isNaN(e) || e < 0) throw new TypeError(\"Invalid ttl value\");\n          if (\"boolean\" != typeof r) throw new TypeError(\"Invalid resetTtl value\");\n          return new Vv(t, e, r);\n        }(o ? o.cacheSize : 5), this._blocksInProgress = new Set();\n      }\n      processDecodedData(t) {\n        const e = t.blockIndex.toString();\n        this._decodedBlocks.get(e) || this._decodedBlocks.set(e, t.data);\n      }\n      getBlockForBand(t) {\n        let e = 0;\n        switch (typeof t) {\n          case \"string\":\n            for (const [r, n] of this.dataIndex.entries()) {\n              for (const [i, a] of n.bands.entries()) if (a === t) return {\n                bandIndex: e + i,\n                blockIndex: r,\n                blockBandIndex: i\n              };\n              e += n.bands.length;\n            }\n            break;\n          case \"number\":\n            for (const [r, n] of this.dataIndex.entries()) {\n              if (t >= e && t < e + n.bands.length) return {\n                bandIndex: t,\n                blockIndex: r,\n                blockBandIndex: t - e\n              };\n              e += n.bands.length;\n            }\n            break;\n          default:\n            throw new Ov(`Invalid band \\`${JSON.stringify(t)}\\`. Expected string or integer.`);\n        }\n        throw new Ov(`Band not found: ${JSON.stringify(t)}`);\n      }\n      getDataRange(t) {\n        let e = 1 / 0,\n          r = -1 / 0,\n          n = 1 / 0,\n          i = -1 / 0;\n        for (const a of t) {\n          const {\n            blockIndex: t\n          } = this.getBlockForBand(a);\n          if (t < 0) throw new Ov(`Invalid band: ${JSON.stringify(a)}`);\n          const s = this.dataIndex[t];\n          n = Math.min(n, t), i = Math.max(i, t), e = Math.min(e, s.first_byte), r = Math.max(r, s.last_byte);\n        }\n        return {\n          layerName: this.name,\n          firstByte: e,\n          lastByte: r,\n          firstBlock: n,\n          lastBlock: i\n        };\n      }\n      hasBand(t) {\n        const {\n          blockIndex: e\n        } = this.getBlockForBand(t);\n        return e >= 0;\n      }\n      hasDataForBand(t) {\n        const {\n          blockIndex: e\n        } = this.getBlockForBand(t);\n        return e >= 0 && !!this._decodedBlocks.get(e.toString());\n      }\n      getBandView(t) {\n        const {\n            blockIndex: e,\n            blockBandIndex: r\n          } = this.getBlockForBand(t),\n          n = this._decodedBlocks.get(e.toString());\n        if (!n) throw new Ov(`Data for band ${JSON.stringify(t)} of layer \"${this.name}\" not decoded.`);\n        const i = this.dataIndex[e],\n          a = this.bandShape.reduce((t, e) => t * e, 1),\n          s = r * a,\n          o = n.subarray(s, s + a);\n        return {\n          data: o,\n          bytes: new Uint8Array(o.buffer).subarray(o.byteOffset, o.byteOffset + o.byteLength),\n          tileSize: this.tileSize,\n          buffer: this.buffer,\n          offset: i.offset,\n          scale: i.scale\n        };\n      }\n    }\n    class vb {\n      constructor(t, e, r) {\n        this.tasks = t, this._onCancel = e, this._onComplete = r, this._finalized = !1;\n      }\n      cancel() {\n        this._finalized || (this._onCancel(), this._finalized = !0);\n      }\n      complete(t, e) {\n        this._finalized || (this._onComplete(t, e), this._finalized = !0);\n      }\n    }\n    gb.performDecoding = function (t, e) {\n      return Promise.all(e.tasks.map(e => {\n        const {\n            layerName: r,\n            firstByte: n,\n            lastByte: i,\n            pixelFormat: a,\n            blockShape: s,\n            blockIndex: o,\n            filters: l,\n            codec: u\n          } = e,\n          c = new Uint8Array(t).subarray(n, i + 1),\n          h = new Uint32Array(s[0] * s[1] * s[2]);\n        let p;\n        if (\"gzip_data\" !== u) throw new Error(`Unhandled codec: ${u}`);\n        return p = function (t, e) {\n          if (!globalThis.DecompressionStream && \"gzip_data\" === e) return Promise.resolve(((a = function (t) {\n            31 == t[0] && 139 == t[1] && 8 == t[2] || cb(6, \"invalid gzip data\");\n            var e = t[3],\n              r = 10;\n            4 & e && (r += 2 + (t[10] | t[11] << 8));\n            for (var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t[r++]);\n            return r + (2 & e);\n          }(i = t)) + 8 > i.length && cb(6, \"invalid gzip data\"), function (t, e, r, n) {\n            var i = t.length;\n            if (!i || e.f && !e.l) return r || new Uv(0);\n            var a = !r,\n              s = a || 2 != e.i,\n              o = e.i;\n            a && (r = new Uv(3 * i));\n            var l = function (t) {\n                var e = r.length;\n                if (t > e) {\n                  var n = new Uv(Math.max(2 * e, t));\n                  n.set(r), r = n;\n                }\n              },\n              u = e.f || 0,\n              c = e.p || 0,\n              h = e.b || 0,\n              p = e.l,\n              f = e.d,\n              d = e.m,\n              m = e.n,\n              y = 8 * i;\n            do {\n              if (!p) {\n                u = ob(t, c, 1);\n                var g = ob(t, c + 1, 3);\n                if (c += 3, !g) {\n                  var x = t[(E = 4 + ((c + 7) / 8 | 0)) - 4] | t[E - 3] << 8,\n                    v = E + x;\n                  if (v > i) {\n                    o && cb(0);\n                    break;\n                  }\n                  s && l(h + x), r.set(t.subarray(E, v), h), e.b = h += x, e.p = c = 8 * v, e.f = u;\n                  continue;\n                }\n                if (1 == g) p = ib, f = ab, d = 9, m = 5;else if (2 == g) {\n                  var b = ob(t, c, 31) + 257,\n                    _ = ob(t, c + 10, 15) + 4,\n                    w = b + ob(t, c + 5, 31) + 1;\n                  c += 14;\n                  for (var M = new Uv(w), A = new Uv(19), S = 0; S < _; ++S) A[Yv[S]] = ob(t, c + 3 * S, 7);\n                  c += 3 * _;\n                  var I = sb(A),\n                    k = (1 << I) - 1,\n                    P = eb(A, I, 1);\n                  for (S = 0; S < w;) {\n                    var E,\n                      z = P[ob(t, c, k)];\n                    if (c += 15 & z, (E = z >> 4) < 16) M[S++] = E;else {\n                      var T = 0,\n                        B = 0;\n                      for (16 == E ? (B = 3 + ob(t, c, 3), c += 2, T = M[S - 1]) : 17 == E ? (B = 3 + ob(t, c, 7), c += 3) : 18 == E && (B = 11 + ob(t, c, 127), c += 7); B--;) M[S++] = T;\n                    }\n                  }\n                  var C = M.subarray(0, b),\n                    R = M.subarray(b);\n                  d = sb(C), m = sb(R), p = eb(C, d, 1), f = eb(R, m, 1);\n                } else cb(1);\n                if (c > y) {\n                  o && cb(0);\n                  break;\n                }\n              }\n              s && l(h + 131072);\n              for (var D = (1 << d) - 1, V = (1 << m) - 1, L = c;; L = c) {\n                var F = (T = p[lb(t, c) & D]) >> 4;\n                if ((c += 15 & T) > y) {\n                  o && cb(0);\n                  break;\n                }\n                if (T || cb(2), F < 256) r[h++] = F;else {\n                  if (256 == F) {\n                    L = c, p = null;\n                    break;\n                  }\n                  var N = F - 254;\n                  F > 264 && (N = ob(t, c, (1 << (j = $v[S = F - 257])) - 1) + Kv[S], c += j);\n                  var O = f[lb(t, c) & V],\n                    U = O >> 4;\n                  if (O || cb(3), c += 15 & O, R = Wv[U], U > 3) {\n                    var j = Gv[U];\n                    R += lb(t, c) & (1 << j) - 1, c += j;\n                  }\n                  if (c > y) {\n                    o && cb(0);\n                    break;\n                  }\n                  s && l(h + 131072);\n                  var q = h + N;\n                  if (h < R) {\n                    var $ = 0 - R,\n                      G = Math.min(R, q);\n                    for ($ + h < 0 && cb(3); h < G; ++h) r[h] = n[$ + h];\n                  }\n                  for (; h < q; ++h) r[h] = r[h - R];\n                }\n              }\n              e.l = p, e.p = L, e.b = h, e.f = u, p && (u = 1, e.m = d, e.d = f, e.n = m);\n            } while (!u);\n            return h != r.length && a ? function (t, e, r) {\n              return (null == e || e < 0) && (e = 0), (null == r || r > t.length) && (r = t.length), new Uv(t.subarray(e, r));\n            }(r, 0, h) : r.subarray(0, h);\n          }(i.subarray(a, -8), {\n            i: 2\n          }, new Uv(((r = i)[(n = r.length) - 4] | r[n - 3] << 8 | r[n - 2] << 16 | r[n - 1] << 24) >>> 0), void 0)));\n          var r, n, i, a;\n          const s = fb[e];\n          if (!s) throw new Error(`Unhandled codec: ${e}`);\n          const o = new globalThis.DecompressionStream(s);\n          return new Response(new Blob([t]).stream().pipeThrough(o)).arrayBuffer().then(t => new Uint8Array(t));\n        }(c, u).then(t => {\n          const e = Dv.read(new Vm(t));\n          if (\"uint32_values\" === e.values) return e.uint32_values.readValuesInto(h), new (0, yb[a])(h.buffer);\n          throw new Error(`Unhandled numeric data \"${e.values}\"`);\n        }), p.then(t => {\n          for (let e = l.length - 1; e >= 0; e--) switch (l[e]) {\n            case \"delta_filter\":\n              Lv(t, s);\n              break;\n            case \"zigzag_filter\":\n              Fv(t);\n              break;\n            case \"bitshuffle_filter\":\n              Nv(t, a);\n              break;\n            default:\n              throw new Error(`Unhandled filter \"${l[e]}\"`);\n          }\n          return {\n            layerName: r,\n            blockIndex: o,\n            data: t\n          };\n        }).catch(t => {\n          throw t;\n        });\n      }));\n    }, ra(vb, \"MRTDecodingBatch\", {\n      omit: [\"_onCancel\", \"_onComplete\"]\n    });\n    const bb = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n    class _b {\n      static from(t) {\n        if (!(t instanceof ArrayBuffer)) throw new Error(\"Data must be an instance of ArrayBuffer.\");\n        const [e, r] = new Uint8Array(t, 0, 2);\n        if (219 !== e) throw new Error(\"Data does not appear to be in a KDBush format.\");\n        const n = r >> 4;\n        if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);\n        const i = bb[15 & r];\n        if (!i) throw new Error(\"Unrecognized array type.\");\n        const [a] = new Uint16Array(t, 2, 1),\n          [s] = new Uint32Array(t, 4, 1);\n        return new _b(s, a, i, t);\n      }\n      constructor(t, e = 64, r = Float64Array, n) {\n        if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);\n        this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;\n        const i = bb.indexOf(this.ArrayType),\n          a = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,\n          s = t * this.IndexArrayType.BYTES_PER_ELEMENT,\n          o = (8 - s % 8) % 8;\n        if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);\n        n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + s + o, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + a + s + o), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + s + o, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t);\n      }\n      add(t, e) {\n        const r = this._pos >> 1;\n        return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = e, r;\n      }\n      finish() {\n        const t = this._pos >> 1;\n        if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);\n        return wb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;\n      }\n      range(t, e, r, n) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: i,\n            coords: a,\n            nodeSize: s\n          } = this,\n          o = [0, i.length - 1, 0],\n          l = [];\n        for (; o.length;) {\n          const u = o.pop() || 0,\n            c = o.pop() || 0,\n            h = o.pop() || 0;\n          if (c - h <= s) {\n            for (let s = h; s <= c; s++) {\n              const o = a[2 * s],\n                u = a[2 * s + 1];\n              o >= t && o <= r && u >= e && u <= n && l.push(i[s]);\n            }\n            continue;\n          }\n          const p = h + c >> 1,\n            f = a[2 * p],\n            d = a[2 * p + 1];\n          f >= t && f <= r && d >= e && d <= n && l.push(i[p]), (0 === u ? t <= f : e <= d) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= f : n >= d) && (o.push(p + 1), o.push(c), o.push(1 - u));\n        }\n        return l;\n      }\n      within(t, e, r) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: n,\n            coords: i,\n            nodeSize: a\n          } = this,\n          s = [0, n.length - 1, 0],\n          o = [],\n          l = r * r;\n        for (; s.length;) {\n          const u = s.pop() || 0,\n            c = s.pop() || 0,\n            h = s.pop() || 0;\n          if (c - h <= a) {\n            for (let r = h; r <= c; r++) Ib(i[2 * r], i[2 * r + 1], t, e) <= l && o.push(n[r]);\n            continue;\n          }\n          const p = h + c >> 1,\n            f = i[2 * p],\n            d = i[2 * p + 1];\n          Ib(f, d, t, e) <= l && o.push(n[p]), (0 === u ? t - r <= f : e - r <= d) && (s.push(h), s.push(p - 1), s.push(1 - u)), (0 === u ? t + r >= f : e + r >= d) && (s.push(p + 1), s.push(c), s.push(1 - u));\n        }\n        return o;\n      }\n    }\n    function wb(t, e, r, n, i, a) {\n      if (i - n <= r) return;\n      const s = n + i >> 1;\n      Mb(t, e, s, n, i, a), wb(t, e, r, n, s - 1, 1 - a), wb(t, e, r, s + 1, i, 1 - a);\n    }\n    function Mb(t, e, r, n, i, a) {\n      for (; i > n;) {\n        if (i - n > 600) {\n          const s = i - n + 1,\n            o = r - n + 1,\n            l = Math.log(s),\n            u = .5 * Math.exp(2 * l / 3),\n            c = .5 * Math.sqrt(l * u * (s - u) / s) * (o - s / 2 < 0 ? -1 : 1);\n          Mb(t, e, r, Math.max(n, Math.floor(r - o * u / s + c)), Math.min(i, Math.floor(r + (s - o) * u / s + c)), a);\n        }\n        const s = e[2 * r + a];\n        let o = n,\n          l = i;\n        for (Ab(t, e, n, r), e[2 * i + a] > s && Ab(t, e, n, i); o < l;) {\n          for (Ab(t, e, o, l), o++, l--; e[2 * o + a] < s;) o++;\n          for (; e[2 * l + a] > s;) l--;\n        }\n        e[2 * n + a] === s ? Ab(t, e, n, l) : (l++, Ab(t, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);\n      }\n    }\n    function Ab(t, e, r, n) {\n      Sb(t, r, n), Sb(e, 2 * r, 2 * n), Sb(e, 2 * r + 1, 2 * n + 1);\n    }\n    function Sb(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function Ib(t, e, r, n) {\n      const i = t - r,\n        a = e - n;\n      return i * i + a * a;\n    }\n    t.$ = Yy, t.A = Di, t.B = Bi, t.C = nr, t.D = qa, t.E = ee, t.F = Oa, t.G = La, t.H = class {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return G(t.expression.evaluate(e));\n      }\n      interpolate(t, e, r) {\n        return {\n          x: ue(t.x, e.x, r),\n          y: ue(t.y, e.y, r),\n          z: ue(t.z, e.z, r),\n          azimuthal: ue(t.azimuthal, e.azimuthal, r),\n          polar: ue(t.polar, e.polar, r)\n        };\n      }\n    }, t.I = dy, t.J = Ta, t.K = Pa, t.L = Ml, t.M = class {\n      constructor(t, e, r, n) {\n        this.id = t, this.position = null != e ? new tl(e[0], e[1]) : new tl(0, 0), this.orientation = null != r ? r : [0, 0, 0], this.nodes = n, this.uploaded = !1, this.aabb = new Bh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];\n      }\n      _applyTransformations(e, r) {\n        if (t.a6.multiply(e.matrix, r, e.matrix), e.meshes) for (const t of e.meshes) {\n          const r = Bh.applyTransform(t.aabb, e.matrix);\n          this.aabb.encapsulate(r);\n        }\n        if (e.children) for (const t of e.children) this._applyTransformations(t, e.matrix);\n      }\n      computeBoundsAndApplyParent() {\n        const e = t.a6.identity([]);\n        for (const t of this.nodes) this._applyTransformations(t, e);\n      }\n      computeModelMatrix(t, e, r, n, i, a, s = !1) {\n        vx(this.matrix, this, t.transform, this.position, e, r, n, i, a, s);\n      }\n      upload(t) {\n        if (!this.uploaded) {\n          for (const e of this.nodes) wx(e, t);\n          for (const t of this.nodes) Mx(t);\n          this.uploaded = !0;\n        }\n      }\n      destroy() {\n        for (const t of this.nodes) Ax(t);\n      }\n    }, t.O = k, t.P = g, t.Q = Va, t.R = At, t.S = rp, t.T = Cg, t.U = ue, t.V = Tr, t.W = ce, t.X = class {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return function ([t, e]) {\n          const r = G([1, t, e]);\n          return {\n            x: r.x,\n            y: r.y,\n            z: r.z\n          };\n        }(t.expression.evaluate(e));\n      }\n      interpolate(t, e, r) {\n        return {\n          x: ue(t.x, e.x, r),\n          y: ue(t.y, e.y, r),\n          z: ue(t.z, e.z, r)\n        };\n      }\n    }, t.Y = function (t, e, r = 0, n = !0) {\n      const i = new g(r, r),\n        a = t.sub(i),\n        s = e.add(i),\n        o = [a, new g(s.x, a.y), s, new g(a.x, s.y)];\n      return n && o.push(a.clone()), o;\n    }, t.Z = Xi, t._ = function (t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; n++) {\n        const i = P(n - 1, -1, t.length - 1),\n          a = P(n + 1, -1, t.length - 1),\n          s = t[n],\n          o = t[a],\n          l = t[i].sub(s).unit(),\n          u = o.sub(s).unit(),\n          c = u.angleWithSep(l.x, l.y),\n          h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));\n        r.push(s.add(h));\n      }\n      return r;\n    }, t.a = te, t.a$ = function (t) {\n      const e = [];\n      for (const r in t) e.push(t[r]);\n      return e;\n    }, t.a0 = Yl, t.a1 = function (e, r, n = 0) {\n      return t.N.fromValues(((r.x - n) * e.scale - e.x) * Tr, (r.y * e.scale - e.y) * Tr, gl(r.z, r.y));\n    }, t.a2 = Sh, t.a3 = jd, t.a4 = function (t) {\n      let e = 1 / 0,\n        r = 1 / 0,\n        n = -1 / 0,\n        i = -1 / 0;\n      for (const a of t) e = Math.min(e, a.x), r = Math.min(r, a.y), n = Math.max(n, a.x), i = Math.max(i, a.y);\n      return {\n        min: new g(e, r),\n        max: new g(n, i)\n      };\n    }, t.a5 = pl, t.a8 = Gl, t.a9 = Sl, t.aA = bi, t.aB = eo, t.aC = B, t.aD = qs, t.aE = Mg, t.aF = function () {\n      ka.isLoading() || ka.isLoaded() || \"deferred\" !== Sa() || Ia();\n    }, t.aG = Ga, t.aH = Bl, t.aI = xv, t.aJ = X, t.aK = Nd, t.aL = lf, t.aM = Tl, t.aN = ps, t.aO = Vs, t.aP = Vh, t.aQ = rf, t.aR = Bg, t.aS = function (e, r) {\n      const n = rp(r.zoom);\n      if (0 === n) return jh(e);\n      const i = Yh(e),\n        a = Xh(i),\n        s = pl(i.getWest()) * r.worldSize,\n        o = pl(i.getEast()) * r.worldSize,\n        l = fl(i.getNorth()) * r.worldSize,\n        u = fl(i.getSouth()) * r.worldSize,\n        c = [s, l, 0],\n        h = [o, l, 0],\n        p = [s, u, 0],\n        f = [o, u, 0],\n        d = t.a6.invert([], r.globeMatrix);\n      return t.N.transformMat4(c, c, d), t.N.transformMat4(h, h, d), t.N.transformMat4(p, p, d), t.N.transformMat4(f, f, d), a[0] = qh(a[0], p, n), a[1] = qh(a[1], f, n), a[2] = qh(a[2], h, n), a[3] = qh(a[3], c, n), Bh.fromPoints(a);\n    }, t.aT = Wh, t.aU = Zh, t.aV = qh, t.aW = fs, t.aX = Dh, t.aY = V, t.aZ = gb, t.a_ = Pt, t.aa = I, t.ab = jo, t.ac = function (t, e) {\n      const r = {};\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n      return r;\n    }, t.ad = el, t.ae = fl, t.af = class {\n      constructor(t) {\n        this.entries = {}, this.scheduler = t;\n      }\n      request(t, e, r, n) {\n        const i = this.entries[t] = this.entries[t] || {\n          callbacks: []\n        };\n        if (i.result) {\n          const [t, r] = i.result;\n          return this.scheduler ? this.scheduler.add(() => {\n            n(t, r);\n          }, e) : n(t, r), () => {};\n        }\n        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {\n          i.result = [r, n];\n          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {\n            t(r, n);\n          }, e) : t(r, n);\n          setTimeout(() => delete this.entries[t], 3e3);\n        })), () => {\n          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));\n        };\n      }\n    }, t.ag = is, t.ah = function (t, e, r) {\n      const n = JSON.stringify(t.request);\n      return t.data && (this.deduped.entries[n] = {\n        result: [null, t.data]\n      }), this.deduped.request(n, {\n        type: \"parseTile\",\n        isSymbolTile: t.isSymbolTile,\n        zoom: t.tileZoom\n      }, e => {\n        const n = Pt(t.request, (t, n, i, a) => {\n          t ? e(t) : n && e(null, {\n            vectorTile: r ? void 0 : new Ef(new Vm(n)),\n            rawData: n,\n            cacheControl: i,\n            expires: a\n          });\n        });\n        return () => {\n          n.cancel(), e();\n        };\n      }, e);\n    }, t.ai = function (t) {\n      yt++, yt > ut && (t.getActor().send(\"enforceCacheSizeLimit\", lt), yt = 0);\n    }, t.aj = qt, t.ak = at, t.al = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));\n    }, t.am = sl, t.an = Og, t.ao = qg, t.ap = Fg, t.aq = function (t, e) {\n      const r = document.createElement(\"video\");\n      r.muted = !0, r.onloadstart = function () {\n        e(null, r);\n      };\n      for (let e = 0; e < t.length; e++) {\n        const n = document.createElement(\"source\");\n        Et(t[e]) || (r.crossOrigin = \"Anonymous\"), n.src = t[e], r.appendChild(n);\n      }\n      return {\n        cancel: () => {}\n      };\n    }, t.ar = Rg, t.as = Gy, t.at = ml, t.au = yl, t.av = ds, t.aw = Es, t.ax = le, t.ay = cs, t.az = Ls, t.b = Qt, t.b$ = wa, t.b0 = function (t, e) {\n      const r = [];\n      for (const n in t) n in e || r.push(n);\n      return r;\n    }, t.b1 = E, t.b2 = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"], t.b3 = function (e, r) {\n      const {\n          x: n,\n          y: i\n        } = e.point,\n        a = ep(n, i, e.worldSize / e._pixelsPerMercatorPixel, 0, 0);\n      return t.a6.multiply(a, a, Jh(jh(r)));\n    }, t.b5 = lm, t.b6 = jm, t.b7 = om, t.b8 = function (t, e, r, n, i) {\n      const a = 5 * e + 2;\n      t.float32[a + 0] = r, t.float32[a + 1] = n, t.float32[a + 2] = i;\n    }, t.b9 = vg, t.bA = Wg, t.bB = Kg, t.bC = function (e) {\n      const r = Kg(e, !0);\n      return t.b4.invert([], [r[0], r[1], r[4], r[5]]);\n    }, t.bD = Ih, t.bE = function (t) {\n      const {\n          x: e,\n          y: r\n        } = t.point,\n        {\n          lng: n,\n          lat: i\n        } = t._center;\n      return ep(e, r, t.worldSize, n, i);\n    }, t.bF = _, t.bG = qo, t.bH = function (t) {\n      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;\n      return w[e];\n    }, t.bI = 45, t.bJ = hl, t.bK = So, t.bL = bo, t.bM = _o, t.bN = vo, t.bO = xo, t.bP = wo, t.bQ = function (t, e, r) {\n      const n = Math.sqrt(t * t + e * e + r * r),\n        i = n > 0 ? Math.acos(r / n) * v : 0;\n      let a = 0 !== t || 0 !== e ? Math.atan2(-e, -t) * v + 90 : 0;\n      return a < 0 && (a += 360), [n, a, i];\n    }, t.bR = wl, t.bS = Bh, t.bT = G, t.bU = function (t) {\n      return [Math.pow(t[0], 1 / 2.2), Math.pow(t[1], 1 / 2.2), Math.pow(t[2], 1 / 2.2)];\n    }, t.bV = function (t) {\n      return t({\n        pluginStatus: ba,\n        pluginURL: _a\n      }), Aa.on(\"pluginStateChange\", t), t;\n    }, t.bW = Px, t.bX = Rx, t.bY = _y, t.bZ = by, t.b_ = It, t.ba = hy, t.bb = Vl, t.bc = im, t.bd = Ry, t.be = Dy, t.bf = Qm, t.bg = _b, t.bh = P, t.bj = b, t.bk = rt, t.bl = dl, t.bm = function (t, e, r) {\n      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];\n    }, t.bn = tl, t.bo = fg, t.bp = al, t.bq = Th, t.br = Hg, t.bs = il, t.bt = Gh, t.bu = function (t, e, r, n, i, a, s, o, l) {\n      if (\"globe\" === l.name) return Gh(t, e, new il(r, n, i), !1);\n      const u = Gy({\n        z: r,\n        x: n,\n        y: i\n      }, l);\n      return new Bh([(a + u.x / u.scale) * e, e * (u.y / u.scale), s], [(a + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);\n    }, t.bv = function (t, e, r) {\n      let n = 0;\n      for (let i = 0; i < 2; ++i) {\n        const a = r ? r[i] : 0;\n        t[i] > a && (n += (t[i] - a) * (t[i] - a)), e[i] < a && (n += (a - e[i]) * (a - e[i]));\n      }\n      return n;\n    }, t.bw = xl, t.bx = $o, t.by = function (e) {\n      const r = t.a6.identity(new Float64Array(16));\n      t.a6.multiply(r, e.pixelMatrix, e.globeMatrix);\n      const n = [0, Zo, 0],\n        i = [0, Ko, 0];\n      return t.N.transformMat4(n, n, r), t.N.transformMat4(i, i, r), [n[0] > 0 && n[0] <= e.width && n[1] > 0 && n[1] <= e.height && !ip(e, new tl(e.center.lat, 90)), i[0] > 0 && i[0] <= e.width && i[1] > 0 && i[1] <= e.height && !ip(e, new tl(e.center.lat, -90))];\n    }, t.bz = function (e, r) {\n      const {\n          scale: n\n        } = e.tileTransform,\n        i = n * Tr / (e.tileSize * Math.pow(2, r.zoom - e.tileID.overscaledZ + e.tileID.canonical.z));\n      return t.b4.scale(new Float32Array(4), r.inverseAdjustmentMatrix, [i, i]);\n    }, t.c = fv, t.c$ = function () {\n      return !!document.fullscreenElement || !!document.webkitFullscreenElement;\n    }, t.c0 = a, t.c1 = O, t.c2 = function (t, e, r) {\n      return \"custom\" === t.type ? new $g(t, e) : new Cv[t.type](t, e, r);\n    }, t.c3 = function (t) {\n      const e = t.indexOf(ns);\n      return e >= 0 ? t.slice(0, e) : t;\n    }, t.c4 = function (t) {\n      return t.indexOf(ns) >= 0;\n    }, t.c5 = function (t) {\n      const e = t.indexOf(ns);\n      return e >= 0 ? t.slice(e + 1) : \"\";\n    }, t.c6 = function (t) {\n      const e = [],\n        r = t.id;\n      return void 0 === r && e.push({\n        message: `layers.${r}: missing required property \"id\"`\n      }), void 0 === t.render && e.push({\n        message: `layers.${r}: missing required method \"render\"`\n      }), t.renderingMode && \"2d\" !== t.renderingMode && \"3d\" !== t.renderingMode && e.push({\n        message: `layers.${r}: property \"renderingMode\" must be either \"2d\" or \"3d\"`\n      }), e;\n    }, t.c7 = N, t.c8 = Aa, t.c9 = kt, t.cA = Gd, t.cB = (t, e, r, n, i, a) => {\n      const s = t.transform;\n      return {\n        u_matrix: $d(t, e, r, n),\n        u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0],\n        u_pixels_to_tile_units: s.calculatePixelsToTileUnitsMatrix(e),\n        u_device_pixel_ratio: i,\n        u_image: 0,\n        u_tile_units_to_pixels: qd(e, s),\n        u_units_to_pixels: [1 / s.pixelsToGLUnits[0], 1 / s.pixelsToGLUnits[1]],\n        u_alpha_discard_threshold: 0,\n        u_trim_offset: a\n      };\n    }, t.cC = (t, e, r, n, i, a, s) => {\n      const o = t.transform,\n        l = o.calculatePixelsToTileUnitsMatrix(e);\n      return {\n        u_matrix: $d(t, e, r, n),\n        u_pixels_to_tile_units: l,\n        u_device_pixel_ratio: a,\n        u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]],\n        u_dash_image: 0,\n        u_gradient_image: 1,\n        u_image_height: i,\n        u_texsize: Yd(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0],\n        u_tile_units_to_pixels: qd(e, t.transform),\n        u_alpha_discard_threshold: 0,\n        u_trim_offset: s,\n        u_emissive_strength: r.paint.get(\"line-emissive-strength\")\n      };\n    }, t.cD = R, t.cE = Ap, t.cF = Md, t.cG = ll, t.cH = md, t.cI = id, t.cJ = 450, t.cK = 7, t.cL = Ng, t.cM = 256, t.cN = Jh, t.cO = Cs, t.cP = Rs, t.cQ = function (t, e, r, n, i) {\n      return I((t - e) / (r - e) * (i - n) + n, n, i);\n    }, t.cR = bl, t.cS = nx, t.cT = [1, 1, 1], t.cU = Wf, t.cV = xx, t.cW = As, t.cX = class {\n      constructor() {\n        this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [];\n      }\n      clear() {\n        this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];\n      }\n      get updateTime() {\n        return this._updateTime;\n      }\n      getReplacementRegionsForTile(t) {\n        const e = Df(new g(0, 0), new g(Tr, Tr), t),\n          r = [];\n        for (const n of this._activeRegions) {\n          if (n.hiddenByOverlap) continue;\n          if (!Rf(e, n)) continue;\n          const i = Vf(n.min, n.max, t);\n          r.push({\n            min: i.min,\n            max: i.max,\n            sourceId: this._sourceIds[n.priority],\n            footprint: n.footprint,\n            footprintTileId: n.tileId\n          });\n        }\n        return r;\n      }\n      setSources(t) {\n        this._setSources(t.map(t => ({\n          getSourceId: () => t.cache.id,\n          getFootprints: () => {\n            const e = [];\n            for (const r of t.cache.getVisibleCoordinates()) {\n              const n = t.cache.getTile(r).buckets[t.layer];\n              if (n) for (const t of n.getNodesInfo()) {\n                const n = t.node;\n                n.footprint && e.push({\n                  footprint: n.footprint,\n                  id: r.toUnwrapped()\n                });\n              }\n            }\n            return e;\n          }\n        })));\n      }\n      _addSource(t) {\n        const e = t.getFootprints();\n        if (0 !== e.length) {\n          for (const t of e) {\n            if (!t.footprint) continue;\n            const e = Df(t.footprint.min, t.footprint.max, t.id);\n            this._activeRegions.push({\n              min: e.min,\n              max: e.max,\n              hiddenByOverlap: !1,\n              priority: this._sourceIds.length,\n              tileId: t.id,\n              footprint: t.footprint\n            });\n          }\n          this._sourceIds.push(t.getSourceId());\n        }\n      }\n      _computeReplacement() {\n        this._activeRegions.sort((t, e) => t.priority - e.priority || Bf(t.min, e.min) || Bf(t.max, e.max));\n        let t = this._activeRegions.length !== this._prevRegions.length;\n        if (!t) {\n          let e = 0,\n            r = 0;\n          for (; !t && e !== this._activeRegions.length;) {\n            const n = this._activeRegions[e],\n              i = this._prevRegions[r];\n            t = n.priority !== i.priority || !Cf(n, i), ++e, ++r;\n          }\n        }\n        if (t) {\n          ++this._updateTime;\n          const t = t => {\n            const e = this._activeRegions;\n            if (t >= e.length) return t;\n            const r = e[t].priority;\n            for (; t < e.length && e[t].priority === r;) ++t;\n            return t;\n          };\n          if (this._sourceIds.length > 1) {\n            let e = 0,\n              r = t(e);\n            for (; e !== r;) {\n              let n = e;\n              const i = e;\n              for (; n !== r;) {\n                const t = this._activeRegions[n];\n                t.hiddenByOverlap = !1;\n                for (let e = 0; e < i; e++) {\n                  const r = this._activeRegions[e];\n                  if (!r.hiddenByOverlap && Rf(t, r) && (t.hiddenByOverlap = Ff(t.footprint, t.tileId, r.footprint, r.tileId), t.hiddenByOverlap)) break;\n                }\n                ++n;\n              }\n              e = r, r = t(e);\n            }\n          }\n        }\n      }\n      _setSources(t) {\n        [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];\n        for (let e = t.length - 1; e >= 0; e--) this._addSource(t[e]);\n        this._computeReplacement();\n      }\n    }, t.cY = class {\n      constructor(t) {\n        this._createGrid(t), this._createPoles(t);\n      }\n      destroy() {\n        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();\n        for (const t of this._poleSegments) t.destroy();\n        for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();\n      }\n      _fillGridMeshWithLods(t, e) {\n        const r = new ps(),\n          n = new Es(),\n          i = [],\n          a = t + 1 + 2,\n          s = e[0] + 1,\n          o = e[0] + 1 + (1 + e.length),\n          l = (t, e, r) => {\n            let n = t === a - 1 ? t - 2 : 0 === t ? t : t - 1;\n            return n += r ? 24575 : 0, [n, e];\n          };\n        for (let t = 0; t < a; ++t) r.emplaceBack(...l(t, 0, !0));\n        for (let t = 0; t < s; ++t) for (let e = 0; e < a; ++e) r.emplaceBack(...l(e, t, (0 === e || e === a - 1) && !0));\n        for (let t = 0; t < e.length; ++t) {\n          const n = e[t];\n          for (let t = 0; t < a; ++t) r.emplaceBack(...l(t, n, !0));\n        }\n        for (let t = 0; t < e.length; ++t) {\n          const s = n.length,\n            l = e[t] + 1 + 2,\n            u = new Es();\n          for (let r = 0; r < l - 1; r++) {\n            const i = r === l - 2,\n              s = i ? a * (o - e.length + t - r) : a;\n            for (let t = 0; t < a - 1; t++) {\n              const e = r * a + t;\n              0 === r || i || 0 === t || t === a - 2 ? (u.emplaceBack(e + 1, e, e + s), u.emplaceBack(e + s, e + s + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + s), n.emplaceBack(e + s, e + s + 1, e + 1));\n            }\n          }\n          const c = eo.simpleSegment(0, s, r.length, n.length - s);\n          for (let t = 0; t < u.uint16.length; t += 3) n.emplaceBack(u.uint16[t], u.uint16[t + 1], u.uint16[t + 2]);\n          const h = eo.simpleSegment(0, s, r.length, n.length - s);\n          i.push({\n            withoutSkirts: c,\n            withSkirts: h\n          });\n        }\n        return {\n          vertices: r,\n          indices: n,\n          segments: i\n        };\n      }\n      _createGrid(t) {\n        const e = this._fillGridMeshWithLods(Yo, Xo);\n        this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, Vh.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);\n      }\n      _createPoles(t) {\n        const e = new Es();\n        for (let t = 0; t <= Yo; t++) e.emplaceBack(0, t + 1, t + 2);\n        this._poleIndexBuffer = t.createIndexBuffer(e, !0);\n        const r = new Cs(),\n          n = new Cs(),\n          i = new Cs(),\n          a = new Cs();\n        this._poleSegments = [];\n        for (let t = 0, e = 0; t < qo; t++) {\n          const s = 360 / (1 << t);\n          r.emplaceBack(0, -jo, 0, .5, 0), n.emplaceBack(0, -jo, 0, .5, 1), i.emplaceBack(0, -jo, 0, .5, .5), a.emplaceBack(0, -jo, 0, .5, .5);\n          for (let t = 0; t <= Yo; t++) {\n            let e = t / Yo,\n              o = 0;\n            const l = ue(0, s, e),\n              [u, c, h] = Ho(sp, op, l, jo);\n            r.emplaceBack(u, c, h, e, o), n.emplaceBack(u, c, h, e, 1 - o);\n            const p = b(l);\n            e = .5 + .5 * Math.sin(p), o = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, o), a.emplaceBack(u, c, h, e, 1 - o);\n          }\n          this._poleSegments.push(eo.simpleSegment(e, 0, 66, 64)), e += 66;\n        }\n        this._poleNorthVertexBuffer = t.createVertexBuffer(r, Rh, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, Rh, !1), this._texturedPoleNorthVertexBuffer = t.createVertexBuffer(i, Rh, !1), this._texturedPoleSouthVertexBuffer = t.createVertexBuffer(a, Rh, !1);\n      }\n      getGridBuffers(t, e) {\n        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];\n      }\n      getPoleBuffers(t, e) {\n        return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];\n      }\n    }, t.cZ = function (t) {\n      return Ht.has(t);\n    }, t.c_ = A, t.ca = Mo, t.cb = class extends go {\n      constructor(t) {\n        super(t), this.current = Io;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 9; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);\n          break;\n        }\n      }\n    }, t.cc = M, t.cd = function (t, e, r) {\n      const n = rp(r.zoom),\n        i = t.style.map._antialias,\n        a = e.options.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;\n      return 0 === n && !i && !a;\n    }, t.ce = function (e) {\n      const r = e.pixelsPerMeter,\n        n = r / dl(1, e.center.lat),\n        i = t.a6.identity(new Float64Array(16));\n      return t.a6.translate(i, i, [e.point.x, e.point.y, 0]), t.a6.scale(i, i, [n, n, r]), Float32Array.from(i);\n    }, t.cf = Yh, t.cg = function (t) {\n      const e = xl - 5;\n      t = I(t, -e, e) / e * 90;\n      const r = Math.pow(Math.abs(Math.sin(b(t))), 3);\n      return Math.round(r * (Xo.length - 1));\n    }, t.ch = function (e, r, n, i) {\n      const a = r.getNorth(),\n        s = r.getSouth(),\n        o = r.getWest(),\n        l = r.getEast(),\n        u = 1 << e.z,\n        c = l - o,\n        h = a - s,\n        p = c / Yo,\n        f = -h / Xo[n],\n        d = [0, p, 0, f, 0, 0, a, o, 0];\n      if (e.z > 0) {\n        const e = 180 / i;\n        t.co.multiply(d, d, [e / c + 1, 0, 0, 0, e / h + 1, 0, -.5 * e / p, .5 * e / f, 1]);\n      }\n      return d[2] = u, d[5] = e.x, d[8] = e.y, d;\n    }, t.ci = jh, t.cj = function (e, r, n) {\n      const i = t.a6.identity(new Float64Array(16)),\n        a = (r / (1 << e) - .5) * Math.PI * 2;\n      return t.a6.rotateY(i, n.globeMatrix, a), Float32Array.from(i);\n    }, t.ck = class {\n      isDataAvailableAtPoint(t) {\n        const e = this._source();\n        if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;\n        const r = e.getSource().maxzoom,\n          n = 1 << r,\n          i = Math.floor(t.x),\n          a = Math.floor((t.x - i) * n),\n          s = Math.floor(t.y * n),\n          o = this.findDEMTileFor(new sl(r, i, r, a, s));\n        return !(!o || !o.dem);\n      }\n      getAtPointOrZero(t, e = 0) {\n        return this.getAtPoint(t, e) || 0;\n      }\n      getAtPoint(t, e, r = !0) {\n        if (this.isUsingMockSource()) return null;\n        null == e && (e = null);\n        const n = this._source();\n        if (!n) return e;\n        if (t.y < 0 || t.y > 1) return e;\n        const i = n.getSource().maxzoom,\n          a = 1 << i,\n          s = Math.floor(t.x),\n          o = t.x - s,\n          l = new sl(i, s, i, Math.floor(o * a), Math.floor(t.y * a)),\n          u = this.findDEMTileFor(l);\n        if (!u || !u.dem) return e;\n        const c = u.dem,\n          h = 1 << u.tileID.canonical.z,\n          p = (o * h - u.tileID.canonical.x) * c.dim,\n          f = (t.y * h - u.tileID.canonical.y) * c.dim,\n          d = Math.floor(p),\n          m = Math.floor(f);\n        return (r ? this.exaggeration() : 1) * ue(ue(c.get(d, m), c.get(d, m + 1), f - m), ue(c.get(d + 1, m), c.get(d + 1, m + 1), f - m), p - d);\n      }\n      getAtTileOffset(t, e, r) {\n        const n = 1 << t.canonical.z;\n        return this.getAtPointOrZero(new Ml(t.wrap + (t.canonical.x + e / Tr) / n, (t.canonical.y + r / Tr) / n));\n      }\n      getAtTileOffsetFunc(e, r, n, i) {\n        return a => {\n          const s = this.getAtTileOffset(e, a.x, a.y),\n            o = i.upVector(e.canonical, a.x, a.y),\n            l = i.upVectorScale(e.canonical, r, n).metersToTile;\n          return t.N.scale(o, o, s * l), o;\n        };\n      }\n      getForTilePoints(t, e, r, n) {\n        if (this.isUsingMockSource()) return !1;\n        const i = Wf.create(this, t, n);\n        return !!i && (e.forEach(t => {\n          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);\n        }), !0);\n      }\n      getMinMaxForTile(t) {\n        if (this.isUsingMockSource()) return null;\n        const e = this.findDEMTileFor(t);\n        if (!e || !e.dem) return null;\n        const r = e.dem.tree,\n          n = e.tileID,\n          i = 1 << t.canonical.z - n.canonical.z;\n        let a = t.canonical.x / i - n.canonical.x,\n          s = t.canonical.y / i - n.canonical.y,\n          o = 0;\n        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {\n          a *= 2, s *= 2;\n          const t = 2 * Math.floor(s) + Math.floor(a);\n          o = r.childOffsets[o] + t, a %= 1, s %= 1;\n        }\n        return {\n          min: this.exaggeration() * r.minimums[o],\n          max: this.exaggeration() * r.maximums[o]\n        };\n      }\n      getMinElevationBelowMSL() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      raycast(t, e, r) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      pointCoordinate(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      _source() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      isUsingMockSource() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      exaggeration() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      findDEMTileFor(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      get visibleDemTiles() {\n        throw new Error(\"Getter must be implemented in subclass.\");\n      }\n      getMinMaxForVisibleTiles() {\n        const t = this.visibleDemTiles;\n        if (0 === t.length) return null;\n        let e = !1,\n          r = Number.MAX_VALUE,\n          n = Number.MIN_VALUE;\n        for (const i of t) {\n          const t = this.getMinMaxForTile(i.tileID);\n          t && (r = Math.min(r, t.min), n = Math.max(n, t.max), e = !0);\n        }\n        return e ? {\n          min: r,\n          max: n\n        } : null;\n      }\n    }, t.cl = Lh, t.cm = _p, t.cn = function (t, e) {\n      return [Math.pow(t[0], 2.2) * e, Math.pow(t[1], 2.2) * e, Math.pow(t[2], 2.2) * e];\n    }, t.cp = tp, t.cq = 256, t.cr = function (e, r) {\n      const n = [0, 0, 0],\n        i = Wh(jh(r.canonical));\n      return t.N.transformMat4(n, n, i), t.N.transformMat4(n, n, e), n;\n    }, t.cs = t => ({\n      u_camera_to_center_distance: new vo(t),\n      u_extrude_scale: new Po(t),\n      u_device_pixel_ratio: new vo(t),\n      u_matrix: new So(t),\n      u_inv_rot_matrix: new So(t),\n      u_merc_center: new bo(t),\n      u_tile_id: new _o(t),\n      u_zoom_transition: new vo(t),\n      u_up_dir: new _o(t),\n      u_emissive_strength: new vo(t)\n    }), t.ct = t => ({\n      u_matrix: new So(t),\n      u_pixels_to_tile_units: new Po(t),\n      u_device_pixel_ratio: new vo(t),\n      u_units_to_pixels: new bo(t),\n      u_dash_image: new xo(t),\n      u_gradient_image: new xo(t),\n      u_image_height: new vo(t),\n      u_texsize: new bo(t),\n      u_tile_units_to_pixels: new vo(t),\n      u_alpha_discard_threshold: new vo(t),\n      u_trim_offset: new bo(t),\n      u_emissive_strength: new vo(t)\n    }), t.cu = t => ({\n      u_matrix: new So(t),\n      u_texsize: new bo(t),\n      u_pixels_to_tile_units: new Po(t),\n      u_device_pixel_ratio: new vo(t),\n      u_image: new xo(t),\n      u_units_to_pixels: new bo(t),\n      u_tile_units_to_pixels: new vo(t),\n      u_alpha_discard_threshold: new vo(t),\n      u_trim_offset: new bo(t)\n    }), t.cv = ks, t.cw = nm, t.cx = um, t.cy = up, t.cz = (t, e, r, n, i, a) => {\n      const s = t.transform,\n        o = \"globe\" === s.projection.name;\n      let l;\n      if (\"map\" === a.paint.get(\"circle-pitch-alignment\")) {\n        if (o) {\n          const t = tp(s.zoom, e.canonical) * s._pixelsPerMercatorPixel;\n          l = Float32Array.from([t, 0, 0, t]);\n        } else l = s.calculatePixelsToTileUnitsMatrix(r);\n      } else l = new Float32Array([s.pixelsToGLUnits[0], 0, 0, s.pixelsToGLUnits[1]]);\n      const u = {\n        u_camera_to_center_distance: t.transform.getCameraToCenterDistance(s.projection),\n        u_matrix: t.translatePosMatrix(e.projMatrix, r, a.paint.get(\"circle-translate\"), a.paint.get(\"circle-translate-anchor\")),\n        u_device_pixel_ratio: st.devicePixelRatio,\n        u_extrude_scale: l,\n        u_inv_rot_matrix: lp,\n        u_merc_center: [0, 0],\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_up_dir: [0, 0, 0],\n        u_emissive_strength: a.paint.get(\"circle-emissive-strength\")\n      };\n      if (o) {\n        u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], u.u_zoom_transition = rp(s.zoom);\n        const t = i[0] * Tr,\n          r = i[1] * Tr;\n        u.u_up_dir = s.projection.upVector(new il(0, 0, 0), t, r);\n      }\n      return u;\n    }, t.d = Ct, t.d0 = S, t.d1 = _l, t.d2 = Wo, t.d3 = function ([t, e, r]) {\n      const n = Math.hypot(t, e, r),\n        i = Math.atan2(t, r),\n        a = .5 * Math.PI - Math.acos(-e / n);\n      return new tl(_(i), _(a));\n    }, t.d4 = Jo, t.d5 = n, t.d6 = ip, t.d7 = np, t.d8 = function (e) {\n      const r = [0, 0, 0],\n        n = t.a6.identity(new Float64Array(16));\n      return t.a6.multiply(n, e.pixelMatrix, e.globeMatrix), t.N.transformMat4(r, r, n), new g(r[0], r[1]);\n    }, t.d9 = function (t) {\n      const e = t.navigator ? t.navigator.userAgent : null;\n      return !!function (t) {\n        if (null == tt) {\n          const e = t.navigator ? t.navigator.userAgent : null;\n          tt = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n        }\n        return tt;\n      }(t) && e && (e.match(\"Version/15.4\") || e.match(\"Version/15.5\") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));\n    }, t.dA = vy, t.dB = yv, t.dC = vv, t.dD = Vd, t.dE = F, t.dF = my, t.dG = function (t, e, r, n, i, a, s, o, l, u, c) {\n      t.createArrays(), t.tilePixelRatio = Tr / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      const h = t.layers[0].layout,\n        p = t.layers[0]._unevaluatedLayout._values,\n        f = {};\n      if (\"composite\" === t.textSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.textSizeData;\n        f.compositeTextSizes = [p[\"text-size\"].possiblyEvaluate(new Pa(e), o), p[\"text-size\"].possiblyEvaluate(new Pa(r), o)];\n      }\n      if (\"composite\" === t.iconSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.iconSizeData;\n        f.compositeIconSizes = [p[\"icon-size\"].possiblyEvaluate(new Pa(e), o), p[\"icon-size\"].possiblyEvaluate(new Pa(r), o)];\n      }\n      f.layoutTextSize = p[\"text-size\"].possiblyEvaluate(new Pa(l + 1), o), f.layoutIconSize = p[\"icon-size\"].possiblyEvaluate(new Pa(l + 1), o), f.textMaxSize = p[\"text-size\"].possiblyEvaluate(new Pa(18), o);\n      const d = \"map\" === h.get(\"text-rotation-alignment\") && \"point\" !== h.get(\"symbol-placement\"),\n        m = h.get(\"text-size\");\n      let y = !1;\n      for (const e of t.features) if (e.icon && e.icon.nameSecondary) {\n        y = !0;\n        break;\n      }\n      for (const a of t.features) {\n        const l = h.get(\"text-font\").evaluate(a, {}, o).join(\",\"),\n          p = m.evaluate(a, {}, o),\n          g = f.layoutTextSize.evaluate(a, {}, o),\n          x = (f.layoutIconSize.evaluate(a, {}, o), {\n            horizontal: {},\n            vertical: void 0\n          }),\n          v = a.text;\n        let b,\n          _ = [0, 0];\n        if (v) {\n          const n = v.toString(),\n            s = h.get(\"text-letter-spacing\").evaluate(a, {}, o) * im,\n            u = h.get(\"text-line-height\").evaluate(a, {}, o) * im,\n            c = ua(n) ? s : 0,\n            f = h.get(\"text-anchor\").evaluate(a, {}, o),\n            m = h.get(\"text-variable-anchor\");\n          if (!m) {\n            const t = h.get(\"text-radial-offset\").evaluate(a, {}, o);\n            _ = t ? Ry(f, [t * im, By]) : h.get(\"text-offset\").evaluate(a, {}, o).map(t => t * im);\n          }\n          let y = d ? \"center\" : h.get(\"text-justify\").evaluate(a, {}, o);\n          const b = \"point\" === h.get(\"symbol-placement\"),\n            w = b ? h.get(\"text-max-width\").evaluate(a, {}, o) * im : 1 / 0,\n            M = a => {\n              t.allowVerticalPlacement && la(n) && (x.vertical = Gm(v, e, r, i, l, w, u, f, a, c, _, jm.vertical, !0, g, p));\n            };\n          if (!d && m) {\n            const t = \"auto\" === y ? m.map(t => Dy(t)) : [y];\n            let n = !1;\n            for (let a = 0; a < t.length; a++) {\n              const s = t[a];\n              if (!x.horizontal[s]) if (n) x.horizontal[s] = x.horizontal[0];else {\n                const t = Gm(v, e, r, i, l, w, u, \"center\", s, c, _, jm.horizontal, !1, g, p);\n                t && (x.horizontal[s] = t, n = 1 === t.positionedLines.length);\n              }\n            }\n            M(\"left\");\n          } else {\n            if (\"auto\" === y && (y = Dy(f)), b || h.get(\"text-writing-mode\").indexOf(\"horizontal\") >= 0 || !la(n)) {\n              const t = Gm(v, e, r, i, l, w, u, f, y, c, _, jm.horizontal, !1, g, p);\n              t && (x.horizontal[y] = t);\n            }\n            M(b ? \"left\" : y);\n          }\n        }\n        let w = !1;\n        if (a.icon && a.icon.namePrimary) {\n          const e = n[a.icon.namePrimary];\n          e && (b = ey(i[a.icon.namePrimary], a.icon.nameSecondary ? i[a.icon.nameSecondary] : void 0, h.get(\"icon-offset\").evaluate(a, {}, o), h.get(\"icon-anchor\").evaluate(a, {}, o)), w = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && j(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (e.pixelRatio !== t.pixelRatio || 0 !== h.get(\"icon-rotate\").constantOr(1)) && (t.iconsNeedLinear = !0));\n        }\n        const M = Oy(x.horizontal) || x.vertical;\n        t.iconsInText || (t.iconsInText = !!M && M.iconsInText), (M || b) && Vy(t, a, x, b, n, f, g, 0, _, w, s, o, u, c, y);\n      }\n      a && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);\n    }, t.dH = Ef, t.dI = Vm, t.dJ = Hf, t.dK = h, t.dL = zf, t.dM = gf, t.dN = m, t.dO = mm, t.dP = function (t) {\n      let e = 0;\n      if (new Uint32Array(t, 0, 1)[0] !== Wx) {\n        const r = new Uint32Array(t, 0, 7),\n          [,, n, i, a, s] = r;\n        e = r.byteLength + i + a + s + a, (n !== t.byteLength || e >= t.byteLength) && j(\"Invalid b3dm header information.\");\n      }\n      return nv(t, e);\n    }, t.dQ = function (t, e) {\n      const r = fv(t);\n      for (const t of r) {\n        for (const e of t.meshes) dv(e);\n        t.lights && (t.lightMeshIndex = t.meshes.length, t.meshes.push(mv(t.lights, e)));\n      }\n      return r;\n    }, t.dR = Pv, t.dS = kx, t.dT = ka, t.dU = function (t) {\n      ft(), ct && ct.then(e => {\n        e.keys().then(r => {\n          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);\n        });\n      });\n    }, t.da = class {\n      constructor(t, e, r) {\n        this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();\n      }\n      _createSkuToken() {\n        const t = function () {\n          let t = \"\";\n          for (let e = 0; e < 10; e++) t += \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"[Math.floor(62 * Math.random())];\n          return {\n            token: [\"1\", Rt, t].join(\"\"),\n            tokenExpiresAt: Date.now() + 432e5\n          };\n        }();\n        this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;\n      }\n      _isSkuTokenExpired() {\n        return Date.now() > this._skuTokenExpiresAt;\n      }\n      transformRequest(t, e) {\n        return this._transformRequestFn && this._transformRequestFn(t, e) || {\n          url: t\n        };\n      }\n      normalizeStyleURL(t, r) {\n        if (!a(t)) return t;\n        const n = Lt(t);\n        return n.params.push(`sdk=js-${e}`), n.path = `/styles/v1${n.path}`, this._makeAPIURL(n, this._customAccessToken || r);\n      }\n      normalizeGlyphsURL(t, e) {\n        if (!a(t)) return t;\n        const r = Lt(t);\n        return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);\n      }\n      normalizeModelURL(t, e) {\n        if (!a(t)) return t;\n        const r = Lt(t);\n        return r.path = `/models/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);\n      }\n      normalizeSourceURL(t, e, r, n) {\n        if (!a(t)) return t;\n        const i = Lt(t);\n        return i.path = `/v4/${i.authority}.json`, i.params.push(\"secure\"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e);\n      }\n      normalizeSpriteURL(t, e, r, n) {\n        const i = Lt(t);\n        return a(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, Ft(i));\n      }\n      normalizeTileURL(t, e, r) {\n        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !a(t)) return t;\n        const i = Lt(t);\n        i.path = i.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, `${e || r && \"raster\" !== i.authority && 512 === r ? \"@2x\" : \"\"}${gt.supported ? \".webp\" : \"$1\"}`), \"raster\" === i.authority ? i.path = `/${n.RASTER_URL_PREFIX}${i.path}` : \"rasterarrays\" === i.authority ? i.path = `/${n.RASTERARRAYS_URL_PREFIX}${i.path}` : (i.path = i.path.replace(/^.+\\/v4\\//, \"/\"), i.path = `/${n.TILE_URL_VERSION}${i.path}`);\n        const s = this._customAccessToken || function (t) {\n          for (const e of t) {\n            const t = e.match(/^access_token=(.*)$/);\n            if (t) return t[1];\n          }\n          return null;\n        }(i.params) || n.ACCESS_TOKEN;\n        return n.REQUIRE_ACCESS_TOKEN && s && this._skuToken && i.params.push(`sku=${this._skuToken}`), this._makeAPIURL(i, s);\n      }\n      canonicalizeTileURL(t, e) {\n        const r = Lt(t);\n        if (!r.path.match(/^(\\/v4\\/|\\/(raster|rasterarrays)\\/v1\\/)/) || !r.path.match(/\\.[\\w]+$/)) return t;\n        let i = \"mapbox://\";\n        r.path.match(/^\\/raster\\/v1\\//) ? i += `raster/${r.path.replace(`/${n.RASTER_URL_PREFIX}/`, \"\")}` : r.path.match(/^\\/rasterarrays\\/v1\\//) ? i += `rasterarrays/${r.path.replace(`/${n.RASTERARRAYS_URL_PREFIX}/`, \"\")}` : i += `tiles/${r.path.replace(`/${n.TILE_URL_VERSION}/`, \"\")}`;\n        let a = r.params;\n        return e && (a = a.filter(t => !t.match(/^access_token=/))), a.length && (i += `?${a.join(\"&\")}`), i;\n      }\n      canonicalizeTileset(t, e) {\n        const r = !!e && a(e),\n          n = [];\n        for (const e of t.tiles || []) i(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);\n        return n;\n      }\n      _makeAPIURL(t, e) {\n        const r = \"See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\",\n          i = Lt(n.API_URL);\n        if (t.protocol = i.protocol, t.authority = i.authority, \"http\" === t.protocol) {\n          const e = t.params.indexOf(\"secure\");\n          e >= 0 && t.params.splice(e, 1);\n        }\n        if (\"/\" !== i.path && (t.path = `${i.path}${t.path}`), !n.REQUIRE_ACCESS_TOKEN) return Ft(t);\n        if (e = e || n.ACCESS_TOKEN, !this._silenceAuthErrors) {\n          if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);\n          if (\"s\" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);\n        }\n        return t.params = t.params.filter(t => -1 === t.indexOf(\"access_token\")), t.params.push(`access_token=${e || \"\"}`), Ft(t);\n      }\n    }, t.db = function (t, e) {\n      e ? Ht.add(t) : Ht.delete(t);\n    }, t.dc = gt, t.dd = Xt, t.de = Kt, t.df = Dt, t.dg = Gt, t.dh = function (t) {\n      Ht.delete(t);\n    }, t.di = Zt, t.dj = $t, t.dk = e, t.dl = function (t, e) {\n      lt = t, ut = e;\n    }, t.dm = function (t, e, r = !1) {\n      if (ba === ya || ba === ga || ba === xa) throw new Error(\"setRTLTextPlugin cannot be called multiple times.\");\n      _a = st.resolveURL(t), ba = ya, va = e, Ma(), r || Ia();\n    }, t.dn = Sa, t.dp = function () {\n      Rx().acquire(Tx);\n    }, t.dq = function () {\n      const t = Cx;\n      t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Tx), Cx = null) : console.warn(\"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()\"));\n    }, t.dr = Bx, t.ds = function (t) {\n      const e = pt();\n      if (!e) return;\n      const r = e.delete(ot);\n      t && r.catch(t).then(() => t());\n    }, t.dt = Ex, t.du = Ux, t.dv = function (t) {\n      Vx = st.resolveURL(t), Ox || (Ox = new Px(Rx(), new ee())), Ox.broadcast(\"setDracoUrl\", Vx);\n    }, t.dw = jx, t.dx = function (t) {\n      Fx = st.resolveURL(t), Ox || (Ox = new Px(Rx(), new ee())), Ox.broadcast(\"setMeshoptUrl\", Fx);\n    }, t.dy = ra, t.dz = vp, t.e = z, t.f = st, t.g = function (t, e) {\n      return kt(z(t, {\n        type: \"json\"\n      }), e);\n    }, t.h = bp, t.i = Ke, t.j = pe, t.k = Ti, t.l = function (t) {\n      return fetch(t).then(t => t.arrayBuffer()).then(e => nv(e, 0, t));\n    }, t.m = Ci, t.n = $i, t.o = ja, t.p = py, t.q = Zi, t.r = Gi, t.s = Ri, t.t = mn, t.u = Ua, t.v = gn, t.w = j, t.x = dn, t.z = $a;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    function t(e) {\n      const t = e ? e.url.toString() : void 0;\n      return t ? performance.getEntriesByName(t) : [];\n    }\n    function s(e) {\n      if (\"number\" == typeof e || \"boolean\" == typeof e || \"string\" == typeof e || null == e) return JSON.stringify(e);\n      if (Array.isArray(e)) {\n        let t = \"[\";\n        for (const i of e) t += `${s(i)},`;\n        return `${t}]`;\n      }\n      let t = \"{\";\n      for (const i of Object.keys(e).sort()) t += `${i}:${s(e[i])},`;\n      return `${t}}`;\n    }\n    function i(t) {\n      let i = \"\";\n      for (const o of e.b2) i += `/${s(t[o])}`;\n      return i;\n    }\n    class o {\n      constructor(e) {\n        this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);\n      }\n      replace(e, t) {\n        this._layerConfigs = {}, this._layers = {}, this.update(e, [], t);\n      }\n      update(t, s, o) {\n        this._options = o;\n        for (const s of t) this._layerConfigs[s.id] = s, (this._layers[s.id] = e.c2(s, this.scope, this._options)).compileFilter(), this.keyCache[s.id] && delete this.keyCache[s.id];\n        for (const e of s) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];\n        this.familiesBySource = {};\n        const r = function (e, t) {\n          const s = {};\n          for (let o = 0; o < e.length; o++) {\n            const r = t && t[e[o].id] || i(e[o]);\n            t && (t[e[o].id] = r);\n            let n = s[r];\n            n || (n = s[r] = []), n.push(e[o]);\n          }\n          const o = [];\n          for (const e in s) o.push(s[e]);\n          return o;\n        }(e.a$(this._layerConfigs), this.keyCache);\n        for (const e of r) {\n          const t = e.map(e => this._layers[e.id]),\n            s = t[0];\n          if (\"none\" === s.visibility) continue;\n          const i = s.source || \"\";\n          let o = this.familiesBySource[i];\n          o || (o = this.familiesBySource[i] = {});\n          const r = s.sourceLayer || \"_geojsonTileLayer\";\n          let n = o[r];\n          n || (n = o[r] = []), n.push(t);\n        }\n      }\n    }\n    const r = 1 * e.dA;\n    class n {\n      constructor(t) {\n        const s = {},\n          i = [];\n        for (const e in t) {\n          const o = t[e],\n            n = s[e] = {};\n          for (const e in o.glyphs) {\n            const t = o.glyphs[+e];\n            if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue;\n            const s = t.metrics.localGlyph ? r : 1,\n              a = {\n                x: 0,\n                y: 0,\n                w: t.bitmap.width + 2 * s,\n                h: t.bitmap.height + 2 * s\n              };\n            i.push(a), n[e] = a;\n          }\n        }\n        const {\n            w: o,\n            h: n\n          } = e.p(i),\n          a = new e.dz({\n            width: o || 1,\n            height: n || 1\n          });\n        for (const i in t) {\n          const o = t[i];\n          for (const t in o.glyphs) {\n            const n = o.glyphs[+t];\n            if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height) continue;\n            const l = s[i][t],\n              h = n.metrics.localGlyph ? r : 1;\n            e.dz.copy(n.bitmap, a, {\n              x: 0,\n              y: 0\n            }, {\n              x: l.x + h,\n              y: l.y + h\n            }, n.bitmap);\n          }\n        }\n        this.image = a, this.positions = s;\n      }\n    }\n    e.dy(n, \"GlyphAtlas\");\n    class a {\n      constructor(t) {\n        this.tileID = new e.am(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.scope = t.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.promoteId = t.promoteId, this.isSymbolTile = t.isSymbolTile, this.tileTransform = e.as(t.tileID.canonical, t.projection), this.projection = t.projection, this.brightness = t.brightness, this.extraShadowCaster = !!t.extraShadowCaster;\n      }\n      parse(t, s, i, o, r) {\n        this.status = \"parsing\", this.data = t, this.collisionBoxArray = new e.aD();\n        const a = new e.dB(Object.keys(t.layers).sort()),\n          h = new e.dC(this.tileID, this.promoteId);\n        h.bucketLayerIDs = [];\n        const c = {},\n          u = new e.dD(256, 256),\n          d = {\n            featureIndex: h,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {},\n            lineAtlas: u,\n            availableImages: i,\n            brightness: this.brightness\n          },\n          p = s.familiesBySource[this.source];\n        for (const s in p) {\n          const o = t.layers[s];\n          if (!o) continue;\n          let r = !1,\n            n = !1,\n            u = !1;\n          for (const e of p[s]) \"symbol\" === e[0].type ? r = !0 : n = !0, e[0].is3D() && \"model\" !== e[0].type && (u = !0);\n          if (this.extraShadowCaster && !u) continue;\n          if (!0 === this.isSymbolTile && !r) continue;\n          if (!1 === this.isSymbolTile && !n) continue;\n          1 === o.version && e.w(`Vector tile source \"${this.source}\" layer \"${s}\" does not use vector tile spec v2 and therefore may have some rendering errors.`);\n          const f = a.encode(s),\n            g = [];\n          for (let e = 0; e < o.length; e++) {\n            const t = o.feature(e),\n              i = h.getId(t, s);\n            g.push({\n              feature: t,\n              id: i,\n              index: e,\n              sourceLayerIndex: f\n            });\n          }\n          for (const e of p[s]) {\n            const t = e[0];\n            (!this.extraShadowCaster || t.is3D() && \"model\" !== t.type) && (void 0 !== this.isSymbolTile && \"symbol\" === t.type !== this.isSymbolTile || t.minzoom && this.zoom < Math.floor(t.minzoom) || t.maxzoom && this.zoom >= t.maxzoom || \"none\" !== t.visibility && (l(e, this.zoom, d.brightness, i), (c[t.id] = t.createBucket({\n              index: h.bucketLayerIDs.length,\n              layers: e,\n              zoom: this.zoom,\n              canonical: this.canonical,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: f,\n              sourceID: this.source,\n              projection: this.projection.spec\n            })).populate(g, d, this.tileID.canonical, this.tileTransform), h.bucketLayerIDs.push(e.map(e => e.id))));\n          }\n        }\n        let f, g, m, y;\n        u.trim();\n        const v = {\n            type: \"maybePrepare\",\n            isSymbolTile: this.isSymbolTile,\n            zoom: this.zoom\n          },\n          x = () => {\n            if (f) return this.status = \"done\", r(f);\n            if (this.extraShadowCaster) this.status = \"done\", r(null, {\n              buckets: e.a$(c).filter(e => !e.isEmpty()),\n              featureIndex: h,\n              collisionBoxArray: null,\n              glyphAtlasImage: null,\n              lineAtlas: null,\n              imageAtlas: null,\n              brightness: d.brightness,\n              glyphMap: null,\n              iconMap: null,\n              glyphPositions: null\n            });else if (g && m && y) {\n              const t = new n(g),\n                s = new e.dF(m, y);\n              for (const o in c) {\n                const r = c[o];\n                r instanceof e.aE ? (l(r.layers, this.zoom, d.brightness, i), e.dG(r, g, t.positions, m, s.iconPositions, this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : r.hasPattern && (r instanceof e.aK || r instanceof e.aL || r instanceof e.cH) && (l(r.layers, this.zoom, d.brightness, i), r.addFeatures(d, this.tileID.canonical, s.patternPositions, i, this.tileTransform, this.brightness));\n              }\n              this.status = \"done\", r(null, {\n                buckets: e.a$(c).filter(e => !e.isEmpty()),\n                featureIndex: h,\n                collisionBoxArray: this.collisionBoxArray,\n                glyphAtlasImage: t.image,\n                lineAtlas: u,\n                imageAtlas: s,\n                brightness: d.brightness\n              });\n            }\n          };\n        if (!this.extraShadowCaster) {\n          const t = e.dE(d.glyphDependencies, e => Object.keys(e).map(Number));\n          Object.keys(t).length ? o.send(\"getGlyphs\", {\n            uid: this.uid,\n            stacks: t,\n            scope: this.scope\n          }, (e, t) => {\n            f || (f = e, g = t, x());\n          }, void 0, !1, v) : g = {};\n          const s = Object.keys(d.iconDependencies);\n          s.length ? o.send(\"getImages\", {\n            icons: s,\n            source: this.source,\n            scope: this.scope,\n            tileID: this.tileID,\n            type: \"icons\"\n          }, (e, t) => {\n            f || (f = e, m = t, x());\n          }, void 0, !1, v) : m = {};\n          const i = Object.keys(d.patternDependencies);\n          i.length ? o.send(\"getImages\", {\n            icons: i,\n            source: this.source,\n            scope: this.scope,\n            tileID: this.tileID,\n            type: \"patterns\"\n          }, (e, t) => {\n            f || (f = e, y = t, x());\n          }, void 0, !1, v) : y = {};\n        }\n        x();\n      }\n    }\n    function l(t, s, i, o) {\n      const r = new e.K(s, {\n        brightness: i\n      });\n      for (const e of t) e.recalculate(r, o);\n    }\n    class h extends e.E {\n      constructor(t, s, i, o, r, n) {\n        super(), this.actor = t, this.layerIndex = s, this.availableImages = i, this.loadVectorData = r || e.ah, this.loading = {}, this.loaded = {}, this.deduped = new e.af(t.scheduler), this.isSpriteLoaded = o, this.scheduler = t.scheduler, this.brightness = n;\n      }\n      loadTile(s, i) {\n        const o = s.uid,\n          r = s && s.request,\n          n = r && r.collectResourceTiming,\n          l = this.loading[o] = new a(s);\n        l.abort = this.loadVectorData(s, (a, h) => {\n          const c = !this.loading[o];\n          if (delete this.loading[o], c || a || !h) return l.status = \"done\", c || (this.loaded[o] = l), i(a);\n          const u = h.rawData,\n            d = {};\n          h.expires && (d.expires = h.expires), h.cacheControl && (d.cacheControl = h.cacheControl), l.vectorTile = h.vectorTile || new e.dH(new e.dI(u));\n          const p = () => {\n            l.parse(l.vectorTile, this.layerIndex, this.availableImages, this.actor, (s, o) => {\n              if (s || !o) return i(s);\n              const a = {};\n              if (n) {\n                const e = t(r);\n                e.length > 0 && (a.resourceTiming = JSON.parse(JSON.stringify(e)));\n              }\n              i(null, e.e({\n                rawTileData: u.slice(0)\n              }, o, d, a));\n            });\n          };\n          this.isSpriteLoaded ? p() : this.once(\"isSpriteLoaded\", () => {\n            this.scheduler ? this.scheduler.add(p, {\n              type: \"parseTile\",\n              isSymbolTile: s.isSymbolTile,\n              zoom: s.tileZoom\n            }) : p();\n          }), this.loaded = this.loaded || {}, this.loaded[o] = l;\n        });\n      }\n      reloadTile(t, s) {\n        const i = this.loaded,\n          o = t.uid,\n          r = this;\n        if (i && i[o]) {\n          const n = i[o];\n          n.showCollisionBoxes = t.showCollisionBoxes, n.projection = t.projection, n.brightness = t.brightness, n.tileTransform = e.as(t.tileID.canonical, t.projection), n.extraShadowCaster = t.extraShadowCaster;\n          const a = (e, t) => {\n            const i = n.reloadCallback;\n            i && (delete n.reloadCallback, n.parse(n.vectorTile, r.layerIndex, this.availableImages, r.actor, i)), s(e, t);\n          };\n          \"parsing\" === n.status ? n.reloadCallback = a : \"done\" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());\n        } else s(null, void 0);\n      }\n      abortTile(e, t) {\n        const s = e.uid,\n          i = this.loading[s];\n        i && (i.abort && i.abort(), delete this.loading[s]), t();\n      }\n      removeTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        s && s[i] && delete s[i], t();\n      }\n    }\n    class c {\n      loadTile(t, s) {\n        const {\n            uid: i,\n            encoding: o,\n            rawImageData: r,\n            padding: n\n          } = t,\n          a = ImageBitmap && r instanceof ImageBitmap ? this.getImageData(r, n) : r;\n        s(null, new e.dJ(i, a, o, n < 1));\n      }\n      getImageData(e, t) {\n        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\", {\n          willReadFrequently: !0\n        })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);\n        const s = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);\n        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;\n      }\n    }\n    class u {\n      decodeRasterArray({\n        task: t,\n        buffer: s\n      }, i) {\n        e.aZ.performDecoding(s, t).then(e => {\n          i(null, e);\n        }, e => {\n          i(e);\n        });\n      }\n    }\n    function d(e, t) {\n      if (0 !== e.length) {\n        p(e[0], t);\n        for (var s = 1; s < e.length; s++) p(e[s], !t);\n      }\n    }\n    function p(e, t) {\n      for (var s = 0, i = 0, o = 0, r = e.length, n = r - 1; o < r; n = o++) {\n        var a = (e[o][0] - e[n][0]) * (e[n][1] + e[o][1]),\n          l = s + a;\n        i += Math.abs(s) >= Math.abs(a) ? s - l + a : a - l + s, s = l;\n      }\n      s + i >= 0 != !!t && e.reverse();\n    }\n    var f = e.dK(function e(t, s) {\n      var i,\n        o = t && t.type;\n      if (\"FeatureCollection\" === o) for (i = 0; i < t.features.length; i++) e(t.features[i], s);else if (\"GeometryCollection\" === o) for (i = 0; i < t.geometries.length; i++) e(t.geometries[i], s);else if (\"Feature\" === o) e(t.geometry, s);else if (\"Polygon\" === o) d(t.coordinates, s);else if (\"MultiPolygon\" === o) for (i = 0; i < t.coordinates.length; i++) d(t.coordinates[i], s);\n      return t;\n    });\n    const g = e.dL.prototype.toGeoJSON;\n    let m = class {\n        constructor(t) {\n          this._feature = t, this.extent = e.V, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n        }\n        loadGeometry() {\n          if (1 === this._feature.type) {\n            const t = [];\n            for (const s of this._feature.geometry) t.push([new e.P(s[0], s[1])]);\n            return t;\n          }\n          {\n            const t = [];\n            for (const s of this._feature.geometry) {\n              const i = [];\n              for (const t of s) i.push(new e.P(t[0], t[1]));\n              t.push(i);\n            }\n            return t;\n          }\n        }\n        toGeoJSON(e, t, s) {\n          return g.call(this, e, t, s);\n        }\n      },\n      y = class {\n        constructor(t) {\n          this.layers = {\n            _geojsonTileLayer: this\n          }, this.name = \"_geojsonTileLayer\", this.extent = e.V, this.length = t.length, this._features = t;\n        }\n        feature(e) {\n          return new m(this._features[e]);\n        }\n      };\n    var v = {\n        exports: {}\n      },\n      x = e.dN,\n      w = e.dM.VectorTileFeature,\n      S = b;\n    function b(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n    function I(e, t) {\n      this.id = \"number\" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n    b.prototype.feature = function (e) {\n      return new I(this.features[e], this.options.extent);\n    }, I.prototype.loadGeometry = function () {\n      var e = this.rawGeometry;\n      this.geometry = [];\n      for (var t = 0; t < e.length; t++) {\n        for (var s = e[t], i = [], o = 0; o < s.length; o++) i.push(new x(s[o][0], s[o][1]));\n        this.geometry.push(i);\n      }\n      return this.geometry;\n    }, I.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n      for (var e = this.geometry, t = 1 / 0, s = -1 / 0, i = 1 / 0, o = -1 / 0, r = 0; r < e.length; r++) for (var n = e[r], a = 0; a < n.length; a++) {\n        var l = n[a];\n        t = Math.min(t, l.x), s = Math.max(s, l.x), i = Math.min(i, l.y), o = Math.max(o, l.y);\n      }\n      return [t, i, s, o];\n    }, I.prototype.toGeoJSON = w.prototype.toGeoJSON;\n    var M = e.dO,\n      k = S;\n    function T(e) {\n      var t = new M();\n      return function (e, t) {\n        for (var s in e.layers) t.writeMessage(3, P, e.layers[s]);\n      }(e, t), t.finish();\n    }\n    function P(e, t) {\n      var s;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || \"\"), t.writeVarintField(5, e.extent || 4096);\n      var i = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n      for (s = 0; s < e.length; s++) i.feature = e.feature(s), t.writeMessage(2, C, i);\n      var o = i.keys;\n      for (s = 0; s < o.length; s++) t.writeStringField(3, o[s]);\n      var r = i.values;\n      for (s = 0; s < r.length; s++) t.writeMessage(4, O, r[s]);\n    }\n    function C(e, t) {\n      var s = e.feature;\n      void 0 !== s.id && t.writeVarintField(1, s.id), t.writeMessage(2, _, e), t.writeVarintField(3, s.type), t.writeMessage(4, j, s);\n    }\n    function _(e, t) {\n      var s = e.feature,\n        i = e.keys,\n        o = e.values,\n        r = e.keycache,\n        n = e.valuecache;\n      for (var a in s.properties) {\n        var l = s.properties[a],\n          h = r[a];\n        if (null !== l) {\n          void 0 === h && (i.push(a), r[a] = h = i.length - 1), t.writeVarint(h);\n          var c = typeof l;\n          \"string\" !== c && \"boolean\" !== c && \"number\" !== c && (l = JSON.stringify(l));\n          var u = c + \":\" + l,\n            d = n[u];\n          void 0 === d && (o.push(l), n[u] = d = o.length - 1), t.writeVarint(d);\n        }\n      }\n    }\n    function D(e, t) {\n      return (t << 3) + (7 & e);\n    }\n    function L(e) {\n      return e << 1 ^ e >> 31;\n    }\n    function j(e, t) {\n      for (var s = e.loadGeometry(), i = e.type, o = 0, r = 0, n = s.length, a = 0; a < n; a++) {\n        var l = s[a],\n          h = 1;\n        1 === i && (h = l.length), t.writeVarint(D(1, h));\n        for (var c = 3 === i ? l.length - 1 : l.length, u = 0; u < c; u++) {\n          1 === u && 1 !== i && t.writeVarint(D(2, c - 1));\n          var d = l[u].x - o,\n            p = l[u].y - r;\n          t.writeVarint(L(d)), t.writeVarint(L(p)), o += d, r += p;\n        }\n        3 === i && t.writeVarint(D(7, 1));\n      }\n    }\n    function O(e, t) {\n      var s = typeof e;\n      \"string\" === s ? t.writeStringField(1, e) : \"boolean\" === s ? t.writeBooleanField(7, e) : \"number\" === s && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n    v.exports = T, v.exports.fromVectorTileJs = T, v.exports.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var s = {};\n      for (var i in e) s[i] = new k(e[i].features, t), s[i].name = i, s[i].version = t.version, s[i].extent = t.extent;\n      return T({\n        layers: s\n      });\n    }, v.exports.GeoJSONWrapper = k;\n    var z = e.dK(v.exports);\n    const Z = {\n        minZoom: 0,\n        maxZoom: 16,\n        minPoints: 2,\n        radius: 40,\n        extent: 512,\n        nodeSize: 64,\n        log: !1,\n        generateId: !1,\n        reduce: null,\n        map: e => e\n      },\n      A = Math.fround || (E = new Float32Array(1), e => (E[0] = +e, E[0]));\n    var E;\n    const F = 3,\n      N = 5,\n      B = 6;\n    class W {\n      constructor(e) {\n        this.options = Object.assign(Object.create(Z), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];\n      }\n      load(e) {\n        const {\n          log: t,\n          minZoom: s,\n          maxZoom: i\n        } = this.options;\n        t && console.time(\"total time\");\n        const o = `prepare ${e.length} points`;\n        t && console.time(o), this.points = e;\n        const r = [];\n        for (let t = 0; t < e.length; t++) {\n          const s = e[t];\n          if (!s.geometry) continue;\n          const [i, o] = s.geometry.coordinates,\n            n = A(R(i)),\n            a = A(Y(o));\n          r.push(n, a, 1 / 0, t, -1, 1), this.options.reduce && r.push(0);\n        }\n        let n = this.trees[i + 1] = this._createTree(r);\n        t && console.timeEnd(o);\n        for (let e = i; e >= s; e--) {\n          const s = +Date.now();\n          n = this.trees[e] = this._createTree(this._cluster(n, e)), t && console.log(\"z%d: %d clusters in %dms\", e, n.numItems, +Date.now() - s);\n        }\n        return t && console.timeEnd(\"total time\"), this;\n      }\n      getClusters(e, t) {\n        let s = ((e[0] + 180) % 360 + 360) % 360 - 180;\n        const i = Math.max(-90, Math.min(90, e[1]));\n        let o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;\n        const r = Math.max(-90, Math.min(90, e[3]));\n        if (e[2] - e[0] >= 360) s = -180, o = 180;else if (s > o) {\n          const e = this.getClusters([s, i, 180, r], t),\n            n = this.getClusters([-180, i, o, r], t);\n          return e.concat(n);\n        }\n        const n = this.trees[this._limitZoom(t)],\n          a = n.range(R(s), Y(r), R(o), Y(i)),\n          l = n.data,\n          h = [];\n        for (const e of a) {\n          const t = this.stride * e;\n          h.push(l[t + N] > 1 ? G(l, t, this.clusterProps) : this.points[l[t + F]]);\n        }\n        return h;\n      }\n      getChildren(e) {\n        const t = this._getOriginId(e),\n          s = this._getOriginZoom(e),\n          i = \"No cluster with the specified id.\",\n          o = this.trees[s];\n        if (!o) throw new Error(i);\n        const r = o.data;\n        if (t * this.stride >= r.length) throw new Error(i);\n        const n = this.options.radius / (this.options.extent * Math.pow(2, s - 1)),\n          a = o.within(r[t * this.stride], r[t * this.stride + 1], n),\n          l = [];\n        for (const t of a) {\n          const s = t * this.stride;\n          r[s + 4] === e && l.push(r[s + N] > 1 ? G(r, s, this.clusterProps) : this.points[r[s + F]]);\n        }\n        if (0 === l.length) throw new Error(i);\n        return l;\n      }\n      getLeaves(e, t, s) {\n        const i = [];\n        return this._appendLeaves(i, e, t = t || 10, s = s || 0, 0), i;\n      }\n      getTile(e, t, s) {\n        const i = this.trees[this._limitZoom(e)],\n          o = Math.pow(2, e),\n          {\n            extent: r,\n            radius: n\n          } = this.options,\n          a = n / r,\n          l = (s - a) / o,\n          h = (s + 1 + a) / o,\n          c = {\n            features: []\n          };\n        return this._addTileFeatures(i.range((t - a) / o, l, (t + 1 + a) / o, h), i.data, t, s, o, c), 0 === t && this._addTileFeatures(i.range(1 - a / o, l, 1, h), i.data, o, s, o, c), t === o - 1 && this._addTileFeatures(i.range(0, l, a / o, h), i.data, -1, s, o, c), c.features.length ? c : null;\n      }\n      getClusterExpansionZoom(e) {\n        let t = this._getOriginZoom(e) - 1;\n        for (; t <= this.options.maxZoom;) {\n          const s = this.getChildren(e);\n          if (t++, 1 !== s.length) break;\n          e = s[0].properties.cluster_id;\n        }\n        return t;\n      }\n      _appendLeaves(e, t, s, i, o) {\n        const r = this.getChildren(t);\n        for (const t of r) {\n          const r = t.properties;\n          if (r && r.cluster ? o + r.point_count <= i ? o += r.point_count : o = this._appendLeaves(e, r.cluster_id, s, i, o) : o < i ? o++ : e.push(t), e.length === s) break;\n        }\n        return o;\n      }\n      _createTree(t) {\n        const s = new e.bg(t.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let e = 0; e < t.length; e += this.stride) s.add(t[e], t[e + 1]);\n        return s.finish(), s.data = t, s;\n      }\n      _addTileFeatures(e, t, s, i, o, r) {\n        for (const n of e) {\n          const e = n * this.stride,\n            a = t[e + N] > 1;\n          let l, h, c;\n          if (a) l = J(t, e, this.clusterProps), h = t[e], c = t[e + 1];else {\n            const s = this.points[t[e + F]];\n            l = s.properties;\n            const [i, o] = s.geometry.coordinates;\n            h = R(i), c = Y(o);\n          }\n          const u = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (h * o - s)), Math.round(this.options.extent * (c * o - i))]],\n            tags: l\n          };\n          let d;\n          d = a || this.options.generateId ? t[e + F] : this.points[t[e + F]].id, void 0 !== d && (u.id = d), r.features.push(u);\n        }\n      }\n      _limitZoom(e) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));\n      }\n      _cluster(e, t) {\n        const {\n            radius: s,\n            extent: i,\n            reduce: o,\n            minPoints: r\n          } = this.options,\n          n = s / (i * Math.pow(2, t)),\n          a = e.data,\n          l = [],\n          h = this.stride;\n        for (let s = 0; s < a.length; s += h) {\n          if (a[s + 2] <= t) continue;\n          a[s + 2] = t;\n          const i = a[s],\n            c = a[s + 1],\n            u = e.within(a[s], a[s + 1], n),\n            d = a[s + N];\n          let p = d;\n          for (const e of u) {\n            const s = e * h;\n            a[s + 2] > t && (p += a[s + N]);\n          }\n          if (p > d && p >= r) {\n            let e,\n              r = i * d,\n              n = c * d,\n              f = -1;\n            const g = (s / h << 5) + (t + 1) + this.points.length;\n            for (const i of u) {\n              const l = i * h;\n              if (a[l + 2] <= t) continue;\n              a[l + 2] = t;\n              const c = a[l + N];\n              r += a[l] * c, n += a[l + 1] * c, a[l + 4] = g, o && (e || (e = this._map(a, s, !0), f = this.clusterProps.length, this.clusterProps.push(e)), o(e, this._map(a, l)));\n            }\n            a[s + 4] = g, l.push(r / p, n / p, 1 / 0, g, -1, p), o && l.push(f);\n          } else {\n            for (let e = 0; e < h; e++) l.push(a[s + e]);\n            if (p > 1) for (const e of u) {\n              const s = e * h;\n              if (!(a[s + 2] <= t)) {\n                a[s + 2] = t;\n                for (let e = 0; e < h; e++) l.push(a[s + e]);\n              }\n            }\n          }\n        }\n        return l;\n      }\n      _getOriginId(e) {\n        return e - this.points.length >> 5;\n      }\n      _getOriginZoom(e) {\n        return (e - this.points.length) % 32;\n      }\n      _map(e, t, s) {\n        if (e[t + N] > 1) {\n          const i = this.clusterProps[e[t + B]];\n          return s ? Object.assign({}, i) : i;\n        }\n        const i = this.points[e[t + F]].properties,\n          o = this.options.map(i);\n        return s && o === i ? Object.assign({}, o) : o;\n      }\n    }\n    function G(e, t, s) {\n      return {\n        type: \"Feature\",\n        id: e[t + F],\n        properties: J(e, t, s),\n        geometry: {\n          type: \"Point\",\n          coordinates: [(i = e[t], 360 * (i - .5)), X(e[t + 1])]\n        }\n      };\n      var i;\n    }\n    function J(e, t, s) {\n      const i = e[t + N],\n        o = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + \"k\" : i,\n        r = e[t + B],\n        n = -1 === r ? {} : Object.assign({}, s[r]);\n      return Object.assign(n, {\n        cluster: !0,\n        cluster_id: e[t + F],\n        point_count: i,\n        point_count_abbreviated: o\n      });\n    }\n    function R(e) {\n      return e / 360 + .5;\n    }\n    function Y(e) {\n      const t = Math.sin(e * Math.PI / 180),\n        s = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return s < 0 ? 0 : s > 1 ? 1 : s;\n    }\n    function X(e) {\n      const t = (180 - 360 * e) * Math.PI / 180;\n      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;\n    }\n    var V = {\n      exports: {}\n    };\n    V.exports = function () {\n      function e(s, i, o, r) {\n        for (var n, a = r, l = o - i >> 1, h = o - i, c = s[i], u = s[i + 1], d = s[o], p = s[o + 1], f = i + 3; f < o; f += 3) {\n          var g = t(s[f], s[f + 1], c, u, d, p);\n          if (g > a) n = f, a = g;else if (g === a) {\n            var m = Math.abs(f - l);\n            m < h && (n = f, h = m);\n          }\n        }\n        a > r && (n - i > 3 && e(s, i, n, r), s[n + 2] = a, o - n > 3 && e(s, n, o, r));\n      }\n      function t(e, t, s, i, o, r) {\n        var n = o - s,\n          a = r - i;\n        if (0 !== n || 0 !== a) {\n          var l = ((e - s) * n + (t - i) * a) / (n * n + a * a);\n          l > 1 ? (s = o, i = r) : l > 0 && (s += n * l, i += a * l);\n        }\n        return (n = e - s) * n + (a = t - i) * a;\n      }\n      function s(e, t, s, o) {\n        var r = {\n          id: void 0 === e ? null : e,\n          type: t,\n          geometry: s,\n          tags: o,\n          minX: 1 / 0,\n          minY: 1 / 0,\n          maxX: -1 / 0,\n          maxY: -1 / 0\n        };\n        return function (e) {\n          var t = e.geometry,\n            s = e.type;\n          if (\"Point\" === s || \"MultiPoint\" === s || \"LineString\" === s) i(e, t);else if (\"Polygon\" === s || \"MultiLineString\" === s) for (var o = 0; o < t.length; o++) i(e, t[o]);else if (\"MultiPolygon\" === s) for (o = 0; o < t.length; o++) for (var r = 0; r < t[o].length; r++) i(e, t[o][r]);\n        }(r), r;\n      }\n      function i(e, t) {\n        for (var s = 0; s < t.length; s += 3) e.minX = Math.min(e.minX, t[s]), e.minY = Math.min(e.minY, t[s + 1]), e.maxX = Math.max(e.maxX, t[s]), e.maxY = Math.max(e.maxY, t[s + 1]);\n      }\n      function o(e, t, i, l) {\n        if (t.geometry) {\n          var h = t.geometry.coordinates,\n            c = t.geometry.type,\n            u = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2),\n            d = [],\n            p = t.id;\n          if (i.promoteId ? p = t.properties[i.promoteId] : i.generateId && (p = l || 0), \"Point\" === c) r(h, d);else if (\"MultiPoint\" === c) for (var f = 0; f < h.length; f++) r(h[f], d);else if (\"LineString\" === c) n(h, d, u, !1);else if (\"MultiLineString\" === c) {\n            if (i.lineMetrics) {\n              for (f = 0; f < h.length; f++) n(h[f], d = [], u, !1), e.push(s(p, \"LineString\", d, t.properties));\n              return;\n            }\n            a(h, d, u, !1);\n          } else if (\"Polygon\" === c) a(h, d, u, !0);else {\n            if (\"MultiPolygon\" !== c) {\n              if (\"GeometryCollection\" === c) {\n                for (f = 0; f < t.geometry.geometries.length; f++) o(e, {\n                  id: p,\n                  geometry: t.geometry.geometries[f],\n                  properties: t.properties\n                }, i, l);\n                return;\n              }\n              throw new Error(\"Input data is not a valid GeoJSON object.\");\n            }\n            for (f = 0; f < h.length; f++) {\n              var g = [];\n              a(h[f], g, u, !0), d.push(g);\n            }\n          }\n          e.push(s(p, c, d, t.properties));\n        }\n      }\n      function r(e, t) {\n        t.push(l(e[0])), t.push(h(e[1])), t.push(0);\n      }\n      function n(t, s, i, o) {\n        for (var r, n, a = 0, c = 0; c < t.length; c++) {\n          var u = l(t[c][0]),\n            d = h(t[c][1]);\n          s.push(u), s.push(d), s.push(0), c > 0 && (a += o ? (r * d - u * n) / 2 : Math.sqrt(Math.pow(u - r, 2) + Math.pow(d - n, 2))), r = u, n = d;\n        }\n        var p = s.length - 3;\n        s[2] = 1, e(s, 0, p, i), s[p + 2] = 1, s.size = Math.abs(a), s.start = 0, s.end = s.size;\n      }\n      function a(e, t, s, i) {\n        for (var o = 0; o < e.length; o++) {\n          var r = [];\n          n(e[o], r, s, i), t.push(r);\n        }\n      }\n      function l(e) {\n        return e / 360 + .5;\n      }\n      function h(e) {\n        var t = Math.sin(e * Math.PI / 180),\n          s = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n        return s < 0 ? 0 : s > 1 ? 1 : s;\n      }\n      function c(e, t, i, o, r, n, a, l) {\n        if (o /= t, n >= (i /= t) && a < o) return e;\n        if (a < i || n >= o) return null;\n        for (var h = [], c = 0; c < e.length; c++) {\n          var p = e[c],\n            g = p.geometry,\n            m = p.type,\n            y = 0 === r ? p.minX : p.minY,\n            v = 0 === r ? p.maxX : p.maxY;\n          if (y >= i && v < o) h.push(p);else if (!(v < i || y >= o)) {\n            var x = [];\n            if (\"Point\" === m || \"MultiPoint\" === m) u(g, x, i, o, r);else if (\"LineString\" === m) d(g, x, i, o, r, !1, l.lineMetrics);else if (\"MultiLineString\" === m) f(g, x, i, o, r, !1);else if (\"Polygon\" === m) f(g, x, i, o, r, !0);else if (\"MultiPolygon\" === m) for (var w = 0; w < g.length; w++) {\n              var S = [];\n              f(g[w], S, i, o, r, !0), S.length && x.push(S);\n            }\n            if (x.length) {\n              if (l.lineMetrics && \"LineString\" === m) {\n                for (w = 0; w < x.length; w++) h.push(s(p.id, m, x[w], p.tags));\n                continue;\n              }\n              \"LineString\" !== m && \"MultiLineString\" !== m || (1 === x.length ? (m = \"LineString\", x = x[0]) : m = \"MultiLineString\"), \"Point\" !== m && \"MultiPoint\" !== m || (m = 3 === x.length ? \"Point\" : \"MultiPoint\"), h.push(s(p.id, m, x, p.tags));\n            }\n          }\n        }\n        return h.length ? h : null;\n      }\n      function u(e, t, s, i, o) {\n        for (var r = 0; r < e.length; r += 3) {\n          var n = e[r + o];\n          n >= s && n <= i && (t.push(e[r]), t.push(e[r + 1]), t.push(e[r + 2]));\n        }\n      }\n      function d(e, t, s, i, o, r, n) {\n        for (var a, l, h = p(e), c = 0 === o ? m : y, u = e.start, d = 0; d < e.length - 3; d += 3) {\n          var f = e[d],\n            v = e[d + 1],\n            x = e[d + 2],\n            w = e[d + 3],\n            S = e[d + 4],\n            b = 0 === o ? f : v,\n            I = 0 === o ? w : S,\n            M = !1;\n          n && (a = Math.sqrt(Math.pow(f - w, 2) + Math.pow(v - S, 2))), b < s ? I > s && (l = c(h, f, v, w, S, s), n && (h.start = u + a * l)) : b > i ? I < i && (l = c(h, f, v, w, S, i), n && (h.start = u + a * l)) : g(h, f, v, x), I < s && b >= s && (l = c(h, f, v, w, S, s), M = !0), I > i && b <= i && (l = c(h, f, v, w, S, i), M = !0), !r && M && (n && (h.end = u + a * l), t.push(h), h = p(e)), n && (u += a);\n        }\n        var k = e.length - 3;\n        f = e[k], v = e[k + 1], x = e[k + 2], (b = 0 === o ? f : v) >= s && b <= i && g(h, f, v, x), k = h.length - 3, r && k >= 3 && (h[k] !== h[0] || h[k + 1] !== h[1]) && g(h, h[0], h[1], h[2]), h.length && t.push(h);\n      }\n      function p(e) {\n        var t = [];\n        return t.size = e.size, t.start = e.start, t.end = e.end, t;\n      }\n      function f(e, t, s, i, o, r) {\n        for (var n = 0; n < e.length; n++) d(e[n], t, s, i, o, r, !1);\n      }\n      function g(e, t, s, i) {\n        e.push(t), e.push(s), e.push(i);\n      }\n      function m(e, t, s, i, o, r) {\n        var n = (r - t) / (i - t);\n        return e.push(r), e.push(s + (o - s) * n), e.push(1), n;\n      }\n      function y(e, t, s, i, o, r) {\n        var n = (r - s) / (o - s);\n        return e.push(t + (i - t) * n), e.push(r), e.push(1), n;\n      }\n      function v(e, t) {\n        for (var i = [], o = 0; o < e.length; o++) {\n          var r,\n            n = e[o],\n            a = n.type;\n          if (\"Point\" === a || \"MultiPoint\" === a || \"LineString\" === a) r = x(n.geometry, t);else if (\"MultiLineString\" === a || \"Polygon\" === a) {\n            r = [];\n            for (var l = 0; l < n.geometry.length; l++) r.push(x(n.geometry[l], t));\n          } else if (\"MultiPolygon\" === a) for (r = [], l = 0; l < n.geometry.length; l++) {\n            for (var h = [], c = 0; c < n.geometry[l].length; c++) h.push(x(n.geometry[l][c], t));\n            r.push(h);\n          }\n          i.push(s(n.id, a, r, n.tags));\n        }\n        return i;\n      }\n      function x(e, t) {\n        var s = [];\n        s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);\n        for (var i = 0; i < e.length; i += 3) s.push(e[i] + t, e[i + 1], e[i + 2]);\n        return s;\n      }\n      function w(e, t) {\n        if (e.transformed) return e;\n        var s,\n          i,\n          o,\n          r = 1 << e.z,\n          n = e.x,\n          a = e.y;\n        for (s = 0; s < e.features.length; s++) {\n          var l = e.features[s],\n            h = l.geometry,\n            c = l.type;\n          if (l.geometry = [], 1 === c) for (i = 0; i < h.length; i += 2) l.geometry.push(S(h[i], h[i + 1], t, r, n, a));else for (i = 0; i < h.length; i++) {\n            var u = [];\n            for (o = 0; o < h[i].length; o += 2) u.push(S(h[i][o], h[i][o + 1], t, r, n, a));\n            l.geometry.push(u);\n          }\n        }\n        return e.transformed = !0, e;\n      }\n      function S(e, t, s, i, o, r) {\n        return [Math.round(s * (e * i - o)), Math.round(s * (t * i - r))];\n      }\n      function b(e, t, s, i, o) {\n        for (var r = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent), n = {\n            features: [],\n            numPoints: 0,\n            numSimplified: 0,\n            numFeatures: 0,\n            source: null,\n            x: s,\n            y: i,\n            z: t,\n            transformed: !1,\n            minX: 2,\n            minY: 1,\n            maxX: -1,\n            maxY: 0\n          }, a = 0; a < e.length; a++) {\n          n.numFeatures++, I(n, e[a], r, o);\n          var l = e[a].minX,\n            h = e[a].minY,\n            c = e[a].maxX,\n            u = e[a].maxY;\n          l < n.minX && (n.minX = l), h < n.minY && (n.minY = h), c > n.maxX && (n.maxX = c), u > n.maxY && (n.maxY = u);\n        }\n        return n;\n      }\n      function I(e, t, s, i) {\n        var o = t.geometry,\n          r = t.type,\n          n = [];\n        if (\"Point\" === r || \"MultiPoint\" === r) for (var a = 0; a < o.length; a += 3) n.push(o[a]), n.push(o[a + 1]), e.numPoints++, e.numSimplified++;else if (\"LineString\" === r) M(n, o, e, s, !1, !1);else if (\"MultiLineString\" === r || \"Polygon\" === r) for (a = 0; a < o.length; a++) M(n, o[a], e, s, \"Polygon\" === r, 0 === a);else if (\"MultiPolygon\" === r) for (var l = 0; l < o.length; l++) {\n          var h = o[l];\n          for (a = 0; a < h.length; a++) M(n, h[a], e, s, !0, 0 === a);\n        }\n        if (n.length) {\n          var c = t.tags || null;\n          if (\"LineString\" === r && i.lineMetrics) {\n            for (var u in c = {}, t.tags) c[u] = t.tags[u];\n            c.mapbox_clip_start = o.start / o.size, c.mapbox_clip_end = o.end / o.size;\n          }\n          var d = {\n            geometry: n,\n            type: \"Polygon\" === r || \"MultiPolygon\" === r ? 3 : \"LineString\" === r || \"MultiLineString\" === r ? 2 : 1,\n            tags: c\n          };\n          null !== t.id && (d.id = t.id), e.features.push(d);\n        }\n      }\n      function M(e, t, s, i, o, r) {\n        var n = i * i;\n        if (i > 0 && t.size < (o ? n : i)) s.numPoints += t.length / 3;else {\n          for (var a = [], l = 0; l < t.length; l += 3) (0 === i || t[l + 2] > n) && (s.numSimplified++, a.push(t[l]), a.push(t[l + 1])), s.numPoints++;\n          o && function (e, t) {\n            for (var s = 0, i = 0, o = e.length, r = o - 2; i < o; r = i, i += 2) s += (e[i] - e[r]) * (e[i + 1] + e[r + 1]);\n            if (s > 0 === t) for (i = 0, o = e.length; i < o / 2; i += 2) {\n              var n = e[i],\n                a = e[i + 1];\n              e[i] = e[o - 2 - i], e[i + 1] = e[o - 1 - i], e[o - 2 - i] = n, e[o - 1 - i] = a;\n            }\n          }(a, r), e.push(a);\n        }\n      }\n      function k(e, t) {\n        var s = (t = this.options = function (e, t) {\n          for (var s in t) e[s] = t[s];\n          return e;\n        }(Object.create(this.options), t)).debug;\n        if (s && console.time(\"preprocess data\"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n        if (t.promoteId && t.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n        var i = function (e, t) {\n          var s = [];\n          if (\"FeatureCollection\" === e.type) for (var i = 0; i < e.features.length; i++) o(s, e.features[i], t, i);else o(s, \"Feature\" === e.type ? e : {\n            geometry: e\n          }, t);\n          return s;\n        }(e, t);\n        this.tiles = {}, this.tileCoords = [], s && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", t.indexMaxZoom, t.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), (i = function (e, t) {\n          var s = t.buffer / t.extent,\n            i = e,\n            o = c(e, 1, -1 - s, s, 0, -1, 2, t),\n            r = c(e, 1, 1 - s, 2 + s, 0, -1, 2, t);\n          return (o || r) && (i = c(e, 1, -s, 1 + s, 0, -1, 2, t) || [], o && (i = v(o, 1).concat(i)), r && (i = i.concat(v(r, -1)))), i;\n        }(i, t)).length && this.splitTile(i, 0, 0, 0), s && (i.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n      }\n      function T(e, t, s) {\n        return 32 * ((1 << e) * s + t) + e;\n      }\n      return k.prototype.options = {\n        maxZoom: 14,\n        indexMaxZoom: 5,\n        indexMaxPoints: 1e5,\n        tolerance: 3,\n        extent: 4096,\n        buffer: 64,\n        lineMetrics: !1,\n        promoteId: null,\n        generateId: !1,\n        debug: 0\n      }, k.prototype.splitTile = function (e, t, s, i, o, r, n) {\n        for (var a = [e, t, s, i], l = this.options, h = l.debug; a.length;) {\n          i = a.pop(), s = a.pop(), t = a.pop(), e = a.pop();\n          var u = 1 << t,\n            d = T(t, s, i),\n            p = this.tiles[d];\n          if (!p && (h > 1 && console.time(\"creation\"), p = this.tiles[d] = b(e, t, s, i, l), this.tileCoords.push({\n            z: t,\n            x: s,\n            y: i\n          }), h)) {\n            h > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", t, s, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd(\"creation\"));\n            var f = \"z\" + t;\n            this.stats[f] = (this.stats[f] || 0) + 1, this.total++;\n          }\n          if (p.source = e, o) {\n            if (t === l.maxZoom || t === o) continue;\n            var g = 1 << o - t;\n            if (s !== Math.floor(r / g) || i !== Math.floor(n / g)) continue;\n          } else if (t === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;\n          if (p.source = null, 0 !== e.length) {\n            h > 1 && console.time(\"clipping\");\n            var m,\n              y,\n              v,\n              x,\n              w,\n              S,\n              I = .5 * l.buffer / l.extent,\n              M = .5 - I,\n              k = .5 + I,\n              P = 1 + I;\n            m = y = v = x = null, w = c(e, u, s - I, s + k, 0, p.minX, p.maxX, l), S = c(e, u, s + M, s + P, 0, p.minX, p.maxX, l), e = null, w && (m = c(w, u, i - I, i + k, 1, p.minY, p.maxY, l), y = c(w, u, i + M, i + P, 1, p.minY, p.maxY, l), w = null), S && (v = c(S, u, i - I, i + k, 1, p.minY, p.maxY, l), x = c(S, u, i + M, i + P, 1, p.minY, p.maxY, l), S = null), h > 1 && console.timeEnd(\"clipping\"), a.push(m || [], t + 1, 2 * s, 2 * i), a.push(y || [], t + 1, 2 * s, 2 * i + 1), a.push(v || [], t + 1, 2 * s + 1, 2 * i), a.push(x || [], t + 1, 2 * s + 1, 2 * i + 1);\n          }\n        }\n      }, k.prototype.getTile = function (e, t, s) {\n        var i = this.options,\n          o = i.extent,\n          r = i.debug;\n        if (e < 0 || e > 24) return null;\n        var n = 1 << e,\n          a = T(e, t = (t % n + n) % n, s);\n        if (this.tiles[a]) return w(this.tiles[a], o);\n        r > 1 && console.log(\"drilling down to z%d-%d-%d\", e, t, s);\n        for (var l, h = e, c = t, u = s; !l && h > 0;) h--, c = Math.floor(c / 2), u = Math.floor(u / 2), l = this.tiles[T(h, c, u)];\n        return l && l.source ? (r > 1 && console.log(\"found parent tile z%d-%d-%d\", h, c, u), r > 1 && console.time(\"drilling down\"), this.splitTile(l.source, h, c, u, e, t, s), r > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? w(this.tiles[a], o) : null) : null;\n      }, function (e, t) {\n        return new k(e, t);\n      };\n    }();\n    var $ = e.dK(V.exports);\n    function U(e, t) {\n      const s = e.tileID.canonical;\n      if (!this._geoJSONIndex) return t(null, null);\n      const i = this._geoJSONIndex.getTile(s.z, s.x, s.y);\n      if (!i) return t(null, null);\n      const o = new y(i.features);\n      let r = z(o);\n      0 === r.byteOffset && r.byteLength === r.buffer.byteLength || (r = new Uint8Array(r)), t(null, {\n        vectorTile: o,\n        rawData: r.buffer\n      });\n    }\n    class q extends h {\n      constructor(e, t, s, i, o, r) {\n        super(e, t, s, i, U, r), o && (this.loadGeoJSON = o);\n      }\n      loadData(s, i) {\n        const o = s && s.request,\n          r = o && o.collectResourceTiming;\n        this.loadGeoJSON(s, (n, a) => {\n          if (n || !a) return i(n);\n          if (\"object\" != typeof a) return i(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));\n          {\n            f(a, !0);\n            try {\n              if (s.filter) {\n                const t = e.r(s.filter, {\n                  type: \"boolean\",\n                  \"property-type\": \"data-driven\",\n                  overridable: !1,\n                  transition: !1\n                });\n                if (\"error\" === t.result) throw new Error(t.value.map(e => `${e.key}: ${e.message}`).join(\", \"));\n                const i = a.features.filter(e => t.value.evaluate({\n                  zoom: 0\n                }, e));\n                a = {\n                  type: \"FeatureCollection\",\n                  features: i\n                };\n              }\n              this._geoJSONIndex = s.cluster ? new W(function ({\n                superclusterOptions: t,\n                clusterProperties: s\n              }) {\n                if (!s || !t) return t;\n                const i = {},\n                  o = {},\n                  r = {\n                    accumulated: null,\n                    zoom: 0\n                  },\n                  n = {\n                    properties: null\n                  },\n                  a = Object.keys(s);\n                for (const t of a) {\n                  const [r, n] = s[t],\n                    a = e.r(n),\n                    l = e.r(\"string\" == typeof r ? [r, [\"accumulated\"], [\"get\", t]] : r);\n                  i[t] = a.value, o[t] = l.value;\n                }\n                return t.map = e => {\n                  n.properties = e;\n                  const t = {};\n                  for (const e of a) t[e] = i[e].evaluate(r, n);\n                  return t;\n                }, t.reduce = (e, t) => {\n                  n.properties = t;\n                  for (const t of a) r.accumulated = e[t], e[t] = o[t].evaluate(r, n);\n                }, t;\n              }(s)).load(a.features) : $(a, s.geojsonVtOptions);\n            } catch (n) {\n              return i(n);\n            }\n            this.loaded = {};\n            const l = {};\n            if (r) {\n              const e = t(o);\n              e && (l.resourceTiming = {}, l.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));\n            }\n            i(null, l);\n          }\n        });\n      }\n      reloadTile(e, t) {\n        const s = this.loaded;\n        return s && s[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);\n      }\n      loadGeoJSON(t, s) {\n        if (t.request) e.g(t.request, s);else {\n          if (\"string\" != typeof t.data) return s(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          try {\n            return s(null, JSON.parse(t.data));\n          } catch (e) {\n            return s(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          }\n        }\n      }\n      getClusterExpansionZoom(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterChildren(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterLeaves(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }\n    }\n    class K {\n      constructor(t, s) {\n        this.tileID = new e.am(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t.projection, this.brightness = s;\n      }\n      parse(t, s, i, o) {\n        this.status = \"parsing\";\n        const r = new e.am(i.tileID.overscaledZ, i.tileID.wrap, i.tileID.canonical.z, i.tileID.canonical.x, i.tileID.canonical.y),\n          n = {},\n          a = s.familiesBySource[i.source],\n          l = new e.dC(r, i.promoteId);\n        return l.bucketLayerIDs = [], l.is3DTile = !0, e.dP(t).then(t => {\n          if (!t) return o(new Error(\"Could not parse tile\"));\n          const s = e.dQ(t, 1 / e.bR(i.tileID.canonical)),\n            h = t.json.extensionsUsed && t.json.extensionsUsed.includes(\"MAPBOX_mesh_features\") || t.json.asset.extras && t.json.asset.extras.MAPBOX_mesh_features,\n            c = t.json.extensionsUsed && t.json.extensionsUsed.includes(\"EXT_meshopt_compression\"),\n            u = new e.K(this.zoom, {\n              brightness: this.brightness\n            });\n          for (const t in a) for (const i of a[t]) {\n            const t = i[0];\n            l.bucketLayerIDs.push(i.map(e => e.id)), t.recalculate(u, []);\n            const o = new e.dR(s, r, h, c, this.brightness, l);\n            h || (o.needsUpload = !0), n[t.fqid] = o, o.evaluate(t);\n          }\n          this.status = \"done\", o(null, {\n            buckets: n,\n            featureIndex: l\n          });\n        }).catch(e => o(new Error(e.message)));\n      }\n    }\n    class H {\n      constructor(e, t, s, i, o, r) {\n        this.actor = e, this.layerIndex = t, this.brightness = r, this.loading = {}, this.loaded = {};\n      }\n      loadTile(t, s) {\n        const i = t.uid,\n          o = this.loading[i] = new K(t, this.brightness);\n        e.a_(t.request, (e, r) => {\n          const n = !this.loading[i];\n          return delete this.loading[i], n || e ? (o.status = \"done\", n || (this.loaded[i] = o), s(e)) : r && 0 !== r.byteLength ? void o.parse(r, this.layerIndex, t, (e, t) => {\n            o.status = \"done\", this.loaded = this.loaded || {}, this.loaded[i] = o, e || !t ? s(e) : s(null, t);\n          }) : (o.status = \"done\", this.loaded[i] = o, s());\n        });\n      }\n      reloadTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        if (s && s[i]) {\n          const o = s[i];\n          o.projection = e.projection, o.brightness = e.brightness;\n          const r = (s, i) => {\n            o.reloadCallback && (delete o.reloadCallback, this.loadTile(e, t)), t(s, i);\n          };\n          \"parsing\" === o.status ? o.reloadCallback = r : \"done\" === o.status && this.loadTile(e, t);\n        }\n      }\n      abortTile(e, t) {\n        const s = e.uid;\n        this.loading[s] && delete this.loading[s], t();\n      }\n      removeTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        s && s[i] && delete s[i], t();\n      }\n    }\n    class Q {\n      constructor(t) {\n        this.self = t, this.actor = new e.dS(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.bo({\n          name: \"mercator\"\n        }), this.workerSourceTypes = {\n          vector: h,\n          geojson: q,\n          \"batched-model\": H\n        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {\n          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name \"${e}\" already registered.`);\n          this.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = t => {\n          if (e.dT.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n          e.dT.applyArabicShaping = t.applyArabicShaping, e.dT.processBidirectionalText = t.processBidirectionalText, e.dT.processStyledBidirectionalText = t.processStyledBidirectionalText;\n        };\n      }\n      clearCaches(e, t, s) {\n        delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], delete this.rasterArrayWorkerSource, s();\n      }\n      checkIfReady(e, t, s) {\n        s();\n      }\n      setReferrer(e, t) {\n        this.referrer = t;\n      }\n      spriteLoaded(t, {\n        scope: s,\n        isLoaded: i\n      }) {\n        if (this.isSpriteLoaded[t] || (this.isSpriteLoaded[t] = {}), this.isSpriteLoaded[t][s] = i, this.workerSources[t] && this.workerSources[t][s]) for (const o in this.workerSources[t][s]) {\n          const r = this.workerSources[t][s][o];\n          for (const t in r) r[t] instanceof h && (r[t].isSpriteLoaded = i, r[t].fire(new e.b(\"isSpriteLoaded\")));\n        }\n      }\n      setImages(e, {\n        scope: t,\n        images: s\n      }, i) {\n        if (this.availableImages[e] || (this.availableImages[e] = {}), this.availableImages[e][t] = s, this.workerSources[e] && this.workerSources[e][t]) {\n          for (const i in this.workerSources[e][t]) {\n            const o = this.workerSources[e][t][i];\n            for (const e in o) o[e].availableImages = s;\n          }\n          i();\n        } else i();\n      }\n      setProjection(t, s) {\n        this.projections[t] = e.bo(s);\n      }\n      setBrightness(e, t, s) {\n        this.brightness = t, s();\n      }\n      setLayers(e, t, s) {\n        this.getLayerIndex(e, t.scope).replace(t.layers, t.options), s();\n      }\n      updateLayers(e, t, s) {\n        this.getLayerIndex(e, t.scope).update(t.layers, t.removedIds, t.options), s();\n      }\n      loadTile(e, t, s) {\n        t.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t.type, t.source, t.scope).loadTile(t, s);\n      }\n      loadDEMTile(e, t, s) {\n        this.getDEMWorkerSource(e, t.source, t.scope).loadTile(t, s);\n      }\n      decodeRasterArray(e, t, s) {\n        this.getRasterArrayWorkerSource().decodeRasterArray(t, s);\n      }\n      reloadTile(e, t, s) {\n        t.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t.type, t.source, t.scope).reloadTile(t, s);\n      }\n      abortTile(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).abortTile(t, s);\n      }\n      removeTile(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).removeTile(t, s);\n      }\n      removeSource(e, t, s) {\n        if (!(this.workerSources[e] && this.workerSources[e][t.scope] && this.workerSources[e][t.scope][t.type] && this.workerSources[e][t.scope][t.type][t.source])) return;\n        const i = this.workerSources[e][t.scope][t.type][t.source];\n        delete this.workerSources[e][t.scope][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, s) : s();\n      }\n      loadWorkerSource(e, t, s) {\n        try {\n          this.self.importScripts(t.url), s();\n        } catch (e) {\n          s(e.toString());\n        }\n      }\n      syncRTLPluginState(t, s, i) {\n        try {\n          e.dT.setState(s);\n          const t = e.dT.getPluginURL();\n          if (e.dT.isLoaded() && !e.dT.isParsed() && null != t) {\n            this.self.importScripts(t);\n            const s = e.dT.isParsed();\n            i(s ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), s);\n          }\n        } catch (e) {\n          i(e.toString());\n        }\n      }\n      setDracoUrl(e, t) {\n        this.dracoUrl = t;\n      }\n      getAvailableImages(e, t) {\n        this.availableImages[e] || (this.availableImages[e] = {});\n        let s = this.availableImages[e][t];\n        return s || (s = []), s;\n      }\n      getLayerIndex(e, t) {\n        this.layerIndexes[e] || (this.layerIndexes[e] = {});\n        let s = this.layerIndexes[e][t];\n        return s || (s = this.layerIndexes[e][t] = new o(), s.scope = t), s;\n      }\n      getWorkerSource(e, t, s, i) {\n        if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][i] || (this.workerSources[e][i] = {}), this.workerSources[e][i][t] || (this.workerSources[e][i][t] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), !this.workerSources[e][i][t][s]) {\n          const o = {\n            send: (t, s, i, o, r, n) => {\n              this.actor.send(t, s, i, e, r, n);\n            },\n            scheduler: this.actor.scheduler\n          };\n          this.workerSources[e][i][t][s] = new this.workerSourceTypes[t](o, this.getLayerIndex(e, i), this.getAvailableImages(e, i), this.isSpriteLoaded[e][i], void 0, this.brightness);\n        }\n        return this.workerSources[e][i][t][s];\n      }\n      getDEMWorkerSource(e, t, s) {\n        return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][s] || (this.demWorkerSources[e][s] = {}), this.demWorkerSources[e][s][t] || (this.demWorkerSources[e][s][t] = new c()), this.demWorkerSources[e][s][t];\n      }\n      getRasterArrayWorkerSource() {\n        return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u()), this.rasterArrayWorkerSource;\n      }\n      enforceCacheSizeLimit(t, s) {\n        e.dU(s);\n      }\n      getWorkerPerformanceMetrics(e, t, s) {\n        s(void 0, void 0);\n      }\n    }\n    return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Q(self)), Q;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    function t(e, i) {\n      if (Array.isArray(e)) {\n        if (!Array.isArray(i) || e.length !== i.length) return !1;\n        for (let o = 0; o < e.length; o++) if (!t(e[o], i[o])) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof e && null !== e && null !== i) {\n        if (\"object\" != typeof i) return !1;\n        if (Object.keys(e).length !== Object.keys(i).length) return !1;\n        for (const o in e) if (!t(e[o], i[o])) return !1;\n        return !0;\n      }\n      return e === i;\n    }\n    var i = o;\n    function o(e) {\n      return !function (e) {\n        return \"undefined\" == typeof window || \"undefined\" == typeof document ? \"not a browser\" : function () {\n          if (!(\"Worker\" in window && \"Blob\" in window && \"URL\" in window)) return !1;\n          var e,\n            t,\n            i = new Blob([\"\"], {\n              type: \"text/javascript\"\n            }),\n            o = URL.createObjectURL(i);\n          try {\n            t = new Worker(o), e = !0;\n          } catch (t) {\n            e = !1;\n          }\n          return t && t.terminate(), URL.revokeObjectURL(o), e;\n        }() ? function () {\n          var e = document.createElement(\"canvas\");\n          e.width = e.height = 1;\n          var t = e.getContext(\"2d\");\n          if (!t) return !1;\n          var i = t.getImageData(0, 0, 1, 1);\n          return i && i.width === e.width;\n        }() ? (void 0 === r[t = e && e.failIfMajorPerformanceCaveat] && (r[t] = function (e) {\n          var t,\n            i = function (e) {\n              var t = document.createElement(\"canvas\"),\n                i = Object.create(o.webGLContextAttributes);\n              return i.failIfMajorPerformanceCaveat = e, t.getContext(\"webgl2\", i);\n            }(e);\n          if (!i) return !1;\n          try {\n            t = i.createShader(i.VERTEX_SHADER);\n          } catch (e) {\n            return !1;\n          }\n          return !(!t || i.isContextLost()) && (i.shaderSource(t, \"void main() {}\"), i.compileShader(t), !0 === i.getShaderParameter(t, i.COMPILE_STATUS));\n        }(t)), r[t] ? document.documentMode ? \"insufficient ECMAScript 6 support\" : void 0 : \"insufficient WebGL2 support\") : \"insufficient Canvas/getImageData support\" : \"insufficient worker support\";\n        var t;\n      }(e);\n    }\n    var r = {};\n    function s(e, t, i) {\n      const o = document.createElement(e);\n      return null != t && (o.className = t), i && i.appendChild(o), o;\n    }\n    function n(e, t, i) {\n      const o = document.createElementNS(\"http://www.w3.org/2000/svg\", e);\n      for (const e of Object.keys(t)) o.setAttributeNS(null, e, String(t[e]));\n      return i && i.appendChild(o), o;\n    }\n    o.webGLContextAttributes = {\n      antialias: !1,\n      alpha: !0,\n      stencil: !0,\n      depth: !0\n    };\n    const a = \"undefined\" != typeof document ? document.documentElement && document.documentElement.style : null,\n      l = a && void 0 !== a.userSelect ? \"userSelect\" : \"WebkitUserSelect\";\n    let c;\n    function h() {\n      a && l && (c = a[l], a[l] = \"none\");\n    }\n    function u() {\n      a && l && (a[l] = c);\n    }\n    function d(e) {\n      e.preventDefault(), e.stopPropagation(), window.removeEventListener(\"click\", d, !0);\n    }\n    function _() {\n      window.addEventListener(\"click\", d, !0), window.setTimeout(() => {\n        window.removeEventListener(\"click\", d, !0);\n      }, 0);\n    }\n    function p(e, t) {\n      const i = e.getBoundingClientRect();\n      return g(e, i, t);\n    }\n    function f(e, t) {\n      const i = e.getBoundingClientRect(),\n        o = [];\n      for (let r = 0; r < t.length; r++) o.push(g(e, i, t[r]));\n      return o;\n    }\n    function m(e) {\n      return void 0 !== window.InstallTrigger && 2 === e.button && e.ctrlKey && window.navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0 ? 0 : e.button;\n    }\n    function g(t, i, o) {\n      const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;\n      return new e.P((o.clientX - i.left) * r, (o.clientY - i.top) * r);\n    }\n    class v {\n      constructor() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set(), this._updatedImages = new Set();\n      }\n      isDirty() {\n        return this._changed;\n      }\n      setDirty() {\n        this._changed = !0;\n      }\n      getUpdatedSourceCaches() {\n        return this._updatedSourceCaches;\n      }\n      updateSourceCache(e, t) {\n        this._updatedSourceCaches[e] = t, this.setDirty();\n      }\n      discardSourceCacheUpdate(e) {\n        delete this._updatedSourceCaches[e];\n      }\n      updateLayer(e) {\n        const t = e.scope;\n        this._updatedLayers[t] = this._updatedLayers[t] || new Set(), this._updatedLayers[t].add(e.id), this.setDirty();\n      }\n      removeLayer(e) {\n        const t = e.scope;\n        this._removedLayers[t] = this._removedLayers[t] || {}, this._updatedLayers[t] = this._updatedLayers[t] || new Set(), this._removedLayers[t][e.id] = e, this._updatedLayers[t].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();\n      }\n      getRemovedLayer(e) {\n        return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;\n      }\n      discardLayerRemoval(e) {\n        this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];\n      }\n      getLayerUpdatesByScope() {\n        const e = {};\n        for (const t in this._updatedLayers) e[t] = e[t] || {}, e[t].updatedIds = Array.from(this._updatedLayers[t].values());\n        for (const t in this._removedLayers) e[t] = e[t] || {}, e[t].removedIds = Object.keys(this._removedLayers[t]);\n        return e;\n      }\n      getUpdatedPaintProperties() {\n        return this._updatedPaintProps;\n      }\n      updatePaintProperties(e) {\n        this._updatedPaintProps.add(e.fqid), this.setDirty();\n      }\n      getUpdatedImages() {\n        return Array.from(this._updatedImages.values());\n      }\n      updateImage(e) {\n        this._updatedImages.add(e), this.setDirty();\n      }\n      resetUpdatedImages() {\n        this._updatedImages.clear();\n      }\n      reset() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();\n      }\n    }\n    class x extends e.E {\n      constructor(e) {\n        super(), this.requestManager = e, this.models = {\n          \"\": {}\n        }, this.numModelsLoading = {};\n      }\n      loadModel(t, i) {\n        return e.l(this.requestManager.transformRequest(i, e.R.Model).url).then(i => {\n          if (!i) return;\n          const o = e.c(i),\n            r = new e.M(t, void 0, void 0, o);\n          return r.computeBoundsAndApplyParent(), r;\n        }).catch(o => {\n          this.fire(new e.a(new Error(`Could not load model ${t} from ${i}: ${o.message}`)));\n        });\n      }\n      load(t, i) {\n        this.models[i] || (this.models[i] = {});\n        const o = Object.keys(t);\n        this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + o.length;\n        const r = [];\n        for (const e of o) r.push(this.loadModel(e, t[e]));\n        Promise.allSettled(r).then(t => {\n          for (let e = 0; e < t.length; e++) {\n            const {\n              status: r,\n              value: s\n            } = t[e];\n            \"fulfilled\" === r && s && (this.models[i][o[e]] = s);\n          }\n          this.numModelsLoading[i] -= o.length, this.fire(new e.b(\"data\", {\n            dataType: \"style\"\n          }));\n        }).catch(t => {\n          this.fire(new e.a(new Error(`Could not load models: ${t.message}`)));\n        });\n      }\n      isLoaded() {\n        for (const e in this.numModelsLoading) if (this.numModelsLoading[e] > 0) return !1;\n        return !0;\n      }\n      hasModel(e, t) {\n        return !!this.getModel(e, t);\n      }\n      getModel(e, t) {\n        return this.models[t] || (this.models[t] = {}), this.models[t][e];\n      }\n      addModel(e, t, i) {\n        this.models[i] || (this.models[i] = {}), this.hasModel(e, i) && this.removeModel(e, i), this.load({\n          [e]: this.requestManager.normalizeModelURL(t)\n        }, i);\n      }\n      addModels(e, t) {\n        const i = {};\n        for (const t in e) i[t] = this.requestManager.normalizeModelURL(e[t]);\n        this.load(i, t);\n      }\n      removeModel(e, t) {\n        this.models[t] || (this.models[t] = {});\n        const i = this.models[t][e];\n        delete this.models[t][e], i.destroy();\n      }\n      listModels(e) {\n        return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);\n      }\n      upload(e, t) {\n        this.models[t] || (this.models[t] = {});\n        for (const i in this.models[t]) this.models[t][i].upload(e.context);\n      }\n    }\n    class y {\n      constructor() {\n        this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n      }\n      updateState(t, i, o) {\n        const r = String(i);\n        if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][r] = this.stateChanges[t][r] || {}, e.e(this.stateChanges[t][r], o), null === this.deletedStates[t]) {\n          this.deletedStates[t] = {};\n          for (const e in this.state[t]) e !== r && (this.deletedStates[t][e] = null);\n        } else if (this.deletedStates[t] && null === this.deletedStates[t][r]) {\n          this.deletedStates[t][r] = {};\n          for (const e in this.state[t][r]) o[e] || (this.deletedStates[t][r][e] = null);\n        } else for (const e in o) this.deletedStates[t] && this.deletedStates[t][r] && null === this.deletedStates[t][r][e] && delete this.deletedStates[t][r][e];\n      }\n      removeFeatureState(e, t, i) {\n        if (null === this.deletedStates[e]) return;\n        const o = String(t);\n        if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t) null !== this.deletedStates[e][o] && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);else if (void 0 !== t) {\n          if (this.stateChanges[e] && this.stateChanges[e][o]) for (i in this.deletedStates[e][o] = {}, this.stateChanges[e][o]) this.deletedStates[e][o][i] = null;else this.deletedStates[e][o] = null;\n        } else this.deletedStates[e] = null;\n      }\n      getState(t, i) {\n        const o = String(i),\n          r = e.e({}, (this.state[t] || {})[o], (this.stateChanges[t] || {})[o]);\n        if (null === this.deletedStates[t]) return {};\n        if (this.deletedStates[t]) {\n          const e = this.deletedStates[t][i];\n          if (null === e) return {};\n          for (const t in e) delete r[t];\n        }\n        return r;\n      }\n      initializeTileState(e, t) {\n        e.setFeatureState(this.state, t);\n      }\n      coalesceChanges(t, i) {\n        const o = {};\n        for (const t in this.stateChanges) {\n          this.state[t] = this.state[t] || {};\n          const i = {};\n          for (const o in this.stateChanges[t]) this.state[t][o] || (this.state[t][o] = {}), e.e(this.state[t][o], this.stateChanges[t][o]), i[o] = this.state[t][o];\n          o[t] = i;\n        }\n        for (const t in this.deletedStates) {\n          this.state[t] = this.state[t] || {};\n          const i = {};\n          if (null === this.deletedStates[t]) for (const e in this.state[t]) i[e] = {}, this.state[t][e] = {};else for (const e in this.deletedStates[t]) {\n            if (null === this.deletedStates[t][e]) this.state[t][e] = {};else if (this.state[t][e]) for (const i of Object.keys(this.deletedStates[t][e])) delete this.state[t][e][i];\n            i[e] = this.state[t][e];\n          }\n          o[t] = o[t] || {}, e.e(o[t], i);\n        }\n        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o).length) for (const e in t) t[e].setFeatureState(o, i);\n      }\n    }\n    function b(e) {\n      const {\n        userImage: t\n      } = e;\n      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);\n    }\n    class w extends e.E {\n      constructor() {\n        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0;\n      }\n      createScope(t) {\n        this.images[t] = {}, this.loaded[t] = !1, this.updatedImages[t] = {}, this.patterns[t] = {}, this.callbackDispatchedThisFrame[t] = {}, this.atlasImage[t] = new e.h({\n          width: 1,\n          height: 1\n        });\n      }\n      isLoaded() {\n        for (const e in this.loaded) if (!this.loaded[e]) return !1;\n        return !0;\n      }\n      setLoaded(e, t) {\n        if (this.loaded[t] !== e && (this.loaded[t] = e, e)) {\n          for (const {\n            ids: e,\n            callback: i\n          } of this.requestors) this._notify(e, t, i);\n          this.requestors = [];\n        }\n      }\n      hasImage(e, t) {\n        return !!this.getImage(e, t);\n      }\n      getImage(e, t) {\n        return this.images[t][e];\n      }\n      addImage(e, t, i) {\n        this._validate(e, i) && (this.images[t][e] = i);\n      }\n      _validate(t, i) {\n        let o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.a(new Error(`Image \"${t}\" has invalid \"stretchX\" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.a(new Error(`Image \"${t}\" has invalid \"stretchY\" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.a(new Error(`Image \"${t}\" has invalid \"content\" value`))), o = !1), o;\n      }\n      _validateStretch(e, t) {\n        if (!e) return !0;\n        let i = 0;\n        for (const o of e) {\n          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;\n          i = o[1];\n        }\n        return !0;\n      }\n      _validateContent(e, t) {\n        return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));\n      }\n      updateImage(e, t, i) {\n        i.version = this.images[t][e].version + 1, this.images[t][e] = i, this.updatedImages[t][e] = !0;\n      }\n      removeImage(e, t) {\n        const i = this.images[t][e];\n        delete this.images[t][e], delete this.patterns[t][e], i.userImage && i.userImage.onRemove && i.userImage.onRemove();\n      }\n      listImages(e) {\n        return Object.keys(this.images[e]);\n      }\n      getImages(e, t, i) {\n        let o = !0;\n        const r = !!this.loaded[t];\n        if (!r) for (const i of e) this.images[t][i] || (o = !1);\n        r || o ? this._notify(e, t, i) : this.requestors.push({\n          ids: e,\n          scope: t,\n          callback: i\n        });\n      }\n      getUpdatedImages(e) {\n        return this.updatedImages[e];\n      }\n      _notify(t, i, o) {\n        const r = {};\n        for (const o of t) {\n          this.images[i][o] || this.fire(new e.b(\"styleimagemissing\", {\n            id: o\n          }));\n          const t = this.images[i][o];\n          t ? r[o] = {\n            data: t.data.clone(),\n            pixelRatio: t.pixelRatio,\n            sdf: t.sdf,\n            version: t.version,\n            stretchX: t.stretchX,\n            stretchY: t.stretchY,\n            content: t.content,\n            hasRenderCallback: Boolean(t.userImage && t.userImage.render)\n          } : e.w(`Image \"${o}\" could not be loaded. Please make sure you have added the image with map.addImage() or a \"sprite\" property in your style. You can provide missing images by listening for the \"styleimagemissing\" map event.`);\n        }\n        o(null, r);\n      }\n      getPixelSize(e) {\n        const {\n          width: t,\n          height: i\n        } = this.atlasImage[e];\n        return {\n          width: t,\n          height: i\n        };\n      }\n      getPattern(t, i) {\n        const o = this.patterns[i][t],\n          r = this.getImage(t, i);\n        if (!r) return null;\n        if (o && o.position.version === r.version) return o.position;\n        if (o) o.position.version = r.version;else {\n          const o = {\n              w: r.data.width + 2,\n              h: r.data.height + 2,\n              x: 0,\n              y: 0\n            },\n            s = new e.I(o, r);\n          this.patterns[i][t] = {\n            bin: o,\n            position: s\n          };\n        }\n        return this._updatePatternAtlas(i), this.patterns[i][t].position;\n      }\n      bind(t, i) {\n        const o = t.gl;\n        let r = this.atlasTexture[i];\n        r ? this.dirty && (r.update(this.atlasImage[i]), this.dirty = !1) : (r = new e.T(t, this.atlasImage[i], o.RGBA), this.atlasTexture[i] = r), r.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }\n      _updatePatternAtlas(t) {\n        const i = [];\n        for (const e in this.patterns[t]) i.push(this.patterns[t][e].bin);\n        const {\n            w: o,\n            h: r\n          } = e.p(i),\n          s = this.atlasImage[t];\n        s.resize({\n          width: o || 1,\n          height: r || 1\n        });\n        for (const i in this.patterns[t]) {\n          const {\n              bin: o\n            } = this.patterns[t][i],\n            r = o.x + 1,\n            n = o.y + 1,\n            a = this.images[t][i].data,\n            l = a.width,\n            c = a.height;\n          e.h.copy(a, s, {\n            x: 0,\n            y: 0\n          }, {\n            x: r,\n            y: n\n          }, {\n            width: l,\n            height: c\n          }), e.h.copy(a, s, {\n            x: 0,\n            y: c - 1\n          }, {\n            x: r,\n            y: n - 1\n          }, {\n            width: l,\n            height: 1\n          }), e.h.copy(a, s, {\n            x: 0,\n            y: 0\n          }, {\n            x: r,\n            y: n + c\n          }, {\n            width: l,\n            height: 1\n          }), e.h.copy(a, s, {\n            x: l - 1,\n            y: 0\n          }, {\n            x: r - 1,\n            y: n\n          }, {\n            width: 1,\n            height: c\n          }), e.h.copy(a, s, {\n            x: 0,\n            y: 0\n          }, {\n            x: r + l,\n            y: n\n          }, {\n            width: 1,\n            height: c\n          });\n        }\n        this.dirty = !0;\n      }\n      beginFrame() {\n        for (const e in this.images) this.callbackDispatchedThisFrame[e] = {};\n      }\n      dispatchRenderCallbacks(e, t) {\n        for (const i of e) {\n          if (this.callbackDispatchedThisFrame[t][i]) continue;\n          this.callbackDispatchedThisFrame[t][i] = !0;\n          const e = this.images[t][i];\n          b(e) && this.updateImage(i, t, e);\n        }\n      }\n    }\n    class T {\n      constructor(e, t, i, o) {\n        this.message = (e ? `${e}: ` : \"\") + i, o && (this.identifier = o), null != t && t.__line__ && (this.line = t.__line__);\n      }\n    }\n    class E extends T {}\n    function S(t) {\n      const i = t.key,\n        o = t.value,\n        r = t.valueSpec || {},\n        s = t.objectElementValidators || {},\n        n = t.style,\n        a = t.styleSpec;\n      let l = [];\n      const c = e.i(o);\n      if (\"object\" !== c) return [new T(i, o, `object expected, ${c} found`)];\n      for (const e in o) {\n        const t = e.split(\".\")[0];\n        let c;\n        s[t] ? c = s[t] : r[t] ? c = $ : s[\"*\"] ? c = s[\"*\"] : r[\"*\"] && (c = $), c ? l = l.concat(c({\n          key: (i ? `${i}.` : i) + e,\n          value: o[e],\n          valueSpec: r[t] || r[\"*\"],\n          style: n,\n          styleSpec: a,\n          object: o,\n          objectKey: e\n        }, o)) : l.push(new E(i, o[e], `unknown property \"${e}\"`));\n      }\n      for (const e in r) s[e] || r[e].required && void 0 === r[e].default && void 0 === o[e] && l.push(new T(i, o, `missing required property \"${e}\"`));\n      return l;\n    }\n    function C(t) {\n      const i = t.value,\n        o = t.valueSpec,\n        r = t.style,\n        s = t.styleSpec,\n        n = t.key,\n        a = t.arrayElementValidator || $;\n      if (\"array\" !== e.i(i)) return [new T(n, i, `array expected, ${e.i(i)} found`)];\n      if (o.length && i.length !== o.length) return [new T(n, i, `array length ${o.length} expected, length ${i.length} found`)];\n      if (o[\"min-length\"] && i.length < o[\"min-length\"]) return [new T(n, i, `array length at least ${o[\"min-length\"]} expected, length ${i.length} found`)];\n      let l = {\n        type: o.value,\n        values: o.values,\n        minimum: o.minimum,\n        maximum: o.maximum,\n        function: void 0\n      };\n      s.$version < 7 && (l.function = o.function), \"object\" === e.i(o.value) && (l = o.value);\n      let c = [];\n      for (let e = 0; e < i.length; e++) c = c.concat(a({\n        array: i,\n        arrayIndex: e,\n        value: i[e],\n        valueSpec: l,\n        style: r,\n        styleSpec: s,\n        key: `${n}[${e}]`\n      }, !0));\n      return c;\n    }\n    function I(t) {\n      const i = t.key,\n        o = t.value,\n        r = t.valueSpec;\n      let s = e.i(o);\n      if (\"number\" === s && o != o && (s = \"NaN\"), \"number\" !== s) return [new T(i, o, `number expected, ${s} found`)];\n      if (\"minimum\" in r) {\n        let s = r.minimum;\n        if (\"array\" === e.i(r.minimum) && (s = r.minimum[t.arrayIndex]), o < s) return [new T(i, o, `${o} is less than the minimum value ${s}`)];\n      }\n      if (\"maximum\" in r) {\n        let s = r.maximum;\n        if (\"array\" === e.i(r.maximum) && (s = r.maximum[t.arrayIndex]), o > s) return [new T(i, o, `${o} is greater than the maximum value ${s}`)];\n      }\n      return [];\n    }\n    function D(t) {\n      const i = t.valueSpec,\n        o = e.u(t.value.type);\n      let r,\n        s,\n        n,\n        a = {};\n      const l = \"categorical\" !== o && void 0 === t.value.property,\n        c = !l,\n        h = \"array\" === e.i(t.value.stops) && \"array\" === e.i(t.value.stops[0]) && \"object\" === e.i(t.value.stops[0][0]),\n        u = S({\n          key: t.key,\n          value: t.value,\n          valueSpec: t.styleSpec.function,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            stops: function (t) {\n              if (\"identity\" === o) return [new T(t.key, t.value, 'identity function may not have a \"stops\" property')];\n              let i = [];\n              const r = t.value;\n              return i = i.concat(C({\n                key: t.key,\n                value: r,\n                valueSpec: t.valueSpec,\n                style: t.style,\n                styleSpec: t.styleSpec,\n                arrayElementValidator: d\n              })), \"array\" === e.i(r) && 0 === r.length && i.push(new T(t.key, r, \"array must have at least one stop\")), i;\n            },\n            default: function (e) {\n              return $({\n                key: e.key,\n                value: e.value,\n                valueSpec: i,\n                style: e.style,\n                styleSpec: e.styleSpec\n              });\n            }\n          }\n        });\n      return \"identity\" === o && l && u.push(new T(t.key, t.value, 'missing required property \"property\"')), \"identity\" === o || t.value.stops || u.push(new T(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === o && t.valueSpec.expression && !e.s(t.valueSpec) && u.push(new T(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (c && !e.k(t.valueSpec) ? u.push(new T(t.key, t.value, \"property functions not supported\")) : l && !e.m(t.valueSpec) && u.push(new T(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== o && !h || void 0 !== t.value.property || u.push(new T(t.key, t.value, '\"property\" property is required')), u;\n      function d(t) {\n        let o = [];\n        const r = t.value,\n          l = t.key;\n        if (\"array\" !== e.i(r)) return [new T(l, r, `array expected, ${e.i(r)} found`)];\n        if (2 !== r.length) return [new T(l, r, `array length 2 expected, length ${r.length} found`)];\n        if (h) {\n          if (\"object\" !== e.i(r[0])) return [new T(l, r, `object expected, ${e.i(r[0])} found`)];\n          if (void 0 === r[0].zoom) return [new T(l, r, \"object stop key must have zoom\")];\n          if (void 0 === r[0].value) return [new T(l, r, \"object stop key must have value\")];\n          const i = e.u(r[0].zoom);\n          if (\"number\" != typeof i) return [new T(l, r[0].zoom, \"stop zoom values must be numbers\")];\n          if (n && n > i) return [new T(l, r[0].zoom, \"stop zoom values must appear in ascending order\")];\n          i !== n && (n = i, s = void 0, a = {}), o = o.concat(S({\n            key: `${l}[0]`,\n            value: r[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: I,\n              value: _\n            }\n          }));\n        } else o = o.concat(_({\n          key: `${l}[0]`,\n          value: r[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, r));\n        return e.n(e.o(r[1])) ? o.concat([new T(`${l}[1]`, r[1], \"expressions are not allowed in function stops.\")]) : o.concat($({\n          key: `${l}[1]`,\n          value: r[1],\n          valueSpec: i,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n      function _(t, n) {\n        const l = e.i(t.value),\n          c = e.u(t.value),\n          h = null !== t.value ? t.value : n;\n        if (r) {\n          if (l !== r) return [new T(t.key, h, `${l} stop domain type must match previous stop domain type ${r}`)];\n        } else r = l;\n        if (\"number\" !== l && \"string\" !== l && \"boolean\" !== l && \"number\" != typeof c && \"string\" != typeof c && \"boolean\" != typeof c) return [new T(t.key, h, \"stop domain value must be a number, string, or boolean\")];\n        if (\"number\" !== l && \"categorical\" !== o) {\n          let r = `number expected, ${l} found`;\n          return e.k(i) && void 0 === o && (r += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new T(t.key, h, r)];\n        }\n        return \"categorical\" !== o || \"number\" !== l || \"number\" == typeof c && isFinite(c) && Math.floor(c) === c ? \"categorical\" !== o && \"number\" === l && \"number\" == typeof c && \"number\" == typeof s && void 0 !== s && c < s ? [new T(t.key, h, \"stop domain values must appear in ascending order\")] : (s = c, \"categorical\" === o && c in a ? [new T(t.key, h, \"stop domain values must be unique\")] : (a[c] = !0, [])) : [new T(t.key, h, `integer expected, found ${String(c)}`)];\n      }\n    }\n    function L(t) {\n      const i = (\"property\" === t.expressionContext ? e.q : e.r)(e.o(t.value), t.valueSpec);\n      if (\"error\" === i.result) return i.value.map(e => new T(`${t.key}${e.key}`, t.value, e.message));\n      const o = i.value.expression || i.value._styleExpression.expression;\n      if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !o.outputDefined()) return [new T(t.key, t.value, `Invalid data expression for \"${t.propertyKey}\". Output values must be contained as literals within the expression.`)];\n      if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !e.t(o)) return [new T(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n      if (\"filter\" === t.expressionContext) return A(o, t);\n      if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n        if (!e.v(o, [\"zoom\", \"feature-state\"])) return [new T(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        if (\"cluster-initial\" === t.expressionContext && !e.x(o)) return [new T(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n      }\n      return [];\n    }\n    function A(t, i) {\n      const o = new Set([\"zoom\", \"feature-state\", \"pitch\", \"distance-from-center\"]);\n      if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters) o.delete(e);\n      if (0 === o.size) return [];\n      const r = [];\n      return t instanceof e.C && o.has(t.name) ? [new T(i.key, i.value, `[\"${t.name}\"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)] : (t.eachChild(e => {\n        r.push(...A(e, i));\n      }), r);\n    }\n    function R(t) {\n      const i = t.key,\n        o = t.value,\n        r = t.valueSpec,\n        s = [];\n      return Array.isArray(r.values) ? -1 === r.values.indexOf(e.u(o)) && s.push(new T(i, o, `expected one of [${r.values.join(\", \")}], ${JSON.stringify(o)} found`)) : -1 === Object.keys(r.values).indexOf(e.u(o)) && s.push(new T(i, o, `expected one of [${Object.keys(r.values).join(\", \")}], ${JSON.stringify(o)} found`)), s;\n    }\n    function P(t) {\n      return e.z(e.o(t.value)) ? L(e.j({}, t, {\n        expressionContext: \"filter\",\n        valueSpec: t.styleSpec[`filter_${t.layerType || \"fill\"}`]\n      })) : M(t);\n    }\n    function M(t) {\n      const i = t.value,\n        o = t.key;\n      if (\"array\" !== e.i(i)) return [new T(o, i, `array expected, ${e.i(i)} found`)];\n      const r = t.styleSpec;\n      let s,\n        n = [];\n      if (i.length < 1) return [new T(o, i, \"filter array must have at least 1 element\")];\n      switch (n = n.concat(R({\n        key: `${o}[0]`,\n        value: i[0],\n        valueSpec: r.filter_operator,\n        style: t.style,\n        styleSpec: t.styleSpec\n      })), e.u(i[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          i.length >= 2 && \"$type\" === e.u(i[1]) && n.push(new T(o, i, `\"$type\" cannot be use with operator \"${i[0]}\"`));\n        case \"==\":\n        case \"!=\":\n          3 !== i.length && n.push(new T(o, i, `filter array for operator \"${i[0]}\" must have 3 elements`));\n        case \"in\":\n        case \"!in\":\n          i.length >= 2 && (s = e.i(i[1]), \"string\" !== s && n.push(new T(`${o}[1]`, i[1], `string expected, ${s} found`)));\n          for (let a = 2; a < i.length; a++) s = e.i(i[a]), \"$type\" === e.u(i[1]) ? n = n.concat(R({\n            key: `${o}[${a}]`,\n            value: i[a],\n            valueSpec: r.geometry_type,\n            style: t.style,\n            styleSpec: t.styleSpec\n          })) : \"string\" !== s && \"number\" !== s && \"boolean\" !== s && n.push(new T(`${o}[${a}]`, i[a], `string, number, or boolean expected, ${s} found`));\n          break;\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let e = 1; e < i.length; e++) n = n.concat(M({\n            key: `${o}[${e}]`,\n            value: i[e],\n            style: t.style,\n            styleSpec: t.styleSpec\n          }));\n          break;\n        case \"has\":\n        case \"!has\":\n          s = e.i(i[1]), 2 !== i.length ? n.push(new T(o, i, `filter array for \"${i[0]}\" operator must have 2 elements`)) : \"string\" !== s && n.push(new T(`${o}[1]`, i[1], `string expected, ${s} found`));\n      }\n      return n;\n    }\n    function z(t, i) {\n      const o = t.key,\n        r = t.style,\n        s = t.layer,\n        n = t.styleSpec,\n        a = t.value,\n        l = t.objectKey,\n        c = n[`${i}_${t.layerType}`];\n      if (!c) return [];\n      const h = l.match(/^(.*)-transition$/);\n      if (\"paint\" === i && h && c[h[1]] && c[h[1]].transition) return $({\n        key: o,\n        value: a,\n        valueSpec: n.transition,\n        style: r,\n        styleSpec: n\n      });\n      const u = t.valueSpec || c[l];\n      if (!u) return [new E(o, a, `unknown property \"${l}\"`)];\n      let d;\n      if (\"string\" === e.i(a) && e.k(u) && !u.tokens && (d = /^{([^}]+)}$/.exec(a))) {\n        const e = `\\`{ \"type\": \"identity\", \"property\": ${d ? JSON.stringify(d[1]) : '\"_\"'} }\\``;\n        return [new T(o, a, `\"${l}\" does not support interpolation syntax\\nUse an identity property function instead: ${e}.`)];\n      }\n      const _ = [];\n      if (\"symbol\" === t.layerType) \"text-field\" !== l || !r || r.glyphs || r.imports || _.push(new T(o, a, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === l && e.A(e.o(a)) && \"identity\" === e.u(a.type) && _.push(new T(o, a, '\"text-font\" does not support identity functions'));else if (\"model\" === t.layerType && \"paint\" === i && s && s.layout && s.layout.hasOwnProperty(\"model-id\") && e.k(u) && (e.B(u) || e.m(u))) {\n        const t = e.q(e.o(a), u),\n          i = t.value.expression || t.value._styleExpression.expression;\n        i && !e.v(i, [\"measure-light\"]) && (\"model-emissive-strength\" === l && e.x(i) && e.t(i) || _.push(new T(o, a, `${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));\n      }\n      return _.concat($({\n        key: t.key,\n        value: a,\n        valueSpec: u,\n        style: r,\n        styleSpec: n,\n        expressionContext: \"property\",\n        propertyType: i,\n        propertyKey: l\n      }));\n    }\n    function O(e) {\n      return z(e, \"paint\");\n    }\n    function F(e) {\n      return z(e, \"layout\");\n    }\n    function B(t) {\n      let i = [];\n      const o = t.value,\n        r = t.key,\n        s = t.style,\n        n = t.styleSpec;\n      o.type || o.ref || i.push(new T(r, o, 'either \"type\" or \"ref\" is required'));\n      let a = e.u(o.type);\n      const l = e.u(o.ref);\n      if (o.id) {\n        const n = e.u(o.id);\n        for (let a = 0; a < t.arrayIndex; a++) {\n          const t = s.layers[a];\n          e.u(t.id) === n && i.push(new T(r, o.id, `duplicate layer id \"${o.id}\", previously used at line ${t.id.__line__}`));\n        }\n      }\n      if (\"ref\" in o) {\n        let t;\n        [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(e => {\n          e in o && i.push(new T(r, o[e], `\"${e}\" is prohibited for ref layers`));\n        }), s.layers.forEach(i => {\n          e.u(i.id) === l && (t = i);\n        }), t ? t.ref ? i.push(new T(r, o.ref, \"ref cannot reference another ref layer\")) : a = e.u(t.type) : \"string\" == typeof l && i.push(new T(r, o.ref, `ref layer \"${l}\" not found`));\n      } else if (\"background\" !== a && \"sky\" !== a && \"slot\" !== a) if (o.source) {\n        const t = s.sources && s.sources[o.source],\n          n = t && e.u(t.type);\n        t ? \"vector\" === n && \"raster\" === a ? i.push(new T(r, o.source, `layer \"${o.id}\" requires a raster source`)) : \"raster\" === n && \"raster\" !== a ? i.push(new T(r, o.source, `layer \"${o.id}\" requires a vector source`)) : \"vector\" !== n || o[\"source-layer\"] ? \"raster-dem\" === n && \"hillshade\" !== a ? i.push(new T(r, o.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"raster-array\" !== n || [\"raster\", \"raster-particle\"].includes(a) ? \"line\" !== a || !o.paint || !o.paint[\"line-gradient\"] && !o.paint[\"line-trim-offset\"] || \"geojson\" === n && t.lineMetrics ? \"raster-particle\" === a && \"raster-array\" !== n && i.push(new T(r, o.source, `layer \"${o.id}\" requires a 'raster-array' source.`)) : i.push(new T(r, o, `layer \"${o.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : i.push(new T(r, o.source, \"raster-array source can only be used with layer type 'raster'.\")) : i.push(new T(r, o, `layer \"${o.id}\" must specify a \"source-layer\"`)) : i.push(new T(r, o.source, `source \"${o.source}\" not found`));\n      } else i.push(new T(r, o, 'missing required property \"source\"'));\n      return i = i.concat(S({\n        key: r,\n        value: o,\n        valueSpec: n.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          \"*\": () => [],\n          type: () => $({\n            key: `${r}.type`,\n            value: o.type,\n            valueSpec: n.layer.type,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            object: o,\n            objectKey: \"type\"\n          }),\n          filter: t => P(e.j({\n            layerType: a\n          }, t)),\n          layout: t => S({\n            layer: o,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => F(e.j({\n                layerType: a\n              }, t))\n            }\n          }),\n          paint: t => S({\n            layer: o,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => O(e.j({\n                layerType: a,\n                layer: o\n              }, t))\n            }\n          })\n        }\n      })), i;\n    }\n    function k(t) {\n      const i = t.value,\n        o = t.key,\n        r = e.i(i);\n      return \"string\" !== r ? [new T(o, i, `string expected, ${r} found`)] : [];\n    }\n    const N = {\n      promoteId: function ({\n        key: t,\n        value: i\n      }) {\n        if (\"string\" === e.i(i)) return k({\n          key: t,\n          value: i\n        });\n        {\n          const e = [];\n          for (const o in i) e.push(...k({\n            key: `${t}.${o}`,\n            value: i[o]\n          }));\n          return e;\n        }\n      }\n    };\n    function U(t) {\n      const i = t.value,\n        o = t.key,\n        r = t.styleSpec,\n        s = t.style;\n      if (!i.type) return [new T(o, i, '\"type\" is required')];\n      const n = e.u(i.type);\n      let a = [];\n      switch ([\"vector\", \"raster\", \"raster-dem\", \"raster-array\"].includes(n) && (i.url || i.tiles || a.push(new E(o, i, 'Either \"url\" or \"tiles\" is required.'))), n) {\n        case \"vector\":\n        case \"raster\":\n        case \"raster-dem\":\n        case \"raster-array\":\n          return a = a.concat(S({\n            key: o,\n            value: i,\n            valueSpec: r[`source_${n.replace(\"-\", \"_\")}`],\n            style: t.style,\n            styleSpec: r,\n            objectElementValidators: N\n          })), a;\n        case \"geojson\":\n          if (a = S({\n            key: o,\n            value: i,\n            valueSpec: r.source_geojson,\n            style: s,\n            styleSpec: r,\n            objectElementValidators: N\n          }), i.cluster) for (const e in i.clusterProperties) {\n            const [t, r] = i.clusterProperties[e],\n              s = \"string\" == typeof t ? [t, [\"accumulated\"], [\"get\", e]] : t;\n            a.push(...L({\n              key: `${o}.${e}.map`,\n              value: r,\n              expressionContext: \"cluster-map\"\n            })), a.push(...L({\n              key: `${o}.${e}.reduce`,\n              value: s,\n              expressionContext: \"cluster-reduce\"\n            }));\n          }\n          return a;\n        case \"video\":\n          return S({\n            key: o,\n            value: i,\n            valueSpec: r.source_video,\n            style: s,\n            styleSpec: r\n          });\n        case \"image\":\n          return S({\n            key: o,\n            value: i,\n            valueSpec: r.source_image,\n            style: s,\n            styleSpec: r\n          });\n        case \"canvas\":\n          return [new T(o, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n        default:\n          return R({\n            key: `${o}.type`,\n            value: i.type,\n            valueSpec: {\n              values: G(r)\n            },\n            style: s,\n            styleSpec: r\n          });\n      }\n    }\n    function G(e) {\n      return e.source.reduce((t, i) => {\n        const o = e[i];\n        return \"enum\" === o.type.type && (t = t.concat(Object.keys(o.type.values))), t;\n      }, []);\n    }\n    function j(t) {\n      const i = t.value;\n      let o = [];\n      if (!i) return o;\n      const r = e.i(i);\n      return \"string\" !== r ? (o = o.concat([new T(t.key, i, `string expected, \"${r}\" found`)]), o) : (function (e) {\n        const t = -1 === e.indexOf(\"://\");\n        try {\n          return new URL(e, t ? \"http://example.com\" : void 0), !0;\n        } catch (e) {\n          return !1;\n        }\n      }(i) || (o = o.concat([new T(t.key, i, `invalid url \"${i}\"`)])), o);\n    }\n    function V(t) {\n      const i = t.value,\n        o = t.styleSpec,\n        r = o.light,\n        s = t.style;\n      let n = [];\n      const a = e.i(i);\n      if (void 0 === i) return n;\n      if (\"object\" !== a) return n = n.concat([new T(\"light\", i, `object expected, ${a} found`)]), n;\n      for (const e in i) {\n        const t = e.match(/^(.*)-transition$/);\n        n = n.concat(t && r[t[1]] && r[t[1]].transition ? $({\n          key: e,\n          value: i[e],\n          valueSpec: o.transition,\n          style: s,\n          styleSpec: o\n        }) : r[e] ? $({\n          key: e,\n          value: i[e],\n          valueSpec: r[e],\n          style: s,\n          styleSpec: o\n        }) : [new T(e, i[e], `unknown property \"${e}\"`)]);\n      }\n      return n;\n    }\n    function Z(t) {\n      const i = t.value;\n      let o = [];\n      if (!i) return o;\n      const r = e.i(i);\n      if (\"object\" !== r) return o = o.concat([new T(\"light-3d\", i, `object expected, ${r} found`)]), o;\n      const s = t.styleSpec,\n        n = s[\"light-3d\"],\n        a = t.key,\n        l = t.style,\n        c = t.style.lights;\n      for (const e of [\"type\", \"id\"]) if (!(e in i)) return o = o.concat([new T(\"light-3d\", i, `missing property ${e} on light`)]), o;\n      if (i.type && c) for (let r = 0; r < t.arrayIndex; r++) {\n        const t = e.u(i.type),\n          s = c[r];\n        e.u(s.type) === t && o.push(new T(a, i.id, `duplicate light type \"${i.type}\", previously defined at line ${s.id.__line__}`));\n      }\n      const h = `properties_light_${i.type}`;\n      if (!(h in s)) return o = o.concat([new T(\"light-3d\", i, `Invalid light type ${i.type}`)]), o;\n      const u = s[h];\n      for (const r in i) if (\"properties\" === r) {\n        const n = i[r],\n          a = e.i(n);\n        if (\"object\" !== a) return o = o.concat([new T(\"properties\", n, `object expected, ${a} found`)]), o;\n        for (const e in n) o = o.concat(u[e] ? $({\n          key: e,\n          value: n[e],\n          valueSpec: u[e],\n          style: l,\n          styleSpec: s\n        }) : [new E(t.key, n[e], `unknown property \"${e}\"`)]);\n      } else {\n        const e = r.match(/^(.*)-transition$/);\n        o = o.concat(e && n[e[1]] && n[e[1]].transition ? $({\n          key: r,\n          value: i[r],\n          valueSpec: s.transition,\n          style: l,\n          styleSpec: s\n        }) : n[r] ? $({\n          key: r,\n          value: i[r],\n          valueSpec: n[r],\n          style: l,\n          styleSpec: s\n        }) : [new E(r, i[r], `unknown property \"${r}\"`)]);\n      }\n      return o;\n    }\n    function H(t) {\n      const i = t.value,\n        o = t.key,\n        r = t.style,\n        s = t.styleSpec,\n        n = s.terrain;\n      let a = [];\n      const l = e.i(i);\n      if (void 0 === i) return a;\n      if (\"null\" === l) return a;\n      if (\"object\" !== l) return a = a.concat([new T(\"terrain\", i, `object expected, ${l} found`)]), a;\n      for (const e in i) {\n        const t = e.match(/^(.*)-transition$/);\n        a = a.concat(t && n[t[1]] && n[t[1]].transition ? $({\n          key: e,\n          value: i[e],\n          valueSpec: s.transition,\n          style: r,\n          styleSpec: s\n        }) : n[e] ? $({\n          key: e,\n          value: i[e],\n          valueSpec: n[e],\n          style: r,\n          styleSpec: s\n        }) : [new E(e, i[e], `unknown property \"${e}\"`)]);\n      }\n      if (i.source) {\n        const t = r.sources && r.sources[i.source],\n          s = t && e.u(t.type);\n        t ? \"raster-dem\" !== s && a.push(new T(o, i.source, `terrain cannot be used with a source of type ${String(s)}, it only be used with a \"raster-dem\" source type`)) : a.push(new T(o, i.source, `source \"${i.source}\" not found`));\n      } else a.push(new T(o, i, 'terrain is missing required property \"source\"'));\n      return a;\n    }\n    function W(t) {\n      const i = t.value,\n        o = t.style,\n        r = t.styleSpec,\n        s = r.fog;\n      let n = [];\n      const a = e.i(i);\n      if (void 0 === i) return n;\n      if (\"object\" !== a) return n = n.concat([new T(\"fog\", i, `object expected, ${a} found`)]), n;\n      for (const e in i) {\n        const t = e.match(/^(.*)-transition$/);\n        n = n.concat(t && s[t[1]] && s[t[1]].transition ? $({\n          key: e,\n          value: i[e],\n          valueSpec: r.transition,\n          style: o,\n          styleSpec: r\n        }) : s[e] ? $({\n          key: e,\n          value: i[e],\n          valueSpec: s[e],\n          style: o,\n          styleSpec: r\n        }) : [new E(e, i[e], `unknown property \"${e}\"`)]);\n      }\n      return n;\n    }\n    const q = {\n      \"*\": () => [],\n      array: C,\n      boolean: function (t) {\n        const i = t.value,\n          o = t.key,\n          r = e.i(i);\n        return \"boolean\" !== r ? [new T(o, i, `boolean expected, ${r} found`)] : [];\n      },\n      number: I,\n      color: function (t) {\n        const i = t.key,\n          o = t.value,\n          r = e.i(o);\n        return \"string\" !== r ? [new T(i, o, `color expected, ${r} found`)] : null === e.y(o) ? [new T(i, o, `color expected, \"${o}\" found`)] : [];\n      },\n      enum: R,\n      filter: P,\n      function: D,\n      layer: B,\n      object: S,\n      source: U,\n      model: j,\n      light: V,\n      \"light-3d\": Z,\n      terrain: H,\n      fog: W,\n      string: k,\n      formatted: function (e) {\n        return 0 === k(e).length ? [] : L(e);\n      },\n      resolvedImage: function (e) {\n        return 0 === k(e).length ? [] : L(e);\n      },\n      projection: function (t) {\n        const i = t.value,\n          o = t.styleSpec,\n          r = o.projection,\n          s = t.style;\n        let n = [];\n        const a = e.i(i);\n        if (\"object\" === a) for (const e in i) n = n.concat($({\n          key: e,\n          value: i[e],\n          valueSpec: r[e],\n          style: s,\n          styleSpec: o\n        }));else \"string\" !== a && (n = n.concat([new T(\"projection\", i, `object or string expected, ${a} found`)]));\n        return n;\n      },\n      import: function (t) {\n        const {\n            value: i,\n            styleSpec: o\n          } = t,\n          {\n            data: r,\n            ...s\n          } = i;\n        Object.defineProperty(s, \"__line__\", {\n          value: i.__line__,\n          enumerable: !1\n        });\n        let n = S(e.j({}, t, {\n          value: s,\n          valueSpec: o.import\n        }));\n        return \"\" === e.u(s.id) && n.push(new T(`${t.key}.id`, s, \"import id can't be an empty string\")), r && (n = n.concat(K(r, o, {\n          key: `${t.key}.data`\n        }))), n;\n      }\n    };\n    function $(t, i = !1) {\n      const o = t.value,\n        r = t.valueSpec,\n        s = t.styleSpec;\n      if (r.expression && e.A(e.u(o))) return D(t);\n      if (r.expression && e.n(e.o(o))) return L(t);\n      if (r.type && q[r.type]) {\n        const o = q[r.type](t);\n        return !0 === i && o.length > 0 && \"array\" === e.i(t.value) ? L(t) : o;\n      }\n      return S(e.j({}, t, {\n        valueSpec: r.type ? s[r.type] : r\n      }));\n    }\n    function X(e) {\n      const t = e.value,\n        i = e.key,\n        o = k(e);\n      return o.length || (-1 === t.indexOf(\"{fontstack}\") && o.push(new T(i, t, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === t.indexOf(\"{range}\") && o.push(new T(i, t, '\"glyphs\" url must include a \"{range}\" token'))), o;\n    }\n    function K(t, i = e.D, o = {}) {\n      return $({\n        key: o.key || \"\",\n        value: t,\n        valueSpec: i.$root,\n        styleSpec: i,\n        style: t,\n        objectElementValidators: {\n          glyphs: X,\n          \"*\": () => []\n        }\n      });\n    }\n    function Y(t, i = e.D) {\n      return le(K(t, i));\n    }\n    const J = e => le(U(e)),\n      Q = e => le(V(e)),\n      ee = e => le(Z(e)),\n      te = e => le(H(e)),\n      ie = e => le(W(e)),\n      oe = e => le(B(e)),\n      re = e => le(P(e)),\n      se = e => le(O(e)),\n      ne = e => le(F(e)),\n      ae = e => le(j(e));\n    function le(e) {\n      return e.slice().sort((e, t) => e.line && t.line ? e.line - t.line : 0);\n    }\n    function ce(t, i) {\n      let o = !1;\n      if (i && i.length) for (const r of i) r instanceof E ? e.w(r.message) : (t.fire(new e.a(new Error(r.message))), o = !0);\n      return o;\n    }\n    const he = new e.F({\n      anchor: new e.G(e.D.light.anchor),\n      position: new e.H(e.D.light.position),\n      color: new e.G(e.D.light.color),\n      intensity: new e.G(e.D.light.intensity)\n    });\n    class ue extends e.E {\n      constructor(t, i = \"flat\") {\n        super(), this._transitionable = new e.J(he), this.setLight(t, i), this._transitioning = this._transitionable.untransitioned();\n      }\n      getLight() {\n        return this._transitionable.serialize();\n      }\n      setLight(e, t, i = {}) {\n        this._validate(Q, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t);\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && ce(this, t.call(Y, e.e({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.D\n        })));\n      }\n    }\n    const de = new e.F({\n      source: new e.G(e.D.terrain.source),\n      exaggeration: new e.G(e.D.terrain.exaggeration)\n    });\n    let _e = class extends e.E {\n      constructor(t, i, o, r) {\n        super(), this.scope = o, this._transitionable = new e.J(de, o, r), this._transitionable.setTransitionOrValue(t, r), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(e, t) {\n        this._transitionable.setTransitionOrValue(e, t);\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      getExaggeration(t) {\n        return this._transitioning.possiblyEvaluate(new e.K(t)).get(\"exaggeration\");\n      }\n      isZoomDependent() {\n        const t = this._transitionable._values.exaggeration;\n        return null != t && null != t.value && null != t.value.expression && t.value.expression instanceof e.Z;\n      }\n    };\n    const pe = 45,\n      fe = 65,\n      me = .05;\n    function ge(t, i, o, r) {\n      const s = e.O(pe, fe, o),\n        [n, a] = ve(t, r);\n      let l = 1 - Math.min(1, Math.exp((i - n) / (a - n) * -6));\n      return l *= l * l, l = Math.min(1, 1.00747 * l), l * s * t.alpha;\n    }\n    function ve(e, t) {\n      const i = .5 / Math.tan(.5 * t);\n      return [e.range[0] + i, e.range[1] + i];\n    }\n    function xe(t, i, o, r, s) {\n      const n = e.N.transformMat4([], [i, o, r], s.mercatorFogMatrix);\n      return ge(t, e.N.length(n), s.pitch, s._fov);\n    }\n    function ye(t, i, o, r, s, n, a) {\n      const l = [[o, r, 0], [s, r, 0], [s, n, 0], [o, n, 0]];\n      let c = Number.MAX_VALUE,\n        h = -Number.MAX_VALUE;\n      for (const t of l) {\n        const o = e.N.transformMat4([], t, i),\n          r = e.N.length(o);\n        c = Math.min(c, r), h = Math.max(h, r);\n      }\n      return [ge(t, c, a.pitch, a._fov), ge(t, h, a.pitch, a._fov)];\n    }\n    const be = new e.F({\n      range: new e.G(e.D.fog.range),\n      color: new e.G(e.D.fog.color),\n      \"high-color\": new e.G(e.D.fog[\"high-color\"]),\n      \"space-color\": new e.G(e.D.fog[\"space-color\"]),\n      \"horizon-blend\": new e.G(e.D.fog[\"horizon-blend\"]),\n      \"star-intensity\": new e.G(e.D.fog[\"star-intensity\"]),\n      \"vertical-range\": new e.G(e.D.fog[\"vertical-range\"])\n    });\n    class we extends e.E {\n      constructor(t, i, o, r) {\n        super(), this._transitionable = new e.J(be, o, new Map(r)), this.set(t, r), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.Q(be);\n      }\n      get state() {\n        const t = this._transform,\n          i = \"globe\" === t.projection.name,\n          o = e.S(t.zoom),\n          r = this.properties.get(\"range\"),\n          s = [.5, 3];\n        return {\n          range: i ? [e.U(s[0], r[0], o), e.U(s[1], r[1], o)] : r,\n          horizonBlend: this.properties.get(\"horizon-blend\"),\n          alpha: this.properties.get(\"color\").a\n        };\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(t, i, o = {}) {\n        if (this._validate(ie, t, o)) return;\n        const r = e.e({}, t);\n        for (const t of Object.keys(e.D.fog)) void 0 === r[t] && (r[t] = e.D.fog[t].default);\n        this._options = r, this._transitionable.setTransitionOrValue(this._options, i);\n      }\n      getOpacity(t) {\n        if (!this._transform.projection.supportsFog) return 0;\n        const i = this.properties && this.properties.get(\"color\") || 1;\n        return (\"globe\" === this._transform.projection.name ? 1 : e.O(pe, fe, t)) * i.a;\n      }\n      getOpacityAtLatLng(t, i) {\n        return this._transform.projection.supportsFog ? function (t, i, o) {\n          const r = e.L.fromLngLat(i),\n            s = o.elevation ? o.elevation.getAtPointOrZero(r) : 0;\n          return xe(t, r.x, r.y, s, o);\n        }(this.state, t, i) : 0;\n      }\n      getOpacityForTile(t) {\n        if (!this._transform.projection.supportsFog) return [1, 1];\n        const i = this._transform.calculateFogTileMatrix(t.toUnwrapped());\n        return ye(this.state, i, 0, 0, e.V, e.V, this._transform);\n      }\n      getOpacityForBounds(e, t, i, o, r) {\n        return this._transform.projection.supportsFog ? ye(this.state, e, t, i, o, r, this._transform) : [1, 1];\n      }\n      getFovAdjustedRange(e) {\n        return this._transform.projection.supportsFog ? ve(this.state, e) : [0, 1];\n      }\n      isVisibleOnFrustum(t) {\n        if (!this._transform.projection.supportsFog) return !1;\n        const i = [4, 5, 6, 7];\n        for (const o of i) {\n          const i = t.points[o];\n          let r;\n          if (i[2] >= 0) r = i;else {\n            const s = t.points[o - 4];\n            r = e.W(s, i, s[2] / (s[2] - i[2]));\n          }\n          if (xe(this.state, r[0], r[1], 0, this._transform) >= me) return !0;\n        }\n        return !1;\n      }\n      updateConfig(e) {\n        this._transitionable.setTransitionOrValue(this._options, new Map(e));\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && ce(this, t.call(Y, e.e({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.D\n        })));\n      }\n    }\n    class Te extends e.E {\n      constructor(t, i, o, r) {\n        super(), this.scope = o, this._options = t, this.properties = new e.Q(i), this._transitionable = new e.J(i, o, new Map(r)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();\n      }\n      updateConfig(e) {\n        this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      get() {\n        return this._options.properties = this._transitionable.serialize(), this._options;\n      }\n      set(e, t) {\n        this._options = e, this._transitionable.setTransitionOrValue(e.properties, t);\n      }\n      shadowsEnabled() {\n        return !!this.properties && !0 === this.properties.get(\"cast-shadows\");\n      }\n    }\n    const Ee = new e.F({\n        color: new e.G(e.D.properties_light_ambient.color),\n        intensity: new e.G(e.D.properties_light_ambient.intensity)\n      }),\n      Se = new e.F({\n        direction: new e.X(e.D.properties_light_directional.direction),\n        color: new e.G(e.D.properties_light_directional.color),\n        intensity: new e.G(e.D.properties_light_directional.intensity),\n        \"cast-shadows\": new e.G(e.D.properties_light_directional[\"cast-shadows\"]),\n        \"shadow-intensity\": new e.G(e.D.properties_light_directional[\"shadow-intensity\"])\n      });\n    class Ce {\n      constructor(e, t, i, o) {\n        this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);\n      }\n      static createFromScreenPoints(t, i) {\n        let o, r;\n        if (t instanceof e.P || \"number\" == typeof t[0]) {\n          const s = e.P.convert(t);\n          o = [s], r = i.isPointAboveHorizon(s);\n        } else {\n          const s = e.P.convert(t[0]),\n            n = e.P.convert(t[1]);\n          o = [s, n], r = e.Y(s, n).every(e => i.isPointAboveHorizon(e));\n        }\n        return new Ce(o, i.getCameraPoint(), r, i);\n      }\n      isPointQuery() {\n        return 1 === this.screenBounds.length;\n      }\n      bufferedScreenGeometry(t) {\n        return e.Y(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);\n      }\n      bufferedCameraGeometry(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1],\n          r = e.Y(i, o, 0, !1);\n        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e._(r, t);\n      }\n      bufferedCameraGeometryGlobe(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1],\n          r = e.Y(i, o, t),\n          s = this.cameraPoint.clone();\n        switch (3 * ((s.y > i.y) + (s.y > o.y)) + ((s.x > i.x) + (s.x > o.x))) {\n          case 0:\n            r[0] = s, r[4] = s.clone();\n            break;\n          case 1:\n            r.splice(1, 0, s);\n            break;\n          case 2:\n            r[1] = s;\n            break;\n          case 3:\n            r.splice(4, 0, s);\n            break;\n          case 5:\n            r.splice(2, 0, s);\n            break;\n          case 6:\n            r[3] = s;\n            break;\n          case 7:\n            r.splice(3, 0, s);\n            break;\n          case 8:\n            r[2] = s;\n        }\n        return r;\n      }\n      containsTile(t, i, o, r = 0) {\n        const s = t.queryPadding / i._pixelsPerMercatorPixel + 1,\n          n = o ? this._bufferedCameraMercator(s, i) : this._bufferedScreenMercator(s, i);\n        let a = t.tileID.wrap + (n.unwrapped ? r : 0);\n        const l = n.polygon.map(i => e.$(t.tileTransform, i, a));\n        if (!e.a0(l, 0, 0, e.V, e.V)) return;\n        a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);\n        const c = this.screenGeometryMercator.polygon.map(i => e.a1(t.tileTransform, i, a)),\n          h = c.map(t => new e.P(t[0], t[1])),\n          u = i.getFreeCameraOptions().position || new e.L(0, 0, 0),\n          d = e.a1(t.tileTransform, u, a),\n          _ = c.map(t => {\n            const i = e.N.sub(t, t, d);\n            return e.N.normalize(i, i), new e.a2(d, i);\n          }),\n          p = e.a3(t, 1, i.zoom) * i._pixelsPerMercatorPixel;\n        return {\n          queryGeometry: this,\n          tilespaceGeometry: h,\n          tilespaceRays: _,\n          bufferedTilespaceGeometry: l,\n          bufferedTilespaceBounds: (f = e.a4(l), f.min.x = e.aa(f.min.x, 0, e.V), f.min.y = e.aa(f.min.y, 0, e.V), f.max.x = e.aa(f.max.x, 0, e.V), f.max.y = e.aa(f.max.y, 0, e.V), f),\n          tile: t,\n          tileID: t.tileID,\n          pixelToTileUnitsFactor: p\n        };\n        var f;\n      }\n      _bufferedScreenMercator(e, t) {\n        const i = Le(e);\n        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : {\n            polygon: this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._screenRaycastCache[i] = o, o;\n        }\n      }\n      _bufferedCameraMercator(e, t) {\n        const i = Le(e);\n        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : {\n            polygon: this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._cameraRaycastCache[i] = o, o;\n        }\n      }\n      _projectAndResample(t, i) {\n        const o = function (t, i) {\n          const o = e.a6.multiply([], i.pixelMatrix, i.globeMatrix),\n            r = [0, -e.ab, 0, 1],\n            s = [0, e.ab, 0, 1],\n            n = [0, 0, 0, 1];\n          e.a7.transformMat4(r, r, o), e.a7.transformMat4(s, s, o), e.a7.transformMat4(n, n, o);\n          const a = new e.P(r[0] / r[3], r[1] / r[3]),\n            l = new e.P(s[0] / s[3], s[1] / s[3]),\n            c = e.a8(t, a) && r[3] < n[3],\n            h = e.a8(t, l) && s[3] < n[3];\n          if (!c && !h) return null;\n          const u = function (e, t, i) {\n            for (let o = 1; o < e.length; o++) {\n              const r = De(t.pointCoordinate3D(e[o - 1]).x),\n                s = De(t.pointCoordinate3D(e[o]).x);\n              if (i < 0) {\n                if (r < s) return {\n                  idx: o,\n                  t: -r / (s - 1 - r)\n                };\n              } else if (s < r) return {\n                idx: o,\n                t: (1 - r) / (s + 1 - r)\n              };\n            }\n            return null;\n          }(t, i, c ? -1 : 1);\n          if (!u) return null;\n          const {\n            idx: d,\n            t: _\n          } = u;\n          let p = d > 1 ? Ie(t.slice(0, d), i) : [],\n            f = d < t.length ? Ie(t.slice(d), i) : [];\n          p = p.map(t => new e.P(De(t.x), t.y)), f = f.map(t => new e.P(De(t.x), t.y));\n          const m = [...p];\n          0 === m.length && m.push(f[f.length - 1]);\n          const g = e.U(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, _);\n          let v;\n          return v = c ? [new e.P(0, g), new e.P(0, 0), new e.P(1, 0), new e.P(1, g)] : [new e.P(1, g), new e.P(1, 1), new e.P(0, 1), new e.P(0, g)], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {\n            polygon: m.map(t => new e.L(t.x, t.y)),\n            unwrapped: !1\n          };\n        }(t, i);\n        if (o) return o;\n        const r = function (t, i) {\n          let o = !1,\n            r = -1 / 0,\n            s = 0;\n          for (let e = 0; e < t.length - 1; e++) t[e].x > r && (r = t[e].x, s = e);\n          for (let e = 0; e < t.length - 1; e++) {\n            const i = (s + e) % (t.length - 1),\n              r = t[i],\n              n = t[i + 1];\n            Math.abs(r.x - n.x) > .5 && (r.x < n.x ? (r.x += 1, 0 === i && (t[t.length - 1].x += 1)) : (n.x += 1, i + 1 === t.length - 1 && (t[0].x += 1)), o = !0);\n          }\n          const n = e.a5(i.center.lng);\n          return o && n < Math.abs(n - 1) && t.forEach(e => {\n            e.x -= 1;\n          }), {\n            polygon: t,\n            unwrapped: o\n          };\n        }(Ie(t, i).map(t => new e.P(De(t.x), t.y)), i);\n        return {\n          polygon: r.polygon.map(t => new e.L(t.x, t.y)),\n          unwrapped: r.unwrapped\n        };\n      }\n    }\n    function Ie(t, i) {\n      return e.a9(t, e => {\n        const t = i.pointCoordinate3D(e);\n        e.x = t.x, e.y = t.y;\n      }, 1 / 256);\n    }\n    function De(e) {\n      return e < 0 ? 1 + e % 1 : e % 1;\n    }\n    function Le(e) {\n      return 100 * e | 0;\n    }\n    function Ae(t, i, o, r, s) {\n      const n = function (o, r) {\n        if (o) return s(o);\n        if (r) {\n          t.url && r.tiles && t.tiles && delete t.tiles;\n          const o = e.ac(e.e(r, t), [\"tiles\", \"minzoom\", \"maxzoom\", \"attribution\", \"mapbox_logo\", \"bounds\", \"scheme\", \"tileSize\", \"encoding\"]);\n          r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map(e => e.id)), r.raster_layers && (o.rasterLayers = r.raster_layers, o.rasterLayerIds = o.rasterLayers.map(e => e.id)), o.tiles = i.canonicalizeTileset(o, t.url), s(null, o);\n        }\n      };\n      return t.url ? e.g(i.transformRequest(i.normalizeSourceURL(t.url, null, o, r), e.R.Source), n) : e.f.frame(() => n(null, t));\n    }\n    class Re {\n      constructor(t, i, o) {\n        this.bounds = e.ad.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;\n      }\n      validateBounds(e) {\n        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];\n      }\n      contains(t) {\n        const i = Math.pow(2, t.z),\n          o = Math.floor(e.a5(this.bounds.getWest()) * i),\n          r = Math.floor(e.ae(this.bounds.getNorth()) * i),\n          s = Math.ceil(e.a5(this.bounds.getEast()) * i),\n          n = Math.ceil(e.ae(this.bounds.getSouth()) * i);\n        return t.x >= o && t.x < s && t.y >= r && t.y < n;\n      }\n    }\n    class Pe extends e.E {\n      constructor(t, i, o, r) {\n        if (super(), this.id = t, this.dispatcher = o, this.type = \"vector\", this.minzoom = 0, this.maxzoom = 22, this.scheme = \"xyz\", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.e(this, e.ac(i, [\"url\", \"scheme\", \"tileSize\", \"promoteId\"])), this._options = e.e({\n          type: \"vector\"\n        }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error(\"vector tile sources must have a tileSize of 512\");\n        this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.af();\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.b(\"dataloading\", {\n          dataType: \"source\"\n        }));\n        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n          o = this.map._worldview;\n        this._tileJSONRequest = Ae(this._options, this.map._requestManager, i, o, (r, s) => {\n          this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.a(r))) : s && (e.e(this, s), s.bounds && (this.tileBounds = new Re(s.bounds, this.minzoom, this.maxzoom)), e.aj(s.tiles, this.map._requestManager._customAccessToken), this.fire(new e.b(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.b(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }))), t && t(r);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest();\n        const t = e.ag(this.id, this.scope);\n        this.load(() => this.map.style.clearSource(t));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove() {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return e.e({}, this._options);\n      }\n      loadTile(t, i) {\n        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),\n          r = {\n            request: this.map._requestManager.transformRequest(o, e.R.Tile),\n            data: void 0,\n            uid: t.uid,\n            tileID: t.tileID,\n            tileZoom: t.tileZoom,\n            zoom: t.tileID.overscaledZ,\n            tileSize: this.tileSize * t.tileID.overscaleFactor(),\n            type: this.type,\n            source: this.id,\n            scope: this.scope,\n            pixelRatio: e.f.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId,\n            isSymbolTile: t.isSymbolTile,\n            brightness: this.map.style && this.map.style.getBrightness() || 0,\n            extraShadowCaster: t.isExtraShadowCaster\n          };\n        if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && \"expired\" !== t.state) \"loading\" === t.state ? t.reloadCallback = i : t.request = t.actor.send(\"reloadTile\", r, s.bind(this));else if (t.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send(\"loadTile\", r, s.bind(this), void 0, !0);else {\n          const i = e.ah.call({\n            deduped: this._deduped\n          }, r, (e, i) => {\n            e || !i ? s.call(this, e) : (r.data = {\n              cacheControl: i.cacheControl,\n              expires: i.expires,\n              rawData: i.rawData.slice(0)\n            }, t.actor && t.actor.send(\"loadTile\", r, s.bind(this), void 0, !0));\n          }, !0);\n          t.request = {\n            cancel: i\n          };\n        }\n        function s(o, r) {\n          return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.ai(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));\n        }\n      }\n      abortTile(e) {\n        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        });\n      }\n      unloadTile(e) {\n        e.actor && e.actor.send(\"removeTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        }), e.destroy();\n      }\n      hasTransition() {\n        return !1;\n      }\n      afterUpdate() {\n        this._tileWorkers = {};\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    class Me extends e.E {\n      constructor(t, i, o, r) {\n        super(), this.id = t, this.dispatcher = o, this.setEventedParent(r), this.type = \"raster\", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = \"xyz\", this.tileSize = 512, this._loaded = !1, this._options = e.e({\n          type: \"raster\"\n        }, i), e.e(this, e.ac(i, [\"url\", \"scheme\", \"tileSize\"]));\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.b(\"dataloading\", {\n          dataType: \"source\"\n        })), this._tileJSONRequest = Ae(this._options, this.map._requestManager, null, null, (i, o) => {\n          this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.a(i)) : o && (e.e(this, o), o.bounds && (this.tileBounds = new Re(o.bounds, this.minzoom, this.maxzoom)), e.aj(o.tiles), this.fire(new e.b(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.b(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }))), t && t(i);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest();\n        const t = e.ag(this.id, this.scope);\n        this.load(() => this.map.style.clearSource(t));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove() {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return e.e({}, this._options);\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      loadTile(t, i) {\n        const o = e.f.devicePixelRatio >= 2,\n          r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);\n        t.request = e.d(this.map._requestManager.transformRequest(r, e.R.Tile), (o, r, s, n) => (delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : o ? (t.state = \"errored\", i(o)) : r ? (this.map._refreshExpiredTiles && t.setExpiryData({\n          cacheControl: s,\n          expires: n\n        }), t.setTexture(r, this.map.painter), t.state = \"loaded\", e.ai(this.dispatcher), void i(null)) : i(null)));\n      }\n      abortTile(e, t) {\n        e.request && (e.request.cancel(), delete e.request), t();\n      }\n      unloadTile(t, i) {\n        t.texture && t.texture instanceof e.T ? (t.destroy(!0), t.texture && t.texture instanceof e.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), i();\n      }\n      hasTransition() {\n        return !1;\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    class ze extends Me {\n      constructor(t, i, o, r) {\n        super(t, i, o, r), this.type = \"raster-array\", this.maxzoom = 22, this._options = e.e({\n          type: \"raster-array\"\n        }, i);\n      }\n      triggerRepaint(e) {\n        const t = this.map.painter._terrain,\n          i = this.map.style.getSourceCache(this.id);\n        t && t.enabled && i && t._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();\n      }\n      loadTile(t, i) {\n        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize),\n          r = this.map._requestManager.transformRequest(o, e.R.Tile);\n        t.requestParams = r, t.actor || (t.actor = this.dispatcher.getActor()), t.request = t.fetchHeader(void 0, (e, o, r, s) => {\n          if (delete t.request, t.aborted) return t.state = \"unloaded\", i(null);\n          if (e) {\n            if (20 === e.code) return;\n            return t.state = \"errored\", i(e);\n          }\n          this.map._refreshExpiredTiles && t.setExpiryData({\n            cacheControl: r,\n            expires: s\n          }), t.state = \"empty\", i(null);\n        });\n      }\n      unloadTile(t) {\n        const i = t.texture;\n        i && i instanceof e.T ? (t.destroy(!0), this.map.painter.saveTileTexture(i)) : (t.destroy(), t.flushQueues(), t._isHeaderLoaded = !1, delete t._mrt, delete t.textureDescriptor), t.fbo && (t.fbo.destroy(), delete t.fbo), delete t.request, delete t.requestParams, delete t.neighboringTiles, t.state = \"unloaded\";\n      }\n      prepareTile(t, i, o) {\n        t._isHeaderLoaded && (\"empty\" !== t.state && (t.state = \"reloading\"), t.fetchBand(i, o, (i, o) => {\n          if (i) return t.state = \"errored\", this.fire(new e.a(i)), void this.triggerRepaint(t);\n          o && (t.setTexture(o, this.map.painter), t.state = \"loaded\", this.triggerRepaint(t));\n        }));\n      }\n      getInitialBand(e) {\n        if (!this.rasterLayers) return 0;\n        const t = this.rasterLayers.find(({\n            id: t\n          }) => t === e),\n          i = t && t.fields,\n          o = i && i.bands && i.bands;\n        return o ? o[0] : 0;\n      }\n      getTextureDescriptor(t, i, o) {\n        if (!t) return;\n        const r = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];\n        if (!r) return;\n        let s = null;\n        i instanceof e.an ? s = i.paint.get(\"raster-array-band\") : i instanceof e.ao && (s = i.paint.get(\"raster-particle-array-band\"));\n        const n = s || this.getInitialBand(r);\n        if (null != n) if (t.textureDescriptor) {\n          if (!t.updateNeeded(r, n) || o) return Object.assign({}, t.textureDescriptor, {\n            texture: t.texture\n          });\n        } else this.prepareTile(t, r, n);\n      }\n    }\n    const Oe = 32,\n      Fe = 33,\n      Be = new Uint16Array(8184);\n    for (let e = 0; e < 2046; e++) {\n      let t = e + 2,\n        i = 0,\n        o = 0,\n        r = 0,\n        s = 0,\n        n = 0,\n        a = 0;\n      for (1 & t ? r = s = n = Oe : i = o = a = Oe; (t >>= 1) > 1;) {\n        const e = i + r >> 1,\n          l = o + s >> 1;\n        1 & t ? (r = i, s = o, i = n, o = a) : (i = r, o = s, r = n, s = a), n = e, a = l;\n      }\n      const l = 4 * e;\n      Be[l + 0] = i, Be[l + 1] = o, Be[l + 2] = r, Be[l + 3] = s;\n    }\n    const ke = new Uint16Array(2178),\n      Ne = new Uint8Array(1089),\n      Ue = new Uint16Array(1089);\n    function Ge(e) {\n      return 0 === e ? -.03125 : 32 === e ? .03125 : 0;\n    }\n    class je {\n      constructor(e, t, i, o) {\n        this.id = je.uniqueIdxCounter, je.uniqueIdxCounter++, this.context = e;\n        const r = e.gl;\n        this.buffer = r.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || o || t.destroy();\n      }\n      bind() {\n        this.context.bindElementBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        this.id = je.uniqueIdxCounter, je.uniqueIdxCounter++;\n        const t = this.context.gl;\n        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    je.uniqueIdxCounter = 0;\n    const Ve = {\n      Int8: \"BYTE\",\n      Uint8: \"UNSIGNED_BYTE\",\n      Int16: \"SHORT\",\n      Uint16: \"UNSIGNED_SHORT\",\n      Int32: \"INT\",\n      Uint32: \"UNSIGNED_INT\",\n      Float32: \"FLOAT\"\n    };\n    class Ze {\n      constructor(e, t, i, o, r, s) {\n        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.instanceCount = s, this.context = e;\n        const n = e.gl;\n        this.buffer = n.createBuffer(), e.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || r || t.destroy();\n      }\n      bind() {\n        this.context.bindVertexBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        const t = this.context.gl;\n        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      enableAttributes(e, t) {\n        for (let i = 0; i < this.attributes.length; i++) {\n          const o = t.attributes[this.attributes[i].name];\n          void 0 !== o && e.enableVertexAttribArray(o);\n        }\n      }\n      setVertexAttribPointers(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const r = this.attributes[o],\n            s = t.attributes[r.name];\n          void 0 !== s && e.vertexAttribPointer(s, r.components, e[Ve[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));\n        }\n      }\n      setVertexAttribDivisor(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const r = t.attributes[this.attributes[o].name];\n          void 0 !== r && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(r, i);\n        }\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    class He {\n      constructor(e) {\n        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n      }\n      get() {\n        return this.current;\n      }\n      set(e) {}\n      getDefault() {\n        return this.default;\n      }\n      setDefault() {\n        this.set(this.default);\n      }\n    }\n    class We extends He {\n      getDefault() {\n        return e.ax.transparent;\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class qe extends He {\n      getDefault() {\n        return 1;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class $e extends He {\n      getDefault() {\n        return 0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Xe extends He {\n      getDefault() {\n        return [!0, !0, !0, !0];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class Ke extends He {\n      getDefault() {\n        return !0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Ye extends He {\n      getDefault() {\n        return 255;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Je extends He {\n      getDefault() {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }\n      set(e) {\n        const t = this.current;\n        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);\n      }\n    }\n    class Qe extends He {\n      getDefault() {\n        const e = this.gl;\n        return [e.KEEP, e.KEEP, e.KEEP];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);\n      }\n    }\n    class et extends He {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class tt extends He {\n      getDefault() {\n        return [0, 1];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n    }\n    class it extends He {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class ot extends He {\n      getDefault() {\n        return this.gl.LESS;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class rt extends He {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;\n      }\n    }\n    class st extends He {\n      getDefault() {\n        const e = this.gl;\n        return [e.ONE, e.ZERO, e.ONE, e.ZERO];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class nt extends He {\n      getDefault() {\n        return e.ax.transparent;\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class at extends He {\n      getDefault() {\n        return this.gl.FUNC_ADD;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);\n      }\n    }\n    class lt extends He {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;\n      }\n    }\n    class ct extends He {\n      getDefault() {\n        return this.gl.BACK;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ht extends He {\n      getDefault() {\n        return this.gl.CCW;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    let ut = class extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);\n      }\n    };\n    class dt extends He {\n      getDefault() {\n        return this.gl.TEXTURE0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class _t extends He {\n      getDefault() {\n        const e = this.gl;\n        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class pt extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ft extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class mt extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class gt extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class vt extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        const t = this.gl;\n        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class xt extends He {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class yt extends He {\n      getDefault() {\n        return 4;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class bt extends He {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class wt extends He {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Tt extends He {\n      constructor(e, t) {\n        super(e), this.context = e, this.parent = t;\n      }\n      getDefault() {\n        return null;\n      }\n    }\n    class Et extends Tt {\n      setDirty() {\n        this.dirty = !0;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class St extends Tt {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ct extends Tt {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, this.attachment(), t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class It extends St {\n      attachment() {\n        return this.gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    class Dt {\n      constructor(e, t, i, o, r) {\n        this.context = e, this.width = t, this.height = i;\n        const s = this.framebuffer = e.gl.createFramebuffer();\n        o && (this.colorAttachment = new Et(e, s)), r && (this.depthAttachmentType = r, this.depthAttachment = \"renderbuffer\" === r ? new St(e, s) : new Ct(e, s));\n      }\n      destroy() {\n        const e = this.context.gl;\n        if (this.colorAttachment) {\n          const t = this.colorAttachment.get();\n          t && e.deleteTexture(t);\n        }\n        if (this.depthAttachment && this.depthAttachmentType) if (\"renderbuffer\" === this.depthAttachmentType) {\n          const t = this.depthAttachment.get();\n          t && e.deleteRenderbuffer(t);\n        } else {\n          const t = this.depthAttachment.get();\n          t && e.deleteTexture(t);\n        }\n        e.deleteFramebuffer(this.framebuffer);\n      }\n    }\n    class Lt {\n      constructor(e, t, i) {\n        this.func = e, this.mask = t, this.range = i;\n      }\n    }\n    Lt.ReadOnly = !1, Lt.ReadWrite = !0, Lt.disabled = new Lt(519, Lt.ReadOnly, [0, 1]);\n    const At = 7680;\n    class Rt {\n      constructor(e, t, i, o, r, s) {\n        this.test = e, this.ref = t, this.mask = i, this.fail = o, this.depthFail = r, this.pass = s;\n      }\n    }\n    Rt.disabled = new Rt({\n      func: 519,\n      mask: 0\n    }, 0, 0, At, At, At);\n    const Pt = 771;\n    class Mt {\n      constructor(e, t, i, o) {\n        this.blendFunction = e, this.blendColor = t, this.mask = i, this.blendEquation = o;\n      }\n    }\n    Mt.Replace = [1, 0, 1, 0], Mt.disabled = new Mt(Mt.Replace, e.ax.transparent, [!1, !1, !1, !1]), Mt.unblended = new Mt(Mt.Replace, e.ax.transparent, [!0, !0, !0, !0]), Mt.alphaBlended = new Mt([1, Pt, 1, Pt], e.ax.transparent, [!0, !0, !0, !0]), Mt.multiply = new Mt([774, 0, 774, 0], e.ax.transparent, [!0, !0, !0, !0]);\n    const zt = 1029,\n      Ot = 2305;\n    class Ft {\n      constructor(e, t, i) {\n        this.enable = e, this.mode = t, this.frontFace = i;\n      }\n    }\n    Ft.disabled = new Ft(!1, zt, Ot), Ft.backCCW = new Ft(!0, zt, Ot), Ft.backCW = new Ft(!0, zt, 2304), Ft.frontCW = new Ft(!0, 1028, 2304), Ft.frontCCW = new Ft(!0, 1028, Ot);\n    class Bt {\n      constructor(e, t) {\n        this.gl = e, this.clearColor = new We(this), this.clearDepth = new qe(this), this.clearStencil = new $e(this), this.colorMask = new Xe(this), this.depthMask = new Ke(this), this.stencilMask = new Ye(this), this.stencilFunc = new Je(this), this.stencilOp = new Qe(this), this.stencilTest = new et(this), this.depthRange = new tt(this), this.depthTest = new it(this), this.depthFunc = new ot(this), this.blend = new rt(this), this.blendFunc = new st(this), this.blendColor = new nt(this), this.blendEquation = new at(this), this.cullFace = new lt(this), this.cullFaceSide = new ct(this), this.frontFace = new ht(this), this.program = new ut(this), this.activeTexture = new dt(this), this.viewport = new _t(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new ft(this), this.bindTexture = new mt(this), this.bindVertexBuffer = new gt(this), this.bindElementBuffer = new vt(this), this.bindVertexArrayOES = new xt(this), this.pixelStoreUnpack = new yt(this), this.pixelStoreUnpackPremultiplyAlpha = new bt(this), this.pixelStoreUnpackFlipY = new wt(this), this.options = t ? {\n          ...t\n        } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension(\"EXT_texture_filter_anisotropic\") || e.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || e.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension(\"WEBGL_debug_renderer_info\"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension(\"OES_texture_float_linear\")), this.extRenderToTextureHalfFloat = e.getExtension(\"EXT_color_buffer_half_float\"), this.extTimerQuery = e.getExtension(\"EXT_disjoint_timer_query_webgl2\"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxPointSize = e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];\n      }\n      setDefault() {\n        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n      }\n      setDirty() {\n        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n      }\n      createIndexBuffer(e, t, i) {\n        return new je(this, e, t, i);\n      }\n      createVertexBuffer(e, t, i, o, r) {\n        return new Ze(this, e, t, i, o, r);\n      }\n      createRenderbuffer(e, t, i) {\n        const o = this.gl,\n          r = o.createRenderbuffer();\n        return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r;\n      }\n      createFramebuffer(e, t, i, o) {\n        return new Dt(this, e, t, i, o);\n      }\n      clear({\n        color: e,\n        depth: t,\n        stencil: i,\n        colorMask: o\n      }) {\n        const r = this.gl;\n        let s = 0;\n        e && (s |= r.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set(o || [!0, !0, !0, !0])), void 0 !== t && (s |= r.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (s |= r.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), r.clear(s);\n      }\n      setCullFace(e) {\n        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));\n      }\n      setDepthMode(e) {\n        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);\n      }\n      setStencilMode(e) {\n        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({\n          func: e.test.func,\n          ref: e.ref,\n          mask: e.test.mask\n        })) : this.stencilTest.set(!1);\n      }\n      setColorMode(e) {\n        t(e.blendFunction, Mt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor), e.blendEquation ? this.blendEquation.set(e.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(e.mask);\n      }\n      unbindVAO() {\n        this.bindVertexArrayOES.set(null);\n      }\n    }\n    var kt = e.ay([{\n      name: \"a_pos\",\n      type: \"Float32\",\n      components: 3\n    }]);\n    class Nt {\n      constructor(t, i, o, r) {\n        const s = {\n            width: o[0],\n            height: o[1],\n            data: null\n          },\n          n = t.gl;\n        this.targetColorTexture = new e.T(t, s, n.RGBA, {\n          useMipmap: !1\n        }), this.backgroundColorTexture = new e.T(t, s, n.RGBA, {\n          useMipmap: !1\n        }), this.context = t, this.setNumParticles(i, r), this.lastInvalidatedAt = 0;\n      }\n      setNumParticles(t, i) {\n        if (this.numParticles === i) return;\n        (this.particleVertices0 || this.particleVertices1 || this.particleSegment) && (this.particleVertices0.destroy(), this.particleVertices1.destroy(), this.particleSegment.destroy());\n        const o = new e.az();\n        o.reserve(Math.round(i));\n        const r = e.aA(t.key);\n        for (let e = 0; e < i; e++) o.emplaceBack(r(), r(), r());\n        this.particleVertices0 = this.context.createVertexBuffer(o, kt.members, !0), this.particleVertices1 = this.context.createVertexBuffer(o, kt.members, !0), this.particleSegment = e.aB.simpleSegment(0, 0, this.particleVertices0.length, 0), this.numParticles = i;\n      }\n      update(t) {\n        return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = e.f.now(), 1));\n      }\n      destroy() {\n        this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleVertices0.destroy(), this.particleVertices1.destroy(), this.particleSegment.destroy();\n      }\n    }\n    const Ut = {\n      type: 2,\n      extent: e.V,\n      loadGeometry: () => [[new e.P(0, 0), new e.P(e.V + 1, 0), new e.P(e.V + 1, e.V + 1), new e.P(0, e.V + 1), new e.P(0, 0)]]\n    };\n    class Gt {\n      constructor(t, i, o, r, s) {\n        this.tileID = t, this.uid = e.aC(), this.uses = 0, this.tileSize = i, this.tileZoom = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = s, r && r.style && (this._lastUpdatedBrightness = r.style.getBrightness()), this.expiredRequestCount = 0, this.state = \"loading\", r && r.transform && (this.projection = r.transform.projection);\n      }\n      registerFadeDuration(t) {\n        const i = t + this.timeAdded;\n        i < e.f.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);\n      }\n      wasRequested() {\n        return \"errored\" === this.state || \"loaded\" === this.state || \"reloading\" === this.state;\n      }\n      get tileTransform() {\n        return this._tileTransform || (this._tileTransform = e.as(this.tileID.canonical, this.projection)), this._tileTransform;\n      }\n      loadVectorData(t, i, o) {\n        if (this.unloadVectorData(), this.state = \"loaded\", t) {\n          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (e, t) {\n            const i = {};\n            if (!t) return i;\n            for (const o of e) {\n              const e = o.layerIds.map(e => t.getLayer(e)).filter(Boolean);\n              if (0 !== e.length) {\n                o.layers = e, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map(t => e.filter(e => e.id === t)[0]));\n                for (const t of e) i[t.fqid] = o;\n              }\n            }\n            return i;\n          }(t.buckets, i.style), this.hasSymbolBuckets = !1;\n          for (const t in this.buckets) {\n            const i = this.buckets[t];\n            if (i instanceof e.aE) {\n              if (this.hasSymbolBuckets = !0, !o) break;\n              i.justReloaded = !0;\n            }\n          }\n          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {\n            const i = this.buckets[t];\n            if (i instanceof e.aE && i.hasRTLText) {\n              this.hasRTLText = !0, e.aF();\n              break;\n            }\n          }\n          this.queryPadding = 0;\n          for (const e in this.buckets) {\n            const t = this.buckets[e],\n              o = i.style.getOwnLayer(e);\n            if (!o) continue;\n            const r = o.queryRadius(t);\n            this.queryPadding = Math.max(this.queryPadding, r);\n          }\n          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;\n        } else this.collisionBoxArray = new e.aD();\n      }\n      unloadVectorData() {\n        if (this.hasData()) {\n          for (const e in this.buckets) this.buckets[e].destroy();\n          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = \"unloaded\";\n        }\n      }\n      getBucket(e) {\n        return this.buckets[e.fqid];\n      }\n      upload(t) {\n        for (const e in this.buckets) {\n          const i = this.buckets[e];\n          i.uploadPending() && i.upload(t);\n        }\n        const i = t.gl,\n          o = this.imageAtlas;\n        if (o && !o.uploaded) {\n          const r = !!Object.keys(o.patternPositions).length;\n          this.imageAtlasTexture = new e.T(t, o.image, i.RGBA, {\n            useMipmap: r\n          }), this.imageAtlas.uploaded = !0;\n        }\n        this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t, this.glyphAtlasImage, i.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t, this.lineAtlas.image, i.R8), this.lineAtlas.uploaded = !0);\n      }\n      prepare(e, t, i) {\n        if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture, i), !t || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;\n        const o = t.style.getBrightness();\n        (this._lastUpdatedBrightness || o) && (this._lastUpdatedBrightness && o && Math.abs(this._lastUpdatedBrightness - o) < .001 || (this._lastUpdatedBrightness = o, this.updateBuckets(void 0, t)));\n      }\n      queryRenderedFeatures(e, t, i, o, r, s, n, a) {\n        return this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) ? this.latestFeatureIndex.query({\n          tileResult: o,\n          pixelPosMatrix: n,\n          transform: s,\n          params: r,\n          tileTransform: this.tileTransform\n        }, e, t, i) : {};\n      }\n      querySourceFeatures(t, i) {\n        const o = this.latestFeatureIndex;\n        if (!o || !o.rawTileData) return;\n        const r = o.loadVTLayers(),\n          s = i ? i.sourceLayer : \"\",\n          n = r._geojsonTileLayer || r[s];\n        if (!n) return;\n        const a = e.aG(i && i.filter),\n          {\n            z: l,\n            x: c,\n            y: h\n          } = this.tileID.canonical,\n          u = {\n            z: l,\n            x: c,\n            y: h\n          };\n        for (let i = 0; i < n.length; i++) {\n          const r = n.feature(i);\n          if (a.needGeometry) {\n            const t = e.aH(r, !0);\n            if (!a.filter(new e.K(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;\n          } else if (!a.filter(new e.K(this.tileID.overscaledZ), r)) continue;\n          const d = o.getId(r, s),\n            _ = new e.aI(r, l, c, h, d);\n          _.tile = u, t.push(_);\n        }\n      }\n      hasData() {\n        return \"loaded\" === this.state || \"reloading\" === this.state || \"expired\" === this.state;\n      }\n      bucketsLoaded() {\n        for (const e in this.buckets) if (this.buckets[e].uploadPending()) return !1;\n        return !0;\n      }\n      patternsLoaded() {\n        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n      }\n      setExpiryData(t) {\n        const i = this.expirationTime;\n        if (t.cacheControl) {\n          const i = e.aJ(t.cacheControl);\n          i[\"max-age\"] && (this.expirationTime = Date.now() + 1e3 * i[\"max-age\"]);\n        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n        if (this.expirationTime) {\n          const e = Date.now();\n          let t = !1;\n          if (this.expirationTime > e) t = !1;else if (i) {\n            if (this.expirationTime < i) t = !0;else {\n              const o = this.expirationTime - i;\n              o ? this.expirationTime = e + Math.max(o, 3e4) : t = !0;\n            }\n          } else t = !0;\n          t ? (this.expiredRequestCount++, this.state = \"expired\") : this.expiredRequestCount = 0;\n        }\n      }\n      getExpiryTimeout() {\n        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n      }\n      setFeatureState(e, t) {\n        this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(e).length && t && this.updateBuckets(e, t);\n      }\n      updateBuckets(t, i) {\n        if (!this.latestFeatureIndex) return;\n        const o = this.latestFeatureIndex.loadVTLayers(),\n          r = i.style.listImages(),\n          s = i.style.getBrightness();\n        for (const n in this.buckets) {\n          if (!i.style.hasLayer(n)) continue;\n          const a = this.buckets[n],\n            l = a.layers[0].sourceLayer || \"_geojsonTileLayer\",\n            c = o[l];\n          let h = {};\n          if (t && (h = t[l], !c || !h || 0 === Object.keys(h).length)) continue;\n          if (a.update(h, c, r, this.imageAtlas && this.imageAtlas.patternPositions || {}, s), a instanceof e.aK || a instanceof e.aL) {\n            const e = i.style.getOwnSourceCache(a.layers[0].source);\n            i._terrain && i._terrain.enabled && e && a.programConfigurations.needsUpload && i._terrain._clearRenderCacheForTile(e.id, this.tileID);\n          }\n          const u = i && i.style && i.style.getOwnLayer(n);\n          u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(a)));\n        }\n      }\n      holdingForFade() {\n        return void 0 !== this.symbolFadeHoldUntil;\n      }\n      symbolFadeFinished() {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.f.now();\n      }\n      clearFadeHold() {\n        this.symbolFadeHoldUntil = void 0;\n      }\n      setHoldDuration(t) {\n        this.symbolFadeHoldUntil = e.f.now() + t;\n      }\n      setTexture(t, i) {\n        const o = i.context,\n          r = o.gl;\n        this.texture = this.texture || i.getTileTexture(t.width), this.texture && this.texture instanceof e.T ? this.texture.update(t, {\n          useMipmap: !0\n        }) : (this.texture = new e.T(o, t, r.RGBA, {\n          useMipmap: !0\n        }), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));\n      }\n      setDependencies(e, t) {\n        const i = {};\n        for (const e of t) i[e] = !0;\n        this.dependencies[e] = i;\n      }\n      hasDependency(e, t) {\n        for (const i of e) {\n          const e = this.dependencies[i];\n          if (e) for (const i of t) if (e[i]) return !0;\n        }\n        return !1;\n      }\n      clearQueryDebugViz() {}\n      _makeDebugTileBoundsBuffers(t, i) {\n        if (!i || \"mercator\" === i.name || this._tileDebugBuffer) return;\n        const o = e.aM(Ut, this.tileID.canonical, this.tileTransform)[0],\n          r = new e.aN(),\n          s = new e.aO();\n        for (let e = 0; e < o.length; e++) {\n          const {\n            x: t,\n            y: i\n          } = o[e];\n          r.emplaceBack(t, i), s.emplaceBack(e);\n        }\n        s.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(s), this._tileDebugBuffer = t.createVertexBuffer(r, e.aP.members), this._tileDebugSegments = e.aB.simpleSegment(0, 0, r.length, s.length);\n      }\n      _makeTileBoundsBuffers(t, i) {\n        if (this._tileBoundsBuffer || !i || \"mercator\" === i.name) return;\n        const o = e.aM(Ut, this.tileID.canonical, this.tileTransform)[0];\n        let r, s;\n        if (this.isRaster) {\n          const t = function (t, i) {\n            const o = e.as(t, i),\n              r = Math.pow(2, t.z);\n            for (let s = 0; s < Fe; s++) for (let n = 0; n < Fe; n++) {\n              const a = e.at((t.x + (n + Ge(n)) / Oe) / r),\n                l = e.au((t.y + (s + Ge(s)) / Oe) / r),\n                c = i.project(a, l),\n                h = s * Fe + n;\n              ke[2 * h + 0] = Math.round((c.x * o.scale - o.x) * e.V), ke[2 * h + 1] = Math.round((c.y * o.scale - o.y) * e.V);\n            }\n            Ne.fill(0), Ue.fill(0);\n            for (let e = 2045; e >= 0; e--) {\n              const t = 4 * e,\n                i = Be[t + 0],\n                o = Be[t + 1],\n                r = Be[t + 2],\n                s = Be[t + 3],\n                n = i + r >> 1,\n                a = o + s >> 1,\n                l = n + a - o,\n                c = a + i - n,\n                h = o * Fe + i,\n                u = s * Fe + r,\n                d = a * Fe + n,\n                _ = Math.hypot((ke[2 * h + 0] + ke[2 * u + 0]) / 2 - ke[2 * d + 0], (ke[2 * h + 1] + ke[2 * u + 1]) / 2 - ke[2 * d + 1]) >= 16;\n              Ne[d] = Ne[d] || (_ ? 1 : 0), e < 1022 && (Ne[d] = Ne[d] || Ne[(o + c >> 1) * Fe + (i + l >> 1)] || Ne[(s + c >> 1) * Fe + (r + l >> 1)]);\n            }\n            const s = new e.av(),\n              n = new e.aw();\n            let a = 0;\n            function l(t, i) {\n              const o = i * Fe + t;\n              return 0 === Ue[o] && (s.emplaceBack(ke[2 * o + 0], ke[2 * o + 1], t * e.V / Oe, i * e.V / Oe), Ue[o] = ++a), Ue[o] - 1;\n            }\n            function c(e, t, i, o, r, s) {\n              const a = e + i >> 1,\n                h = t + o >> 1;\n              if (Math.abs(e - r) + Math.abs(t - s) > 1 && Ne[h * Fe + a]) c(r, s, e, t, a, h), c(i, o, r, s, a, h);else {\n                const a = l(e, t),\n                  c = l(i, o),\n                  h = l(r, s);\n                n.emplaceBack(a, c, h);\n              }\n            }\n            return c(0, 0, Oe, Oe, Oe, 0), c(Oe, Oe, 0, 0, 0, Oe), {\n              vertices: s,\n              indices: n\n            };\n          }(this.tileID.canonical, i);\n          r = t.vertices, s = t.indices;\n        } else {\n          r = new e.av(), s = new e.aw();\n          for (const {\n            x: e,\n            y: t\n          } of o) r.emplaceBack(e, t, 0, 0);\n          const t = e.aQ(r.int16, void 0, 4);\n          for (let e = 0; e < t.length; e += 3) s.emplaceBack(t[e], t[e + 1], t[e + 2]);\n        }\n        this._tileBoundsBuffer = t.createVertexBuffer(r, e.aR.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(s), this._tileBoundsSegments = e.aB.simpleSegment(0, 0, r.length, s.length);\n      }\n      _makeGlobeTileDebugBuffers(t, i) {\n        const o = i.projection;\n        if (!o || \"globe\" !== o.name || i.freezeTileCoverage) return;\n        const r = this.tileID.canonical,\n          s = e.aS(r, i),\n          n = e.aT(s),\n          a = e.S(i.zoom);\n        let l;\n        a > 0 && (l = e.a6.invert(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, r, i, n, l, a), this._makeGlobeTileDebugTextBuffer(t, r, i, n, l, a);\n      }\n      _globePoint(t, i, o, r, s, n, a) {\n        let l = e.aU(t, i, o);\n        if (n) {\n          const s = 1 << o.z,\n            c = e.a5(r.center.lng),\n            h = e.ae(r.center.lat),\n            u = (o.x + .5) / s - c;\n          let d = 0;\n          u > .5 ? d = -1 : u < -.5 && (d = 1);\n          let _ = (t / e.V + o.x) / s + d,\n            p = (i / e.V + o.y) / s;\n          _ = (_ - c) * r._pixelsPerMercatorPixel + c, p = (p - h) * r._pixelsPerMercatorPixel + h;\n          const f = [_ * r.worldSize, p * r.worldSize, 0];\n          e.N.transformMat4(f, f, n), l = e.aV(l, f, a);\n        }\n        return e.N.transformMat4(l, l, s);\n      }\n      _makeGlobeTileDebugBorderBuffer(t, i, o, r, s, n) {\n        const a = new e.aN(),\n          l = new e.aO(),\n          c = new e.aW(),\n          h = (e, t, h, u, d) => {\n            const _ = (h - e) / (d - 1),\n              p = (u - t) / (d - 1),\n              f = a.length;\n            for (let h = 0; h < d; h++) {\n              const u = e + h * _,\n                d = t + h * p;\n              a.emplaceBack(u, d);\n              const m = this._globePoint(u, d, i, o, r, s, n);\n              c.emplaceBack(m[0], m[1], m[2]), l.emplaceBack(f + h);\n            }\n          },\n          u = e.V;\n        h(0, 0, u, 0, 16), h(u, 0, u, u, 16), h(u, u, 0, u, 16), h(0, u, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(l), this._tileDebugBuffer = t.createVertexBuffer(a, e.aP.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(c, e.aX.members), this._tileDebugSegments = e.aB.simpleSegment(0, 0, a.length, l.length);\n      }\n      _makeGlobeTileDebugTextBuffer(t, i, o, r, s, n) {\n        const a = e.V / 4,\n          l = new e.aN(),\n          c = new e.aw(),\n          h = new e.aW(),\n          u = 25;\n        c.reserve(32), l.reserve(u), h.reserve(u);\n        const d = (e, t) => u * e + t;\n        for (let e = 0; e < u; e++) {\n          const t = e * a;\n          for (let e = 0; e < u; e++) {\n            const c = e * a;\n            l.emplaceBack(c, t);\n            const u = this._globePoint(c, t, i, o, r, s, n);\n            h.emplaceBack(u[0], u[1], u[2]);\n          }\n        }\n        for (let e = 0; e < 4; e++) for (let t = 0; t < 4; t++) {\n          const i = d(e, t),\n            o = d(e, t + 1),\n            r = d(e + 1, t),\n            s = d(e + 1, t + 1);\n          c.emplaceBack(i, o, r), c.emplaceBack(r, o, s);\n        }\n        this._tileDebugTextIndexBuffer = t.createIndexBuffer(c), this._tileDebugTextBuffer = t.createVertexBuffer(l, e.aP.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(h, e.aX.members), this._tileDebugTextSegments = e.aB.simpleSegment(0, 0, u, 32);\n      }\n      destroy(t = !1) {\n        for (const e in this.buckets) this.buckets[e].destroy();\n        this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = \"unloaded\";\n      }\n    }\n    const jt = {\n        vector: Pe,\n        raster: Me,\n        \"raster-dem\": class extends Me {\n          constructor(t, i, o, r) {\n            super(t, i, o, r), this.type = \"raster-dem\", this.maxzoom = 22, this._options = e.e({\n              type: \"raster-dem\"\n            }, i), this.encoding = i.encoding || \"mapbox\";\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);\n            function r(e, o) {\n              e && (t.state = \"errored\", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = \"loaded\", i(null));\n            }\n            t.request = e.d(this.map._requestManager.transformRequest(o, e.R.Tile), function (o, s, n, a) {\n              if (delete t.request, t.aborted) t.state = \"unloaded\", i(null);else if (o) t.state = \"errored\", i(o);else if (s) {\n                this.map._refreshExpiredTiles && t.setExpiryData({\n                  cacheControl: n,\n                  expires: a\n                });\n                const i = ImageBitmap && s instanceof ImageBitmap && e.ak(),\n                  o = 1 - (s.width - e.al(s.width)) / 2;\n                o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));\n                const l = i ? s : e.f.getImageData(s, o),\n                  c = {\n                    uid: t.uid,\n                    coord: t.tileID,\n                    source: this.id,\n                    scope: this.scope,\n                    rawImageData: l,\n                    encoding: this.encoding,\n                    padding: o\n                  };\n                t.actor && \"expired\" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send(\"loadDEMTile\", c, r.bind(this), void 0, !0));\n              }\n            }.bind(this));\n          }\n          _getNeighboringTiles(t) {\n            const i = t.canonical,\n              o = Math.pow(2, i.z),\n              r = (i.x - 1 + o) % o,\n              s = 0 === i.x ? t.wrap - 1 : t.wrap,\n              n = (i.x + 1 + o) % o,\n              a = i.x + 1 === o ? t.wrap + 1 : t.wrap,\n              l = {};\n            return l[new e.am(t.overscaledZ, s, i.z, r, i.y).key] = {\n              backfilled: !1\n            }, l[new e.am(t.overscaledZ, a, i.z, n, i.y).key] = {\n              backfilled: !1\n            }, i.y > 0 && (l[new e.am(t.overscaledZ, s, i.z, r, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.am(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.am(t.overscaledZ, a, i.z, n, i.y - 1).key] = {\n              backfilled: !1\n            }), i.y + 1 < o && (l[new e.am(t.overscaledZ, s, i.z, r, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.am(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.am(t.overscaledZ, a, i.z, n, i.y + 1).key] = {\n              backfilled: !1\n            }), l;\n          }\n        },\n        \"raster-array\": ze,\n        geojson: class extends e.E {\n          constructor(t, i, o, r) {\n            super(), this.id = t, this.type = \"geojson\", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.e({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;\n            const s = e.V / this.tileSize;\n            this.workerOptions = e.e({\n              source: this.id,\n              scope: this.scope,\n              cluster: i.cluster || !1,\n              geojsonVtOptions: {\n                buffer: (void 0 !== i.buffer ? i.buffer : 128) * s,\n                tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * s,\n                extent: e.V,\n                maxZoom: this.maxzoom,\n                lineMetrics: i.lineMetrics || !1,\n                generateId: i.generateId || !1\n              },\n              superclusterOptions: {\n                maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,\n                minPoints: Math.max(2, i.clusterMinPoints || 2),\n                extent: e.V,\n                radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * s,\n                log: !1,\n                generateId: i.generateId || !1\n              },\n              clusterProperties: i.clusterProperties,\n              filter: i.filter\n            }, i.workerOptions);\n          }\n          onAdd(e) {\n            this.map = e, this.setData(this._data);\n          }\n          setData(e) {\n            return this._data = e, this._updateWorkerData(), this;\n          }\n          getClusterExpansionZoom(e, t) {\n            return this.actor.send(\"geojson.getClusterExpansionZoom\", {\n              clusterId: e,\n              source: this.id,\n              scope: this.scope\n            }, t), this;\n          }\n          getClusterChildren(e, t) {\n            return this.actor.send(\"geojson.getClusterChildren\", {\n              clusterId: e,\n              source: this.id,\n              scope: this.scope\n            }, t), this;\n          }\n          getClusterLeaves(e, t, i, o) {\n            return this.actor.send(\"geojson.getClusterLeaves\", {\n              source: this.id,\n              scope: this.scope,\n              clusterId: e,\n              limit: t,\n              offset: i\n            }, o), this;\n          }\n          _updateWorkerData() {\n            if (this._pendingLoad) return void (this._coalesce = !0);\n            this.fire(new e.b(\"dataloading\", {\n              dataType: \"source\"\n            })), this._loaded = !1;\n            const t = e.e({}, this.workerOptions);\n            t.scope = this.scope;\n            const i = this._data;\n            \"string\" == typeof i ? (t.request = this.map._requestManager.transformRequest(e.f.resolveURL(i), e.R.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (t, i) => {\n              if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.a(t));else {\n                const t = {\n                  dataType: \"source\",\n                  sourceDataType: this._metadataFired ? \"content\" : \"metadata\"\n                };\n                this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t.resourceTiming = i.resourceTiming[this.id]), this.fire(new e.b(\"data\", t)), this._metadataFired = !0;\n              }\n              this._coalesce && (this._updateWorkerData(), this._coalesce = !1);\n            });\n          }\n          loaded() {\n            return this._loaded;\n          }\n          loadTile(t, i) {\n            const o = t.actor ? \"reloadTile\" : \"loadTile\";\n            t.actor = this.actor;\n            const r = {\n              type: this.type,\n              uid: t.uid,\n              tileID: t.tileID,\n              tileZoom: t.tileZoom,\n              zoom: t.tileID.overscaledZ,\n              maxZoom: this.maxzoom,\n              tileSize: this.tileSize,\n              source: this.id,\n              scope: this.scope,\n              pixelRatio: e.f.devicePixelRatio,\n              showCollisionBoxes: this.map.showCollisionBoxes,\n              promoteId: this.promoteId,\n              brightness: this.map.style && this.map.style.getBrightness() || 0\n            };\n            t.request = this.actor.send(o, r, (e, r) => (delete t.request, t.destroy(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(r, this.map.painter, \"reloadTile\" === o), i(null))), void 0, \"loadTile\" === o);\n          }\n          abortTile(e) {\n            e.request && (e.request.cancel(), delete e.request), e.aborted = !0;\n          }\n          unloadTile(e) {\n            this.actor.send(\"removeTile\", {\n              uid: e.uid,\n              type: this.type,\n              source: this.id,\n              scope: this.scope\n            }), e.destroy();\n          }\n          onRemove() {\n            this._pendingLoad && this._pendingLoad.cancel();\n          }\n          serialize() {\n            return e.e({}, this._options, {\n              type: this.type,\n              data: this._data\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n        },\n        video: class extends e.ap {\n          constructor(e, t, i, o) {\n            super(e, t, i, o), this.roundZoom = !0, this.type = \"video\", this.options = t;\n          }\n          load() {\n            this._loaded = !1;\n            const t = this.options;\n            this.urls = [];\n            for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);\n            e.aq(this.urls, (t, i) => {\n              this._loaded = !0, t ? this.fire(new e.a(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute(\"playsinline\", \"\"), this.video.addEventListener(\"playing\", () => {\n                this.map.triggerRepaint();\n              }), this.map && this.video.play(), this._finishLoading());\n            });\n          }\n          pause() {\n            this.video && this.video.pause();\n          }\n          play() {\n            this.video && this.video.play();\n          }\n          seek(t) {\n            if (this.video) {\n              const i = this.video.seekable;\n              t < i.start(0) || t > i.end(0) ? this.fire(new e.a(new T(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;\n            }\n          }\n          getVideo() {\n            return this.video;\n          }\n          onAdd(e) {\n            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n          }\n          prepare() {\n            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;\n            const t = this.map.painter.context,\n              i = t.gl;\n            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);\n          }\n          serialize() {\n            return {\n              type: \"video\",\n              urls: this.urls,\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this.video && !this.video.paused;\n          }\n        },\n        image: e.ap,\n        model: class extends e.E {\n          constructor(e, t, i, o) {\n            super(), this.id = e, this.type = \"model\", this.models = [], this._loaded = !1, this._options = t;\n          }\n          load() {\n            const t = [];\n            for (const i in this._options.models) {\n              const o = this._options.models[i],\n                r = e.l(this.map._requestManager.transformRequest(o.uri, e.R.Model).url).then(t => {\n                  if (!t) return;\n                  const r = e.c(t),\n                    s = new e.M(i, o.position, o.orientation, r);\n                  s.computeBoundsAndApplyParent(), this.models.push(s);\n                }).catch(t => {\n                  this.fire(new e.a(new Error(`Could not load model ${i} from ${o.uri}: ${t.message}`)));\n                });\n              t.push(r);\n            }\n            return Promise.allSettled(t).then(() => {\n              this._loaded = !0, this.fire(new e.b(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"metadata\"\n              }));\n            }).catch(t => {\n              this.fire(new e.a(new Error(`Could not load models: ${t.message}`)));\n            });\n          }\n          onAdd(e) {\n            this.map = e, this.load();\n          }\n          hasTransition() {\n            return !1;\n          }\n          loaded() {\n            return this._loaded;\n          }\n          getModels() {\n            return this.models;\n          }\n          loadTile(e, t) {}\n          serialize() {\n            return {\n              type: \"model\"\n            };\n          }\n        },\n        \"batched-model\": class extends e.E {\n          constructor(e, t, i, o) {\n            super(), this.type = \"batched-model\", this.id = e, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = \"xyz\", this._loaded = !1, this.setEventedParent(o);\n          }\n          onAdd(e) {\n            this.map = e, this.load();\n          }\n          load(t) {\n            this._loaded = !1, this.fire(new e.b(\"dataloading\", {\n              dataType: \"source\"\n            }));\n            const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n              o = this.map._worldview;\n            this._tileJSONRequest = Ae(this._options, this.map._requestManager, i, o, (r, s) => {\n              this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.a(r))) : s && (e.e(this, s), s.bounds && (this.tileBounds = new Re(s.bounds, this.minzoom, this.maxzoom)), e.aj(s.tiles, this.map._requestManager._customAccessToken), this.fire(new e.b(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"metadata\"\n              })), this.fire(new e.b(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"content\"\n              }))), t && t(r);\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n          hasTile(e) {\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loaded() {\n            return this._loaded;\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),\n              r = {\n                request: this.map._requestManager.transformRequest(o, e.R.Tile),\n                data: void 0,\n                uid: t.uid,\n                tileID: t.tileID,\n                tileZoom: t.tileZoom,\n                zoom: t.tileID.overscaledZ,\n                tileSize: this.tileSize * t.tileID.overscaleFactor(),\n                type: this.type,\n                source: this.id,\n                scope: this.scope,\n                showCollisionBoxes: this.map.showCollisionBoxes,\n                isSymbolTile: t.isSymbolTile,\n                brightness: this.map.style && this.map.style.getBrightness() || 0\n              };\n            if (t.actor && \"expired\" !== t.state) {\n              if (\"loading\" === t.state) t.reloadCallback = i;else {\n                if (t.buckets) {\n                  const e = Object.values(t.buckets);\n                  for (const t of e) t.dirty = !0;\n                  return void (t.state = \"loaded\");\n                }\n                t.request = t.actor.send(\"reloadTile\", r, s.bind(this));\n              }\n            } else t.actor = this.dispatcher.getActor(), t.request = t.actor.send(\"loadTile\", r, s.bind(this), void 0, !0);\n            function s(e, o) {\n              return t.aborted ? i(null) : e && 404 !== e.status ? i(e) : (o && (o.resourceTiming && (t.resourceTiming = o.resourceTiming), this.map._refreshExpiredTiles && t.setExpiryData(o), t.buckets = {\n                ...t.buckets,\n                ...o.buckets\n              }, o.featureIndex && (t.latestFeatureIndex = o.featureIndex)), t.state = \"loaded\", void i(null));\n            }\n          }\n          serialize() {\n            return e.e({}, this._options);\n          }\n        },\n        canvas: class extends e.ap {\n          constructor(t, i, o, r) {\n            super(t, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => \"number\" != typeof e)) || this.fire(new e.a(new T(`sources.${t}`, null, '\"coordinates\" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.a(new T(`sources.${t}`, null, 'missing required property \"coordinates\"'))), i.animate && \"boolean\" != typeof i.animate && this.fire(new e.a(new T(`sources.${t}`, null, 'optional \"animate\" property must be a boolean value'))), i.canvas ? \"string\" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.a(new T(`sources.${t}`, null, '\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.a(new T(`sources.${t}`, null, 'missing required property \"canvas\"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;\n          }\n          load() {\n            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.a(new Error(\"Canvas dimensions cannot be less than or equal to zero.\"))) : (this.play = function () {\n              this._playing = !0, this.map.triggerRepaint();\n            }, this.pause = function () {\n              this._playing && (this.prepare(), this._playing = !1);\n            }, this._finishLoading());\n          }\n          getCanvas() {\n            return this.canvas;\n          }\n          onAdd(e) {\n            this.map = e, this.load(), this.canvas && this.animate && this.play();\n          }\n          onRemove() {\n            this.pause();\n          }\n          prepare() {\n            let t = !1;\n            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;\n            if (0 === Object.keys(this.tiles).length) return;\n            const i = this.map.painter.context;\n            this.texture ? !t && !this._playing || this.texture instanceof e.ar || this.texture.update(this.canvas, {\n              premultiply: !0\n            }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA, {\n              premultiply: !0\n            }), this._prepareData(i);\n          }\n          serialize() {\n            return {\n              type: \"canvas\",\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this._playing;\n          }\n          _hasInvalidDimensions() {\n            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;\n            return !1;\n          }\n        },\n        custom: class extends e.E {\n          constructor(t, i, o, r) {\n            super(), this.id = t, this.type = \"custom\", this._dataType = \"raster\", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = \"xyz\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.a(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.a(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Re(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.e(this, e.ac(i, [\"dataType\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\", \"minTileCacheSize\", \"maxTileCacheSize\"]));\n          }\n          serialize() {\n            return e.ac(this, [\"type\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\"]);\n          }\n          load() {\n            this._loaded = !0, this.fire(new e.b(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.b(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n          loaded() {\n            return this._loaded;\n          }\n          onAdd(t) {\n            this._map = t, this._loaded = !1, this.fire(new e.b(\"dataloading\", {\n              dataType: \"source\"\n            })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();\n          }\n          onRemove(e) {\n            this._implementation.onRemove && this._implementation.onRemove(e);\n          }\n          hasTile(e) {\n            if (this._implementation.hasTile) {\n              const {\n                x: t,\n                y: i,\n                z: o\n              } = e.canonical;\n              return this._implementation.hasTile({\n                x: t,\n                y: i,\n                z: o\n              });\n            }\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loadTile(e, t) {\n            const {\n                x: i,\n                y: o,\n                z: r\n              } = e.tileID.canonical,\n              s = new AbortController();\n            e.request = Promise.resolve(this._implementation.loadTile({\n              x: i,\n              y: o,\n              z: r\n            }, {\n              signal: s.signal\n            })).then(function (i) {\n              return delete e.request, e.aborted ? (e.state = \"unloaded\", t(null)) : void 0 === i ? (e.state = \"errored\", t(null)) : null === i ? (this.loadTileData(e, {\n                width: this.tileSize,\n                height: this.tileSize,\n                data: null\n              }), e.state = \"loaded\", t(null)) : function (e) {\n                return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;\n              }(i) ? (this.loadTileData(e, i), e.state = \"loaded\", void t(null)) : (e.state = \"errored\", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));\n            }.bind(this)).catch(i => {\n              20 !== i.code && (e.state = \"errored\", t(i));\n            }), e.request.cancel = () => s.abort();\n          }\n          loadTileData(e, t) {\n            e.setTexture(t, this._map.painter);\n          }\n          unloadTile(t, i) {\n            if (t.texture && t.texture instanceof e.T ? (t.destroy(!0), t.texture && t.texture instanceof e.T && this._map.painter.saveTileTexture(t.texture)) : t.destroy(), this._implementation.unloadTile) {\n              const {\n                x: e,\n                y: i,\n                z: o\n              } = t.tileID.canonical;\n              this._implementation.unloadTile({\n                x: e,\n                y: i,\n                z: o\n              });\n            }\n            i();\n          }\n          abortTile(e, t) {\n            e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();\n          }\n          hasTransition() {\n            return !1;\n          }\n          _coveringTiles() {\n            return this._map.transform.coveringTiles({\n              tileSize: this.tileSize,\n              minzoom: this.minzoom,\n              maxzoom: this.maxzoom,\n              roundZoom: this.roundZoom\n            }).map(e => ({\n              x: e.canonical.x,\n              y: e.canonical.y,\n              z: e.canonical.z\n            }));\n          }\n          _clearTiles() {\n            const t = e.ag(this.id, this.scope);\n            this._map.style.clearSource(t);\n          }\n          _update() {\n            this.fire(new e.b(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n        }\n      },\n      Vt = function (t, i, o, r) {\n        const s = new jt[i.type](t, i, o, r);\n        if (s.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${s.id}`);\n        return e.aY([\"load\", \"abort\", \"unload\", \"serialize\", \"prepare\"], s), s;\n      };\n    function Zt(t, i) {\n      const o = e.a6.identity([]);\n      return e.a6.scale(o, o, [.5 * t.width, .5 * -t.height, 1]), e.a6.translate(o, o, [1, -1, 0]), e.a6.multiply(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);\n    }\n    function Ht(e, t, i, o, r, s, n, a = !1) {\n      const l = e.tilesIn(o, n, a);\n      l.sort(qt);\n      const c = [];\n      for (const o of l) c.push({\n        wrappedTileID: o.tile.tileID.wrapped().key,\n        queryResults: o.tile.queryRenderedFeatures(t, i, e._state, o, r, s, Zt(e.transform, o.tile.tileID), a)\n      });\n      const h = function (e) {\n        const t = {},\n          i = {};\n        for (const o of e) {\n          const e = o.queryResults,\n            r = o.wrappedTileID,\n            s = i[r] = i[r] || {};\n          for (const i in e) {\n            const o = e[i],\n              r = s[i] = s[i] || {},\n              n = t[i] = t[i] || [];\n            for (const e of o) r[e.featureIndex] || (r[e.featureIndex] = !0, n.push(e));\n          }\n        }\n        return t;\n      }(c);\n      for (const t in h) h[t].forEach(t => {\n        const i = t.feature,\n          o = i.layer;\n        o && \"background\" !== o.type && \"sky\" !== o.type && \"slot\" !== o.type && (i.source = o.source, o[\"source-layer\"] && (i.sourceLayer = o[\"source-layer\"]), i.state = void 0 !== i.id ? e.getFeatureState(o[\"source-layer\"], i.id) : {});\n      });\n      return h;\n    }\n    function Wt(e, t) {\n      const i = e.getRenderableIds().map(t => e.getTileByID(t)),\n        o = [],\n        r = {};\n      for (let e = 0; e < i.length; e++) {\n        const s = i[e],\n          n = s.tileID.canonical.key;\n        r[n] || (r[n] = !0, s.querySourceFeatures(o, t));\n      }\n      return o;\n    }\n    function qt(e, t) {\n      const i = e.tileID,\n        o = t.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n    class $t extends Gt {\n      constructor(e, t, i, o, r) {\n        super(e, t, i, o, r), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;\n      }\n      setTexture(t, i) {\n        const o = i.context,\n          r = o.gl;\n        this.texture = this.texture || i.getTileTexture(t.width), this.texture && this.texture instanceof e.T ? this.texture.update(t, {\n          useMipmap: !1,\n          premultiply: !1\n        }) : this.texture = new e.T(o, t, r.RGBA, {\n          useMipmap: !1,\n          premultiply: !1\n        });\n      }\n      flushQueues() {\n        for (; this._workQueue.length;) this._workQueue.pop()();\n        for (; this._fetchQueue.length;) this._fetchQueue.pop()();\n      }\n      fetchHeader(t = 16384, i) {\n        const o = this._mrt = new e.aZ(30),\n          r = Object.assign({}, this.requestParams, {\n            headers: {\n              Range: \"bytes=0-\" + (t - 1)\n            }\n          });\n        return this.entireBuffer = null, this.request = e.a_(r, (e, r, s, n) => {\n          if (e) i(e);else try {\n            const e = o.getHeaderLength(r);\n            if (e > t) return void (this.request = this.fetchHeader(e, i));\n            o.parseHeader(r), this._isHeaderLoaded = !0;\n            let a = 0;\n            for (const e of Object.values(o.layers)) a = Math.max(a, e.dataIndex[e.dataIndex.length - 1].last_byte);\n            r.byteLength >= a && (this.entireBuffer = r), i(null, this.entireBuffer || r, s, n);\n          } catch (e) {\n            i(e);\n          }\n        }), this.request;\n      }\n      fetchBand(t, i, o) {\n        const r = this._mrt;\n        if (!this._isHeaderLoaded || !r) return void o(new Error(\"Tile header is not ready\"));\n        const s = this.actor;\n        if (!s) return void o(new Error(\"Can't fetch tile band without an actor\"));\n        let n;\n        const a = (e, r) => {\n            n.complete(e, r), e ? o(e) : (this.updateTextureDescriptor(t, i), o(null, this.textureDescriptor && this.textureDescriptor.img));\n          },\n          l = (e, t) => {\n            if (e) return o(e);\n            const i = s.send(\"decodeRasterArray\", {\n              buffer: t,\n              task: n\n            }, a, void 0, !0);\n            this._workQueue.push(() => {\n              i && i.cancel(), n.cancel();\n            });\n          },\n          c = r.getLayer(t);\n        if (!c) return void o(new Error(`Unknown sourceLayer \"${t}\"`));\n        if (c.hasDataForBand(i)) return this.updateTextureDescriptor(t, i), void o(null, this.textureDescriptor ? this.textureDescriptor.img : null);\n        const h = c.getDataRange([i]);\n        if (n = r.createDecodingTask(h), !n || n.tasks.length) {\n          if (this.flushQueues(), this.entireBuffer) l(null, this.entireBuffer.slice(h.firstByte, h.lastByte + 1));else {\n            const t = Object.assign({}, this.requestParams, {\n                headers: {\n                  Range: `bytes=${h.firstByte}-${h.lastByte}`\n                }\n              }),\n              i = e.a_(t, l);\n            this._fetchQueue.push(() => {\n              i.cancel(), n.cancel();\n            });\n          }\n        } else o(null);\n      }\n      updateNeeded(e, t) {\n        return (!this.textureDescriptor || this.textureDescriptor.band !== t || this.textureDescriptor.layer !== e) && \"errored\" !== this.state;\n      }\n      updateTextureDescriptor(t, i) {\n        if (!this._mrt) return;\n        const o = this._mrt.getLayer(t);\n        if (!o || !o.hasBand(i) || !o.hasDataForBand(i)) return;\n        const {\n            bytes: r,\n            tileSize: s,\n            buffer: n,\n            offset: a,\n            scale: l\n          } = o.getBandView(i),\n          c = s + 2 * n,\n          h = {\n            data: r,\n            width: c,\n            height: c\n          },\n          u = this.texture;\n        u && u instanceof e.T && u.update(h, {\n          useMipmap: !1,\n          premultiply: !1\n        }), this.textureDescriptor = {\n          layer: t,\n          band: i,\n          img: h,\n          buffer: n,\n          offset: a,\n          tileSize: s,\n          format: o.pixelFormat,\n          mix: [l, 256 * l, 65536 * l, 16777216 * l]\n        };\n      }\n    }\n    class Xt {\n      constructor(e, t) {\n        this.max = e, this.onRemove = t, this.reset();\n      }\n      reset() {\n        for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);\n        return this.data = {}, this.order = [], this;\n      }\n      add(e, t, i) {\n        const o = e.wrapped().key;\n        void 0 === this.data[o] && (this.data[o] = []);\n        const r = {\n          value: t,\n          timeout: void 0\n        };\n        if (void 0 !== i && (r.timeout = setTimeout(() => {\n          this.remove(e, r);\n        }, i)), this.data[o].push(r), this.order.push(o), this.order.length > this.max) {\n          const e = this._getAndRemoveByKey(this.order[0]);\n          e && this.onRemove(e);\n        }\n        return this;\n      }\n      has(e) {\n        return e.wrapped().key in this.data;\n      }\n      getAndRemove(e) {\n        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;\n      }\n      _getAndRemoveByKey(e) {\n        const t = this.data[e].shift();\n        return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;\n      }\n      getByKey(e) {\n        const t = this.data[e];\n        return t ? t[0].value : null;\n      }\n      get(e) {\n        return this.has(e) ? this.data[e.wrapped().key][0].value : null;\n      }\n      remove(e, t) {\n        if (!this.has(e)) return this;\n        const i = e.wrapped().key,\n          o = void 0 === t ? 0 : this.data[i].indexOf(t),\n          r = this.data[i][o];\n        return this.data[i].splice(o, 1), r.timeout && clearTimeout(r.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(r.value), this.order.splice(this.order.indexOf(i), 1), this;\n      }\n      setMaxSize(e) {\n        for (this.max = e; this.order.length > this.max;) {\n          const e = this._getAndRemoveByKey(this.order[0]);\n          e && this.onRemove(e);\n        }\n        return this;\n      }\n      filter(e) {\n        const t = [];\n        for (const i in this.data) for (const o of this.data[i]) e(o.value) || t.push(o);\n        for (const e of t) this.remove(e.value.tileID, e);\n      }\n    }\n    class Kt extends e.E {\n      constructor(e, t, i) {\n        super(), this.id = e, this._onlySymbols = i, t.on(\"data\", e => {\n          \"source\" === e.dataType && \"metadata\" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && \"source\" === e.dataType && \"content\" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform));\n        }), t.on(\"error\", () => {\n          this._sourceErrored = !0;\n        }), this._source = t, this._tiles = {}, this._cache = new Xt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new y(), this._isRaster = \"raster\" === this._source.type || \"raster-dem\" === this._source.type || \"raster-array\" === this._source.type || \"custom\" === this._source.type && \"raster\" === this._source._dataType;\n      }\n      onAdd(e) {\n        this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize;\n      }\n      loaded() {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n        for (const e in this._tiles) {\n          const t = this._tiles[e];\n          if (\"errored\" !== t.state && (\"loaded\" !== t.state || !t.bucketsLoaded())) return !1;\n        }\n        return !0;\n      }\n      getSource() {\n        return this._source;\n      }\n      pause() {\n        this._paused = !0;\n      }\n      resume() {\n        if (!this._paused) return;\n        const e = this._shouldReloadOnResume;\n        this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);\n      }\n      _loadTile(e, t) {\n        return e.isSymbolTile = this._onlySymbols, e.isExtraShadowCaster = this._shadowCasterTiles[e.tileID.key], this._source.loadTile(e, t);\n      }\n      _unloadTile(e) {\n        if (this._source.unloadTile) return this._source.unloadTile(e, () => {});\n      }\n      _abortTile(e) {\n        if (this._source.abortTile) return this._source.abortTile(e, () => {});\n      }\n      serialize() {\n        return this._source.serialize();\n      }\n      prepare(e) {\n        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n        for (const t in this._tiles) {\n          const i = this._tiles[t];\n          i.upload(e), i.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);\n        }\n      }\n      getIds() {\n        return e.a$(this._tiles).map(e => e.tileID).sort(Yt).map(e => e.key);\n      }\n      getRenderableIds(t, i) {\n        const o = [];\n        for (const e in this._tiles) this._isIdRenderable(+e, t, i) && o.push(this._tiles[e]);\n        return t ? o.sort((t, i) => {\n          const o = t.tileID,\n            r = i.tileID,\n            s = new e.P(o.canonical.x, o.canonical.y)._rotate(this.transform.angle),\n            n = new e.P(r.canonical.x, r.canonical.y)._rotate(this.transform.angle);\n          return o.overscaledZ - r.overscaledZ || n.y - s.y || n.x - s.x;\n        }).map(e => e.tileID.key) : o.map(e => e.tileID).sort(Yt).map(e => e.key);\n      }\n      hasRenderableParent(e) {\n        const t = this.findLoadedParent(e, 0);\n        return !!t && this._isIdRenderable(t.tileID.key);\n      }\n      _isIdRenderable(e, t, i) {\n        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade()) && (i || !this._shadowCasterTiles[e]);\n      }\n      reload() {\n        if (this._paused) this._shouldReloadOnResume = !0;else {\n          this._cache.reset();\n          for (const e in this._tiles) \"errored\" !== this._tiles[e].state && this._reloadTile(+e, \"reloading\");\n        }\n      }\n      _reloadTile(e, t) {\n        const i = this._tiles[e];\n        i && (\"loading\" !== i.state && (i.state = t), this._loadTile(i, this._tileLoaded.bind(this, i, e, t)));\n      }\n      _tileLoaded(t, i, o, r) {\n        if (r) {\n          if (t.state = \"errored\", 404 !== r.status) this._source.fire(new e.a(r, {\n            tile: t\n          }));else {\n            if (!(t.tileID.key in this._loadedParentTiles)) return void this._source.fire(new e.b(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"error\",\n              sourceId: this._source.id\n            }));\n            if (\"raster-dem\" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {\n              const e = this.map.painter.terrain;\n              this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id);\n            } else this.update(this.transform);\n          }\n        } else t.timeAdded = e.f.now(), \"expired\" === o && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t), \"raster-dem\" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new e.b(\"data\", {\n          dataType: \"source\",\n          tile: t,\n          coord: t.tileID,\n          sourceCacheId: this.id\n        }));\n      }\n      _backfillDEM(e) {\n        const t = this.getRenderableIds();\n        for (let o = 0; o < t.length; o++) {\n          const r = t[o];\n          if (e.neighboringTiles && e.neighboringTiles[r]) {\n            const t = this.getTileByID(r);\n            i(e, t), i(t, e);\n          }\n        }\n        function i(e, t) {\n          if (!e.dem || e.dem.borderReady) return;\n          e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;\n          let i = t.tileID.canonical.x - e.tileID.canonical.x;\n          const o = t.tileID.canonical.y - e.tileID.canonical.y,\n            r = Math.pow(2, e.tileID.canonical.z),\n            s = t.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + r) ? i += r : 1 === Math.abs(i - r) && (i -= r)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, i, o), e.neighboringTiles && e.neighboringTiles[s] && (e.neighboringTiles[s].backfilled = !0)));\n        }\n      }\n      getTile(e) {\n        return this.getTileByID(e.key);\n      }\n      getTileByID(e) {\n        return this._tiles[e];\n      }\n      _retainLoadedChildren(e, t, i, o) {\n        for (const r in this._tiles) {\n          let s = this._tiles[r];\n          if (o[r] || !s.hasData() || s.tileID.overscaledZ <= t || s.tileID.overscaledZ > i) continue;\n          let n = s.tileID;\n          for (; s && s.tileID.overscaledZ > t + 1;) {\n            const e = s.tileID.scaledTo(s.tileID.overscaledZ - 1);\n            s = this._tiles[e.key], s && s.hasData() && (n = e);\n          }\n          let a = n;\n          for (; a.overscaledZ > t;) if (a = a.scaledTo(a.overscaledZ - 1), e[a.key]) {\n            o[n.key] = n;\n            break;\n          }\n        }\n      }\n      findLoadedParent(e, t) {\n        if (e.key in this._loadedParentTiles) {\n          const i = this._loadedParentTiles[e.key];\n          return i && i.tileID.overscaledZ >= t ? i : null;\n        }\n        for (let i = e.overscaledZ - 1; i >= t; i--) {\n          const t = e.scaledTo(i),\n            o = this._getLoadedTile(t);\n          if (o) return o;\n        }\n      }\n      _getLoadedTile(e) {\n        const t = this._tiles[e.key];\n        return t && t.hasData() ? t : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);\n      }\n      updateCacheSize(e, t) {\n        t = t || this._source.tileSize;\n        const i = Math.ceil(e.width / t) + 1,\n          o = Math.ceil(e.height / t) + 1,\n          r = Math.floor(i * o * 5),\n          s = \"number\" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r) : r,\n          n = \"number\" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;\n        this._cache.setMaxSize(n);\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);\n        if (this._prevLng = e, t) {\n          const e = {};\n          for (const i in this._tiles) {\n            const o = this._tiles[i];\n            o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t), e[o.tileID.key] = o;\n          }\n          this._tiles = e;\n          for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];\n          for (const e in this._tiles) this._setTileReloadTimer(+e, this._tiles[e]);\n        }\n      }\n      update(t, i, o, r) {\n        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;\n        if (this.usedForTerrain && !o) return;\n        let s;\n        if (this.updateCacheSize(t, i), \"globe\" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}, this.used || this.usedForTerrain) {\n          if (this._source.tileID) s = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new e.am(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y));else if (0 !== this.tileCoverLift) {\n            const r = t.clone();\n            r.tileCoverLift = this.tileCoverLift, s = r.coveringTiles({\n              tileSize: i || this._source.tileSize,\n              minzoom: this._source.minzoom,\n              maxzoom: this._source.maxzoom,\n              roundZoom: this._source.roundZoom && !o,\n              reparseOverscaled: this._source.reparseOverscaled,\n              isTerrainDEM: this.usedForTerrain\n            }), this._source.minzoom <= 1 && \"globe\" === t.projection.name && (s.push(new e.am(1, 0, 1, 0, 0)), s.push(new e.am(1, 0, 1, 1, 0)), s.push(new e.am(1, 0, 1, 0, 1)), s.push(new e.am(1, 0, 1, 1, 1)));\n          } else s = t.coveringTiles({\n            tileSize: i || this._source.tileSize,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom && !o,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain\n          }), this._source.hasTile && (s = s.filter(e => this._source.hasTile(e)));\n        } else s = [];\n        if (s.length > 0 && this.castsShadows && r && \"globe\" !== this.transform.projection.name && !this.usedForTerrain && !Jt(this._source.type)) {\n          const e = t.coveringZoomLevel({\n              tileSize: i || this._source.tileSize,\n              roundZoom: this._source.roundZoom && !o\n            }),\n            n = Math.min(e, this._source.maxzoom),\n            a = t.extendTileCoverForShadows(s, r, n);\n          for (const e of a) this._shadowCasterTiles[e.key] = !0, s.push(e);\n        }\n        const n = this._updateRetainedTiles(s);\n        if (Jt(this._source.type) && 0 !== s.length) {\n          const t = {},\n            i = {},\n            o = Object.keys(n);\n          for (const r of o) {\n            const o = n[r],\n              s = this._tiles[r];\n            if (!s || s.fadeEndTime && s.fadeEndTime <= e.f.now()) continue;\n            const a = this.findLoadedParent(o, Math.max(o.overscaledZ - Kt.maxOverzooming, this._source.minzoom));\n            a && (this._addTile(a.tileID), t[a.tileID.key] = a.tileID), i[r] = o;\n          }\n          const r = s[s.length - 1].overscaledZ;\n          for (const e in this._tiles) {\n            const t = this._tiles[e];\n            if (n[e] || !t.hasData()) continue;\n            let o = t.tileID;\n            for (; o.overscaledZ > r;) {\n              o = o.scaledTo(o.overscaledZ - 1);\n              const r = this._tiles[o.key];\n              if (r && r.hasData() && i[o.key]) {\n                n[e] = t.tileID;\n                break;\n              }\n            }\n          }\n          for (const e in t) n[e] || (this._coveredTiles[e] = !0, n[e] = t[e]);\n        }\n        for (const e in n) this._tiles[e].clearFadeHold();\n        const a = e.b0(this._tiles, n);\n        for (const e of a) {\n          const t = this._tiles[e];\n          t.hasSymbolBuckets && !t.holdingForFade() ? t.setHoldDuration(this.map._fadeDuration) : t.hasSymbolBuckets && !t.symbolFadeFinished() || this._removeTile(+e);\n        }\n        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();\n      }\n      releaseSymbolFadeTiles() {\n        for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(+e);\n      }\n      _updateRetainedTiles(e) {\n        const t = {};\n        if (0 === e.length) return t;\n        const i = {},\n          o = e.reduce((e, t) => Math.min(e, t.overscaledZ), 1 / 0),\n          r = e[0].overscaledZ,\n          s = Math.max(r - Kt.maxOverzooming, this._source.minzoom),\n          n = Math.max(r + Kt.maxUnderzooming, this._source.minzoom),\n          a = {};\n        for (const i of e) {\n          const e = this._addTile(i);\n          t[i.key] = i, e.hasData() || o < this._source.maxzoom && (a[i.key] = i);\n        }\n        this._retainLoadedChildren(a, o, n, t);\n        for (const o of e) {\n          let e = this._tiles[o.key];\n          if (e.hasData()) continue;\n          if (o.canonical.z >= this._source.maxzoom) {\n            const e = o.children(this._source.maxzoom)[0],\n              i = this.getTile(e);\n            if (i && i.hasData()) {\n              t[e.key] = e;\n              continue;\n            }\n          } else {\n            const e = o.children(this._source.maxzoom);\n            if (t[e[0].key] && t[e[1].key] && t[e[2].key] && t[e[3].key]) continue;\n          }\n          let r = e.wasRequested();\n          for (let n = o.overscaledZ - 1; n >= s; --n) {\n            const s = o.scaledTo(n);\n            if (i[s.key]) break;\n            if (i[s.key] = !0, e = this.getTile(s), !e && r && (e = this._addTile(s)), e && (t[s.key] = s, r = e.wasRequested(), e.hasData())) break;\n          }\n        }\n        return t;\n      }\n      _updateLoadedParentTileCache() {\n        this._loadedParentTiles = {};\n        for (const e in this._tiles) {\n          const t = [];\n          let i,\n            o = this._tiles[e].tileID;\n          for (; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n            t.push(o.key);\n            const e = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(e), i) break;\n            o = e;\n          }\n          for (const e of t) this._loadedParentTiles[e] = i;\n        }\n      }\n      _addTile(t) {\n        let i = this._tiles[t.key];\n        if (i) return !0 !== i.isExtraShadowCaster || !!this._shadowCasterTiles[t.key] || this._reloadTile(t.key, \"reloading\"), i;\n        i = this._cache.getAndRemove(t), i && (this._setTileReloadTimer(t.key, i), i.tileID = t, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, i)));\n        const o = Boolean(i);\n        if (!o) {\n          const e = this.map ? this.map.painter : null,\n            o = this._source.tileSize * t.overscaleFactor();\n          i = \"raster-array\" === this._source.type ? new $t(t, o, this.transform.tileZoom, e, this._isRaster) : new Gt(t, o, this.transform.tileZoom, e, this._isRaster), this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state));\n        }\n        return i ? (i.uses++, this._tiles[t.key] = i, o || this._source.fire(new e.b(\"dataloading\", {\n          tile: i,\n          coord: i.tileID,\n          dataType: \"source\"\n        })), i) : null;\n      }\n      _setTileReloadTimer(e, t) {\n        e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);\n        const i = t.getExpiryTimeout();\n        i && (this._timers[e] = setTimeout(() => {\n          this._reloadTile(e, \"expired\"), delete this._timers[e];\n        }, i));\n      }\n      _removeTile(e) {\n        const t = this._tiles[e];\n        t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() && \"reloading\" !== t.state || \"empty\" === t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t))));\n      }\n      clearTiles() {\n        this._shouldReloadOnResume = !1, this._paused = !1;\n        for (const e in this._tiles) this._removeTile(+e);\n        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);\n      }\n      tilesIn(t, i, o) {\n        const r = [],\n          s = this.transform;\n        if (!s) return r;\n        const n = \"globe\" === s.projection.name,\n          a = e.a5(s.center.lng);\n        for (const l in this._tiles) {\n          const c = this._tiles[l];\n          if (o && c.clearQueryDebugViz(), c.holdingForFade()) continue;\n          let h;\n          if (n) {\n            const t = c.tileID.canonical;\n            if (0 === t.z) {\n              const i = [Math.abs(e.aa(a, ...Qt(t, -1)) - a), Math.abs(e.aa(a, ...Qt(t, 1)) - a)];\n              h = [0, 2 * i.indexOf(Math.min(...i)) - 1];\n            } else {\n              const i = [Math.abs(e.aa(a, ...Qt(t, -1)) - a), Math.abs(e.aa(a, ...Qt(t, 0)) - a), Math.abs(e.aa(a, ...Qt(t, 1)) - a)];\n              h = [i.indexOf(Math.min(...i)) - 1];\n            }\n          } else h = [0];\n          for (const e of h) {\n            const o = t.containsTile(c, s, i, e);\n            o && r.push(o);\n          }\n        }\n        return r;\n      }\n      getShadowCasterCoordinates() {\n        return this._getRenderableCoordinates(!1, !0);\n      }\n      getVisibleCoordinates(e) {\n        return this._getRenderableCoordinates(e);\n      }\n      _getRenderableCoordinates(e, t) {\n        const i = this.getRenderableIds(e, t).map(e => this._tiles[e].tileID),\n          o = \"globe\" === this.transform.projection.name;\n        for (const e of i) e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped()), e.expandedProjMatrix = o ? this.transform.calculateProjMatrix(e.toUnwrapped(), !1, !0) : e.projMatrix;\n        return i;\n      }\n      sortCoordinatesByDistance(e) {\n        const t = e.slice(),\n          i = this.transform._camera.position,\n          o = this.transform._camera.forward(),\n          r = {};\n        for (const e of t) {\n          const t = 1 / (1 << e.canonical.z);\n          r[e.key] = ((e.canonical.x + .5) * t + e.wrap - i[0]) * o[0] + ((e.canonical.y + .5) * t - i[1]) * o[1] - i[2] * o[2];\n        }\n        return t.sort((e, t) => r[e.key] - r[t.key]), t;\n      }\n      hasTransition() {\n        if (this._source.hasTransition()) return !0;\n        if (Jt(this._source.type)) for (const t in this._tiles) {\n          const i = this._tiles[t];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.f.now()) return !0;\n        }\n        return !1;\n      }\n      setFeatureState(e, t, i) {\n        this._state.updateState(e = e || \"_geojsonTileLayer\", t, i);\n      }\n      removeFeatureState(e, t, i) {\n        this._state.removeFeatureState(e = e || \"_geojsonTileLayer\", t, i);\n      }\n      getFeatureState(e, t) {\n        return this._state.getState(e = e || \"_geojsonTileLayer\", t);\n      }\n      setDependencies(e, t, i) {\n        const o = this._tiles[e];\n        o && o.setDependencies(t, i);\n      }\n      reloadTilesForDependencies(e, t) {\n        for (const i in this._tiles) this._tiles[i].hasDependency(e, t) && this._reloadTile(+i, \"reloading\");\n        this._cache.filter(i => !i.hasDependency(e, t));\n      }\n      _preloadTiles(t, i) {\n        if (!this._sourceLoaded) {\n          const e = () => {\n            this._sourceLoaded && (this._source.off(\"data\", e), this._preloadTiles(t, i));\n          };\n          return void this._source.on(\"data\", e);\n        }\n        const o = new Map(),\n          r = Array.isArray(t) ? t : [t],\n          s = this.map.painter.terrain,\n          n = this.usedForTerrain && s ? s.getScaledDemTileSize() : this._source.tileSize;\n        for (const e of r) {\n          const t = e.coveringTiles({\n            tileSize: n,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom && !this.usedForTerrain,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain\n          });\n          for (const e of t) o.set(e.key, e);\n          this.usedForTerrain && e.updateElevation(!1);\n        }\n        const a = Array.from(o.values());\n        e.b1(a, (e, t) => {\n          const i = new Gt(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);\n          this._loadTile(i, e => {\n            \"raster-dem\" === this._source.type && i.dem && this._backfillDEM(i), t(e, i);\n          });\n        }, i);\n      }\n    }\n    function Yt(e, t) {\n      const i = Math.abs(2 * e.wrap) - +(e.wrap < 0),\n        o = Math.abs(2 * t.wrap) - +(t.wrap < 0);\n      return e.overscaledZ - t.overscaledZ || o - i || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x;\n    }\n    function Jt(e) {\n      return \"raster\" === e || \"image\" === e || \"video\" === e || \"custom\" === e;\n    }\n    function Qt(e, t) {\n      const i = 1 << e.z;\n      return [e.x / i + t, (e.x + 1) / i + t];\n    }\n    Kt.maxOverzooming = 10, Kt.maxUnderzooming = 3;\n    class ei {\n      constructor(e) {\n        this.style = e, this.layersGotHidden = !1, this.layers = [];\n      }\n      processLayersChanged() {\n        this.layers = [];\n        const e = !1,\n          t = !1;\n        for (const i in this.style._mergedLayers) {\n          const o = this.style._mergedLayers[i];\n          if (\"fill-extrusion\" === o.type) this.layers.push({\n            layer: o,\n            visible: e,\n            visibilityChanged: t\n          });else if (\"model\" === o.type) {\n            const i = this.style.getLayerSource(o);\n            i && \"batched-model\" === i.type && this.layers.push({\n              layer: o,\n              visible: e,\n              visibilityChanged: t\n            });\n          }\n        }\n      }\n      onNewFrame(e) {\n        this.layersGotHidden = !1;\n        for (const t of this.layers) {\n          const i = t.layer;\n          let o = !1;\n          \"fill-extrusion\" === i.type ? o = !i.isHidden(e) && i.paint.get(\"fill-extrusion-opacity\") > 0 : \"model\" === i.type && (o = !i.isHidden(e) && i.paint.get(\"model-opacity\") > 0), this.layersGotHidden = this.layersGotHidden || !o && t.visible, t.visible = o;\n        }\n      }\n      updateZOffset(e, t) {\n        this.currentBuildingBuckets = [];\n        for (const e of this.layers) {\n          const i = e.layer,\n            o = this.style.getLayerSourceCache(i);\n          let r = 1;\n          \"fill-extrusion\" === i.type && (r = e.visible ? i.paint.get(\"fill-extrusion-vertical-scale\") : 0);\n          let s = o ? o.getTile(t) : null;\n          if (!s && o && t.canonical.z > o.getSource().minzoom) {\n            let e = t.scaledTo(Math.min(o.getSource().maxzoom, t.overscaledZ - 1));\n            for (; e.overscaledZ >= o.getSource().minzoom && (s = o.getTile(e), !s && 0 !== e.overscaledZ);) e = e.scaledTo(e.overscaledZ - 1);\n          }\n          this.currentBuildingBuckets.push({\n            bucket: s ? s.getBucket(i) : null,\n            tileID: s ? s.tileID : t,\n            verticalScale: r\n          });\n        }\n        e.hasAnyZOffset = !1;\n        let i = !1;\n        for (let o = 0; o < e.symbolInstances.length; o++) {\n          const r = e.symbolInstances.get(o),\n            s = r.zOffset,\n            n = this._getHeightAtTileOffset(t, r.tileAnchorX, r.tileAnchorY);\n          r.zOffset = n !== Number.NEGATIVE_INFINITY ? n : s, i || s === r.zOffset || (i = !0), e.hasAnyZOffset || 0 === r.zOffset || (e.hasAnyZOffset = !0);\n        }\n        i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);\n      }\n      _mapCoordToOverlappingTile(t, i, o, r) {\n        let s = i,\n          n = o;\n        if (t.canonical.z !== r.canonical.z) {\n          const a = r.canonical,\n            l = 1 / (1 << t.canonical.z - a.z);\n          s = (i + t.canonical.x * e.V) * l - a.x * e.V | 0, n = (o + t.canonical.y * e.V) * l - a.y * e.V | 0;\n        }\n        return {\n          tileX: s,\n          tileY: n\n        };\n      }\n      _getHeightAtTileOffset(e, t, i) {\n        let o, r;\n        for (let s = 0; s < this.layers.length; ++s) {\n          if (\"fill-extrusion\" !== this.layers[s].layer.type) continue;\n          const {\n            bucket: n,\n            tileID: a,\n            verticalScale: l\n          } = this.currentBuildingBuckets[s];\n          if (!n) continue;\n          const {\n              tileX: c,\n              tileY: h\n            } = this._mapCoordToOverlappingTile(e, t, i, a),\n            u = n.getHeightAtTileCoord(c, h);\n          u && void 0 !== u.height && (u.hidden ? o = u.height : r = Math.max(u.height * l, r || 0));\n        }\n        if (void 0 !== r) return r;\n        for (let r = 0; r < this.layers.length; ++r) {\n          const s = this.layers[r];\n          if (\"model\" !== s.layer.type || !s.visible) continue;\n          const {\n            bucket: n,\n            tileID: a\n          } = this.currentBuildingBuckets[r];\n          if (!n) continue;\n          const {\n              tileX: l,\n              tileY: c\n            } = this._mapCoordToOverlappingTile(e, t, i, a),\n            h = n.getHeightAtTileCoord(l, c);\n          if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : (h.height || 0) * h.verticalScale;\n        }\n        return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;\n      }\n    }\n    function ti(t, i) {\n      const o = {};\n      for (const e in t) \"ref\" !== e && (o[e] = t[e]);\n      return e.b2.forEach(e => {\n        e in i && (o[e] = i[e]);\n      }), o;\n    }\n    function ii(e) {\n      e = e.slice();\n      const t = Object.create(null);\n      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];\n      for (let i = 0; i < e.length; i++) \"ref\" in e[i] && (e[i] = ti(e[i], t[e[i].ref]));\n      return e;\n    }\n    const oi = {\n      setStyle: \"setStyle\",\n      addLayer: \"addLayer\",\n      removeLayer: \"removeLayer\",\n      setPaintProperty: \"setPaintProperty\",\n      setLayoutProperty: \"setLayoutProperty\",\n      setSlot: \"setSlot\",\n      setFilter: \"setFilter\",\n      addSource: \"addSource\",\n      removeSource: \"removeSource\",\n      setGeoJSONSourceData: \"setGeoJSONSourceData\",\n      setLayerZoomRange: \"setLayerZoomRange\",\n      setLayerProperty: \"setLayerProperty\",\n      setCenter: \"setCenter\",\n      setZoom: \"setZoom\",\n      setBearing: \"setBearing\",\n      setPitch: \"setPitch\",\n      setSprite: \"setSprite\",\n      setGlyphs: \"setGlyphs\",\n      setTransition: \"setTransition\",\n      setLight: \"setLight\",\n      setTerrain: \"setTerrain\",\n      setFog: \"setFog\",\n      setCamera: \"setCamera\",\n      setLights: \"setLights\",\n      setProjection: \"setProjection\",\n      addImport: \"addImport\",\n      removeImport: \"removeImport\",\n      updateImport: \"updateImport\"\n    };\n    function ri(e, t, i) {\n      i.push({\n        command: oi.addSource,\n        args: [e, t[e]]\n      });\n    }\n    function si(e, t, i) {\n      t.push({\n        command: oi.removeSource,\n        args: [e]\n      }), i[e] = !0;\n    }\n    function ni(e, t, i, o) {\n      si(e, i, o), ri(e, t, i);\n    }\n    function ai(e, i, o) {\n      let r;\n      for (r in e[o]) if (e[o].hasOwnProperty(r) && \"data\" !== r && !t(e[o][r], i[o][r])) return !1;\n      for (r in i[o]) if (i[o].hasOwnProperty(r) && \"data\" !== r && !t(e[o][r], i[o][r])) return !1;\n      return !0;\n    }\n    function li(e, i, o, r, s, n) {\n      let a;\n      for (a in i = i || {}, e = e || {}) e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({\n        command: n,\n        args: [r, a, i[a], s]\n      }));\n      for (a in i) i.hasOwnProperty(a) && !e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({\n        command: n,\n        args: [r, a, i[a], s]\n      }));\n    }\n    function ci(e) {\n      return e.id;\n    }\n    function hi(e, t) {\n      return e[t.id] = t, e;\n    }\n    class ui {\n      constructor(e, t) {\n        this.reset(e, t);\n      }\n      reset(e, t) {\n        this.points = e || [], this._distances = [0];\n        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);\n        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n      }\n      lerp(t) {\n        if (1 === this.points.length) return this.points[0];\n        t = e.aa(t, 0, 1);\n        let i = 1,\n          o = this._distances[i];\n        const r = t * this.paddedLength + this.padding;\n        for (; o < r && i < this._distances.length;) o = this._distances[++i];\n        const s = i - 1,\n          n = this._distances[s],\n          a = o - n,\n          l = a > 0 ? (r - n) / a : 0;\n        return this.points[s].mult(1 - l).add(this.points[i].mult(l));\n      }\n    }\n    class di {\n      constructor(e, t, i) {\n        const o = this.boxCells = [],\n          r = this.circleCells = [];\n        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);\n        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), r.push([]);\n        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;\n      }\n      keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n      }\n      insert(e, t, i, o, r) {\n        this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);\n      }\n      insertCircle(e, t, i, o) {\n        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);\n      }\n      _insertBoxCell(e, t, i, o, r, s) {\n        this.boxCells[r].push(s);\n      }\n      _insertCircleCell(e, t, i, o, r, s) {\n        this.circleCells[r].push(s);\n      }\n      _query(e, t, i, o, r, s) {\n        if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];\n        const n = [];\n        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {\n          if (r) return !0;\n          for (let e = 0; e < this.boxKeys.length; e++) n.push({\n            key: this.boxKeys[e],\n            x1: this.bboxes[4 * e],\n            y1: this.bboxes[4 * e + 1],\n            x2: this.bboxes[4 * e + 2],\n            y2: this.bboxes[4 * e + 3]\n          });\n          for (let e = 0; e < this.circleKeys.length; e++) {\n            const t = this.circles[3 * e],\n              i = this.circles[3 * e + 1],\n              o = this.circles[3 * e + 2];\n            n.push({\n              key: this.circleKeys[e],\n              x1: t - o,\n              y1: i - o,\n              x2: t + o,\n              y2: i + o\n            });\n          }\n          return s ? n.filter(s) : n;\n        }\n        return this._forEachCell(e, t, i, o, this._queryCell, n, {\n          hitTest: r,\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, s), r ? n.length > 0 : n;\n      }\n      _queryCircle(e, t, i, o, r) {\n        const s = e - i,\n          n = e + i,\n          a = t - i,\n          l = t + i;\n        if (n < 0 || s > this.width || l < 0 || a > this.height) return !o && [];\n        const c = [];\n        return this._forEachCell(s, a, n, l, this._queryCellCircle, c, {\n          hitTest: o,\n          circle: {\n            x: e,\n            y: t,\n            radius: i\n          },\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, r), o ? c.length > 0 : c;\n      }\n      query(e, t, i, o, r) {\n        return this._query(e, t, i, o, !1, r);\n      }\n      hitTest(e, t, i, o, r) {\n        return this._query(e, t, i, o, !0, r);\n      }\n      hitTestCircle(e, t, i, o) {\n        return this._queryCircle(e, t, i, !0, o);\n      }\n      _queryCell(e, t, i, o, r, s, n, a) {\n        const l = n.seenUids,\n          c = this.boxCells[r];\n        if (null !== c) {\n          const r = this.bboxes;\n          for (const h of c) if (!l.box[h]) {\n            l.box[h] = !0;\n            const c = 4 * h;\n            if (e <= r[c + 2] && t <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {\n              if (n.hitTest) return s.push(!0), !0;\n              s.push({\n                key: this.boxKeys[h],\n                x1: r[c],\n                y1: r[c + 1],\n                x2: r[c + 2],\n                y2: r[c + 3]\n              });\n            }\n          }\n        }\n        const h = this.circleCells[r];\n        if (null !== h) {\n          const r = this.circles;\n          for (const c of h) if (!l.circle[c]) {\n            l.circle[c] = !0;\n            const h = 3 * c;\n            if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t, i, o) && (!a || a(this.circleKeys[c]))) {\n              if (n.hitTest) return s.push(!0), !0;\n              {\n                const e = r[h],\n                  t = r[h + 1],\n                  i = r[h + 2];\n                s.push({\n                  key: this.circleKeys[c],\n                  x1: e - i,\n                  y1: t - i,\n                  x2: e + i,\n                  y2: t + i\n                });\n              }\n            }\n          }\n        }\n      }\n      _queryCellCircle(e, t, i, o, r, s, n, a) {\n        const l = n.circle,\n          c = n.seenUids,\n          h = this.boxCells[r];\n        if (null !== h) {\n          const e = this.bboxes;\n          for (const t of h) if (!c.box[t]) {\n            c.box[t] = !0;\n            const i = 4 * t;\n            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t]))) return s.push(!0), !0;\n          }\n        }\n        const u = this.circleCells[r];\n        if (null !== u) {\n          const e = this.circles;\n          for (const t of u) if (!c.circle[t]) {\n            c.circle[t] = !0;\n            const i = 3 * t;\n            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t]))) return s.push(!0), !0;\n          }\n        }\n      }\n      _forEachCell(e, t, i, o, r, s, n, a) {\n        const l = this._convertToXCellCoord(e),\n          c = this._convertToYCellCoord(t),\n          h = this._convertToXCellCoord(i),\n          u = this._convertToYCellCoord(o);\n        for (let d = l; d <= h; d++) for (let l = c; l <= u; l++) if (r.call(this, e, t, i, o, this.xCellCount * l + d, s, n, a)) return;\n      }\n      _convertToXCellCoord(e) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));\n      }\n      _convertToYCellCoord(e) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));\n      }\n      _circlesCollide(e, t, i, o, r, s) {\n        const n = o - e,\n          a = r - t,\n          l = i + s;\n        return l * l > n * n + a * a;\n      }\n      _circleAndRectCollide(e, t, i, o, r, s, n) {\n        const a = (s - o) / 2,\n          l = Math.abs(e - (o + a));\n        if (l > a + i) return !1;\n        const c = (n - r) / 2,\n          h = Math.abs(t - (r + c));\n        if (h > c + i) return !1;\n        if (l <= a || h <= c) return !0;\n        const u = l - a,\n          d = h - c;\n        return u * u + d * d <= i * i;\n      }\n    }\n    const _i = {\n        unknown: 0,\n        flipRequired: 1,\n        flipNotRequired: 2\n      },\n      pi = Math.tan(85 * Math.PI / 180);\n    function fi(t, i, o, r, s, n, a) {\n      const l = e.a6.create();\n      if (o) {\n        if (\"globe\" === n.name) {\n          const t = e.b3(s, i);\n          e.a6.multiply(l, l, t);\n        } else {\n          const t = e.b4.invert([], a);\n          l[0] = t[0], l[1] = t[1], l[4] = t[2], l[5] = t[3], r || e.a6.rotateZ(l, l, s.angle);\n        }\n      } else e.a6.multiply(l, s.labelPlaneMatrix, t);\n      return l;\n    }\n    function mi(e, t, i, o, r, s, n) {\n      const a = fi(e, t, i, o, r, s, n);\n      return \"globe\" === s.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;\n    }\n    function gi(t, i, o, r, s, n, a) {\n      if (o) {\n        if (\"globe\" === n.name) {\n          const l = fi(t, i, o, r, s, n, a);\n          return e.a6.invert(l, l), e.a6.multiply(l, t, l), l;\n        }\n        {\n          const i = e.a6.clone(t),\n            o = e.a6.identity([]);\n          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.a6.multiply(i, i, o), r || e.a6.rotateZ(i, i, -s.angle), i;\n        }\n      }\n      return s.glCoordMatrix;\n    }\n    function vi(t, i, o, r) {\n      const s = [t, i, o, 1];\n      o ? e.a7.transformMat4(s, s, r) : Li(s, s, r);\n      const n = s[3];\n      return s[0] /= n, s[1] /= n, s[2] /= n, s;\n    }\n    function xi(e, t) {\n      return Math.min(.5 + e / t * .5, 1.5);\n    }\n    function yi(e, t) {\n      const i = e[0] / e[3],\n        o = e[1] / e[3];\n      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];\n    }\n    function bi(t, i, o, r, s, n, a, l, c, h) {\n      const u = o.transform,\n        d = r ? t.textSizeData : t.iconSizeData,\n        _ = e.b5(d, o.transform.zoom),\n        p = \"globe\" === u.projection.name,\n        f = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n        m = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;\n      m.clear();\n      let g = null;\n      p && (g = r ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray);\n      const v = t.lineVertexArray,\n        x = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,\n        y = o.transform.width / o.transform.height;\n      let b,\n        w = !1;\n      for (let r = 0; r < x.length; r++) {\n        const p = x.get(r),\n          {\n            numGlyphs: T,\n            writingMode: E\n          } = p;\n        if (E !== e.b6.vertical || w || b === e.b6.horizontal || (w = !0), b = E, (p.hidden || E === e.b6.vertical) && !w) {\n          Di(T, m);\n          continue;\n        }\n        w = !1;\n        const S = new e.P(p.tileAnchorX, p.tileAnchorY);\n        let {\n          x: C,\n          y: I,\n          z: D\n        } = u.projection.projectTilePoint(S.x, S.y, h.canonical);\n        if (c) {\n          const [e, t, i] = c(S);\n          C += e, I += t, D += i;\n        }\n        const L = [C, I, D, 1];\n        if (e.a7.transformMat4(L, L, i), !yi(L, f)) {\n          Di(T, m);\n          continue;\n        }\n        const A = L[3],\n          R = xi(o.transform.getCameraToCenterDistance(u.projection), A),\n          P = e.b7(d, _, p),\n          M = a ? P / R : P * R,\n          z = vi(C, I, D, s);\n        if (z[3] <= 0) {\n          Di(T, m);\n          continue;\n        }\n        let O = {};\n        const F = a ? null : c,\n          B = Ei(p, M, !1, l, i, s, n, t.glyphOffsetArray, v, m, g, z, S, O, y, F, u.projection, h, a);\n        w = B.useVertical, F && B.needsFlipping && (O = {}), (B.notEnoughRoom || w || B.needsFlipping && Ei(p, M, !0, l, i, s, n, t.glyphOffsetArray, v, m, g, z, S, O, y, F, u.projection, h, a).notEnoughRoom) && Di(T, m);\n      }\n      r ? (t.text.dynamicLayoutVertexBuffer.updateData(m), g && t.text.globeExtVertexBuffer && t.text.globeExtVertexBuffer.updateData(g)) : (t.icon.dynamicLayoutVertexBuffer.updateData(m), g && t.icon.globeExtVertexBuffer && t.icon.globeExtVertexBuffer.updateData(g));\n    }\n    function wi(e, t, i, o, r, s, n, a, l, c, h, u, d, _, p, f) {\n      const {\n          lineStartIndex: m,\n          glyphStartIndex: g,\n          segment: v\n        } = a,\n        x = g + a.numGlyphs,\n        y = m + a.lineLength,\n        b = t.getoffsetX(g),\n        w = t.getoffsetX(x - 1),\n        T = Ii(e * b, i, o, r, s, n, v, m, y, l, c, h, u, d, !0, _, p, f);\n      if (!T) return null;\n      const E = Ii(e * w, i, o, r, s, n, v, m, y, l, c, h, u, d, !0, _, p, f);\n      return E ? {\n        first: T,\n        last: E\n      } : null;\n    }\n    function Ti(t, i, o, r) {\n      return t === e.b6.horizontal && Math.abs(r) > Math.abs(o) ? {\n        useVertical: !0\n      } : t === e.b6.vertical ? r > 0 ? {\n        needsFlipping: !0\n      } : null : i !== _i.unknown && function (e, t) {\n        return 0 === e || Math.abs(t / e) > pi;\n      }(o, r) ? i === _i.flipRequired ? {\n        needsFlipping: !0\n      } : null : o < 0 ? {\n        needsFlipping: !0\n      } : null;\n    }\n    function Ei(t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g, v, x) {\n      const y = i / 24,\n        b = t.lineOffsetX * y,\n        w = t.lineOffsetY * y,\n        {\n          lineStartIndex: T,\n          glyphStartIndex: E,\n          numGlyphs: S,\n          segment: C,\n          writingMode: I,\n          flipState: D\n        } = t,\n        L = T + t.lineLength,\n        A = t => {\n          if (u) {\n            const [i, o, r] = t.up,\n              s = h.length;\n            e.b8(u, s + 0, i, o, r), e.b8(u, s + 1, i, o, r), e.b8(u, s + 2, i, o, r), e.b8(u, s + 3, i, o, r);\n          }\n          const [i, o, r] = t.point;\n          e.b9(h, i, o, r, t.angle);\n        };\n      if (S > 1) {\n        const e = wi(y, l, b, w, o, d, _, t, c, n, p, m, !1, g, v, x);\n        if (!e) return {\n          notEnoughRoom: !0\n        };\n        if (r && !o) {\n          let [i, o, r] = e.first.point,\n            [s, n, l] = e.last.point;\n          [i, o] = vi(i, o, r, a), [s, n] = vi(s, n, l, a);\n          const c = Ti(I, D, (s - i) * f, n - o);\n          if (t.flipState = c && c.needsFlipping ? _i.flipRequired : _i.flipNotRequired, c) return c;\n        }\n        A(e.first);\n        for (let e = E + 1; e < E + S - 1; e++) {\n          const t = Ii(y * l.getoffsetX(e), b, w, o, d, _, C, T, L, c, n, p, m, !1, !1, g, v, x);\n          if (!t) return h.length -= 4 * (e - E), {\n            notEnoughRoom: !0\n          };\n          A(t);\n        }\n        A(e.last);\n      } else {\n        if (r && !o) {\n          const i = vi(_.x, _.y, 0, s),\n            o = T + C + 1,\n            r = new e.P(c.getx(o), c.gety(o)),\n            n = vi(r.x, r.y, 0, s),\n            a = n[3] > 0 ? n : Ci(_, r, i, 1, s, void 0, g, v.canonical),\n            l = Ti(I, D, (a[0] - i[0]) * f, a[1] - i[1]);\n          if (t.flipState = l && l.needsFlipping ? _i.flipRequired : _i.flipNotRequired, l) return l;\n        }\n        const i = Ii(y * l.getoffsetX(E), b, w, o, d, _, C, T, L, c, n, p, m, !1, !1, g, v, x);\n        if (!i) return {\n          notEnoughRoom: !0\n        };\n        A(i);\n      }\n      return {};\n    }\n    function Si(e, t, i, o, r) {\n      const {\n        x: s,\n        y: n,\n        z: a\n      } = o.projectTilePoint(e.x, e.y, t);\n      if (!r) return vi(s, n, a, i);\n      const [l, c, h] = r(e);\n      return vi(s + l, n + c, a + h, i);\n    }\n    function Ci(t, i, o, r, s, n, a, l) {\n      const c = Si(t.sub(i)._unit()._add(t), l, s, a, n);\n      return e.N.sub(c, o, c), e.N.normalize(c, c), e.N.scaleAndAdd(c, o, c, r);\n    }\n    function Ii(t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g, v) {\n      const x = r ? t - i : t + i;\n      let y = x > 0 ? 1 : -1,\n        b = 0;\n      r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);\n      let w = l + a + (y > 0 ? 0 : 1) | 0,\n        T = s,\n        E = s,\n        S = 0,\n        C = 0;\n      const I = Math.abs(x),\n        D = [],\n        L = [];\n      let A = n,\n        R = A;\n      const P = () => Ci(R, A, E, I - S + 1, u, _, m, g.canonical);\n      for (; S + C <= I;) {\n        if (w += y, w < l || w >= c) return null;\n        if (E = T, R = A, D.push(E), p && L.push(R), A = new e.P(h.getx(w), h.gety(w)), T = d[w], !T) {\n          const e = Si(A, g.canonical, u, m, _);\n          T = e[3] > 0 ? d[w] = e : P();\n        }\n        S += C, C = e.N.distance(E, T);\n      }\n      f && _ && (d[w] && (T = P(), C = e.N.distance(E, T)), d[w] = T);\n      const M = (I - S) / C,\n        z = A.sub(R)._mult(M)._add(R),\n        O = e.N.sub([], T, E),\n        F = e.N.scaleAndAdd([], E, O, M);\n      let B = [0, 0, 1],\n        k = O[0],\n        N = O[1];\n      if (v && (B = m.upVector(g.canonical, z.x, z.y), 0 !== B[0] || 0 !== B[1] || 1 !== B[2])) {\n        const t = [B[2], 0, -B[0]],\n          i = e.N.cross([], B, t);\n        e.N.normalize(t, t), e.N.normalize(i, i), k = e.N.dot(O, t), N = e.N.dot(O, i);\n      }\n      if (o) {\n        const t = e.N.cross([], B, O);\n        e.N.normalize(t, t), e.N.scaleAndAdd(F, F, t, o * y);\n      }\n      const U = b + Math.atan2(N, k);\n      return D.push(F), p && L.push(z), {\n        point: F,\n        angle: U,\n        path: D,\n        tilePath: L,\n        up: B\n      };\n    }\n    function Di(e, t) {\n      const i = t.length,\n        o = i + 4 * e;\n      t.resize(o), t.float32.fill(-1 / 0, 4 * i, 4 * o);\n    }\n    function Li(e, t, i) {\n      const o = t[0],\n        r = t[1];\n      return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;\n    }\n    const Ai = 100;\n    class Ri {\n      constructor(e, t, i = new di(e.width + 200, e.height + 200, 25), o = new di(e.width + 200, e.height + 200, 25)) {\n        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Ai, this.screenBottomBoundary = e.height + Ai, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;\n      }\n      placeCollisionBox(e, t, i, o, r, s, n, a) {\n        let l = i.projectedAnchorX,\n          c = i.projectedAnchorY,\n          h = i.projectedAnchorZ;\n        const u = i.elevation,\n          d = i.tileID,\n          _ = e.getProjection();\n        if (u && d) {\n          const [e, t, o] = _.upVector(d.canonical, i.tileAnchorX, i.tileAnchorY),\n            r = _.upVectorScale(d.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;\n          l += e * u * r, c += t * u * r, h += o * u * r;\n        }\n        const p = this.projectAndGetPerspectiveRatio(n, l, c, h, i.tileID, \"globe\" === _.name || !!u || this.transform.pitch > 0, _),\n          f = s * p.perspectiveRatio,\n          m = (i.x1 * t + o.x - i.padding) * f + p.point.x,\n          g = (i.y1 * t + o.y - i.padding) * f + p.point.y,\n          v = (i.x2 * t + o.x + i.padding) * f + p.point.x,\n          x = (i.y2 * t + o.y + i.padding) * f + p.point.y,\n          y = p.perspectiveRatio <= .55 || p.occluded;\n        return !this.isInsideGrid(m, g, v, x) || !r && this.grid.hitTest(m, g, v, x, a) || y ? {\n          box: [],\n          offscreen: !1,\n          occluded: p.occluded\n        } : {\n          box: [m, g, v, x],\n          offscreen: this.isOffscreen(m, g, v, x),\n          occluded: !1\n        };\n      }\n      placeCollisionCircles(t, i, o, r, s, n, a, l, c, h, u, d, _, p, f) {\n        const m = [],\n          g = this.transform.elevation,\n          v = t.getProjection(),\n          x = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, v) : null,\n          y = new e.P(o.tileAnchorX, o.tileAnchorY);\n        let {\n          x: b,\n          y: w,\n          z: T\n        } = v.projectTilePoint(y.x, y.y, f.canonical);\n        if (x) {\n          const [e, t, i] = x(y);\n          b += e, w += t, T += i;\n        }\n        const E = \"globe\" === v.name,\n          S = this.projectAndGetPerspectiveRatio(a, b, w, T, f, E || !!g || this.transform.pitch > 0, v),\n          {\n            perspectiveRatio: C\n          } = S,\n          I = (u ? n / C : n * C) / e.bc,\n          D = vi(b, w, T, l),\n          L = S.signedDistanceFromCamera > 0 ? wi(I, s, o.lineOffsetX * I, o.lineOffsetY * I, !1, D, y, o, r, l, {}, g && !u ? x : null, u && !!g, v, f, u) : null;\n        let A = !1,\n          R = !1,\n          P = !0;\n        if (L && !S.occluded) {\n          const t = .5 * _ * C + p,\n            o = new e.P(-100, -100),\n            r = new e.P(this.screenRightBoundary, this.screenBottomBoundary),\n            s = new ui(),\n            {\n              first: n,\n              last: a\n            } = L,\n            l = n.path.length;\n          let u = [];\n          for (let e = l - 1; e >= 1; e--) u.push(n.path[e]);\n          for (let e = 1; e < a.path.length; e++) u.push(a.path[e]);\n          const f = 2.5 * t;\n          c && (u = u.map(([e, t, i], o) => (x && !E && (i = x(o < l - 1 ? n.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), vi(e, t, i, c))), u.some(e => e[3] <= 0) && (u = []));\n          let g = [];\n          if (u.length > 0) {\n            let t = 1 / 0,\n              i = -1 / 0,\n              s = 1 / 0,\n              n = -1 / 0;\n            for (const e of u) t = Math.min(t, e[0]), s = Math.min(s, e[1]), i = Math.max(i, e[0]), n = Math.max(n, e[1]);\n            i >= o.x && t <= r.x && n >= o.y && s <= r.y && (g = [u.map(t => new e.P(t[0], t[1]))], (t < o.x || i > r.x || s < o.y || n > r.y) && (g = e.ba(g, o.x, o.y, r.x, r.y)));\n          }\n          for (const e of g) {\n            s.reset(e, .25 * t);\n            let o = 0;\n            o = s.length <= .5 * t ? 1 : Math.ceil(s.paddedLength / f) + 1;\n            for (let e = 0; e < o; e++) {\n              const r = e / Math.max(o - 1, 1),\n                n = s.lerp(r),\n                a = n.x + Ai,\n                l = n.y + Ai;\n              m.push(a, l, t, 0);\n              const c = a - t,\n                u = l - t,\n                _ = a + t,\n                p = l + t;\n              if (P = P && this.isOffscreen(c, u, _, p), R = R || this.isInsideGrid(c, u, _, p), !i && this.grid.hitTestCircle(a, l, t, d) && (A = !0, !h)) return {\n                circles: [],\n                offscreen: !1,\n                collisionDetected: A,\n                occluded: !1\n              };\n            }\n          }\n        }\n        return {\n          circles: !h && A || !R ? [] : m,\n          offscreen: P,\n          collisionDetected: A,\n          occluded: S.occluded\n        };\n      }\n      queryRenderedSymbols(t) {\n        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n        const i = [];\n        let o = 1 / 0,\n          r = 1 / 0,\n          s = -1 / 0,\n          n = -1 / 0;\n        for (const a of t) {\n          const t = new e.P(a.x + Ai, a.y + Ai);\n          o = Math.min(o, t.x), r = Math.min(r, t.y), s = Math.max(s, t.x), n = Math.max(n, t.y), i.push(t);\n        }\n        const a = this.grid.query(o, r, s, n).concat(this.ignoredGrid.query(o, r, s, n)),\n          l = {},\n          c = {};\n        for (const t of a) {\n          const o = t.key;\n          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;\n          const r = [new e.P(t.x1, t.y1), new e.P(t.x2, t.y1), new e.P(t.x2, t.y2), new e.P(t.x1, t.y2)];\n          e.bb(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));\n        }\n        return c;\n      }\n      insertCollisionBox(e, t, i, o, r) {\n        (t ? this.ignoredGrid : this.grid).insert({\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: r\n        }, e[0], e[1], e[2], e[3]);\n      }\n      insertCollisionCircles(e, t, i, o, r) {\n        const s = t ? this.ignoredGrid : this.grid,\n          n = {\n            bucketInstanceId: i,\n            featureIndex: o,\n            collisionGroupID: r\n          };\n        for (let t = 0; t < e.length; t += 4) s.insertCircle(n, e[t], e[t + 1], e[t + 2]);\n      }\n      projectAndGetPerspectiveRatio(t, i, o, r, s, n, a) {\n        const l = [i, o, r, 1];\n        let c = !1;\n        if (r || this.transform.pitch > 0) {\n          if (e.a7.transformMat4(l, l, t), this.fogState && s && \"globe\" !== a.name) {\n            const t = function (t, i, o, r, s, n) {\n              const a = n.calculateFogTileMatrix(s),\n                l = [i, o, r];\n              return e.N.transformMat4(l, l, a), ge(t, e.N.length(l), n.pitch, n._fov);\n            }(this.fogState, i, o, r, s.toUnwrapped(), this.transform);\n            c = t > .9;\n          }\n        } else Li(l, l, t);\n        const h = l[3];\n        return {\n          point: new e.P((l[0] / h + 1) / 2 * this.transform.width + Ai, (-l[1] / h + 1) / 2 * this.transform.height + Ai),\n          perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),\n          signedDistanceFromCamera: h,\n          occluded: n && l[2] > h || c\n        };\n      }\n      isOffscreen(e, t, i, o) {\n        return i < Ai || e >= this.screenRightBoundary || o < Ai || t > this.screenBottomBoundary;\n      }\n      isInsideGrid(e, t, i, o) {\n        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;\n      }\n      getViewportMatrix() {\n        const t = e.a6.identity([]);\n        return e.a6.translate(t, t, [-100, -100, 0]), t;\n      }\n    }\n    function Pi(t, i, o) {\n      const r = i.createTileMatrix(t, t.worldSize, o.toUnwrapped());\n      return e.a6.multiply(new Float32Array(16), t.projMatrix, r);\n    }\n    function Mi(e, t, i) {\n      if (t.projection.name === i.projection.name) return e.projMatrix;\n      const o = i.clone();\n      return o.setProjection(t.projection), Pi(o, t.getProjection(), e);\n    }\n    function zi(e, t, i) {\n      return t.name === i.projection.name ? e.projMatrix : Pi(i, t, e);\n    }\n    class Oi {\n      constructor(e, t, i, o) {\n        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;\n      }\n      isHidden() {\n        return 0 === this.opacity && !this.placed;\n      }\n    }\n    class Fi {\n      constructor(e, t, i, o, r, s = !1) {\n        this.text = new Oi(e ? e.text : null, t, i, r), this.icon = new Oi(e ? e.icon : null, t, o, r), this.clipped = s;\n      }\n      isHidden() {\n        return this.text.isHidden() && this.icon.isHidden();\n      }\n    }\n    class Bi {\n      constructor(e, t, i, o = !1) {\n        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;\n      }\n    }\n    class ki {\n      constructor() {\n        this.invProjMatrix = e.a6.create(), this.viewportMatrix = e.a6.create(), this.circles = [];\n      }\n    }\n    class Ni {\n      constructor(e, t, i, o, r) {\n        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;\n      }\n    }\n    class Ui {\n      constructor(e) {\n        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};\n      }\n      get(e) {\n        if (this.crossSourceCollisions) return {\n          ID: 0,\n          predicate: null\n        };\n        if (!this.collisionGroups[e]) {\n          const t = ++this.maxGroupID;\n          this.collisionGroups[e] = {\n            ID: t,\n            predicate: e => e.collisionGroupID === t\n          };\n        }\n        return this.collisionGroups[e];\n      }\n    }\n    function Gi(t, i, o, r, s) {\n      const {\n          horizontalAlign: n,\n          verticalAlign: a\n        } = e.bf(t),\n        l = -(n - .5) * i,\n        c = -(a - .5) * o,\n        h = e.bd(t, r);\n      return new e.P(l + h[0] * s, c + h[1] * s);\n    }\n    function ji(t, i, o, r, s) {\n      const n = new e.P(t, i);\n      return o && n._rotate(r ? s : -s), n;\n    }\n    class Vi {\n      constructor(e, t, i, o, r, s) {\n        this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new Ri(this.transform, r), this.buildingIndex = s, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new Ui(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n      }\n      getBucketParts(t, i, o, r) {\n        const s = o.getBucket(i),\n          n = o.latestFeatureIndex;\n        if (!s || !n || i.fqid !== s.layerIds[0]) return;\n        const a = s.layers[0].layout,\n          l = o.collisionBoxArray,\n          c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n          h = o.tileSize / e.V,\n          u = o.tileID.toUnwrapped();\n        this.transform.setProjection(s.projection);\n        const d = (_ = o.tileID, p = s.getProjection(), f = this.transform, p.name === this.projection ? f.calculateProjMatrix(_.toUnwrapped()) : Pi(f, p, _));\n        var _, p, f;\n        const m = \"map\" === a.get(\"text-pitch-alignment\"),\n          g = \"map\" === a.get(\"text-rotation-alignment\");\n        i.compileFilter();\n        const v = i.dynamicFilter(),\n          x = i.dynamicFilterNeedsFeature(),\n          y = this.transform.calculatePixelsToTileUnitsMatrix(o),\n          b = mi(d, o.tileID.canonical, m, g, this.transform, s.getProjection(), y);\n        let w = null;\n        if (m) {\n          const t = gi(d, o.tileID.canonical, m, g, this.transform, s.getProjection(), y);\n          w = e.a6.multiply([], this.transform.labelPlaneMatrix, t);\n        }\n        let T = null;\n        v && o.latestFeatureIndex && (T = {\n          unwrappedTileID: u,\n          dynamicFilter: v,\n          dynamicFilterNeedsFeature: x,\n          featureIndex: o.latestFeatureIndex\n        }), this.retainedQueryData[s.bucketInstanceId] = new Ni(s.bucketInstanceId, n, s.sourceLayerIndex, s.index, o.tileID);\n        const E = {\n          bucket: s,\n          layout: a,\n          posMatrix: d,\n          textLabelPlaneMatrix: b,\n          labelToScreenMatrix: w,\n          clippingData: T,\n          scale: c,\n          textPixelRatio: h,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: l,\n          partiallyEvaluatedTextSize: e.b5(s.textSizeData, this.transform.zoom),\n          partiallyEvaluatedIconSize: e.b5(s.iconSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(s.sourceID)\n        };\n        if (r) for (const e of s.sortKeyRanges) {\n          const {\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: r\n          } = e;\n          t.push({\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: r,\n            parameters: E\n          });\n        } else t.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: s.symbolInstances.length,\n          parameters: E\n        });\n      }\n      attemptAnchorPlacement(e, t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g) {\n        const {\n            textOffset0: v,\n            textOffset1: x,\n            crossTileID: y\n          } = u,\n          b = [v, x],\n          w = Gi(e, i, o, b, r),\n          T = this.collisionIndex.placeCollisionBox(_, r, t, ji(w.x, w.y, s, n, this.transform.angle), h, a, l, c.predicate);\n        if (f) {\n          const e = _.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);\n          if (0 === this.collisionIndex.placeCollisionBox(_, e, f, ji(w.x, w.y, s, n, this.transform.angle), h, a, l, c.predicate).box.length) return;\n        }\n        if (T.box.length > 0) {\n          let t;\n          return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = {\n            textOffset: b,\n            width: i,\n            height: o,\n            anchor: e,\n            textScale: r,\n            prevAnchor: t\n          }, this.markUsedJustification(_, e, u, p), _.allowVerticalPlacement && (this.markUsedOrientation(_, p, u), this.placedOrientations[y] = p), {\n            shift: w,\n            placedGlyphBoxes: T\n          };\n        }\n      }\n      placeLayerBucketPart(t, i, o, r) {\n        const {\n            bucket: s,\n            layout: n,\n            posMatrix: a,\n            textLabelPlaneMatrix: l,\n            labelToScreenMatrix: c,\n            clippingData: h,\n            textPixelRatio: u,\n            holdingForFade: d,\n            collisionBoxArray: _,\n            partiallyEvaluatedTextSize: p,\n            partiallyEvaluatedIconSize: f,\n            collisionGroup: m\n          } = t.parameters,\n          g = n.get(\"text-optional\"),\n          v = n.get(\"icon-optional\"),\n          x = n.get(\"text-allow-overlap\"),\n          y = n.get(\"icon-allow-overlap\"),\n          b = \"map\" === n.get(\"text-rotation-alignment\"),\n          w = \"map\" === n.get(\"text-pitch-alignment\"),\n          T = \"viewport-y\" === n.get(\"symbol-z-order\"),\n          E = n.get(\"symbol-z-elevate\");\n        this.transform.setProjection(s.projection);\n        let S = x && (y || !s.hasIconData() || v),\n          C = y && (x || !s.hasTextData() || g);\n        !s.collisionArrays && _ && s.deserializeCollisionBoxes(_), o && r && s.updateCollisionDebugBuffers(this.transform.zoom, _);\n        const I = (t, r, _) => {\n          const {\n            crossTileID: T,\n            numVerticalGlyphVertices: E\n          } = t;\n          if (h) {\n            const o = {\n              zoom: this.transform.zoom,\n              pitch: this.transform.pitch\n            };\n            let r = null;\n            if (h.dynamicFilterNeedsFeature) {\n              const e = this.retainedQueryData[s.bucketInstanceId];\n              r = h.featureIndex.loadFeature({\n                featureIndex: t.featureIndex,\n                bucketIndex: e.bucketIndex,\n                sourceLayerIndex: e.sourceLayerIndex,\n                layoutVertexArrayOffset: 0\n              });\n            }\n            if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[s.bucketInstanceId].tileID.canonical, new e.P(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[T] = new Bi(!1, !1, !1, !0), void i.add(T);\n          }\n          if (i.has(T)) return;\n          if (d) return void (this.placements[T] = new Bi(!1, !1, !1));\n          let I = !1,\n            D = !1,\n            L = !0,\n            A = !1,\n            R = !1,\n            P = null,\n            M = {\n              box: null,\n              offscreen: null,\n              occluded: null\n            },\n            z = {\n              box: null,\n              offscreen: null,\n              occluded: null\n            },\n            O = null,\n            F = null,\n            B = null,\n            k = 0,\n            N = 0,\n            U = 0;\n          _.textFeatureIndex ? k = _.textFeatureIndex : t.useRuntimeCollisionCircles && (k = t.featureIndex), _.verticalTextFeatureIndex && (N = _.verticalTextFeatureIndex);\n          const G = e => {\n              e.tileID = this.retainedQueryData[s.bucketInstanceId].tileID;\n              const i = this.transform.elevation;\n              e.elevation = t.zOffset + (i ? i.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0);\n            },\n            j = _.textBox;\n          if (j) {\n            G(j);\n            const i = i => {\n                let o = e.b6.horizontal;\n                if (s.allowVerticalPlacement && !i && this.prevPlacement) {\n                  const e = this.prevPlacement.placedOrientations[T];\n                  e && (this.placedOrientations[T] = e, o = e, this.markUsedOrientation(s, o, t));\n                }\n                return o;\n              },\n              o = (t, i) => {\n                if (s.allowVerticalPlacement && E > 0 && _.verticalTextBox) {\n                  for (const o of s.writingModes) if (o === e.b6.vertical ? (M = i(), z = M) : M = t(), M && M.box && M.box.length) break;\n                } else M = t();\n              };\n            if (n.get(\"text-variable-anchor\")) {\n              let l = n.get(\"text-variable-anchor\");\n              if (this.prevPlacement && this.prevPlacement.variableOffsets[T]) {\n                const e = this.prevPlacement.variableOffsets[T];\n                l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor));\n              }\n              const c = (e, i, o) => {\n                const n = s.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),\n                  c = (e.x2 - e.x1) * n + 2 * e.padding,\n                  h = (e.y2 - e.y1) * n + 2 * e.padding,\n                  d = t.hasIconTextFit && !y ? i : null;\n                d && G(d);\n                let _ = {\n                  box: [],\n                  offscreen: !1,\n                  occluded: !1\n                };\n                const g = x ? 2 * l.length : l.length;\n                for (let i = 0; i < g; ++i) {\n                  const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, n, b, w, u, a, m, i >= l.length, t, r, s, o, d, p, f);\n                  if (g && (_ = g.placedGlyphBoxes, _ && _.box && _.box.length)) {\n                    I = !0, P = g.shift;\n                    break;\n                  }\n                }\n                return _;\n              };\n              o(() => c(j, _.iconBox, e.b6.horizontal), () => {\n                const t = _.verticalTextBox;\n                return t && G(t), s.allowVerticalPlacement && !(M && M.box && M.box.length) && E > 0 && t ? c(t, _.verticalIconBox, e.b6.vertical) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), M && (I = M.box, L = M.offscreen, A = M.occluded);\n              const h = i(!(!M || !M.box));\n              if (!I && this.prevPlacement) {\n                const e = this.prevPlacement.variableOffsets[T];\n                e && (this.variableOffsets[T] = e, this.markUsedJustification(s, e.anchor, t, h));\n              }\n            } else {\n              const n = (i, o) => {\n                const n = s.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),\n                  l = this.collisionIndex.placeCollisionBox(s, n, i, new e.P(0, 0), x, u, a, m.predicate);\n                return l && l.box && l.box.length && (this.markUsedOrientation(s, o, t), this.placedOrientations[T] = o), l;\n              };\n              o(() => n(j, e.b6.horizontal), () => {\n                const t = _.verticalTextBox;\n                return s.allowVerticalPlacement && E > 0 && t ? (G(t), n(t, e.b6.vertical)) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), i(!!(M && M.box && M.box.length));\n            }\n          }\n          if (O = M, I = O && O.box && O.box.length > 0, L = O && O.offscreen, A = O && O.occluded, t.useRuntimeCollisionCircles) {\n            const i = s.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),\n              r = e.b7(s.textSizeData, p, i),\n              h = n.get(\"text-padding\");\n            F = this.collisionIndex.placeCollisionCircles(s, x, i, s.lineVertexArray, s.glyphOffsetArray, r, a, l, c, o, w, m.predicate, t.collisionCircleDiameter * r / e.bc, h, this.retainedQueryData[s.bucketInstanceId].tileID), I = x || F.circles.length > 0 && !F.collisionDetected, L = L && F.offscreen, A = F.occluded;\n          }\n          if (_.iconFeatureIndex && (U = _.iconFeatureIndex), _.iconBox) {\n            const i = i => {\n              G(i);\n              const o = t.hasIconTextFit && P ? ji(P.x, P.y, b, w, this.transform.angle) : new e.P(0, 0),\n                r = s.getSymbolInstanceIconSize(f, this.transform.zoom, t.placedIconSymbolIndex);\n              return this.collisionIndex.placeCollisionBox(s, r, i, o, y, u, a, m.predicate);\n            };\n            z && z.box && z.box.length && _.verticalIconBox ? (B = i(_.verticalIconBox), D = B.box.length > 0) : (B = i(_.iconBox), D = B.box.length > 0), L = L && B.offscreen, R = B.occluded;\n          }\n          const V = g || 0 === t.numHorizontalGlyphVertices && 0 === E,\n            Z = v || 0 === t.numIconVertices;\n          if (V || Z ? Z ? V || (D = D && I) : I = D && I : D = I = D && I, I && O && O.box && this.collisionIndex.insertCollisionBox(O.box, n.get(\"text-ignore-placement\"), s.bucketInstanceId, z && z.box && N ? N : k, m.ID), D && B && this.collisionIndex.insertCollisionBox(B.box, n.get(\"icon-ignore-placement\"), s.bucketInstanceId, U, m.ID), F && (I && this.collisionIndex.insertCollisionCircles(F.circles, n.get(\"text-ignore-placement\"), s.bucketInstanceId, k, m.ID), o)) {\n            const e = s.bucketInstanceId;\n            let t = this.collisionCircleArrays[e];\n            void 0 === t && (t = this.collisionCircleArrays[e] = new ki());\n            for (let e = 0; e < F.circles.length; e += 4) t.circles.push(F.circles[e + 0]), t.circles.push(F.circles[e + 1]), t.circles.push(F.circles[e + 2]), t.circles.push(F.collisionDetected ? 1 : 0);\n          }\n          const H = \"globe\" !== s.projection.name;\n          S = S && (H || !A), C = C && (H || !R), this.placements[T] = new Bi(I || S, D || C, L || s.justReloaded), i.add(T);\n        };\n        if (E && this.buildingIndex && (this.buildingIndex.updateZOffset(s, this.retainedQueryData[s.bucketInstanceId].tileID), s.updateZOffset()), T) {\n          const t = s.getSortedSymbolIndexes(this.transform.angle);\n          for (let e = t.length - 1; e >= 0; --e) {\n            const i = t[e];\n            I(s.symbolInstances.get(i), i, s.collisionArrays[i]);\n          }\n          s.hasAnyZOffset && e.w(`${s.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);\n        } else if (s.hasAnyZOffset) {\n          const e = s.getSortedIndexesByZOffset();\n          for (let t = 0; t < e.length; ++t) {\n            const i = e[t];\n            I(s.symbolInstances.get(i), i, s.collisionArrays[i]);\n          }\n        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) I(s.symbolInstances.get(e), e, s.collisionArrays[e]);\n        if (o && s.bucketInstanceId in this.collisionCircleArrays) {\n          const t = this.collisionCircleArrays[s.bucketInstanceId];\n          e.a6.invert(t.invProjMatrix, a), t.viewportMatrix = this.collisionIndex.getViewportMatrix();\n        }\n        s.justReloaded = !1;\n      }\n      markUsedJustification(t, i, o, r) {\n        const {\n            leftJustifiedTextSymbolIndex: s,\n            centerJustifiedTextSymbolIndex: n,\n            rightJustifiedTextSymbolIndex: a,\n            verticalPlacedTextSymbolIndex: l,\n            crossTileID: c\n          } = o,\n          h = e.be(i),\n          u = r === e.b6.vertical ? l : \"left\" === h ? s : \"center\" === h ? n : \"right\" === h ? a : -1;\n        s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c), n >= 0 && (t.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);\n      }\n      markUsedOrientation(t, i, o) {\n        const r = i === e.b6.horizontal || i === e.b6.horizontalOnly ? i : 0,\n          s = i === e.b6.vertical ? i : 0,\n          {\n            leftJustifiedTextSymbolIndex: n,\n            centerJustifiedTextSymbolIndex: a,\n            rightJustifiedTextSymbolIndex: l,\n            verticalPlacedTextSymbolIndex: c\n          } = o,\n          h = t.text.placedSymbolArray;\n        n >= 0 && (h.get(n).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = s);\n      }\n      commit(e) {\n        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;\n        const t = this.prevPlacement;\n        let i = !1;\n        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;\n        const o = t ? t.symbolFadeChange(e) : 1,\n          r = t ? t.opacities : {},\n          s = t ? t.variableOffsets : {},\n          n = t ? t.placedOrientations : {};\n        for (const e in this.placements) {\n          const t = this.placements[e],\n            s = r[e];\n          s ? (this.opacities[e] = new Fi(s, o, t.text, t.icon, null, t.clipped), i = i || t.text !== s.text.placed || t.icon !== s.icon.placed) : (this.opacities[e] = new Fi(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);\n        }\n        for (const e in r) {\n          const t = r[e];\n          if (!this.opacities[e]) {\n            const r = new Fi(t, o, !1, !1);\n            r.isHidden() || (this.opacities[e] = r, i = i || t.text.placed || t.icon.placed);\n          }\n        }\n        for (const e in s) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = s[e]);\n        for (const e in n) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = n[e]);\n        i ? this.lastPlacementChangeTime = e : \"number\" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);\n      }\n      updateLayerOpacities(e, t) {\n        const i = new Set();\n        for (const o of t) {\n          const t = o.getBucket(e);\n          t && o.latestFeatureIndex && e.fqid === t.layerIds[0] && (this.updateBucketOpacities(t, i, o.collisionBoxArray), t.layers[0].layout.get(\"symbol-z-elevate\") && this.buildingIndex && (this.buildingIndex.updateZOffset(t, o.tileID), t.updateZOffset()));\n        }\n      }\n      updateBucketOpacities(t, i, o) {\n        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();\n        const r = t.layers[0].layout,\n          s = !!t.layers[0].dynamicFilter(),\n          n = new Fi(null, 0, !1, !1, !0),\n          a = r.get(\"text-allow-overlap\"),\n          l = r.get(\"icon-allow-overlap\"),\n          c = r.get(\"text-variable-anchor\"),\n          h = \"map\" === r.get(\"text-rotation-alignment\"),\n          u = \"map\" === r.get(\"text-pitch-alignment\"),\n          d = new Fi(null, 0, a && (l || !t.hasIconData() || r.get(\"icon-optional\")), l && (a || !t.hasTextData() || r.get(\"text-optional\")), !0);\n        !t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);\n        const _ = (e, t, i) => {\n          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);\n        };\n        let p = 0;\n        for (let o = 0; o < t.symbolInstances.length; o++) {\n          const r = t.symbolInstances.get(o),\n            {\n              numHorizontalGlyphVertices: a,\n              numVerticalGlyphVertices: l,\n              crossTileID: f,\n              numIconVertices: m\n            } = r,\n            g = i.has(f);\n          let v = this.opacities[f];\n          g ? v = n : v || (v = d, this.opacities[f] = v), i.add(f);\n          const x = a > 0 || l > 0,\n            y = m > 0,\n            b = this.placedOrientations[f],\n            w = b === e.b6.vertical,\n            T = b === e.b6.horizontal || b === e.b6.horizontalOnly;\n          if (!x && !y || v.isHidden() || p++, x) {\n            const e = Ji(v.text);\n            _(t.text, a, w ? Qi : e), _(t.text, l, T ? Qi : e);\n            const i = v.text.isHidden(),\n              {\n                leftJustifiedTextSymbolIndex: o,\n                centerJustifiedTextSymbolIndex: s,\n                rightJustifiedTextSymbolIndex: n,\n                verticalPlacedTextSymbolIndex: c\n              } = r,\n              h = t.text.placedSymbolArray,\n              u = i || w ? 1 : 0;\n            o >= 0 && (h.get(o).hidden = u), s >= 0 && (h.get(s).hidden = u), n >= 0 && (h.get(n).hidden = u), c >= 0 && (h.get(c).hidden = i || T ? 1 : 0);\n            const d = this.variableOffsets[f];\n            d && this.markUsedJustification(t, d.anchor, r, b);\n            const p = this.placedOrientations[f];\n            p && (this.markUsedJustification(t, \"left\", r, p), this.markUsedOrientation(t, p, r));\n          }\n          if (y) {\n            const e = Ji(v.icon),\n              {\n                placedIconSymbolIndex: i,\n                verticalPlacedIconSymbolIndex: o\n              } = r,\n              s = t.icon.placedSymbolArray,\n              n = v.icon.isHidden() ? 1 : 0;\n            i >= 0 && (_(t.icon, m, w ? Qi : e), s.get(i).hidden = n), o >= 0 && (_(t.icon, r.numVerticalIconVertices, T ? Qi : e), s.get(o).hidden = n);\n          }\n          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {\n            const i = t.collisionArrays[o];\n            if (i) {\n              let o = new e.P(0, 0),\n                n = !0;\n              if (i.textBox || i.verticalTextBox) {\n                if (c) {\n                  const e = this.variableOffsets[f];\n                  e ? (o = Gi(e.anchor, e.width, e.height, e.textOffset, e.textScale), h && o._rotate(u ? this.transform.angle : -this.transform.angle)) : n = !1;\n                }\n                s && (n = !v.clipped), i.textBox && Zi(t.textCollisionBox.collisionVertexArray, v.text.placed, !n || w, o.x, o.y), i.verticalTextBox && Zi(t.textCollisionBox.collisionVertexArray, v.text.placed, !n || T, o.x, o.y);\n              }\n              const a = n && Boolean(!T && i.verticalIconBox);\n              i.iconBox && Zi(t.iconCollisionBox.collisionVertexArray, v.icon.placed, a, r.hasIconTextFit ? o.x : 0, r.hasIconTextFit ? o.y : 0), i.verticalIconBox && Zi(t.iconCollisionBox.collisionVertexArray, v.icon.placed, !a, r.hasIconTextFit ? o.x : 0, r.hasIconTextFit ? o.y : 0);\n            }\n          }\n        }\n        if (t.fullyClipped = 0 === p, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {\n          const e = this.collisionCircleArrays[t.bucketInstanceId];\n          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];\n        }\n      }\n      symbolFadeChange(e) {\n        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n      }\n      zoomAdjustment(e) {\n        return Math.max(0, (this.transform.zoom - e) / 1.5);\n      }\n      hasTransitions(e) {\n        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;\n      }\n      stillRecent(e, t) {\n        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;\n        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;\n      }\n      setStale() {\n        this.stale = !0;\n      }\n    }\n    function Zi(e, t, i, o, r) {\n      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0);\n    }\n    const Hi = Math.pow(2, 25),\n      Wi = Math.pow(2, 24),\n      qi = Math.pow(2, 17),\n      $i = Math.pow(2, 16),\n      Xi = Math.pow(2, 9),\n      Ki = Math.pow(2, 8),\n      Yi = Math.pow(2, 1);\n    function Ji(e) {\n      if (0 === e.opacity && !e.placed) return 0;\n      if (1 === e.opacity && e.placed) return 4294967295;\n      const t = e.placed ? 1 : 0,\n        i = Math.floor(127 * e.opacity);\n      return i * Hi + t * Wi + i * qi + t * $i + i * Xi + t * Ki + i * Yi + t;\n    }\n    const Qi = 0;\n    class eo {\n      constructor(e) {\n        this._sortAcrossTiles = \"viewport-y\" !== e.layout.get(\"symbol-z-order\") && void 0 !== e.layout.get(\"symbol-sort-key\").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set(), this._bucketParts = [];\n      }\n      continuePlacement(e, t, i, o, r) {\n        const s = this._bucketParts;\n        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(s, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;\n        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, s.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < s.length;) {\n          const e = s[this._currentPartIndex];\n          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;\n        }\n        return !1;\n      }\n    }\n    class to {\n      constructor(e, t, i, o, r, s, n, a, l) {\n        this.placement = new Vi(e, r, s, n, a, l), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n      }\n      isDone() {\n        return this._done;\n      }\n      continuePlacement(t, i, o, r) {\n        const s = e.f.now(),\n          n = () => {\n            const t = e.f.now() - s;\n            return !this._forceFullPlacement && t > 2;\n          };\n        for (; this._currentPlacementIndex >= 0;) {\n          const s = i[t[this._currentPlacementIndex]],\n            a = this.placement.collisionIndex.transform.zoom;\n          if (\"symbol\" === s.type && (!s.minzoom || s.minzoom <= a) && (!s.maxzoom || s.maxzoom > a)) {\n            const t = s,\n              i = t.layout.get(\"symbol-z-elevate\"),\n              a = this._inProgressLayer = this._inProgressLayer || new eo(t),\n              l = e.ag(s.source, s.scope);\n            if (a.continuePlacement(i ? r[l] : o[l], this.placement, this._showCollisionBoxes, s, n)) return;\n            delete this._inProgressLayer;\n          }\n          this._currentPlacementIndex--;\n        }\n        this._done = !0;\n      }\n      commit(e) {\n        return this.placement.commit(e), this.placement;\n      }\n    }\n    const io = 512 / e.V / 2;\n    class oo {\n      constructor(t, i, o) {\n        this.tileID = t, this.bucketInstanceId = o, this.index = new e.bg(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];\n        const r = t.canonical.x * e.V,\n          s = t.canonical.y * e.V;\n        for (let e = 0; e < i.length; e++) {\n          const {\n              key: t,\n              crossTileID: o,\n              tileAnchorX: n,\n              tileAnchorY: a\n            } = i.get(e),\n            l = Math.floor((r + n) * io),\n            c = Math.floor((s + a) * io);\n          this.index.add(l, c), this.keys.push(t), this.crossTileIDs.push(o);\n        }\n        this.index.finish();\n      }\n      findMatches(t, i, o) {\n        const r = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z),\n          s = io / Math.pow(2, i.canonical.z - this.tileID.canonical.z),\n          n = i.canonical.x * e.V,\n          a = i.canonical.y * e.V;\n        for (let e = 0; e < t.length; e++) {\n          const i = t.get(e);\n          if (i.crossTileID) continue;\n          const {\n              key: l,\n              tileAnchorX: c,\n              tileAnchorY: h\n            } = i,\n            u = Math.floor((n + c) * s),\n            d = Math.floor((a + h) * s),\n            _ = this.index.range(u - r, d - r, u + r, d + r);\n          for (const e of _) {\n            const t = this.crossTileIDs[e];\n            if (this.keys[e] === l && !o.has(t)) {\n              o.add(t), i.crossTileID = t;\n              break;\n            }\n          }\n        }\n      }\n    }\n    class ro {\n      constructor() {\n        this.maxCrossTileID = 0;\n      }\n      generate() {\n        return ++this.maxCrossTileID;\n      }\n    }\n    class so {\n      constructor() {\n        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - this.lng) / 360);\n        if (0 !== t) for (const e in this.indexes) {\n          const i = this.indexes[e],\n            o = {};\n          for (const e in i) {\n            const r = i[e];\n            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), o[r.tileID.key] = r;\n          }\n          this.indexes[e] = o;\n        }\n        this.lng = e;\n      }\n      addBucket(e, t, i) {\n        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {\n          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;\n          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;\n        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set());\n        const o = this.usedCrossTileIDs[e.overscaledZ];\n        for (const i in this.indexes) {\n          const r = this.indexes[i];\n          if (Number(i) > e.overscaledZ) for (const i in r) {\n            const s = r[i];\n            s.tileID.isChildOf(e) && s.findMatches(t.symbolInstances, e, o);\n          } else {\n            const s = r[e.scaledTo(Number(i)).key];\n            s && s.findMatches(t.symbolInstances, e, o);\n          }\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) {\n          const r = t.symbolInstances.get(e);\n          r.crossTileID || (r.crossTileID = i.generate(), o.add(r.crossTileID));\n        }\n        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new oo(e, t.symbolInstances, t.bucketInstanceId), !0;\n      }\n      removeBucketCrossTileIDs(e, t) {\n        for (const i of t.crossTileIDs) this.usedCrossTileIDs[e].delete(i);\n      }\n      removeStaleBuckets(e) {\n        let t = !1;\n        for (const i in this.indexes) {\n          const o = this.indexes[i];\n          for (const r in o) e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t = !0);\n        }\n        return t;\n      }\n    }\n    class no {\n      constructor() {\n        this.layerIndexes = {}, this.crossTileIDs = new ro(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n      }\n      addLayer(e, t, i, o) {\n        let r = this.layerIndexes[e.fqid];\n        void 0 === r && (r = this.layerIndexes[e.fqid] = new so());\n        let s = !1;\n        const n = {};\n        \"globe\" !== o.name && r.handleWrapJump(i);\n        for (const i of t) {\n          const t = i.getBucket(e);\n          t && e.fqid === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (s = !0), n[t.bucketInstanceId] = !0);\n        }\n        return r.removeStaleBuckets(n) && (s = !0), s;\n      }\n      pruneUnusedLayers(e) {\n        const t = {};\n        e.forEach(e => {\n          t[e] = !0;\n        });\n        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];\n      }\n    }\n    class ao {\n      constructor(e = 0, t = 0, i = 0, o = 0) {\n        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error(\"Invalid value for edge-insets, top, bottom, left and right must all be numbers\");\n        this.top = e, this.bottom = t, this.left = i, this.right = o;\n      }\n      interpolate(t, i, o) {\n        return null != i.top && null != t.top && (this.top = e.U(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.U(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.U(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.U(t.right, i.right, o)), this;\n      }\n      getCenter(t, i) {\n        const o = e.aa((this.left + t - this.right) / 2, 0, t),\n          r = e.aa((this.top + i - this.bottom) / 2, 0, i);\n        return new e.P(o, r);\n      }\n      equals(e) {\n        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;\n      }\n      clone() {\n        return new ao(this.top, this.bottom, this.left, this.right);\n      }\n      toJSON() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n    }\n    function lo(t, i) {\n      const o = e.bk(t, 3);\n      e.a6.fromQuat(t, i), e.bm(t, 3, o);\n    }\n    function co(t, i) {\n      const o = e.bi.identity([]);\n      return e.bi.rotateZ(o, o, -i), e.bi.rotateX(o, o, -t), o;\n    }\n    function ho(t, i) {\n      const o = [t[0], t[1], 0],\n        r = [i[0], i[1], 0];\n      if (e.N.length(o) >= 1e-15) {\n        const t = e.N.normalize([], o);\n        e.N.scale(r, t, e.N.dot(r, t)), i[0] = r[0], i[1] = r[1];\n      }\n      const s = e.N.cross([], i, t);\n      if (e.N.len(s) < 1e-15) return null;\n      const n = Math.atan2(-s[1], s[0]);\n      return co(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), n);\n    }\n    class uo {\n      constructor(e, t) {\n        this.position = e, this.orientation = t;\n      }\n      get position() {\n        return this._position;\n      }\n      set position(t) {\n        if (t) {\n          const i = t instanceof e.L ? t : new e.L(t[0], t[1], t[2]);\n          this._renderWorldCopies && (i.x = e.bh(i.x, 0, 1)), this._position = i;\n        } else this._position = null;\n      }\n      lookAtPoint(t, i) {\n        if (this.orientation = null, !this.position) return;\n        const o = this.position,\n          r = this._elevation ? this._elevation.getAtPointOrZero(e.L.fromLngLat(t)) : 0,\n          s = e.L.fromLngLat(t, r),\n          n = [s.x - o.x, s.y - o.y, s.z - o.z];\n        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = ho(n, i);\n      }\n      setPitchBearing(t, i) {\n        this.orientation = co(e.bj(t), e.bj(-i));\n      }\n    }\n    class _o {\n      constructor(t, i) {\n        this._transform = e.a6.identity([]), this.orientation = i, this.position = t;\n      }\n      get mercatorPosition() {\n        const t = this.position;\n        return new e.L(t[0], t[1], t[2]);\n      }\n      get position() {\n        const t = e.bk(this._transform, 3);\n        return [t[0], t[1], t[2]];\n      }\n      set position(t) {\n        var i;\n        t && e.bm(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);\n      }\n      get orientation() {\n        return this._orientation;\n      }\n      set orientation(t) {\n        this._orientation = t || e.bi.identity([]), t && lo(this._transform, this._orientation);\n      }\n      getPitchBearing() {\n        const e = this.forward(),\n          t = this.right();\n        return {\n          bearing: Math.atan2(-t[1], t[0]),\n          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])\n        };\n      }\n      setPitchBearing(e, t) {\n        this._orientation = co(e, t), lo(this._transform, this._orientation);\n      }\n      forward() {\n        const t = e.bk(this._transform, 2);\n        return [-t[0], -t[1], -t[2]];\n      }\n      up() {\n        const t = e.bk(this._transform, 1);\n        return [-t[0], -t[1], -t[2]];\n      }\n      right() {\n        const t = e.bk(this._transform, 0);\n        return [t[0], t[1], t[2]];\n      }\n      getCameraToWorld(t, i) {\n        const o = new Float64Array(16);\n        return e.a6.invert(o, this.getWorldToCamera(t, i)), o;\n      }\n      getCameraToWorldMercator() {\n        return this._transform;\n      }\n      getWorldToCameraPosition(t, i, o) {\n        const r = this.position;\n        e.N.scale(r, r, -t);\n        const s = new Float64Array(16);\n        return e.a6.fromScaling(s, [o, o, o]), e.a6.translate(s, s, r), s[10] *= i, s;\n      }\n      getWorldToCamera(t, i) {\n        const o = new Float64Array(16),\n          r = new Float64Array(4),\n          s = this.position;\n        return e.bi.conjugate(r, this._orientation), e.N.scale(s, s, -t), e.a6.fromQuat(o, r), e.a6.translate(o, o, s), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;\n      }\n      getCameraToClipPerspective(t, i, o, r) {\n        const s = new Float64Array(16);\n        return e.a6.perspective(s, t, i, o, r), s;\n      }\n      getCameraToClipOrthographic(t, i, o, r, s, n) {\n        const a = new Float64Array(16);\n        return e.a6.ortho(a, t, i, o, r, s, n), a;\n      }\n      getDistanceToElevation(t, i = !1) {\n        const o = 0 === t ? 0 : e.bl(t, i ? e.au(this.position[1]) : this.position[1]),\n          r = this.forward();\n        return (o - this.position[2]) / r[2];\n      }\n      clone() {\n        return new _o([...this.position], [...this.orientation]);\n      }\n    }\n    const po = (e, t, i) => (1 - i) * e + i * t,\n      fo = e => e * e * e * e * e;\n    class mo {\n      constructor(t, i, o, r, s, n, a) {\n        this.tileSize = 512, this._renderWorldCopies = void 0 === s || s, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(n), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.bn(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ao(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new _o(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = \"ground\", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1;\n      }\n      clone() {\n        const e = new mo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());\n        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e;\n      }\n      get isOrthographic() {\n        return \"globe\" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;\n      }\n      get elevation() {\n        return this._elevation;\n      }\n      set elevation(e) {\n        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());\n      }\n      get depthOcclusionForSymbolsAndCircles() {\n        return \"globe\" !== this.projection.name && !this.isOrthographic;\n      }\n      updateElevation(e, t = !1) {\n        const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;\n        (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t), this._calcMatrices();\n      }\n      getProjection() {\n        return e.ac(this.projection, [\"name\", \"center\", \"parallels\"]);\n      }\n      setProjection(i) {\n        this.projectionOptions = i || {\n          name: \"mercator\"\n        };\n        const o = this.projection ? this.getProjection() : void 0;\n        this.projection = e.bo(this.projectionOptions);\n        const r = !t(o, this.getProjection());\n        return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;\n      }\n      setOrthographicProjectionAtLowPitch(e) {\n        return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);\n      }\n      setMercatorFromTransition() {\n        const t = this.projection.name;\n        this.mercatorFromTransition = !0, this.projectionOptions = {\n          name: \"mercator\"\n        }, this.projection = e.bo({\n          name: \"mercator\"\n        });\n        const i = t !== this.projection.name;\n        return i && this._calcMatrices(), i;\n      }\n      get minZoom() {\n        return this._minZoom;\n      }\n      set minZoom(e) {\n        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));\n      }\n      get maxZoom() {\n        return this._maxZoom;\n      }\n      set maxZoom(e) {\n        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));\n      }\n      get minPitch() {\n        return this._minPitch;\n      }\n      set minPitch(e) {\n        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));\n      }\n      get maxPitch() {\n        return this._maxPitch;\n      }\n      set maxPitch(e) {\n        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));\n      }\n      get renderWorldCopies() {\n        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;\n      }\n      set renderWorldCopies(e) {\n        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;\n      }\n      get worldSize() {\n        return this.tileSize * this.scale;\n      }\n      get cameraWorldSizeForFog() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get cameraWorldSize() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get pixelsPerMeter() {\n        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);\n      }\n      get cameraPixelsPerMeter() {\n        return e.bl(1, this.center.lat) * this.cameraWorldSizeForFog;\n      }\n      get centerOffset() {\n        return this.centerPoint._sub(this.size._div(2));\n      }\n      get size() {\n        return new e.P(this.width, this.height);\n      }\n      get bearing() {\n        return e.bh(this.rotation, -180, 180);\n      }\n      set bearing(e) {\n        this.rotation = e;\n      }\n      get rotation() {\n        return -this.angle / Math.PI * 180;\n      }\n      set rotation(t) {\n        const i = -t * Math.PI / 180;\n        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.b4.create(), e.b4.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));\n      }\n      get pitch() {\n        return this._pitch / Math.PI * 180;\n      }\n      set pitch(t) {\n        const i = e.aa(t, this.minPitch, this.maxPitch) / 180 * Math.PI;\n        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n      }\n      get aspect() {\n        return this.width / this.height;\n      }\n      get fov() {\n        return this._fov / Math.PI * 180;\n      }\n      get fovX() {\n        return this._fov;\n      }\n      get fovY() {\n        const e = 1 / Math.tan(.5 * this.fovX);\n        return 2 * Math.atan(1 / this.aspect / e);\n      }\n      set fov(t) {\n        t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.bj(t), this._calcMatrices());\n      }\n      get averageElevation() {\n        return this._averageElevation;\n      }\n      set averageElevation(e) {\n        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};\n      }\n      get zoom() {\n        return this._zoom;\n      }\n      set zoom(e) {\n        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);\n        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());\n      }\n      _setZoom(e) {\n        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;\n      }\n      get tileCoverLift() {\n        return this._tileCoverLift;\n      }\n      set tileCoverLift(e) {\n        this._tileCoverLift !== e && (this._tileCoverLift = e);\n      }\n      _updateCameraOnTerrain() {\n        const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY,\n          t = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;\n        if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);\n        const i = this._elevation;\n        t || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();\n      }\n      _updateSeaLevelZoom() {\n        void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));\n      }\n      sampleAverageElevation() {\n        if (!this._elevation) return 0;\n        const t = this._elevation,\n          i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],\n          o = this.horizonLineFromTop();\n        let r = 0,\n          s = 0;\n        for (let n = 0; n < i.length; n++) {\n          const a = new e.P(i[n][0] * this.width, o + i[n][1] * (this.height - o)),\n            l = t.pointCoordinate(a);\n          if (!l) continue;\n          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);\n          r += l[3] * c, s += c;\n        }\n        return 0 === s ? NaN : r / s;\n      }\n      get center() {\n        return this._center;\n      }\n      set center(e) {\n        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && (\"ground\" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());\n      }\n      _updateZoomFromElevation() {\n        if (null == this._seaLevelZoom || !this._elevation) return;\n        const e = this._seaLevelZoom,\n          t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),\n          i = this.pixelsPerMeter / this.worldSize * t,\n          o = this._mercatorZfromZoom(e),\n          r = this._mercatorZfromZoom(this._maxZoom),\n          s = Math.max(o - i, r);\n        this._setZoom(this._zoomFromMercatorZ(s));\n      }\n      get padding() {\n        return this._edgeInsets.toJSON();\n      }\n      set padding(e) {\n        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());\n      }\n      computeZoomRelativeTo(t) {\n        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));\n        let o;\n        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];\n        const r = e.N.length(e.N.sub([], this._camera.position, o));\n        return e.aa(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);\n      }\n      setFreeCameraOptions(t) {\n        if (!this.height) return;\n        if (!t.position && !t.orientation) return;\n        this._updateCameraState();\n        let i = !1;\n        if (t.orientation && !e.bi.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {\n          const o = [t.position.x, t.position.y, t.position.z];\n          e.N.exactEquals(o, this._camera.position) || (this._setCameraPosition(o), i = !0);\n        }\n        i && (this._updateStateFromCamera(), this.recenterOnTerrain());\n      }\n      getFreeCameraOptions() {\n        this._updateCameraState();\n        const t = this._camera.position,\n          i = new uo();\n        return i.position = new e.L(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;\n      }\n      _setCameraOrientation(t) {\n        if (!e.bi.length(t)) return !1;\n        e.bi.normalize(t, t);\n        const i = e.N.transformQuat([], [0, 0, -1], t),\n          o = e.N.transformQuat([], [0, -1, 0], t);\n        if (o[2] < 0) return !1;\n        const r = ho(i, o);\n        return !!r && (this._camera.orientation = r, !0);\n      }\n      _setCameraPosition(t) {\n        const i = this.zoomScale(this.minZoom) * this.tileSize,\n          o = this.zoomScale(this.maxZoom) * this.tileSize,\n          r = this.cameraToCenterDistance;\n        t[2] = e.aa(t[2], r / o, r / i), this._camera.position = t;\n      }\n      get centerPoint() {\n        return this._edgeInsets.getCenter(this.width, this.height);\n      }\n      get fovAboveCenter() {\n        return this._fov * (.5 + this.centerOffset.y / this.height);\n      }\n      isPaddingEqual(e) {\n        return this._edgeInsets.equals(e);\n      }\n      interpolatePadding(e, t, i) {\n        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();\n      }\n      coveringZoomLevel(e) {\n        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));\n        return Math.max(0, t);\n      }\n      getVisibleUnwrappedCoordinates(t) {\n        const i = [new e.bp(0, t)];\n        if (this.renderWorldCopies) {\n          const o = this.pointCoordinate(new e.P(0, 0)),\n            r = this.pointCoordinate(new e.P(this.width, 0)),\n            s = this.pointCoordinate(new e.P(this.width, this.height)),\n            n = this.pointCoordinate(new e.P(0, this.height)),\n            a = Math.floor(Math.min(o.x, r.x, s.x, n.x)),\n            l = Math.floor(Math.max(o.x, r.x, s.x, n.x)),\n            c = 1;\n          for (let o = a - c; o <= l + c; o++) 0 !== o && i.push(new e.bp(o, t));\n        }\n        return i;\n      }\n      isLODDisabled(e) {\n        return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;\n      }\n      extendTileCoverForShadows(t, i, o) {\n        let r = [];\n        if (0 === i[0] && 0 === i[1]) return r;\n        for (const o of t) {\n          const t = o.canonical,\n            s = o.overscaledZ,\n            n = o.wrap,\n            a = 1 << t.z,\n            l = t.x + 1 < a,\n            c = t.x > 0,\n            h = t.y + 1 < a,\n            u = t.y > 0,\n            d = o.wrap - (c ? 0 : 1),\n            _ = o.wrap + (l ? 0 : 1),\n            p = c ? t.x - 1 : a - 1,\n            f = l ? t.x + 1 : 0;\n          i[0] < 0 ? (r.push(new e.am(s, _, t.z, f, t.y)), i[1] < 0 && h && (r.push(new e.am(s, n, t.z, t.x, t.y + 1)), r.push(new e.am(s, _, t.z, f, t.y + 1))), i[1] > 0 && u && (r.push(new e.am(s, n, t.z, t.x, t.y - 1)), r.push(new e.am(s, _, t.z, f, t.y - 1)))) : i[0] > 0 ? (r.push(new e.am(s, d, t.z, p, t.y)), i[1] < 0 && h && (r.push(new e.am(s, n, t.z, t.x, t.y + 1)), r.push(new e.am(s, d, t.z, p, t.y + 1))), i[1] > 0 && u && (r.push(new e.am(s, n, t.z, t.x, t.y - 1)), r.push(new e.am(s, d, t.z, p, t.y - 1)))) : i[1] < 0 && h ? r.push(new e.am(s, n, t.z, t.x, t.y + 1)) : u && r.push(new e.am(s, n, t.z, t.x, t.y - 1));\n        }\n        if (r.length > 1) {\n          r.sort((e, t) => e.overscaledZ - t.overscaledZ || e.wrap - t.wrap || e.canonical.z - t.canonical.z || e.canonical.x - t.canonical.x || e.canonical.y - t.canonical.y);\n          let e = 0,\n            t = 0;\n          for (; t < r.length;) r[t].equals(r[e]) ? ++t : r[++e] = r[t++];\n          r.length = e + 1;\n        }\n        const s = [];\n        for (const e of r) r.some(t => e.isChildOf(t)) || s.push(e);\n        return r = s.filter(e => !t.some(t => !!(e.overscaledZ < o && t.isChildOf(e)) || e.equals(t) || e.isChildOf(t))), r;\n      }\n      coveringTiles(t) {\n        let i = this.coveringZoomLevel(t);\n        const o = i,\n          r = this.elevation && this.elevation.exaggeration(),\n          s = r && !t.isTerrainDEM,\n          n = \"mercator\" === this.projection.name;\n        if (void 0 !== t.minzoom && i < t.minzoom) return [];\n        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);\n        const a = this.locationCoordinate(this.center),\n          l = this.center.lat,\n          c = 1 << i,\n          h = [c * a.x, c * a.y, 0],\n          u = \"globe\" === this.projection.name,\n          d = !u,\n          _ = e.bq.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, d),\n          p = u ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n          f = c * e.bl(1, this.center.lat),\n          m = this._camera.position[2] / e.bl(1, this.center.lat),\n          g = [c * p.x, c * p.y, m * (d ? 1 : f)],\n          v = u || r,\n          x = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),\n          y = this.isLODDisabled(!0) ? i : 0;\n        let b;\n        if (this._elevation && t.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();else if (this._elevation) {\n          const e = this._elevation.getMinMaxForVisibleTiles();\n          b = e ? e.max : this._centerAltitude;\n        } else b = this._centerAltitude;\n        const w = t.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,\n          T = this.projection.isReprojectedInTileSpace ? e.br(this) : 1,\n          E = t => {\n            const i = 1 / 4e4,\n              o = new e.L(t.x + i, t.y, t.z),\n              r = new e.L(t.x, t.y + i, t.z),\n              s = t.toLngLat(),\n              n = o.toLngLat(),\n              a = r.toLngLat(),\n              l = this.locationCoordinate(s),\n              c = this.locationCoordinate(n),\n              h = this.locationCoordinate(a),\n              u = Math.hypot(c.x - l.x, c.y - l.y),\n              d = Math.hypot(h.x - l.x, h.y - l.y);\n            return Math.sqrt(u * d) * T / i;\n          },\n          S = t => {\n            const i = b,\n              o = w;\n            return {\n              aabb: e.bu(this, c, 0, 0, 0, t, o, i, this.projection),\n              zoom: 0,\n              x: 0,\n              y: 0,\n              minZ: o,\n              maxZ: i,\n              wrap: t,\n              fullyVisible: !1\n            };\n          },\n          C = [];\n        let I = [];\n        const D = i,\n          L = t.reparseOverscaled ? o : i,\n          A = e => e * e,\n          R = A((m - this._centerAltitude) * f),\n          P = e => {\n            if (!this._elevation || !e.tileID || !n) return;\n            const t = this._elevation.getMinMaxForTile(e.tileID),\n              i = e.aabb;\n            t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = M(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));\n          },\n          M = t => {\n            if (t.zoom < y) return !0;\n            if (t.zoom === D) return !1;\n            if (null != t.shouldSplit) return t.shouldSplit;\n            const i = t.aabb.distanceX(g),\n              r = t.aabb.distanceY(g);\n            let n = R,\n              a = 1;\n            if (u) {\n              n = A(t.aabb.distanceZ(g));\n              const i = Math.pow(2, t.zoom),\n                o = e.au((t.y + 1) / i),\n                r = e.au(t.y / i),\n                s = Math.min(Math.max(l, o), r),\n                c = e.bJ(s) / e.bJ(l);\n              if (a = s === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio), this.zoom <= e.bG && t.zoom === D - 1 && c >= .9) return !0;\n            } else if (s && (n = A(t.aabb.distanceZ(g) * f)), this.projection.isReprojectedInTileSpace && o <= 5) {\n              const i = Math.pow(2, t.zoom),\n                o = E(new e.L((t.x + .5) / i, (t.y + .5) / i));\n              a = o > .85 ? 1 : o;\n            }\n            const c = i * i + r * r + n,\n              h = A((1 << D - t.zoom) * x * a * ((e, t) => {\n                if (t * A(.707) < e) return 1;\n                const i = Math.sqrt(t / e);\n                return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);\n              })(Math.max(n, R), c));\n            return c < h;\n          };\n        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) C.push(S(-e)), C.push(S(e));\n        for (C.push(S(0)); C.length > 0;) {\n          const o = C.pop(),\n            r = o.x,\n            a = o.y;\n          let l = o.fullyVisible;\n          const d = () => \"globe\" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);\n          if (!l) {\n            let t = v ? o.aabb.intersects(_) : o.aabb.intersectsFlat(_);\n            if (0 === t && d()) {\n              const i = new e.bs(o.zoom, r, a);\n              t = e.bt(this, c, i, !0).intersects(_);\n            }\n            if (0 === t) continue;\n            l = 2 === t;\n          }\n          if (o.zoom !== D && M(o)) for (let t = 0; t < 4; t++) {\n            const i = (r << 1) + t % 2,\n              h = (a << 1) + (t >> 1),\n              d = {\n                aabb: n ? o.aabb.quadrant(t) : e.bu(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),\n                zoom: o.zoom + 1,\n                x: i,\n                y: h,\n                wrap: o.wrap,\n                fullyVisible: l,\n                tileID: void 0,\n                shouldSplit: void 0,\n                minZ: o.minZ,\n                maxZ: o.maxZ\n              };\n            s && !u && (d.tileID = new e.am(o.zoom + 1 === D ? L : o.zoom + 1, o.wrap, o.zoom + 1, i, h), P(d)), C.push(d);\n          } else {\n            const s = o.zoom === D ? L : o.zoom;\n            if (t.minzoom && t.minzoom > s) continue;\n            if (!l) {\n              let t = v ? o.aabb.intersectsPrecise(_) : o.aabb.intersectsPreciseFlat(_);\n              if (0 === t && d()) {\n                const i = new e.bs(o.zoom, r, a);\n                t = e.bt(this, c, i, !0).intersectsPrecise(_);\n              }\n              if (0 === t) continue;\n            }\n            const n = h[0] - (.5 + r + (o.wrap << o.zoom)) * (1 << i - o.zoom),\n              u = h[1] - .5 - a,\n              p = o.tileID ? o.tileID : new e.am(s, o.wrap, o.zoom, r, a);\n            I.push({\n              tileID: p,\n              distanceSq: n * n + u * u\n            });\n          }\n        }\n        if (this.fogCullDistSq) {\n          const i = this.fogCullDistSq,\n            o = this.horizonLineFromTop();\n          I = I.filter(r => {\n            const s = [0, 0, 0, 1],\n              n = [e.V, e.V, 0, 1],\n              a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());\n            e.a7.transformMat4(s, s, a), e.a7.transformMat4(n, n, a);\n            const l = e.a7.min([], s, n),\n              c = e.a7.max([], s, n),\n              h = e.bv(l, c);\n            if (0 === h) return !0;\n            let u = !1;\n            const d = this._elevation;\n            if (d && h > i && 0 !== o) {\n              const i = this.calculateProjMatrix(r.tileID.toUnwrapped());\n              let s;\n              t.isTerrainDEM || (s = d.getMinMaxForTile(r.tileID)), s || (s = {\n                min: w,\n                max: b\n              });\n              const n = e.bH(this.rotation),\n                a = [n[0] * e.V, n[1] * e.V, s.max];\n              e.N.transformMat4(a, a, i), u = (1 - a[1]) * this.height * .5 < o;\n            }\n            return h < i || u;\n          });\n        }\n        return I.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);\n      }\n      resize(e, t) {\n        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();\n      }\n      get unmodified() {\n        return this._unmodified;\n      }\n      zoomScale(e) {\n        return Math.pow(2, e);\n      }\n      scaleZoom(e) {\n        return Math.log(e) / Math.LN2;\n      }\n      project(t) {\n        const i = e.aa(t.lat, -e.bw, e.bw),\n          o = this.projection.project(t.lng, i);\n        return new e.P(o.x * this.worldSize, o.y * this.worldSize);\n      }\n      unproject(e) {\n        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);\n      }\n      get point() {\n        return this.project(this.center);\n      }\n      get pointMerc() {\n        return this.point._div(this.worldSize);\n      }\n      get pixelsPerMeterRatio() {\n        return this.pixelsPerMeter / e.bl(1, this.center.lat) / this.worldSize;\n      }\n      setLocationAtPoint(t, i) {\n        let o, r;\n        const s = this.centerPoint;\n        if (\"globe\" === this.projection.name) {\n          const e = this.worldSize;\n          o = (i.x - s.x) / e, r = (i.y - s.y) / e;\n        } else {\n          const e = this.pointCoordinate(i),\n            t = this.pointCoordinate(s);\n          o = e.x - t.x, r = e.y - t.y;\n        }\n        const n = this.locationCoordinate(t);\n        this.setLocation(new e.L(n.x - o, n.y - r));\n      }\n      setLocation(e) {\n        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());\n      }\n      locationPoint(e) {\n        return this.projection.locationPoint(this, e);\n      }\n      locationPoint3D(e) {\n        return this.projection.locationPoint(this, e, !0);\n      }\n      pointLocation(e) {\n        return this.coordinateLocation(this.pointCoordinate(e));\n      }\n      pointLocation3D(e) {\n        return this.coordinateLocation(this.pointCoordinate3D(e));\n      }\n      locationCoordinate(t, i) {\n        const o = i ? e.bl(i, t.lat) : void 0,\n          r = this.projection.project(t.lng, t.lat);\n        return new e.L(r.x, r.y, o);\n      }\n      coordinateLocation(e) {\n        return this.projection.unproject(e.x, e.y);\n      }\n      pointRayIntersection(t, i) {\n        const o = null != i ? i : this._centerAltitude,\n          r = [t.x, t.y, 0, 1],\n          s = [t.x, t.y, 1, 1];\n        e.a7.transformMat4(r, r, this.pixelMatrixInverse), e.a7.transformMat4(s, s, this.pixelMatrixInverse);\n        const n = s[3];\n        e.a7.scale(r, r, 1 / r[3]), e.a7.scale(s, s, 1 / n);\n        const a = r[2],\n          l = s[2];\n        return {\n          p0: r,\n          p1: s,\n          t: a === l ? 0 : (o - a) / (l - a)\n        };\n      }\n      screenPointToMercatorRay(t) {\n        const i = [t.x, t.y, 0, 1],\n          o = [t.x, t.y, 1, 1];\n        return e.a7.transformMat4(i, i, this.pixelMatrixInverse), e.a7.transformMat4(o, o, this.pixelMatrixInverse), e.a7.scale(i, i, 1 / i[3]), e.a7.scale(o, o, 1 / o[3]), i[2] = e.bl(i[2], this._center.lat) * this.worldSize, o[2] = e.bl(o[2], this._center.lat) * this.worldSize, e.a7.scale(i, i, 1 / this.worldSize), e.a7.scale(o, o, 1 / this.worldSize), new e.a2([i[0], i[1], i[2]], e.N.normalize([], e.N.sub([], o, i)));\n      }\n      rayIntersectionCoordinate(t) {\n        const {\n            p0: i,\n            p1: o,\n            t: r\n          } = t,\n          s = e.bl(i[2], this._center.lat),\n          n = e.bl(o[2], this._center.lat);\n        return new e.L(e.U(i[0], o[0], r) / this.worldSize, e.U(i[1], o[1], r) / this.worldSize, e.U(s, n, r));\n      }\n      pointCoordinate(e, t = this._centerAltitude) {\n        return this.projection.pointCoordinate(this, e.x, e.y, t);\n      }\n      pointCoordinate3D(t) {\n        if (!this.elevation) return this.pointCoordinate(t);\n        let i = this.projection.pointCoordinate3D(this, t.x, t.y);\n        if (i) return new e.L(i[0], i[1], i[2]);\n        let o = 0,\n          r = this.horizonLineFromTop();\n        if (t.y > r) return this.pointCoordinate(t);\n        const s = .02 * r,\n          n = t.clone();\n        for (let t = 0; t < 10 && r - o > s; t++) {\n          n.y = e.U(o, r, .66);\n          const t = this.projection.pointCoordinate3D(this, n.x, n.y);\n          t ? (r = n.y, i = t) : o = n.y;\n        }\n        return i ? new e.L(i[0], i[1], i[2]) : this.pointCoordinate(t);\n      }\n      isPointAboveHorizon(e) {\n        return this.projection.isPointAboveHorizon(this, e);\n      }\n      isPointOnSurface(t) {\n        if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;\n        if (this.elevation || this.zoom >= e.bx) return !this.isPointAboveHorizon(t);\n        const i = this.pointCoordinate(t);\n        return i.y >= 0 && i.y <= 1;\n      }\n      _coordinatePoint(t, i) {\n        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,\n          r = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];\n        return e.a7.transformMat4(r, r, this.pixelMatrix), r[3] > 0 ? new e.P(r[0] / r[3], r[1] / r[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);\n      }\n      _getBoundsNonRectangular() {\n        const {\n            top: t,\n            left: i\n          } = this._edgeInsets,\n          o = this.height - this._edgeInsets.bottom,\n          r = this.width - this._edgeInsets.right,\n          s = this.pointLocation3D(new e.P(i, t)),\n          n = this.pointLocation3D(new e.P(r, t)),\n          a = this.pointLocation3D(new e.P(r, o)),\n          l = this.pointLocation3D(new e.P(i, o));\n        let c = Math.min(s.lng, n.lng, a.lng, l.lng),\n          h = Math.max(s.lng, n.lng, a.lng, l.lng),\n          u = Math.min(s.lat, n.lat, a.lat, l.lat),\n          d = Math.max(s.lat, n.lat, a.lat, l.lat);\n        const _ = Math.pow(2, -this.zoom) / 16 * 270,\n          p = \"globe\" === this.projection.name ? 1 : 4,\n          f = (t, i, o, r, s) => {\n            const n = (t + o) / 2,\n              a = (i + r) / 2,\n              l = new e.P(n, a),\n              {\n                lng: m,\n                lat: g\n              } = this.pointLocation3D(l),\n              v = Math.max(0, c - m, u - g, m - h, g - d);\n            c = Math.min(c, m), h = Math.max(h, m), u = Math.min(u, g), d = Math.max(d, g), (s < p || v > _) && (f(t, i, n, a, s + 1), f(n, a, o, r, s + 1));\n          };\n        if (f(i, t, r, t, 1), f(r, t, r, o, 1), f(r, o, i, o, 1), f(i, o, i, t, 1), \"globe\" === this.projection.name) {\n          const [t, i] = e.by(this);\n          t ? (d = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);\n        }\n        return new e.ad(new e.bn(c, u), new e.bn(h, d));\n      }\n      _getBoundsRectangular(t, i) {\n        const {\n            top: o,\n            left: r\n          } = this._edgeInsets,\n          s = this.height - this._edgeInsets.bottom,\n          n = this.width - this._edgeInsets.right,\n          a = new e.P(r, o),\n          l = new e.P(n, o),\n          c = new e.P(n, s),\n          h = new e.P(r, s);\n        let u = this.pointCoordinate(a, t),\n          d = this.pointCoordinate(l, t);\n        const _ = this.pointCoordinate(c, i),\n          p = this.pointCoordinate(h, i),\n          f = (e, t) => (t.y - e.y) / (t.x - e.x);\n        return u.y > 1 && d.y >= 0 ? u = new e.L((1 - p.y) / f(p, u) + p.x, 1) : u.y < 0 && d.y <= 1 && (u = new e.L(-p.y / f(p, u) + p.x, 0)), d.y > 1 && u.y >= 0 ? d = new e.L((1 - _.y) / f(_, d) + _.x, 1) : d.y < 0 && u.y <= 1 && (d = new e.L(-_.y / f(_, d) + _.x, 0)), new e.ad().extend(this.coordinateLocation(u)).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_));\n      }\n      _getBoundsRectangularTerrain() {\n        const e = this.elevation;\n        if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);\n        const t = e.visibleDemTiles.reduce((e, t) => {\n          if (t.dem) {\n            const i = t.dem.tree;\n            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);\n          }\n          return e;\n        }, {\n          min: Number.MAX_VALUE,\n          max: 0\n        });\n        return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration());\n      }\n      getBounds() {\n        return \"mercator\" === this.projection.name || \"equirectangular\" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();\n      }\n      horizonLineFromTop(e = !0) {\n        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y,\n          i = this.height / 2 - t * (1 - this._horizonShift);\n        return e ? Math.max(0, i) : i;\n      }\n      getMaxBounds() {\n        return this.maxBounds;\n      }\n      setMaxBounds(t) {\n        this.maxBounds = t, this.minLat = -e.bw, this.maxLat = e.bw, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.a5(this.minLng) * this.tileSize, this.worldMaxX = e.a5(this.maxLng) * this.tileSize, this.worldMinY = e.ae(this.maxLat) * this.tileSize, this.worldMaxY = e.ae(this.minLat) * this.tileSize, this._constrain();\n      }\n      calculatePosMatrix(e, t) {\n        return this.projection.createTileMatrix(this, t, e);\n      }\n      calculateDistanceTileData(t) {\n        const i = t.key,\n          o = this._distanceTileDataCache;\n        if (o[i]) return o[i];\n        const r = t.canonical,\n          s = 1 / this.height,\n          n = this.cameraWorldSize,\n          a = n / this.zoomScale(r.z),\n          l = (r.x + Math.pow(2, r.z) * t.wrap) * a,\n          c = r.y * a,\n          h = this.point;\n        h.x *= n / this.worldSize, h.y *= n / this.worldSize;\n        const u = this.angle,\n          d = Math.sin(-u),\n          _ = -Math.cos(-u);\n        return o[i] = {\n          bearing: [d, _],\n          center: [(h.x - l) * s, (h.y - c) * s],\n          scale: a / e.V * s\n        }, o[i];\n      }\n      calculateFogTileMatrix(t) {\n        const i = t.key,\n          o = this._fogTileMatrixCache;\n        if (o[i]) return o[i];\n        const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);\n        return e.a6.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];\n      }\n      calculateProjMatrix(t, i = !1, o = !1) {\n        const r = t.key;\n        let s;\n        if (s = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, s[r]) return s[r];\n        const n = this.calculatePosMatrix(t, this.worldSize);\n        let a;\n        return a = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.a6.multiply(n, a, n), s[r] = new Float32Array(n), s[r];\n      }\n      calculatePixelsToTileUnitsMatrix(t) {\n        const i = t.tileID.key,\n          o = this._pixelsToTileUnitsCache;\n        if (o[i]) return o[i];\n        const r = e.bz(t, this);\n        return o[i] = r, o[i];\n      }\n      customLayerMatrix() {\n        return this.mercatorMatrix.slice();\n      }\n      globeToMercatorMatrix() {\n        if (\"globe\" === this.projection.name) {\n          const t = 1 / this.worldSize,\n            i = e.a6.fromScaling([], [t, t, t]);\n          return e.a6.multiply(i, i, this.globeMatrix), i;\n        }\n      }\n      recenterOnTerrain() {\n        if (!this._elevation || \"globe\" === this.projection.name) return;\n        const t = this._elevation;\n        this._updateCameraState();\n        const i = e.bl(1, this._center.lat) * this.worldSize,\n          o = this._computeCameraPosition(i),\n          r = this._camera.forward(),\n          s = e.bl(1, this._center.lat);\n        o[2] /= s, r[2] /= s, e.N.normalize(r, r);\n        const n = t.raycast(o, r, t.exaggeration());\n        if (n) {\n          const t = e.N.scaleAndAdd([], o, r, n),\n            i = new e.L(t[0], t[1], e.bl(t[2], e.au(t[1]))),\n            a = (i.z + e.N.length([i.x - o[0], i.y - o[1], i.z - o[2] * s])) * this._pixelsPerMercatorPixel;\n          this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();\n        }\n      }\n      _constrainCamera(t = !1) {\n        if (!this._elevation) return;\n        const i = this._elevation,\n          o = e.bl(1, this._center.lat) * this.worldSize,\n          r = this._computeCameraPosition(o),\n          s = i.getAtPointOrZero(new e.L(...r)),\n          n = this.pixelsPerMeter / this.worldSize * s,\n          a = this._minimumHeightOverTerrain(),\n          l = r[2] - n;\n        if (l <= a) if (l < 0 || t) {\n          const t = this.locationCoordinate(this._center, this._centerAltitude),\n            i = [r[0], r[1], t.z - r[2]],\n            o = e.N.length(i);\n          i[2] -= (a - l) / this._pixelsPerMercatorPixel;\n          const s = e.N.length(i);\n          if (0 === s) return;\n          e.N.scale(i, i, o / s * this._pixelsPerMercatorPixel), this._camera.position = [r[0], r[1], t.z * this._pixelsPerMercatorPixel - i[2]], this._updateStateFromCamera();\n        } else this._isCameraConstrained = !0;\n      }\n      _constrain() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n        this._constraining = !0;\n        const t = \"globe\" === this.projection.name || this.mercatorFromTransition;\n        if (this.projection.isReprojectedInTileSpace || t) {\n          const i = this.center;\n          return i.lat = e.aa(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (i.lng = e.aa(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);\n        }\n        const i = this._unmodified,\n          {\n            x: o,\n            y: r\n          } = this.point;\n        let s = 0,\n          n = o,\n          a = r;\n        const l = this.width / 2,\n          c = this.height / 2,\n          h = this.worldMinY * this.scale,\n          u = this.worldMaxY * this.scale;\n        if (r - c < h && (a = h + c), r + c > u && (a = u - c), u - h < this.height && (s = Math.max(s, this.height / (u - h)), a = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {\n          const e = this.worldMinX * this.scale,\n            t = this.worldMaxX * this.scale,\n            i = this.worldSize / 2 - (e + t) / 2;\n          n = (o + i + this.worldSize) % this.worldSize - i, n - l < e && (n = e + l), n + l > t && (n = t - l), t - e < this.width && (s = Math.max(s, this.width / (t - e)), n = (t + e) / 2);\n        }\n        n === o && a === r || (this.center = this.unproject(new e.P(n, a))), s && (this.zoom += this.scaleZoom(s)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;\n      }\n      _minZoomForBounds() {\n        let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));\n        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;\n      }\n      _maxCameraBoundsDistance() {\n        return this._mercatorZfromZoom(this._minZoomForBounds());\n      }\n      _calcMatrices() {\n        if (!this.height) return;\n        const t = this.centerOffset,\n          i = \"globe\" === this.projection.name,\n          o = this.pixelsPerMeter;\n        \"globe\" === this.projection.name && (this._mercatorScaleRatio = e.bl(1, this.center.lat) / e.bl(1, e.bI));\n        const r = e.bA(this.projection, this.zoom, this.width, this.height, 1024);\n        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;\n        const s = \"meters\" === this.projection.zAxisUnit ? o : 1,\n          n = this._camera.getWorldToCamera(this.worldSize, s);\n        let a;\n        const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);\n        if (l[8] = 2 * -t.x / this.width, l[9] = 2 * t.y / this.height, this.isOrthographic) {\n          let e = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov),\n            i = e * this.aspect,\n            o = -i,\n            r = -e;\n          i -= t.x, o -= t.x, e += t.y, r += t.y, a = this._camera.getCameraToClipOrthographic(o, i, r, e, this._nearZ, this._farZ), ((e, t, i, o) => {\n            for (let r = 0; r < 16; r++) e[r] = po(t[r], i[r], o);\n          })(a, a, l, fo(this.pitch >= 15 ? 1 : this.pitch / 15));\n        } else a = l;\n        const c = e.a6.mul([], l, n);\n        let h = e.a6.mul([], a, n);\n        if (this.projection.isReprojectedInTileSpace) {\n          const t = this.locationCoordinate(this.center),\n            i = e.a6.identity([]);\n          e.a6.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.a6.multiply(i, i, e.bB(this)), e.a6.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.a6.multiply(h, h, i), e.a6.multiply(c, c, i), this.inverseAdjustmentMatrix = e.bC(this);\n        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];\n        if (this.mercatorMatrix = e.a6.scale([], h, [this.worldSize, this.worldSize, this.worldSize / s, 1]), this.projMatrix = h, this.invProjMatrix = e.a6.invert(new Float64Array(16), this.projMatrix), i) {\n          const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);\n          i[8] = 2 * -t.x / this.width, i[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = e.a6.mul([], i, n);\n        } else this.expandedFarZProjMatrix = this.projMatrix;\n        const u = e.a6.invert([], a);\n        this.frustumCorners = e.bD.fromInvProjectionMatrix(u, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.bq.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);\n        const d = new Float32Array(16);\n        e.a6.identity(d), e.a6.scale(d, d, [1, -1, 1]), e.a6.rotateX(d, d, this._pitch), e.a6.rotateZ(d, d, this.angle);\n        const _ = e.a6.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);\n        this.starsProjMatrix = e.a6.clone(_);\n        const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;\n        _[8] = 2 * -t.x / this.width, _[9] = 2 * (t.y + p) / this.height, this.skyboxMatrix = e.a6.multiply(d, _, d);\n        const f = this.point,\n          m = f.x,\n          g = f.y,\n          v = this.width % 2 / 2,\n          x = this.height % 2 / 2,\n          y = Math.cos(this.angle),\n          b = Math.sin(this.angle),\n          w = m - Math.round(m) + y * v + b * x,\n          T = g - Math.round(g) + y * x + b * v,\n          E = new Float64Array(h);\n        if (e.a6.translate(E, E, [w > .5 ? w - 1 : w, T > .5 ? T - 1 : T, 0]), this.alignedProjMatrix = E, h = e.a6.create(), e.a6.scale(h, h, [this.width / 2, -this.height / 2, 1]), e.a6.translate(h, h, [1, -1, 0]), this.labelPlaneMatrix = h, h = e.a6.create(), e.a6.scale(h, h, [1, -1, 1]), e.a6.translate(h, h, [-1, -1, 0]), e.a6.scale(h, h, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h, this.pixelMatrix = e.a6.multiply(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.a6.invert(new Float64Array(16), this.pixelMatrix), !h) throw new Error(\"failed to invert matrix\");\n        if (this.pixelMatrixInverse = h, \"globe\" === this.projection.name || this.mercatorFromTransition) {\n          this.globeMatrix = e.bE(this);\n          const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];\n          this.globeCenterInViewSpace = e.N.transformMat4(t, t, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;\n        } else this.globeMatrix = h;\n        this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};\n      }\n      _calcFogMatrices() {\n        this._fogTileMatrixCache = {};\n        const t = this.cameraWorldSizeForFog,\n          i = this.cameraPixelsPerMeter,\n          o = this._camera.position,\n          r = 1 / this.height / this._pixelsPerMercatorPixel,\n          s = [t, t, i];\n        e.N.scale(s, s, r), e.N.scale(o, o, -1), e.N.multiply(o, o, s);\n        const n = e.a6.create();\n        e.a6.translate(n, n, o), e.a6.scale(n, n, s), this.mercatorFogMatrix = n, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, r);\n      }\n      _computeCameraPosition(e) {\n        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,\n          i = this._camera.forward(),\n          o = this.point,\n          r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;\n        return [o.x / this.worldSize - i[0] * r, o.y / this.worldSize - i[1] * r, e / this.worldSize * this._centerAltitude - i[2] * r];\n      }\n      _updateCameraState() {\n        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());\n      }\n      _translateCameraConstrained(t) {\n        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),\n          o = this._camera.position[2],\n          r = t[2];\n        let s = 1;\n        this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (s = Math.min((i - o) / r, 1)), this._camera.position = e.N.scaleAndAdd([], this._camera.position, t, s), this._updateStateFromCamera();\n      }\n      _updateStateFromCamera() {\n        const t = this._camera.position,\n          i = this._camera.forward(),\n          {\n            pitch: o,\n            bearing: r\n          } = this._camera.getPitchBearing(),\n          s = e.bl(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,\n          n = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.bj(this._maxPitch)),\n          a = Math.max((t[2] - s) / Math.cos(o), n),\n          l = this._zoomFromMercatorZ(a);\n        e.N.scaleAndAdd(t, t, i, a), this._pitch = e.aa(o, e.bj(this.minPitch), e.bj(this.maxPitch)), this.angle = e.bh(r, -Math.PI, Math.PI), this._setZoom(e.aa(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.L(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();\n      }\n      _worldSizeFromZoom(e) {\n        return Math.pow(2, e) * this.tileSize;\n      }\n      _mercatorZfromZoom(e) {\n        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);\n      }\n      _minimumHeightOverTerrain() {\n        const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;\n        return this._mercatorZfromZoom(e);\n      }\n      _zoomFromMercatorZ(e) {\n        return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));\n      }\n      zoomFromMercatorZAdjusted(t) {\n        let i = 0,\n          o = e.bx,\n          r = 0,\n          s = 1 / 0;\n        for (; o - i > 1e-6 && o > i;) {\n          const e = i + .5 * (o - i),\n            n = this.tileSize * Math.pow(2, e),\n            a = this.getCameraToCenterDistance(this.projection, e, n),\n            l = this.scaleZoom(a / (t * this.tileSize)),\n            c = Math.abs(e - l);\n          c < s && (s = c, r = e), e < l ? i = e : o = e;\n        }\n        return r;\n      }\n      _terrainEnabled() {\n        return !(!this._elevation || !this.projection.supportsTerrain && (e.w(\"Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.\"), 1));\n      }\n      anyCornerOffEdge(t, i) {\n        const o = Math.min(t.x, i.x),\n          r = Math.max(t.x, i.x),\n          s = Math.min(t.y, i.y),\n          n = Math.max(t.y, i.y);\n        if (s < this.horizonLineFromTop(!1)) return !0;\n        if (\"mercator\" !== this.projection.name) return !1;\n        const a = [new e.P(o, s), new e.P(r, n), new e.P(o, n), new e.P(r, s)],\n          l = this.renderWorldCopies ? -3 : 0,\n          c = this.renderWorldCopies ? 4 : 1;\n        for (const e of a) {\n          const t = this.pointRayIntersection(e);\n          if (t.t < 0) return !0;\n          const i = this.rayIntersectionCoordinate(t);\n          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;\n        }\n        return !1;\n      }\n      isHorizonVisible() {\n        return this.pitch + e.bF(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));\n      }\n      zoomDeltaToMovement(t, i) {\n        const o = e.N.length(e.N.sub([], this._camera.position, t)),\n          r = this._zoomFromMercatorZ(o) + i;\n        return o - this._mercatorZfromZoom(r);\n      }\n      getCameraPoint() {\n        if (\"globe\" === this.projection.name) {\n          const t = function ([t, i, o], r) {\n            const s = [t, i, o, 1];\n            e.a7.transformMat4(s, s, r);\n            const n = s[3] = Math.max(s[3], 1e-6);\n            return s[0] /= n, s[1] /= n, s[2] /= n, s;\n          }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);\n          return new e.P(t[0], t[1]);\n        }\n        {\n          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n          return this.centerPoint.add(new e.P(0, t));\n        }\n      }\n      getCameraToCenterDistance(t, i = this.zoom, o = this.worldSize) {\n        const r = e.bA(t, i, this.width, this.height, 1024),\n          s = t.pixelSpaceConversion(this.center.lat, o, r);\n        let n = .5 / Math.tan(.5 * this._fov) * this.height * s;\n        return this.isOrthographic && (n = po(1, n, fo(this.pitch >= 15 ? 1 : this.pitch / 15))), n;\n      }\n      getWorldToCameraMatrix() {\n        const t = this._camera.getWorldToCamera(this.worldSize, \"meters\" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);\n        return \"globe\" === this.projection.name && e.a6.multiply(t, t, this.globeMatrix), t;\n      }\n      getFrustum(t) {\n        return e.bq.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, \"meters\" === this.projection.zAxisUnit);\n      }\n    }\n    const go = {\n        BaseColor: 5,\n        MetallicRoughness: 6,\n        Normal: 7,\n        Occlusion: 8,\n        Emission: 9,\n        ShadowMap0: 10\n      },\n      vo = (t, i) => {\n        if (i > 0 && t.terrain && e.w(\"Cutoff is currently disabled on terrain\"), i <= 0 || t.terrain) return {\n          shouldRenderCutoff: !1,\n          uniformValues: {\n            u_cutoff_params: [0, 0, 0, 1]\n          }\n        };\n        const o = t.transform,\n          r = Math.max(Math.abs(o._zoom - (t.minCutoffZoom - 1)), 1),\n          s = o.isLODDisabled(!1) ? e.O(60, 45, o.pitch) : e.O(30, 15, o.pitch),\n          n = o._farZ - o._nearZ,\n          a = i * o.height,\n          l = ((1 - (c = s)) * o.cameraToCenterDistance + c * (o._farZ + a)) * r;\n        var c;\n        return {\n          shouldRenderCutoff: s < 1,\n          uniformValues: {\n            u_cutoff_params: [o._nearZ, o._farZ, (l - o._nearZ) / n, (l - a - o._nearZ) / n]\n          }\n        };\n      },\n      xo = {\n        cascadeCount: 2,\n        shadowMapResolution: 2048\n      };\n    class yo {\n      constructor(e, t) {\n        this.aabb = e, this.lastCascade = t;\n      }\n    }\n    class bo {\n      add(e, t) {\n        const i = this.receivers[e.key];\n        void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t.max[2])) : this.receivers[e.key] = new yo(t, null);\n      }\n      clear() {\n        this.receivers = {};\n      }\n      get(e) {\n        return this.receivers[e.key];\n      }\n      computeRequiredCascades(t, i, o) {\n        const r = e.bS.fromPoints(t.points);\n        let s = 0;\n        for (const t in this.receivers) {\n          const n = this.receivers[t];\n          if (!n) continue;\n          if (!r.intersectsAabb(n.aabb)) continue;\n          n.aabb.min = r.closestPoint(n.aabb.min), n.aabb.max = r.closestPoint(n.aabb.max);\n          const a = n.aabb.getCorners();\n          for (let t = 0; t < o.length; t++) {\n            let r = !0;\n            for (const s of a) {\n              const n = [s[0] * i, s[1] * i, s[2]];\n              if (e.N.transformMat4(n, n, o[t].matrix), n[0] < -1 || n[0] > 1 || n[1] < -1 || n[1] > 1) {\n                r = !1;\n                break;\n              }\n            }\n            if (n.lastCascade = t, s = Math.max(s, t), r) break;\n          }\n        }\n        return s + 1;\n      }\n    }\n    class wo {\n      constructor(e) {\n        this.painter = e, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new bo(), this._depthMode = new Lt(e.context.gl.LEQUAL, Lt.ReadWrite, [0, 1]), this._uniformValues = {\n          u_light_matrix_0: new Float32Array(16),\n          u_light_matrix_1: new Float32Array(16),\n          u_shadow_intensity: 0,\n          u_fade_range: [0, 0],\n          u_shadow_normal_offset: [1, 1, 1],\n          u_shadow_texel_size: 1,\n          u_shadow_map_resolution: 1,\n          u_shadow_direction: [0, 0, 1],\n          u_shadow_bias: [36e-5, .0012, .012],\n          u_shadowmap_0: 0,\n          u_shadowmap_1: 0\n        }, this.useNormalOffset = !1, e.tp.registerParameter(xo, [\"Shadows\"], \"cascadeCount\", {\n          min: 1,\n          max: 2,\n          step: 1\n        }), e.tp.registerParameter(xo, [\"Shadows\"], \"shadowMapResolution\", {\n          min: 32,\n          max: 2048,\n          step: 32\n        });\n      }\n      destroy() {\n        for (const e of this._cascades) e.texture.destroy(), e.framebuffer.destroy();\n        this._cascades = [];\n      }\n      updateShadowParameters(t, i) {\n        const o = this.painter;\n        if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i || !i.properties) return;\n        const r = i.properties.get(\"shadow-intensity\");\n        if (!i.shadowsEnabled() || r <= 0) return;\n        if (this._shadowLayerCount = o.style.order.reduce((e, i) => {\n          const r = o.style._mergedLayers[i];\n          return e + (r.hasShadowPass() && !r.isHidden(t.zoom) ? 1 : 0);\n        }, 0), this._enabled = this._shadowLayerCount > 0, !this._enabled) return;\n        const s = o.context,\n          n = xo.shadowMapResolution,\n          a = xo.shadowMapResolution;\n        if (0 === this._cascades.length || xo.shadowMapResolution !== this._cascades[0].texture.size[0]) {\n          this._cascades = [];\n          for (let t = 0; t < xo.cascadeCount; ++t) {\n            const t = o._shadowMapDebug,\n              i = s.gl,\n              r = s.createFramebuffer(n, a, t, \"texture\"),\n              l = new e.T(s, {\n                width: n,\n                height: a,\n                data: null\n              }, i.DEPTH_COMPONENT);\n            if (r.depthAttachment.set(l.texture), t) {\n              const t = new e.T(s, {\n                width: n,\n                height: a,\n                data: null\n              }, i.RGBA);\n              r.colorAttachment.set(t.texture);\n            }\n            this._cascades.push({\n              framebuffer: r,\n              texture: l,\n              matrix: [],\n              far: 0,\n              boundingSphereRadius: 0,\n              frustum: new e.bq(),\n              scale: 0\n            });\n          }\n        }\n        this.shadowDirection = Eo(i);\n        let l = 0;\n        if (t.elevation) {\n          const e = t.elevation,\n            i = [1e4, -1e4];\n          e.visibleDemTiles.filter(e => e.dem).forEach(e => {\n            const t = e.dem.tree;\n            i[0] = Math.min(i[0], t.minimums[0]), i[1] = Math.max(i[1], t.maximums[0]);\n          }), 1e4 !== i[0] && (l = (i[1] - i[0]) * e.exaggeration());\n        }\n        const c = 1.5 * t.cameraToCenterDistance,\n          h = 3 * c,\n          u = new Float64Array(16);\n        for (let i = 0; i < this._cascades.length; ++i) {\n          const o = this._cascades[i];\n          let r = t.height / 50,\n            s = 1;\n          1 === xo.cascadeCount ? s = h : 0 === i ? s = c : (r = c, s = h);\n          const [n, a] = Co(t, this.shadowDirection, r, s, xo.shadowMapResolution, l);\n          o.scale = t.scale, o.matrix = n, o.boundingSphereRadius = a, e.a6.invert(u, o.matrix), o.frustum = e.bq.fromInvProjectionMatrix(u, 1, 0, !0), o.far = s;\n        }\n        const d = this._cascades.length - 1;\n        this._uniformValues.u_fade_range = [.75 * this._cascades[d].far, this._cascades[d].far], this._uniformValues.u_shadow_intensity = r, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / xo.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = xo.shadowMapResolution, this._uniformValues.u_shadowmap_0 = go.ShadowMap0, this._uniformValues.u_shadowmap_1 = go.ShadowMap0 + 1, this._groundShadowTiles = o.transform.coveringTiles({\n          tileSize: 512,\n          renderWorldCopies: !0\n        });\n        const _ = o.transform.elevation;\n        for (const e of this._groundShadowTiles) {\n          let t = {\n            min: 0,\n            max: 0\n          };\n          if (_) {\n            const i = _.getMinMaxForTile(e);\n            i && (t = i);\n          }\n          this.addShadowReceiver(e.toUnwrapped(), t.min, t.max);\n        }\n      }\n      get enabled() {\n        return this._enabled;\n      }\n      set enabled(e) {\n        this._enabled = e;\n      }\n      drawShadowPass(t, i) {\n        if (!this._enabled) return;\n        const o = this.painter,\n          r = o.context;\n        this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), r.viewport.set([0, 0, xo.shadowMapResolution, xo.shadowMapResolution]);\n        for (let s = 0; s < this._numCascadesToRender; ++s) {\n          o.currentShadowCascade = s, r.bindFramebuffer.set(this._cascades[s].framebuffer.framebuffer), r.clear({\n            color: e.ax.white,\n            depth: 1\n          });\n          for (const e of t.order) {\n            const r = t._mergedLayers[e];\n            if (!r.hasShadowPass() || r.isHidden(o.transform.zoom)) continue;\n            const s = t.getLayerSourceCache(r),\n              n = s ? i[s.id] : void 0;\n            (\"model\" === r.type || n && n.length) && o.renderLayer(o, s, r, n);\n          }\n        }\n        o.currentShadowCascade = 0;\n      }\n      drawGroundShadows() {\n        if (!this._enabled) return;\n        const e = this.painter,\n          t = e.style,\n          i = e.context,\n          o = t.directionalLight,\n          r = t.ambientLight;\n        if (!o || !r) return;\n        const s = [],\n          n = vo(e, e.longestCutoffRange);\n        n.shouldRenderCutoff && s.push(\"RENDER_CUTOFF\");\n        const a = So(o, r),\n          l = new Lt(i.gl.LEQUAL, Lt.ReadOnly, e.depthRangeFor3D);\n        for (const t of this._groundShadowTiles) {\n          const o = t.toUnwrapped(),\n            r = e.isTileAffectedByFog(t),\n            c = e.getOrCreateProgram(\"groundShadow\", {\n              defines: s,\n              overrideFog: r\n            });\n          this.setupShadows(o, c), e.uploadCommonUniforms(i, c, o, null, n);\n          const h = {\n            u_matrix: e.transform.calculateProjMatrix(o),\n            u_ground_shadow_factor: a\n          };\n          c.draw(e, i.gl.TRIANGLES, l, Rt.disabled, Mt.multiply, Ft.disabled, h, \"ground_shadow\", e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments, {}, e.transform.zoom, null, null);\n        }\n      }\n      getShadowPassColorMode() {\n        return this.painter._shadowMapDebug ? Mt.unblended : Mt.disabled;\n      }\n      getShadowPassDepthMode() {\n        return this._depthMode;\n      }\n      getShadowCastingLayerCount() {\n        return this._shadowLayerCount;\n      }\n      calculateShadowPassMatrixFromTile(t) {\n        const i = this.painter.transform,\n          o = i.calculatePosMatrix(t, i.worldSize);\n        return e.a6.multiply(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);\n      }\n      calculateShadowPassMatrixFromMatrix(t) {\n        return e.a6.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);\n      }\n      setupShadows(t, i, o, r = 0) {\n        if (!this._enabled) return;\n        const s = this.painter.transform,\n          n = this.painter.context,\n          a = n.gl,\n          l = this._uniformValues,\n          c = new Float64Array(16),\n          h = s.calculatePosMatrix(t, s.worldSize);\n        for (let t = 0; t < this._cascades.length; t++) e.a6.multiply(c, this._cascades[t].matrix, h), l[0 === t ? \"u_light_matrix_0\" : \"u_light_matrix_1\"] = Float32Array.from(c), n.activeTexture.set(a.TEXTURE0 + go.ShadowMap0 + t), this._cascades[t].texture.bind(a.NEAREST, a.CLAMP_TO_EDGE);\n        if (this.useNormalOffset = !!o, this.useNormalOffset) {\n          const i = e.bR(t.canonical),\n            n = 2 / s.tileSize * e.V / xo.shadowMapResolution,\n            a = n * this._cascades[0].boundingSphereRadius,\n            c = n * this._cascades[this._cascades.length - 1].boundingSphereRadius,\n            h = (\"vector-tile\" === o ? 1 : 3) / Math.pow(2, r - t.canonical.z - (1 - s.zoom + Math.floor(s.zoom)));\n          l.u_shadow_normal_offset = [i, a * h, c * h], l.u_shadow_bias = [6e-5, .0012, .012];\n        } else l.u_shadow_bias = [36e-5, .0012, .012];\n        i.setShadowUniformValues(n, l);\n      }\n      setupShadowsFromMatrix(t, i, o = !1) {\n        if (!this._enabled) return;\n        const r = this.painter.context,\n          s = r.gl,\n          n = this._uniformValues,\n          a = new Float64Array(16);\n        for (let i = 0; i < xo.cascadeCount; i++) e.a6.multiply(a, this._cascades[i].matrix, t), n[0 === i ? \"u_light_matrix_0\" : \"u_light_matrix_1\"] = Float32Array.from(a), r.activeTexture.set(s.TEXTURE0 + go.ShadowMap0 + i), this._cascades[i].texture.bind(s.NEAREST, s.CLAMP_TO_EDGE);\n        if (this.useNormalOffset = o, o) {\n          const e = 5;\n          n.u_shadow_normal_offset = [1, e, e], n.u_shadow_bias = [6e-5, .0012, .012];\n        } else n.u_shadow_bias = [36e-5, .0012, .012];\n        i.setShadowUniformValues(r, n);\n      }\n      getShadowUniformValues() {\n        return this._uniformValues;\n      }\n      getCurrentCascadeFrustum() {\n        return this._cascades[this.painter.currentShadowCascade].frustum;\n      }\n      computeSimplifiedTileShadowVolume(t, i, o, r) {\n        if (r[2] >= 0) return {};\n        const s = function (t, i, o) {\n            const r = o / (1 << t.canonical.z);\n            return new e.bS([t.canonical.x * r + t.wrap * o, t.canonical.y * r + t.wrap * o, 0], [(t.canonical.x + 1) * r + t.wrap * o, (t.canonical.y + 1) * r + t.wrap * o, i]);\n          }(t, i, o).getCorners(),\n          n = i / -r[2];\n        r[0] < 0 ? (e.N.add(s[0], s[0], [r[0] * n, 0, 0]), e.N.add(s[3], s[3], [r[0] * n, 0, 0])) : r[0] > 0 && (e.N.add(s[1], s[1], [r[0] * n, 0, 0]), e.N.add(s[2], s[2], [r[0] * n, 0, 0])), r[1] < 0 ? (e.N.add(s[0], s[0], [0, r[1] * n, 0]), e.N.add(s[1], s[1], [0, r[1] * n, 0])) : r[1] > 0 && (e.N.add(s[2], s[2], [0, r[1] * n, 0]), e.N.add(s[3], s[3], [0, r[1] * n, 0]));\n        const a = {};\n        return a.vertices = s, a.planes = [To(s[1], s[0], s[4]), To(s[2], s[1], s[5]), To(s[3], s[2], s[6]), To(s[0], s[3], s[7])], a;\n      }\n      addShadowReceiver(t, i, o) {\n        this._receivers.add(t, e.bS.fromTileIdAndHeight(t, i, o));\n      }\n      getMaxCascadeForTile(e) {\n        const t = this._receivers.get(e);\n        return t && t.lastCascade ? t.lastCascade : 0;\n      }\n    }\n    function To(t, i, o) {\n      const r = e.N.sub([], o, i),\n        s = e.N.sub([], t, i),\n        n = e.N.cross([], r, s),\n        a = e.N.length(n);\n      return 0 === a ? [0, 0, 1, 0] : (e.N.scale(n, n, 1 / a), [n[0], n[1], n[2], -e.N.dot(n, i)]);\n    }\n    function Eo(t) {\n      const i = t.properties.get(\"direction\"),\n        o = e.bQ(i.x, i.y, i.z);\n      o[2] = e.aa(o[2], 0, 75);\n      const r = e.bT([o[0], o[1], o[2]]);\n      return e.N.fromValues(r.x, r.y, r.z);\n    }\n    function So(t, i) {\n      const o = t.properties.get(\"color\"),\n        r = t.properties.get(\"intensity\"),\n        s = t.properties.get(\"direction\"),\n        n = [s.x, s.y, s.z],\n        a = i.properties.get(\"color\"),\n        l = i.properties.get(\"intensity\"),\n        c = Math.max(e.N.dot([0, 0, 1], n), 0),\n        h = [0, 0, 0];\n      e.N.scale(h, a.toArray01Linear().slice(0, 3), l);\n      const u = [0, 0, 0];\n      return e.N.scale(u, o.toArray01Linear().slice(0, 3), c * r), e.bU([h[0] > 0 ? h[0] / (h[0] + u[0]) : 0, h[1] > 0 ? h[1] / (h[1] + u[1]) : 0, h[2] > 0 ? h[2] / (h[2] + u[2]) : 0]);\n    }\n    function Co(t, i, o, r, s, n) {\n      const a = t.zoom,\n        l = t.scale,\n        c = t.worldSize,\n        h = 1 / c,\n        u = t.aspect,\n        d = Math.sqrt(1 + u * u) * Math.tan(.5 * t.fovX),\n        _ = d * d,\n        p = r - o,\n        f = r + o;\n      let m, g;\n      _ > p / f ? (m = r, g = r * d) : (m = .5 * f * (1 + _), g = .5 * Math.sqrt(p * p + 2 * (r * r + o * o) * _ + f * f * _ * _));\n      const v = t.projection.pixelsPerMeter(t.center.lat, c),\n        x = t._camera.getCameraToWorldMercator(),\n        y = [0, 0, -m * h];\n      e.N.transformMat4(y, y, x);\n      let b = g * h;\n      const w = t._edgeInsets;\n      if (!(0 === w.left && 0 === w.top && 0 === w.right && 0 === w.bottom || w.left === w.right && w.top === w.bottom)) {\n        const i = t._camera.getWorldToCamera(t.worldSize, \"meters\" === t.projection.zAxisUnit ? v : 1),\n          s = t._camera.getCameraToClipPerspective(t._fov, t.width / t.height, o, r);\n        s[8] = 2 * -t.centerOffset.x / t.width, s[9] = 2 * t.centerOffset.y / t.height;\n        const n = new Float64Array(16);\n        e.a6.mul(n, s, i);\n        const h = new Float64Array(16);\n        e.a6.invert(h, n);\n        const u = e.bq.fromInvProjectionMatrix(h, c, a, !0);\n        for (const i of u.points) {\n          const o = ((T = i)[0] /= l, T[1] /= l, T[2] = e.bl(T[2], t._center.lat), T);\n          b = Math.max(b, e.N.len(e.N.subtract([], y, o)));\n        }\n      }\n      var T;\n      b *= s / (s - 1);\n      const E = Math.acos(i[2]),\n        S = Math.atan2(-i[0], -i[1]),\n        C = new _o();\n      C.position = y, C.setPitchBearing(E, S);\n      const I = C.getWorldToCamera(c, v),\n        D = b * c,\n        L = Math.min(t._mercatorZfromZoom(17) * c * -2, -2 * D),\n        A = C.getCameraToClipOrthographic(-D, D, -D, D, L, (D + n * v) / i[2]),\n        R = new Float64Array(16);\n      e.a6.multiply(R, A, I);\n      const P = e.N.fromValues(Math.floor(1e6 * y[0]) / 1e6 * c, Math.floor(1e6 * y[1]) / 1e6 * c, 0),\n        M = .5 * s,\n        z = [0, 0, 0];\n      e.N.transformMat4(z, P, R), e.N.scale(z, z, M);\n      const O = [Math.floor(z[0]), Math.floor(z[1]), Math.floor(z[2])],\n        F = [0, 0, 0];\n      e.N.sub(F, z, O), e.N.scale(F, F, -1 / M);\n      const B = new Float64Array(16);\n      return e.a6.identity(B), e.a6.translate(B, B, F), e.a6.multiply(R, B, R), [R, D];\n    }\n    const Io = (e, t) => ce(e, t && t.filter(e => \"source.canvas\" !== e.identifier)),\n      Do = e.ac(oi, [\"addLayer\", \"removeLayer\", \"setLights\", \"setPaintProperty\", \"setLayoutProperty\", \"setSlot\", \"setFilter\", \"addSource\", \"removeSource\", \"setLayerZoomRange\", \"setLight\", \"setTransition\", \"setGeoJSONSourceData\", \"setTerrain\", \"setFog\", \"setProjection\", \"setCamera\", \"addImport\", \"removeImport\", \"updateImport\"]),\n      Lo = e.ac(oi, [\"setCenter\", \"setZoom\", \"setBearing\", \"setPitch\"]),\n      Ao = {\n        version: 8,\n        layers: [],\n        sources: {}\n      },\n      Ro = {\n        duration: 300,\n        delay: 0\n      },\n      Po = new Set([\"fill\", \"line\", \"background\", \"hillshade\", \"raster\"]);\n    class Mo extends e.E {\n      constructor(t, i = {}) {\n        super(), this.map = t, this.scope = i.scope || \"\", this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map(), this.resolvedImports = i.resolvedImports || new Set(), this.transition = e.e({}, Ro), this._buildingIndex = new ei(this), this.crossTileSymbolIndex = new no(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = i.styleChanges || new v(), this.dispatcher = i.dispatcher ? i.dispatcher : new e.bW(e.bX(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new w(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.bY(t._requestManager, i.localFontFamily ? e.bZ.all : i.localIdeographFontFamily ? e.bZ.ideographs : e.bZ.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new x(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = i.configOptions ? i.configOptions : new Map(), this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set(), this._config = i.config, this.dispatcher.broadcast(\"setReferrer\", e.b_());\n        const o = this;\n        this._rtlTextPluginCallback = Mo.registerForPluginStateChange(t => {\n          o.dispatcher.broadcast(\"syncRTLPluginState\", {\n            pluginStatus: t.pluginStatus,\n            pluginURL: t.pluginURL\n          }, (t, i) => {\n            if (e.b$(t), i && i.every(e => e)) for (const e in o._sourceCaches) {\n              const t = o._sourceCaches[e],\n                i = t.getSource().type;\n              \"vector\" !== i && \"geojson\" !== i || t.reload();\n            }\n          });\n        }), this.on(\"data\", e => {\n          if (\"source\" !== e.dataType || \"metadata\" !== e.sourceDataType) return;\n          const t = this.getOwnSource(e.sourceId);\n          if (t && t.vectorLayerIds) for (const e in this._layers) {\n            const i = this._layers[e];\n            i.source === t.id && this._validateLayer(i);\n          }\n        });\n      }\n      loadURL(t, i = {}) {\n        this.fire(new e.b(\"dataloading\", {\n          dataType: \"style\"\n        }));\n        const o = \"boolean\" == typeof i.validate ? i.validate : !e.c0(t);\n        t = this.map._requestManager.normalizeStyleURL(t, i.accessToken), this.resolvedImports.add(t);\n        const r = this.importsCache.get(t);\n        if (r) return this._load(r, o);\n        const s = this.map._requestManager.transformRequest(t, e.R.Style);\n        this._request = e.g(s, (i, r) => {\n          if (this._request = null, i) this.fire(new e.a(i));else if (r) return this.importsCache.set(t, r), this._load(r, o);\n        });\n      }\n      loadJSON(t, i = {}) {\n        this.fire(new e.b(\"dataloading\", {\n          dataType: \"style\"\n        })), this._request = e.f.frame(() => {\n          this._request = null, this._load(t, !1 !== i.validate);\n        });\n      }\n      loadEmpty() {\n        this.fire(new e.b(\"dataloading\", {\n          dataType: \"style\"\n        })), this._load(Ao, !1);\n      }\n      _loadImports(t, i, o) {\n        if (this.importDepth >= 4) return e.w(\"Style doesn't support nesting deeper than 5\"), Promise.resolve();\n        const r = [];\n        for (const e of t) {\n          const t = this._createFragmentStyle(e),\n            s = new Promise(e => {\n              t.once(\"style.import.load\", e), t.once(\"error\", e);\n            }).then(() => this.mergeAll());\n          if (r.push(s), this.resolvedImports.has(e.url)) {\n            t.loadEmpty();\n            continue;\n          }\n          const n = e.data || this.importsCache.get(e.url);\n          n ? t.loadJSON(n, {\n            validate: i\n          }) : e.url ? t.loadURL(e.url, {\n            validate: i\n          }) : t.loadEmpty();\n          const a = {\n            style: t,\n            id: e.id,\n            config: e.config\n          };\n          if (o) {\n            const e = this.fragments.findIndex(({\n              id: e\n            }) => e === o);\n            this.fragments = this.fragments.slice(0, e).concat(a).concat(this.fragments.slice(e));\n          } else this.fragments.push(a);\n        }\n        return Promise.allSettled(r);\n      }\n      _createFragmentStyle(t) {\n        const i = this.scope ? e.ag(t.id, this.scope) : t.id,\n          o = new Mo(this.map, {\n            scope: i,\n            styleChanges: this._changes,\n            importDepth: this.importDepth + 1,\n            importsCache: this.importsCache,\n            resolvedImports: new Set(this.resolvedImports),\n            dispatcher: this.dispatcher,\n            imageManager: this.imageManager,\n            glyphManager: this.glyphManager,\n            modelManager: this.modelManager,\n            config: t.config,\n            configOptions: this.options,\n            configDependentLayers: this._configDependentLayers\n          });\n        return o.setEventedParent(this.map, {\n          style: o\n        }), o;\n      }\n      _reloadImports() {\n        this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast(\"setLayers\", {\n          layers: this._serializeLayers(this._order),\n          scope: this.scope,\n          options: this.options\n        });\n        const t = this.isRootStyle();\n        this._shouldPrecompile = t, this.fire(new e.b(t ? \"style.load\" : \"style.import.load\"));\n      }\n      _load(t, i) {\n        const o = t.schema;\n        if (this.isRootStyle() && (t.fragment || o && !1 !== t.fragment)) {\n          const o = e.e({}, Ao, {\n            imports: [{\n              id: \"basemap\",\n              data: t,\n              url: \"\"\n            }]\n          });\n          return void this._load(o, i);\n        }\n        if (this.setConfig(this._config, o), i && Io(this, Y(t))) return;\n        this._loaded = !0, this.stylesheet = e.c1(t);\n        for (const e in t.sources) this.addSource(e, t.sources[e], {\n          validate: !1,\n          isInitialLoad: !0\n        });\n        t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n          scope: this.scope,\n          isLoaded: !0\n        })), this.glyphManager.setURL(t.glyphs, this.scope);\n        const r = ii(this.stylesheet.layers);\n        if (this._order = r.map(e => e.id), this.stylesheet.light && e.w(\"The `light` root property is deprecated, prefer using `lights` with `flat` light type instead.\"), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && \"flat\" === this.stylesheet.lights[0].type) {\n          const e = this.stylesheet.lights[0];\n          this.light = new ue(e.properties, e.id);\n        } else this.setLights(this.stylesheet.lights);\n        this.light || (this.light = new ue(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};\n        for (const t of r) {\n          const i = e.c2(t, this.scope, this.options);\n          i.isConfigDependent && this._configDependentLayers.add(i.fqid), i.setEventedParent(this, {\n            layer: {\n              id: i.id\n            }\n          }), this._layers[i.id] = i, this._serializedLayers[i.id] = i.serialize();\n          const o = this.getOwnLayerSourceCache(i),\n            r = !!this.directionalLight && this.directionalLight.shadowsEnabled();\n          o && i.canCastShadows() && r && (o.castsShadows = !0);\n        }\n        this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);\n        const s = this.stylesheet.terrain;\n        s && (void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.f.hasCanvasFingerprintNoise()), this.disableElevatedTerrain ? e.w(\"Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).\") : this.terrainSetForDrapingOnly() || this._createTerrain(s, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.b(\"data\", {\n          dataType: \"style\"\n        })), t.imports ? this._loadImports(t.imports, i).then(() => this._reloadImports()) : this._reloadImports();\n      }\n      isRootStyle() {\n        return 0 === this.importDepth;\n      }\n      mergeAll() {\n        let t, i, o, r, s, n, a, l;\n        this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(e => {\n          if (e.stylesheet) {\n            if (null != e.light && (t = e.light), e.stylesheet.lights) for (const t of e.stylesheet.lights) \"ambient\" === t.type && null != e.ambientLight && (i = e.ambientLight), \"directional\" === t.type && null != e.directionalLight && (o = e.directionalLight);\n            r = this._prioritizeTerrain(r, e.terrain, e.stylesheet.terrain), e.stylesheet.fog && null != e.fog && (s = e.fog), null != e.stylesheet.camera && (l = e.stylesheet.camera), null != e.stylesheet.projection && (n = e.stylesheet.projection), null != e.stylesheet.transition && (a = e.stylesheet.transition);\n          }\n        }), this.light = t, this.ambientLight = i, this.directionalLight = o, this.fog = s, null === r ? delete this.terrain : this.terrain = r, this.camera = l || {\n          \"camera-projection\": \"perspective\"\n        }, this.projection = n || {\n          name: \"mercator\"\n        }, this.transition = e.e({}, Ro, a), this.mergeSources(), this.mergeLayers();\n      }\n      forEachFragmentStyle(e) {\n        const t = i => {\n          for (const e of i.fragments) t(e.style);\n          e(i);\n        };\n        t(this);\n      }\n      _prioritizeTerrain(e, t, i) {\n        const o = e && 0 === e.drapeRenderMode;\n        return null === i ? t && 0 === t.drapeRenderMode ? t : o ? e : null : null != t && (!e || o || t && 1 === t.drapeRenderMode) ? t : e;\n      }\n      mergeTerrain() {\n        let e;\n        this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(t => {\n          e = this._prioritizeTerrain(e, t.terrain, t.stylesheet.terrain);\n        }), null === e ? delete this.terrain : this.terrain = e;\n      }\n      mergeProjection() {\n        let e;\n        this.forEachFragmentStyle(t => {\n          null != t.stylesheet.projection && (e = t.stylesheet.projection);\n        }), this.projection = e || {\n          name: \"mercator\"\n        };\n      }\n      mergeSources() {\n        const t = {},\n          i = {},\n          o = {};\n        this.forEachFragmentStyle(r => {\n          for (const i in r._sourceCaches) {\n            const o = e.ag(i, r.scope);\n            t[o] = r._sourceCaches[i];\n          }\n          for (const t in r._otherSourceCaches) {\n            const o = e.ag(t, r.scope);\n            i[o] = r._otherSourceCaches[t];\n          }\n          for (const t in r._symbolSourceCaches) {\n            const i = e.ag(t, r.scope);\n            o[i] = r._symbolSourceCaches[t];\n          }\n        }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;\n      }\n      mergeLayers() {\n        const t = {},\n          i = [],\n          o = {};\n        this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle(o => {\n          for (const r of o._order) {\n            const s = o._layers[r];\n            if (\"slot\" === s.type) {\n              const i = e.c3(r);\n              if (t[i]) continue;\n              t[i] = [];\n            }\n            s.slot && t[s.slot] ? t[s.slot].push(s) : i.push(s);\n          }\n        }), this._mergedOrder = [];\n        const r = (i = []) => {\n          for (const s of i) if (\"slot\" === s.type) {\n            const i = e.c3(s.id);\n            t[i] && r(t[i]);\n          } else {\n            const t = e.ag(s.id, s.scope);\n            this._mergedOrder.push(t), o[t] = s, s.is3D() && (this._has3DLayers = !0), \"circle\" === s.type && (this._hasCircleLayers = !0), \"symbol\" === s.type && (this._hasSymbolLayers = !0);\n          }\n        };\n        r(i), this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();\n      }\n      terrainSetForDrapingOnly() {\n        return !!this.terrain && 0 === this.terrain.drapeRenderMode;\n      }\n      getCamera() {\n        return this.stylesheet.camera;\n      }\n      setCamera(t) {\n        return this.stylesheet.camera = e.e({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this;\n      }\n      setProjection(e) {\n        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();\n      }\n      applyProjectionUpdate() {\n        this._loaded && (this.dispatcher.broadcast(\"setProjection\", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));\n      }\n      _updateMapProjection() {\n        this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));\n      }\n      _loadSprite(t) {\n        this._spriteRequest = function (t, i, o) {\n          let r, s, n;\n          const a = e.f.devicePixelRatio > 1 ? \"@2x\" : \"\";\n          let l = e.g(i.transformRequest(i.normalizeSpriteURL(t, a, \".json\"), e.R.SpriteJSON), (e, t) => {\n              l = null, n || (n = e, r = t, h());\n            }),\n            c = e.d(i.transformRequest(i.normalizeSpriteURL(t, a, \".png\"), e.R.SpriteImage), (e, t) => {\n              c = null, n || (n = e, s = t, h());\n            });\n          function h() {\n            if (n) o(n);else if (r && s) {\n              const t = e.f.getImageData(s),\n                i = {};\n              for (const o in r) {\n                const {\n                    width: s,\n                    height: n,\n                    x: a,\n                    y: l,\n                    sdf: c,\n                    pixelRatio: h,\n                    stretchX: u,\n                    stretchY: d,\n                    content: _\n                  } = r[o],\n                  p = new e.h({\n                    width: s,\n                    height: n\n                  });\n                e.h.copy(t, p, {\n                  x: a,\n                  y: l\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: s,\n                  height: n\n                }), i[o] = {\n                  data: p,\n                  pixelRatio: h,\n                  sdf: c,\n                  stretchX: u,\n                  stretchY: d,\n                  content: _\n                };\n              }\n              o(null, i);\n            }\n          }\n          return {\n            cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n          };\n        }(t, this.map._requestManager, (t, i) => {\n          if (this._spriteRequest = null, t) this.fire(new e.a(t));else if (i) for (const e in i) this.imageManager.addImage(e, this.scope, i[e]);\n          this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast(\"setImages\", {\n            scope: this.scope,\n            images: this._availableImages\n          }), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          }), this.fire(new e.b(\"data\", {\n            dataType: \"style\"\n          }));\n        });\n      }\n      _validateLayer(t) {\n        const i = this.getOwnSource(t.source);\n        if (!i) return;\n        const o = t.sourceLayer;\n        o && (\"geojson\" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.a(new Error(`Source layer \"${o}\" does not exist on source \"${i.id}\" as specified by style layer \"${t.id}\"`)));\n      }\n      loaded() {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;\n        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;\n        if (!this.imageManager.isLoaded()) return !1;\n        if (!this.modelManager.isLoaded()) return !1;\n        for (const {\n          style: e\n        } of this.fragments) if (!e.loaded()) return !1;\n        return !0;\n      }\n      _serializeImports() {\n        if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t) => {\n          const i = this.fragments[t];\n          return i && i.style && (e.data = i.style.serialize()), e;\n        });\n      }\n      _serializeSources() {\n        const e = {};\n        for (const t in this._sourceCaches) {\n          const i = this._sourceCaches[t].getSource();\n          e[i.id] || (e[i.id] = i.serialize());\n        }\n        return e;\n      }\n      _serializeLayers(e) {\n        const t = [];\n        for (const i of e) {\n          const e = this._layers[i];\n          e && \"custom\" !== e.type && t.push(e.serialize());\n        }\n        return t;\n      }\n      hasLightTransitions() {\n        return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());\n      }\n      hasFogTransition() {\n        return !!this.fog && this.fog.hasTransition();\n      }\n      hasTransitions() {\n        if (this.hasLightTransitions()) return !0;\n        if (this.hasFogTransition()) return !0;\n        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;\n        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;\n        return !1;\n      }\n      get order() {\n        return this.terrain ? this._drapedFirstOrder : this._mergedOrder;\n      }\n      isLayerDraped(e) {\n        return !!this.terrain && (\"function\" == typeof e.isLayerDraped ? e.isLayerDraped(this.getLayerSourceCache(e)) : Po.has(e.type));\n      }\n      _checkLoaded() {\n        if (!this._loaded) throw new Error(\"Style is not done loading\");\n      }\n      _checkLayer(t) {\n        const i = this.getOwnLayer(t);\n        if (i) return i;\n        this.fire(new e.a(new Error(`The layer '${t}' does not exist in the map's style.`)));\n      }\n      _checkSource(t) {\n        const i = this.getOwnSource(t);\n        if (i) return i;\n        this.fire(new e.a(new Error(`The source '${t}' does not exist in the map's style.`)));\n      }\n      update(t) {\n        if (!this._loaded) return;\n        this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);\n        const i = this.calculateLightsBrightness();\n        t.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast(\"setBrightness\", i));\n        const o = this._changes.isDirty();\n        if (this._changes.isDirty()) {\n          const e = this._changes.getLayerUpdatesByScope();\n          for (const t in e) {\n            const {\n              updatedIds: i,\n              removedIds: o\n            } = e[t];\n            (i || o) && this._updateWorkerLayers(t, i, o);\n          }\n          this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._changes.reset();\n        }\n        const r = {};\n        for (const e in this._mergedSourceCaches) {\n          const t = this._mergedSourceCaches[e];\n          r[e] = t.used, t.used = !1, t.tileCoverLift = 0;\n        }\n        for (const e of this._mergedOrder) {\n          const i = this._mergedLayers[e];\n          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {\n            const e = this.getLayerSourceCache(i);\n            e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));\n          }\n          if (!this._precompileDone && this._shouldPrecompile) for (let e = i.minzoom || 0; e < (i.maxzoom || 25.5); e++) {\n            const e = this.map.painter;\n            if (e) {\n              const o = i.getProgramIds();\n              if (!o) continue;\n              for (const r of o) {\n                const o = i.getDefaultProgramParams(r, t.zoom);\n                o && (e.style = this, this.fog && (e._fogVisible = !0, o.overrideFog = !0, e.getOrCreateProgram(r, o)), e._fogVisible = !1, o.overrideFog = !1, e.getOrCreateProgram(r, o), (this.stylesheet.terrain || this.stylesheet.projection && \"globe\" === this.stylesheet.projection.name) && (o.overrideRtt = !0, e.getOrCreateProgram(r, o)));\n              }\n            }\n          }\n        }\n        this._shouldPrecompile && (this._precompileDone = !0);\n        for (const t in r) {\n          const i = this._mergedSourceCaches[t];\n          r[t] !== i.used && i.getSource().fire(new e.b(\"data\", {\n            sourceDataType: \"visibility\",\n            dataType: \"source\",\n            sourceId: i.getSource().id\n          }));\n        }\n        this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), o && this.fire(new e.b(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      _updateTilesForChangedImages() {\n        const e = this._changes.getUpdatedImages();\n        if (e.length) {\n          for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies([\"icons\", \"patterns\"], e);\n          this._changes.resetUpdatedImages();\n        }\n      }\n      _updateWorkerLayers(e, t, i) {\n        const o = this.getFragmentStyle(e);\n        o && this.dispatcher.broadcast(\"updateLayers\", {\n          layers: t ? o._serializeLayers(t) : [],\n          scope: e,\n          removedIds: i || [],\n          options: o.options\n        });\n      }\n      setState(i) {\n        if (this._checkLoaded(), Io(this, Y(i))) return !1;\n        (i = e.c1(i)).layers = ii(i.layers);\n        const o = function (e, i) {\n          if (!e) return [{\n            command: oi.setStyle,\n            args: [i]\n          }];\n          let o = [];\n          try {\n            if (!t(e.version, i.version)) return [{\n              command: oi.setStyle,\n              args: [i]\n            }];\n            t(e.center, i.center) || o.push({\n              command: oi.setCenter,\n              args: [i.center]\n            }), t(e.zoom, i.zoom) || o.push({\n              command: oi.setZoom,\n              args: [i.zoom]\n            }), t(e.bearing, i.bearing) || o.push({\n              command: oi.setBearing,\n              args: [i.bearing]\n            }), t(e.pitch, i.pitch) || o.push({\n              command: oi.setPitch,\n              args: [i.pitch]\n            }), t(e.sprite, i.sprite) || o.push({\n              command: oi.setSprite,\n              args: [i.sprite]\n            }), t(e.glyphs, i.glyphs) || o.push({\n              command: oi.setGlyphs,\n              args: [i.glyphs]\n            }), t(e.imports, i.imports) || function (e = [], i = [], o) {\n              i = i || [];\n              const r = (e = e || []).map(ci),\n                s = i.map(ci),\n                n = e.reduce(hi, {}),\n                a = i.reduce(hi, {}),\n                l = r.slice();\n              let c, h, u, d;\n              for (c = 0, h = 0; c < r.length; c++) u = r[c], a.hasOwnProperty(u) ? h++ : (o.push({\n                command: oi.removeImport,\n                args: [u]\n              }), l.splice(l.indexOf(u, h), 1));\n              for (c = 0, h = 0; c < s.length; c++) u = s[s.length - 1 - c], l[l.length - 1 - c] !== u && (n.hasOwnProperty(u) ? (o.push({\n                command: oi.removeImport,\n                args: [u]\n              }), l.splice(l.lastIndexOf(u, l.length - h), 1)) : h++, d = l[l.length - c], o.push({\n                command: oi.addImport,\n                args: [a[u], d]\n              }), l.splice(l.length - c, 0, u));\n              for (const e of i) {\n                const i = n[e.id];\n                i && !t(i, e) && o.push({\n                  command: oi.updateImport,\n                  args: [e.id, e]\n                });\n              }\n            }(e.imports, i.imports, o), t(e.transition, i.transition) || o.push({\n              command: oi.setTransition,\n              args: [i.transition]\n            }), t(e.light, i.light) || o.push({\n              command: oi.setLight,\n              args: [i.light]\n            }), t(e.fog, i.fog) || o.push({\n              command: oi.setFog,\n              args: [i.fog]\n            }), t(e.projection, i.projection) || o.push({\n              command: oi.setProjection,\n              args: [i.projection]\n            }), t(e.lights, i.lights) || o.push({\n              command: oi.setLights,\n              args: [i.lights]\n            }), t(e.camera, i.camera) || o.push({\n              command: oi.setCamera,\n              args: [i.camera]\n            });\n            const r = {},\n              s = [];\n            !function (e, i, o, r) {\n              let s;\n              for (s in i = i || {}, e = e || {}) e.hasOwnProperty(s) && (i.hasOwnProperty(s) || si(s, o, r));\n              for (s in i) {\n                if (!i.hasOwnProperty(s)) continue;\n                const n = i[s];\n                e.hasOwnProperty(s) ? t(e[s], n) || (\"geojson\" === e[s].type && \"geojson\" === n.type && ai(e, i, s) ? o.push({\n                  command: oi.setGeoJSONSourceData,\n                  args: [s, n.data]\n                }) : ni(s, i, o, r)) : ri(s, i, o);\n              }\n            }(e.sources, i.sources, s, r);\n            const n = [];\n            e.layers && e.layers.forEach(e => {\n              e.source && r[e.source] ? o.push({\n                command: oi.removeLayer,\n                args: [e.id]\n              }) : n.push(e);\n            });\n            let a = e.terrain;\n            a && r[a.source] && (o.push({\n              command: oi.setTerrain,\n              args: [void 0]\n            }), a = void 0), o = o.concat(s), t(a, i.terrain) || o.push({\n              command: oi.setTerrain,\n              args: [i.terrain]\n            }), function (e, i, o) {\n              i = i || [];\n              const r = (e = e || []).map(ci),\n                s = i.map(ci),\n                n = e.reduce(hi, {}),\n                a = i.reduce(hi, {}),\n                l = r.slice(),\n                c = Object.create(null);\n              let h, u, d, _, p, f, m;\n              for (h = 0, u = 0; h < r.length; h++) d = r[h], a.hasOwnProperty(d) ? u++ : (o.push({\n                command: oi.removeLayer,\n                args: [d]\n              }), l.splice(l.indexOf(d, u), 1));\n              for (h = 0, u = 0; h < s.length; h++) d = s[s.length - 1 - h], l[l.length - 1 - h] !== d && (n.hasOwnProperty(d) ? (o.push({\n                command: oi.removeLayer,\n                args: [d]\n              }), l.splice(l.lastIndexOf(d, l.length - u), 1)) : u++, f = l[l.length - h], o.push({\n                command: oi.addLayer,\n                args: [a[d], f]\n              }), l.splice(l.length - h, 0, d), c[d] = !0);\n              for (h = 0; h < s.length; h++) if (d = s[h], _ = n[d], p = a[d], !c[d] && !t(_, p)) if (t(_.source, p.source) && t(_[\"source-layer\"], p[\"source-layer\"]) && t(_.type, p.type)) {\n                for (m in li(_.layout, p.layout, o, d, null, oi.setLayoutProperty), li(_.paint, p.paint, o, d, null, oi.setPaintProperty), t(_.slot, p.slot) || o.push({\n                  command: oi.setSlot,\n                  args: [d, p.slot]\n                }), t(_.filter, p.filter) || o.push({\n                  command: oi.setFilter,\n                  args: [d, p.filter]\n                }), t(_.minzoom, p.minzoom) && t(_.maxzoom, p.maxzoom) || o.push({\n                  command: oi.setLayerZoomRange,\n                  args: [d, p.minzoom, p.maxzoom]\n                }), _) _.hasOwnProperty(m) && \"layout\" !== m && \"paint\" !== m && \"filter\" !== m && \"metadata\" !== m && \"minzoom\" !== m && \"maxzoom\" !== m && \"slot\" !== m && (0 === m.indexOf(\"paint.\") ? li(_[m], p[m], o, d, m.slice(6), oi.setPaintProperty) : t(_[m], p[m]) || o.push({\n                  command: oi.setLayerProperty,\n                  args: [d, m, p[m]]\n                }));\n                for (m in p) p.hasOwnProperty(m) && !_.hasOwnProperty(m) && \"layout\" !== m && \"paint\" !== m && \"filter\" !== m && \"metadata\" !== m && \"minzoom\" !== m && \"maxzoom\" !== m && \"slot\" !== m && (0 === m.indexOf(\"paint.\") ? li(_[m], p[m], o, d, m.slice(6), oi.setPaintProperty) : t(_[m], p[m]) || o.push({\n                  command: oi.setLayerProperty,\n                  args: [d, m, p[m]]\n                }));\n              } else o.push({\n                command: oi.removeLayer,\n                args: [d]\n              }), f = l[l.lastIndexOf(d) + 1], o.push({\n                command: oi.addLayer,\n                args: [p, f]\n              });\n            }(n, i.layers, o);\n          } catch (e) {\n            console.warn(\"Unable to compute style diff:\", e), o = [{\n              command: oi.setStyle,\n              args: [i]\n            }];\n          }\n          return o;\n        }(this.serialize(), i).filter(e => !(e.command in Lo));\n        if (0 === o.length) return !1;\n        const r = o.filter(e => !(e.command in Do));\n        if (r.length > 0) throw new Error(`Unimplemented: ${r.map(e => e.command).join(\", \")}.`);\n        return o.forEach(e => {\n          this[e.command].apply(this, e.args);\n        }), this.stylesheet = i, this.mergeAll(), this.dispatcher.broadcast(\"setLayers\", {\n          layers: this._serializeLayers(this._order),\n          scope: this.scope,\n          options: this.options\n        }), !0;\n      }\n      addImage(t, i) {\n        return this.getImage(t) ? this.fire(new e.a(new Error(\"An image with this name already exists.\"))) : (this.imageManager.addImage(t, this.scope, i), this._afterImageUpdated(t), this);\n      }\n      updateImage(e, t) {\n        this.imageManager.updateImage(e, this.scope, t);\n      }\n      getImage(e) {\n        return this.imageManager.getImage(e, this.scope);\n      }\n      removeImage(t) {\n        return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._afterImageUpdated(t), this) : this.fire(new e.a(new Error(\"No image with this name exists.\")));\n      }\n      _afterImageUpdated(t) {\n        this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t), this.dispatcher.broadcast(\"setImages\", {\n          scope: this.scope,\n          images: this._availableImages\n        }), this.fire(new e.b(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      listImages() {\n        return this._checkLoaded(), this._availableImages.slice();\n      }\n      addModel(e, t, i = {}) {\n        return this._checkLoaded(), this._validate(ae, `models.${e}`, t, null, i) || (this.modelManager.addModel(e, t, this.scope), this._changes.setDirty()), this;\n      }\n      hasModel(e) {\n        return this.modelManager.hasModel(e, this.scope);\n      }\n      removeModel(t) {\n        return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new e.a(new Error(\"No model with this ID exists.\")));\n      }\n      listModels() {\n        return this._checkLoaded(), this.modelManager.listModels(this.scope);\n      }\n      addSource(t, i, o = {}) {\n        if (this._checkLoaded(), void 0 !== this.getOwnSource(t)) throw new Error(`There is already a source with ID \"${t}\".`);\n        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(\", \")}.`);\n        if ([\"vector\", \"raster\", \"geojson\", \"video\", \"image\"].indexOf(i.type) >= 0 && this._validate(J, `sources.${t}`, i, null, o)) return;\n        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n        const r = Vt(t, i, this.dispatcher, this);\n        r.scope = this.scope, r.setEventedParent(this, () => ({\n          isSourceLoaded: this._isSourceCacheLoaded(r.id),\n          source: r.serialize(),\n          sourceId: r.id\n        }));\n        const s = t => {\n          const i = (t ? \"symbol:\" : \"other:\") + r.id,\n            o = e.ag(i, this.scope),\n            s = this._sourceCaches[i] = new Kt(o, r, t);\n          (t ? this._symbolSourceCaches : this._otherSourceCaches)[r.id] = s, s.onAdd(this.map);\n        };\n        s(!1), \"vector\" !== i.type && \"geojson\" !== i.type || s(!0), r.onAdd && r.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());\n      }\n      removeSource(t) {\n        this._checkLoaded();\n        const i = this.getOwnSource(t);\n        if (!i) throw new Error(\"There is no source with this ID\");\n        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.a(new Error(`Source \"${t}\" cannot be removed while layer \"${i}\" is using it.`)));\n        if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new e.a(new Error(`Source \"${t}\" cannot be removed while terrain is using it.`)));\n        const o = this.getOwnSourceCaches(t);\n        for (const t of o) {\n          const i = e.c3(t.id);\n          delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t.id), t.fire(new e.b(\"data\", {\n            sourceDataType: \"metadata\",\n            dataType: \"source\",\n            sourceId: t.getSource().id\n          })), t.setEventedParent(null), t.clearTiles();\n        }\n        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;\n      }\n      setGeoJSONSourceData(e, t) {\n        this._checkLoaded(), this.getOwnSource(e).setData(t), this._changes.setDirty();\n      }\n      getOwnSource(e) {\n        const t = this.getOwnSourceCache(e);\n        return t && t.getSource();\n      }\n      getOwnSources() {\n        const e = [];\n        for (const t in this._otherSourceCaches) {\n          const i = this.getOwnSourceCache(t);\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      areTilesLoaded() {\n        const e = this._mergedSourceCaches;\n        for (const t in e) {\n          const i = e[t]._tiles;\n          for (const e in i) {\n            const t = i[e];\n            if (\"loaded\" !== t.state && \"errored\" !== t.state) return !1;\n          }\n        }\n        return !0;\n      }\n      setLights(t) {\n        if (this._checkLoaded(), !t) return delete this.ambientLight, void delete this.directionalLight;\n        const i = this._getTransitionParameters();\n        for (const e of t) {\n          if (this._validate(ee, \"lights\", e)) return;\n          switch (e.type) {\n            case \"ambient\":\n              if (this.ambientLight) {\n                const t = this.ambientLight;\n                t.set(e), t.updateTransitions(i);\n              } else this.ambientLight = new Te(e, Ee, this.scope, this.options);\n              break;\n            case \"directional\":\n              if (this.directionalLight) {\n                const t = this.directionalLight;\n                t.set(e), t.updateTransitions(i);\n              } else this.directionalLight = new Te(e, Se, this.scope, this.options);\n          }\n        }\n        const o = new e.K(this.z || 0, i);\n        this.ambientLight && this.ambientLight.recalculate(o), this.directionalLight && this.directionalLight.recalculate(o), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast(\"setBrightness\", this._brightness);\n      }\n      calculateLightsBrightness() {\n        const t = this.directionalLight,\n          i = this.ambientLight;\n        if (!t || !i) return;\n        const o = e => .2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)),\n          r = t.properties.get(\"color\").toArray01(),\n          s = t.properties.get(\"intensity\"),\n          n = t.properties.get(\"direction\"),\n          a = 1 - e.bQ(n.x, n.y, n.z)[2] / 90,\n          l = o(r) * s * a,\n          c = i.properties.get(\"color\").toArray01(),\n          h = i.properties.get(\"intensity\");\n        return (l + o(c) * h) / 2;\n      }\n      getBrightness() {\n        return this._brightness;\n      }\n      getLights() {\n        if (!this.enable3dLights()) return null;\n        const e = [];\n        return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;\n      }\n      enable3dLights() {\n        return !!this.ambientLight && !!this.directionalLight;\n      }\n      getFragmentStyle(t) {\n        if (!t) return this;\n        if (e.c4(t)) {\n          const i = e.c5(t),\n            o = this.fragments.find(({\n              id: e\n            }) => e === i);\n          if (!o) throw new Error(`Style import not found: ${t}`);\n          const r = e.c3(t);\n          return o.style.getFragmentStyle(r);\n        }\n        {\n          const e = this.fragments.find(({\n            id: e\n          }) => e === t);\n          if (!e) throw new Error(`Style import not found: ${t}`);\n          return e.style;\n        }\n      }\n      getConfigProperty(t, i) {\n        const o = this.getFragmentStyle(t);\n        if (!o) return null;\n        const r = e.ag(i, o.scope),\n          s = o.options.get(r),\n          n = s ? s.value || s.default : null;\n        return n ? n.serialize() : null;\n      }\n      setConfigProperty(t, i, o) {\n        const r = e.r(o);\n        if (\"success\" !== r.result) return void Io(this, r.value);\n        const s = r.value.expression,\n          n = this.getFragmentStyle(t);\n        if (!n) return;\n        const a = e.ag(i, n.scope),\n          l = n.options.get(a);\n        l && (this.options.set(a, {\n          ...l,\n          value: s\n        }), this.updateConfigDependencies());\n      }\n      setConfig(t, i) {\n        if (this._config = t, t || i) if (i) for (const o in i) {\n          let r, s;\n          const n = e.r(i[o].default);\n          if (\"success\" === n.result && (r = n.value.expression), t && void 0 !== t[o]) {\n            const i = e.r(t[o]);\n            \"success\" === i.result && (s = i.value.expression);\n          }\n          const {\n            minValue: a,\n            maxValue: l,\n            stepValue: c,\n            type: h,\n            values: u\n          } = i[o];\n          if (r) {\n            const t = e.ag(o, this.scope);\n            this.options.set(t, {\n              default: r,\n              value: s,\n              minValue: a,\n              maxValue: l,\n              stepValue: c,\n              type: h,\n              values: u\n            });\n          } else this.fire(new e.a(new Error(`No schema defined for config option \"${o}\".`)));\n        } else this.fire(new e.a(new Error(\"Attempting to set config for a style without schema.\")));\n      }\n      updateConfigDependencies() {\n        for (const e of this._configDependentLayers) {\n          const t = this.getLayer(e);\n          t && (t.possiblyEvaluateVisibility(), this._updateLayer(t));\n        }\n        this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this._changes.setDirty();\n      }\n      addLayer(t, i, o = {}) {\n        this._checkLoaded();\n        const r = t.id;\n        if (this._layers[r]) return void this.fire(new e.a(new Error(`Layer with id \"${r}\" already exists on this map`)));\n        let s;\n        if (\"custom\" === t.type) {\n          if (Io(this, e.c6(t))) return;\n          s = e.c2(t, this.scope, this.options);\n        } else {\n          if (\"object\" == typeof t.source && (this.addSource(r, t.source), t = e.c1(t), t = e.e(t, {\n            source: r\n          })), this._validate(oe, `layers.${r}`, t, {\n            arrayIndex: -1\n          }, o)) return;\n          s = e.c2(t, this.scope, this.options), this._validateLayer(s), s.setEventedParent(this, {\n            layer: {\n              id: r\n            }\n          }), this._serializedLayers[s.id] = s.serialize();\n        }\n        s.isConfigDependent && this._configDependentLayers.add(s.fqid);\n        let n = this._order.length;\n        if (i) {\n          const t = this._order.indexOf(i);\n          if (-1 === t) return void this.fire(new e.a(new Error(`Layer with id \"${i}\" does not exist on this map.`)));\n          s.slot === this._layers[i].slot ? n = t : e.w(`Layer with id \"${i}\" has a different slot. Layers can only be rearranged within the same slot.`);\n        }\n        this._order.splice(n, 0, r), this._layerOrderChanged = !0, this._layers[r] = s;\n        const a = this.getOwnLayerSourceCache(s),\n          l = !!this.directionalLight && this.directionalLight.shadowsEnabled();\n        a && s.canCastShadows() && l && (a.castsShadows = !0);\n        const c = this._changes.getRemovedLayer(s);\n        if (c && s.source && a && \"custom\" !== s.type) {\n          this._changes.discardLayerRemoval(s);\n          const t = e.ag(s.source, s.scope);\n          c.type !== s.type ? this._changes.updateSourceCache(t, \"clear\") : (this._changes.updateSourceCache(t, \"reload\"), a.pause());\n        }\n        this._updateLayer(s), s.onAdd && s.onAdd(this.map), s.scope = this.scope, this.mergeLayers();\n      }\n      moveLayer(t, i) {\n        this._checkLoaded();\n        const o = this._checkLayer(t);\n        if (!o) return;\n        if (t === i) return;\n        const r = this._order.indexOf(t);\n        this._order.splice(r, 1);\n        let s = this._order.length;\n        if (i) {\n          const t = this._order.indexOf(i);\n          if (-1 === t) return void this.fire(new e.a(new Error(`Layer with id \"${i}\" does not exist on this map.`)));\n          o.slot === this._layers[i].slot ? s = t : e.w(`Layer with id \"${i}\" has a different slot. Layers can only be rearranged within the same slot.`);\n        }\n        this._order.splice(s, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();\n      }\n      removeLayer(e) {\n        this._checkLoaded();\n        const t = this._checkLayer(e);\n        if (!t) return;\n        t.setEventedParent(null);\n        const i = this._order.indexOf(e);\n        this._order.splice(i, 1), delete this._layers[e], delete this._serializedLayers[e], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t.fqid), this._changes.removeLayer(t);\n        const o = this.getOwnLayerSourceCache(t);\n        if (o && o.castsShadows) {\n          let e = !1;\n          for (const i in this._layers) if (this._layers[i].source === t.source && this._layers[i].canCastShadows()) {\n            e = !0;\n            break;\n          }\n          o.castsShadows = e;\n        }\n        t.onRemove && t.onRemove(this.map), this.mergeLayers();\n      }\n      getOwnLayer(e) {\n        return this._layers[e];\n      }\n      hasLayer(e) {\n        return e in this._mergedLayers;\n      }\n      hasLayerType(e) {\n        for (const t in this._layers) if (this._layers[t].type === e) return !0;\n        return !1;\n      }\n      setLayerZoomRange(e, t, i) {\n        this._checkLoaded();\n        const o = this._checkLayer(e);\n        o && (o.minzoom === t && o.maxzoom === i || (null != t && (o.minzoom = t), null != i && (o.maxzoom = i), this._updateLayer(o)));\n      }\n      setSlot(e, t) {\n        this._checkLoaded();\n        const i = this._checkLayer(e);\n        i && i.slot !== t && (i.slot = t, this._updateLayer(i));\n      }\n      setFilter(i, o, r = {}) {\n        this._checkLoaded();\n        const s = this._checkLayer(i);\n        if (s && !t(s.filter, o)) return null == o ? (s.filter = void 0, void this._updateLayer(s)) : void (this._validate(re, `layers.${s.id}.filter`, o, {\n          layerType: s.type\n        }, r) || (s.filter = e.c1(o), this._updateLayer(s)));\n      }\n      getFilter(t) {\n        const i = this._checkLayer(t);\n        if (i) return e.c1(i.filter);\n      }\n      setLayoutProperty(i, o, r, s = {}) {\n        this._checkLoaded();\n        const n = this._checkLayer(i);\n        if (n && !t(n.getLayoutProperty(o), r)) {\n          if (null != r && (!s || !1 !== s.validate) && Io(n, ne.call(Y, {\n            key: `layers.${i}.layout.${o}`,\n            layerType: n.type,\n            objectKey: o,\n            value: r,\n            styleSpec: e.D,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            }\n          }))) return;\n          n.setLayoutProperty(o, r), n.isConfigDependent && this._configDependentLayers.add(n.fqid), this._updateLayer(n);\n        }\n      }\n      getLayoutProperty(e, t) {\n        const i = this._checkLayer(e);\n        if (i) return i.getLayoutProperty(t);\n      }\n      setPaintProperty(i, o, r, s = {}) {\n        this._checkLoaded();\n        const n = this._checkLayer(i);\n        if (!n) return;\n        if (t(n.getPaintProperty(o), r)) return;\n        if (null != r && (!s || !1 !== s.validate) && Io(n, se.call(Y, {\n          key: `layers.${i}.paint.${o}`,\n          layerType: n.type,\n          objectKey: o,\n          value: r,\n          styleSpec: e.D\n        }))) return;\n        const a = n.setPaintProperty(o, r);\n        n.isConfigDependent && this._configDependentLayers.add(n.fqid), a && this._updateLayer(n), this._changes.updatePaintProperties(n);\n      }\n      getPaintProperty(e, t) {\n        const i = this._checkLayer(e);\n        if (i) return i.getPaintProperty(t);\n      }\n      setFeatureState(t, i) {\n        this._checkLoaded();\n        const o = t.source,\n          r = t.sourceLayer,\n          s = this._checkSource(o);\n        if (!s) return;\n        const n = s.type;\n        if (\"geojson\" === n && r) return void this.fire(new e.a(new Error(\"GeoJSON sources cannot have a sourceLayer parameter.\")));\n        if (\"vector\" === n && !r) return void this.fire(new e.a(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        void 0 === t.id && this.fire(new e.a(new Error(\"The feature id parameter must be provided.\")));\n        const a = this.getOwnSourceCaches(o);\n        for (const e of a) e.setFeatureState(r, t.id, i);\n      }\n      removeFeatureState(t, i) {\n        this._checkLoaded();\n        const o = t.source,\n          r = this._checkSource(o);\n        if (!r) return;\n        const s = r.type,\n          n = \"vector\" === s ? t.sourceLayer : void 0;\n        if (\"vector\" === s && !n) return void this.fire(new e.a(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        if (i && \"string\" != typeof t.id && \"number\" != typeof t.id) return void this.fire(new e.a(new Error(\"A feature id is required to remove its specific state property.\")));\n        const a = this.getOwnSourceCaches(o);\n        for (const e of a) e.removeFeatureState(n, t.id, i);\n      }\n      getFeatureState(t) {\n        this._checkLoaded();\n        const i = t.source,\n          o = t.sourceLayer,\n          r = this._checkSource(i);\n        if (r) {\n          if (\"vector\" !== r.type || o) return void 0 === t.id && this.fire(new e.a(new Error(\"The feature id parameter must be provided.\"))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t.id);\n          this.fire(new e.a(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        }\n      }\n      setTransition(t) {\n        return this.stylesheet.transition = e.e({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this;\n      }\n      getTransition() {\n        return e.e({}, this.stylesheet.transition);\n      }\n      serialize() {\n        this._checkLoaded();\n        const t = this.getTerrain(),\n          i = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;\n        return e.c7({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          imports: this._serializeImports(),\n          schema: this.stylesheet.schema,\n          camera: this.stylesheet.camera,\n          light: this.stylesheet.light,\n          lights: this.stylesheet.lights,\n          terrain: i,\n          fog: this.stylesheet.fog,\n          center: this.stylesheet.center,\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          projection: this.stylesheet.projection,\n          sources: this._serializeSources(),\n          layers: this._serializeLayers(this._order)\n        }, e => void 0 !== e);\n      }\n      _updateLayer(t) {\n        this._changes.updateLayer(t);\n        const i = this.getLayerSourceCache(t),\n          o = e.ag(t.source, t.scope),\n          r = this._changes.getUpdatedSourceCaches();\n        t.source && !r[o] && i && \"raster\" !== i.getSource().type && (this._changes.updateSourceCache(o, \"reload\"), i.pause()), t.invalidateCompiledFilter();\n      }\n      _flattenAndSortRenderedFeatures(e) {\n        const t = e => \"fill-extrusion\" === this._mergedLayers[e].type || \"model\" === this._mergedLayers[e].type,\n          i = this.order,\n          o = {},\n          r = [];\n        for (let s = i.length - 1; s >= 0; s--) {\n          const n = i[s];\n          if (t(n)) {\n            o[n] = s;\n            for (const t of e) {\n              const e = t[n];\n              if (e) for (const t of e) r.push(t);\n            }\n          }\n        }\n        r.sort((e, t) => t.intersectionZ - e.intersectionZ);\n        const s = [];\n        for (let n = i.length - 1; n >= 0; n--) {\n          const a = i[n];\n          if (t(a)) for (let e = r.length - 1; e >= 0; e--) {\n            const t = r[e].feature;\n            if (o[t.layer.id] < n) break;\n            s.push(t), r.pop();\n          } else for (const t of e) {\n            const e = t[a];\n            if (e) for (const t of e) s.push(t.feature);\n          }\n        }\n        return s;\n      }\n      queryRenderedFeatures(t, i, o) {\n        i && i.filter && this._validate(re, \"queryRenderedFeatures.filter\", i.filter, null, i), i.scope = this.scope, i.availableImages = this._availableImages, i.serializedLayers = this._serializedLayers;\n        const r = {};\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new e.a(new Error(\"parameters.layers must be an Array.\"))), [];\n          for (const t of i.layers) {\n            const i = this._mergedLayers[t];\n            if (!i) return this.fire(new e.a(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];\n            r[i.source] = !0;\n          }\n        }\n        const s = [],\n          n = i.serializedLayers || {},\n          a = i && i.layers ? i.layers.some(e => {\n            const t = this.getLayer(e);\n            return t && t.is3D();\n          }) : this.has3DLayers(),\n          l = Ce.createFromScreenPoints(t, o);\n        for (const e in this._mergedSourceCaches) {\n          const t = this._mergedSourceCaches[e].getSource();\n          if (!t || t.scope !== i.scope) continue;\n          const c = this._mergedSourceCaches[e].getSource().id;\n          i.layers && !r[c] || s.push(Ht(this._mergedSourceCaches[e], this._mergedLayers, n, l, i, o, a, !!this.map._showQueryGeometry));\n        }\n        return this.placement && s.push(function (e, t, i, o, r, s, n) {\n          const a = {},\n            l = s.queryRenderedSymbols(o),\n            c = [];\n          for (const e of Object.keys(l).map(Number)) c.push(n[e]);\n          c.sort(qt);\n          for (const i of c) {\n            const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);\n            for (const e in o) {\n              const t = a[e] = a[e] || [],\n                r = o[e];\n              r.sort((e, t) => {\n                const o = i.featureSortOrder;\n                if (o) {\n                  const i = o.indexOf(e.featureIndex);\n                  return o.indexOf(t.featureIndex) - i;\n                }\n                return t.featureIndex - e.featureIndex;\n              });\n              for (const e of r) t.push(e);\n            }\n          }\n          for (const t in a) a[t].forEach(o => {\n            const r = o.feature,\n              s = i(e[t]);\n            if (!s) return;\n            const n = s.getFeatureState(r.layer[\"source-layer\"], r.id);\n            r.source = r.layer.source, r.layer[\"source-layer\"] && (r.sourceLayer = r.layer[\"source-layer\"]), r.state = n;\n          });\n          return a;\n        }(this._mergedLayers, n, this.getLayerSourceCache.bind(this), l.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s);\n      }\n      querySourceFeatures(e, t) {\n        t && t.filter && this._validate(re, \"querySourceFeatures.filter\", t.filter, null, t);\n        const i = this.getOwnSourceCaches(e);\n        let o = [];\n        for (const e of i) o = o.concat(Wt(e, t));\n        return o;\n      }\n      addSourceType(e, t, i) {\n        return Mo.getSourceType(e) ? i(new Error(`A source type called \"${e}\" already exists.`)) : (Mo.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast(\"loadWorkerSource\", {\n          name: e,\n          url: t.workerSourceURL\n        }, i) : i(null, null));\n      }\n      getFlatLight() {\n        return this.light.getLight();\n      }\n      setFlatLight(e, i, o = {}) {\n        this._checkLoaded();\n        const r = this.light.getLight();\n        let s = !1;\n        for (const i in e) if (!t(e[i], r[i])) {\n          s = !0;\n          break;\n        }\n        if (!s) return;\n        const n = this._getTransitionParameters();\n        this.light.setLight(e, i, o), this.light.updateTransitions(n);\n      }\n      getTerrain() {\n        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;\n      }\n      setTerrainForDraping() {\n        this.setTerrain({\n          source: \"\",\n          exaggeration: 0\n        }, 0);\n      }\n      setTerrain(i, o = 1) {\n        if (this._checkLoaded(), !i) return this.terrainSetForDrapingOnly() && 0 !== o || delete this.terrain, null === i ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);\n        let r = i;\n        const s = null == i.source;\n        if (1 === o) {\n          if (\"object\" == typeof r.source) {\n            const t = \"terrain-dem-src\";\n            this.addSource(t, r.source), r = e.c1(r), r = e.e(r, {\n              source: t\n            });\n          }\n          const t = e.e({}, r),\n            i = {};\n          if (this.terrain && s) {\n            t.source = this.terrain.get().source;\n            const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;\n            e && (i.style = e.serialize());\n          }\n          if (this._validate(te, \"terrain\", t, i)) return;\n        }\n        if (!this.terrain || this.terrain.scope !== this.scope && !s || this.terrain && o !== this.terrain.drapeRenderMode) {\n          if (!r) return;\n          this._createTerrain(r, o), this.fire(new e.b(\"data\", {\n            dataType: \"style\"\n          }));\n        } else {\n          const o = this.terrain,\n            s = o.get();\n          for (const t of Object.keys(e.D.terrain)) !r.hasOwnProperty(t) && e.D.terrain[t].default && (r[t] = e.D.terrain[t].default);\n          for (const r in i) if (!t(i[r], s[r])) {\n            o.set(i, this.options), this.stylesheet.terrain = i;\n            const t = this._getTransitionParameters({\n              duration: 0\n            });\n            o.updateTransitions(t), this.fire(new e.b(\"data\", {\n              dataType: \"style\"\n            }));\n            break;\n          }\n        }\n        this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;\n      }\n      _createFog(e) {\n        const t = this.fog = new we(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.fog = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _updateMarkersOpacity() {\n        0 !== this.map._markers.length && this.map._requestDomTask(() => {\n          for (const e of this.map._markers) e._evaluateOpacity();\n        });\n      }\n      getFog() {\n        return this.fog ? this.fog.get() : null;\n      }\n      setFog(e) {\n        if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);\n        if (this.fog) {\n          const i = this.fog;\n          if (!t(i.get(), e)) {\n            i.set(e, this.options), this.stylesheet.fog = i.get();\n            const t = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(t);\n          }\n        } else this._createFog(e);\n        this._markersNeedUpdate = !0;\n      }\n      _getTransitionParameters(t) {\n        return {\n          now: e.f.now(),\n          transition: e.e(this.transition, t)\n        };\n      }\n      updateDrapeFirstLayers() {\n        if (!this.terrain) return;\n        const e = [],\n          t = [];\n        for (const i in this._mergedLayers) this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t.push(i);\n        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);\n      }\n      _createTerrain(e, t) {\n        const i = this.terrain = new _e(e, t, this.scope, this.options);\n        1 === t && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();\n        const o = this._getTransitionParameters({\n          duration: 0\n        });\n        i.updateTransitions(o);\n      }\n      _force3DLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"fill-extrusion\" === t.type && this._updateLayer(t);\n        }\n      }\n      _forceSymbolLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this._updateLayer(t);\n        }\n      }\n      _validate(t, i, o, r, s = {}) {\n        if (s && !1 === s.validate) return !1;\n        const n = e.e({}, this.serialize());\n        return Io(this, t.call(Y, e.e({\n          key: i,\n          style: n,\n          value: o,\n          styleSpec: e.D\n        }, r)));\n      }\n      _remove() {\n        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.c8.off(\"pluginStateChange\", this._rtlTextPluginCallback);\n        for (const e in this._mergedLayers) this._mergedLayers[e].setEventedParent(null);\n        for (const e in this._mergedSourceCaches) this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);\n        this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());\n      }\n      clearSource(e) {\n        const t = this.getSourceCaches(e);\n        for (const e of t) e.clearTiles();\n      }\n      clearSources() {\n        for (const e in this._mergedSourceCaches) this._mergedSourceCaches[e].clearTiles();\n      }\n      reloadSource(e) {\n        const t = this.getSourceCaches(e);\n        for (const e of t) e.resume(), e.reload();\n      }\n      reloadSources() {\n        for (const e of this.getSources()) e.reload && e.reload();\n      }\n      updateSources(e) {\n        let t;\n        this.directionalLight && (t = Eo(this.directionalLight));\n        for (const i in this._mergedSourceCaches) this._mergedSourceCaches[i].update(e, void 0, void 0, t);\n      }\n      _generateCollisionBoxes() {\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          t.resume(), t.reload();\n        }\n      }\n      _updatePlacement(t, i, o, r, s = !1) {\n        let n = !1,\n          a = !1;\n        const l = {},\n          c = {};\n        for (const i of this._mergedOrder) {\n          const o = this._mergedLayers[i];\n          if (\"symbol\" !== o.type) continue;\n          const r = e.ag(o.source, o.scope);\n          let s = l[r];\n          if (!s) {\n            const e = this.getLayerSourceCache(o);\n            if (!e) continue;\n            const t = e.getRenderableIds(!0).map(t => e.getTileByID(t));\n            c[r] = t.slice(), s = l[r] = t.sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));\n          }\n          const a = this.crossTileSymbolIndex.addLayer(o, s, t.center.lng, t.projection);\n          n = n || a;\n        }\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), s = s || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e.b(\"neworder\")), (s || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.f.now(), t.zoom)) && (this.pauseablePlacement = new to(t, this._mergedOrder, s, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l, c), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.f.now()), a = !0), n && this.pauseablePlacement.placement.setStale()), a || n) {\n          this._buildingIndex.onNewFrame(t.zoom);\n          for (const t of this._mergedOrder) {\n            const i = this._mergedLayers[t];\n            \"symbol\" === i.type && this.placement.updateLayerOpacities(i, l[e.ag(i.source, i.scope)]);\n          }\n        }\n        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.f.now());\n      }\n      _releaseSymbolFadeTiles() {\n        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();\n      }\n      addImport(t, i) {\n        this._checkLoaded();\n        const o = this.stylesheet.imports = this.stylesheet.imports || [];\n        if (-1 !== o.findIndex(({\n          id: e\n        }) => e === t.id)) return this.fire(new e.a(new Error(`Import with id '${t.id}' already exists in the map's style.`)));\n        if (!i) return o.push(t), this._loadImports([t], !0), this;\n        const r = o.findIndex(({\n          id: e\n        }) => e === i);\n        return -1 === r ? this.fire(new e.a(new Error(`Import with id \"${i}\" does not exist on this map.`))) : (this.stylesheet.imports = o.slice(0, r).concat(t).concat(o.slice(r)), this._loadImports([t], !0, i), this);\n      }\n      updateImport(e, i) {\n        this._checkLoaded();\n        const o = this.stylesheet.imports || [],\n          r = this.getImportIndex(e);\n        return -1 === r ? this : \"string\" == typeof i ? (this.setImportUrl(e, i), this) : (i.url && i.url !== o[r].url && this.setImportUrl(e, i.url), t(i.config, o[r].config) || this.setImportConfig(e, i.config), t(i.data, o[r].data) || this.setImportData(e, i.data), this);\n      }\n      moveImport(e, t) {\n        this._checkLoaded();\n        let i = this.stylesheet.imports || [];\n        const o = this.getImportIndex(e);\n        if (-1 === o) return this;\n        const r = this.getImportIndex(t);\n        if (-1 === r) return this;\n        const s = i[o],\n          n = this.fragments[o];\n        return i = i.filter(({\n          id: t\n        }) => t !== e), this.fragments = this.fragments.filter(({\n          id: t\n        }) => t !== e), this.stylesheet.imports = i.slice(0, r).concat(s).concat(i.slice(r)), this.fragments = this.fragments.slice(0, r).concat(n).concat(this.fragments.slice(r)), this.mergeLayers(), this;\n      }\n      setImportUrl(e, t) {\n        this._checkLoaded();\n        const i = this.stylesheet.imports || [],\n          o = this.getImportIndex(e);\n        if (-1 === o) return this;\n        i[o].url = t;\n        const r = this.fragments[o];\n        return r.style = this._createFragmentStyle(i[o]), r.style.on(\"style.import.load\", () => this.mergeAll()), r.style.loadURL(t), this;\n      }\n      setImportData(e, t) {\n        this._checkLoaded();\n        const i = this.getImportIndex(e),\n          o = this.stylesheet.imports || [];\n        return -1 === i ? this : t ? (this.fragments[i].style.setState(t), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));\n      }\n      setImportConfig(e, t) {\n        this._checkLoaded();\n        const i = this.getImportIndex(e),\n          o = this.stylesheet.imports || [];\n        if (-1 === i) return this;\n        t ? o[i].config = t : delete o[i].config;\n        const r = this.fragments[i],\n          s = r.style.stylesheet && r.style.stylesheet.schema;\n        return r.config = t, r.style.setConfig(t, s), this.updateConfigDependencies(), this;\n      }\n      removeImport(e) {\n        this._checkLoaded();\n        const t = this.stylesheet.imports || [],\n          i = this.getImportIndex(e);\n        return -1 === i || (t.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports()), this;\n      }\n      getImportIndex(t) {\n        const i = (this.stylesheet.imports || []).findIndex(e => e.id === t);\n        return -1 === i && this.fire(new e.a(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), i;\n      }\n      getLayer(e) {\n        return this._mergedLayers[e];\n      }\n      getSources() {\n        const e = [];\n        for (const t in this._mergedOtherSourceCaches) {\n          const i = this._mergedOtherSourceCaches[t];\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      getSource(e, t) {\n        const i = this.getSourceCache(e, t);\n        return i && i.getSource();\n      }\n      getLayerSource(e) {\n        const t = this.getLayerSourceCache(e);\n        return t && t.getSource();\n      }\n      getSourceCache(t, i) {\n        const o = e.ag(t, i);\n        return this._mergedOtherSourceCaches[o];\n      }\n      getLayerSourceCache(t) {\n        const i = e.ag(t.source, t.scope);\n        return \"symbol\" === t.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];\n      }\n      getSourceCaches(e) {\n        const t = [];\n        return this._mergedOtherSourceCaches[e] && t.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t.push(this._mergedSymbolSourceCaches[e]), t;\n      }\n      updateSourceCaches() {\n        const e = this._changes.getUpdatedSourceCaches();\n        for (const t in e) {\n          const i = e[t];\n          \"reload\" === i ? this.reloadSource(t) : \"clear\" === i && this.clearSource(t);\n        }\n      }\n      updateLayers(e) {\n        const t = this._changes.getUpdatedPaintProperties();\n        for (const i of t) {\n          const t = this.getLayer(i);\n          t && t.updateTransitions(e);\n        }\n      }\n      getImages(e, t, i) {\n        this.imageManager.getImages(t.icons, t.scope, i), this._updateTilesForChangedImages();\n        const o = e => {\n          e && e.setDependencies(t.tileID.key, t.type, t.icons);\n        };\n        o(this._otherSourceCaches[t.source]), o(this._symbolSourceCaches[t.source]);\n      }\n      getGlyphs(e, t, i) {\n        this.glyphManager.getGlyphs(t.stacks, t.scope, i);\n      }\n      getResource(t, i, o) {\n        return e.c9(i, o);\n      }\n      getOwnSourceCache(e) {\n        return this._otherSourceCaches[e];\n      }\n      getOwnLayerSourceCache(e) {\n        return \"symbol\" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];\n      }\n      getOwnSourceCaches(e) {\n        const t = [];\n        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;\n      }\n      _isSourceCacheLoaded(t) {\n        const i = this.getOwnSourceCaches(t);\n        return 0 === i.length ? (this.fire(new e.a(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());\n      }\n      has3DLayers() {\n        return this._has3DLayers;\n      }\n      hasSymbolLayers() {\n        return this._hasSymbolLayers;\n      }\n      hasCircleLayers() {\n        return this._hasCircleLayers;\n      }\n      _clearWorkerCaches() {\n        this.dispatcher.broadcast(\"clearCaches\");\n      }\n      destroy() {\n        this._clearWorkerCaches(), this.fragments.forEach(e => {\n          e.style._remove();\n        }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);\n      }\n    }\n    Mo.getSourceType = function (e) {\n      return jt[e];\n    }, Mo.setSourceType = function (e, t) {\n      jt[e] = t;\n    }, Mo.registerForPluginStateChange = e.bV;\n    var zo = \"\\n#define EPSILON 0.0000001\\n#define PI 3.141592653589793\\n#ifdef RENDER_CUTOFF\\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\\n#endif\",\n      Oo = \"\\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\\n#ifdef INDICATOR_CUTOUT\\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\\n#endif\\nvec4 applyCutout(vec4 color) {\\n#ifdef INDICATOR_CUTOUT\\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\\n#else\\nreturn color;\\n#endif\\n}\\n#ifdef DEBUG_WIREFRAME\\n#define HANDLE_WIREFRAME_DEBUG \\\\\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\\\\ngl_FragDepth=gl_FragCoord.z-0.0001;\\n#else\\n#define HANDLE_WIREFRAME_DEBUG\\n#endif\\n#ifdef RENDER_CUTOFF\\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\\n#endif\\nvec4 textureLodCustom(sampler2D image,vec2 pos,vec2 lod_coord) {vec2 size=vec2(textureSize(image,0));vec2 dx=dFdx(lod_coord.xy*size);vec2 dy=dFdy(lod_coord.xy*size);float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}\",\n      Fo = \"\\n#define EXTENT 8192.0\\n#define RAD_TO_DEG 180.0/PI\\n#define DEG_TO_RAD PI/180.0\\n#define GLOBE_RADIUS EXTENT/PI/2.0\\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\\n#ifndef PROJECTED_POS_ON_VIEWPORT\\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\\n#ifdef RENDER_CUTOFF\\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\\n#endif\\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\",\n      Bo = \"in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}\",\n      ko = \"\\n#define ELEVATION_SCALE 7.0\\n#define ELEVATION_OFFSET 450.0\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\\n#else\\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\\n#endif\\n#ifdef TERRAIN\\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}float prevElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}\\n#ifdef TERRAIN_VERTEX_MORPHING\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\\n#else\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nreturn currentElevation(apos);}\\n#endif\\nhighp float unpack_depth(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\\nunpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))\\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\\n#else\\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\\n#endif\",\n      No = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\\n#endif\",\n      Uo = \"highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\\n#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\\n#ifdef FOG_DITHERING\\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\\n#else\\nreturn color;\\n#endif\\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\\n#endif\",\n      Go = \"#ifdef RASTER_ARRAY\\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\\n#endif\",\n      jo = \"#ifdef RASTER_ARRAY\\nuniform sampler2D u_velocity;uniform vec2 u_velocity_res;uniform float u_max_speed;const vec2 INVALID_VELOCITY=vec2(-1);uniform vec2 u_texture_offset;uniform float u_data_offset;uniform vec4 u_data_scale;vec2 lookup_velocity(vec2 uv) {uv=u_texture_offset.x+u_texture_offset.y*uv;vec2 fxy;ivec4 c=_raTexLinearCoord(uv,u_velocity_res,fxy);vec4 tl=texelFetch(u_velocity,c.yz,0);vec4 tr=texelFetch(u_velocity,c.xz,0);vec4 bl=texelFetch(u_velocity,c.yw,0);vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NODATA) {return INVALID_VELOCITY;}if (tr==NODATA) {return INVALID_VELOCITY;}if (bl==NODATA) {return INVALID_VELOCITY;}if (br==NODATA) {return INVALID_VELOCITY;}vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);\\n#ifdef DATA_FORMAT_UINT32\\nvec2 velocity=vec2(u_data_offset+dot(t,u_data_scale),0);return velocity;\\n#else\\nvec2 velocity=vec2(u_data_offset+dot(t.rg,u_data_scale.yx),-(u_data_offset+dot(t.ba,u_data_scale.yx)));\\n#endif\\nreturn velocity/max(u_max_speed,length(velocity));}\\n#endif\",\n      Vo = \"#ifdef RENDER_SHADOWS\\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\\n#endif//RENDER_SHADOWS\",\n      Zo = \"#ifdef RENDER_SHADOWS\\n#ifdef DEPTH_TEXTURE\\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\\n#else\\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\\n#endif\\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\\n#ifdef DEPTH_TEXTURE\\nshadow_depth=texture(u_shadowmap_1,uv).r;\\n#else\\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\\n#endif\\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\\n#ifdef DEPTH_TEXTURE\\nshadow_depth=texture(u_shadowmap_0,uv).r;\\n#else\\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\\n#endif\\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\\n#ifdef NATIVE\\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\\n#else\\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\\n);\\n#endif\\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\\n#ifdef SHADOWS_SINGLE_CASCADE\\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\\n#else\\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\\n#endif\\n}highp float calculate_shadow_bias(float NDotL) {\\n#ifdef NORMAL_OFFSET\\nreturn 0.5*u_shadow_bias.x;\\n#else\\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\\n#endif\\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\\n#endif\";\n    const Ho = [];\n    Yo(zo, Ho), Yo(Fo, Ho), Yo(Oo, Ho);\n    const Wo = {\n        \"_prelude_fog.vertex.glsl\": No,\n        \"_prelude_terrain.vertex.glsl\": ko,\n        \"_prelude_shadow.vertex.glsl\": Vo,\n        \"_prelude_fog.fragment.glsl\": Uo,\n        \"_prelude_shadow.fragment.glsl\": Zo,\n        \"_prelude_lighting.glsl\": \"\\n#ifdef LIGHTING_3D_MODE\\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\\n#endif//LIGHTING_3D_MODE\",\n        \"_prelude_raster_array.glsl\": Go,\n        \"_prelude_raster_particle.glsl\": jo\n      },\n      qo = {};\n    Jo(\"\", ko), Jo(Uo, No), Jo(Zo, Vo), Jo(Go, \"\"), Jo(jo, \"\");\n    const $o = Jo(Oo, Fo),\n      Xo = zo;\n    var Ko = {\n      background: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec4 u_color;uniform float u_opacity;\\n#ifdef LIGHTING_3D_MODE\\nin vec4 v_color;\\n#endif\\nvoid main() {vec4 out_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=v_color;\\n#else\\nout_color=u_color;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec2 a_pos;uniform mat4 u_matrix;\\n#ifdef LIGHTING_3D_MODE\\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef LIGHTING_3D_MODE\\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      backgroundPattern: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      circle: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec3 v_data;in float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nuniform float u_emissive_strength;void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\\n#endif\\nglFragColor=out_color*(v_visibility*opacity_t);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define NUM_VISIBILITY_RINGS 2\\n#define INV_SQRT2 0.70710678\\n#define ELEVATION_BIAS 0.0001\\n#define NUM_SAMPLES_PER_RING 16\\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nout vec3 v_data;out float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\\n#if defined(TERRAIN)\\nreturn elevation(pos)+ELEVATION_BIAS;\\n#else\\nreturn 0.0;\\n#endif\\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\\n#ifdef PITCH_WITH_MAP\\n#ifdef PROJECTION_GLOBE_VIEW\\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\\n#else\\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\\n#endif\\n#else\\nreturn projected_center+vec4(sample_offset,0,0);\\n#endif\\n}float get_sample_step() {\\n#ifdef PITCH_WITH_MAP\\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\\n#else\\nreturn PI/float(NUM_SAMPLES_PER_RING);\\n#endif\\n}void main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\\n#else \\nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\\n#endif\\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\\n#ifdef PITCH_WITH_MAP\\n#ifdef SCALE_WITH_MAP\\nview_scale=1.0;\\n#else\\nview_scale=projected_center.w/u_camera_to_center_distance;\\n#endif\\n#else\\n#ifdef SCALE_WITH_MAP\\nview_scale=u_camera_to_center_distance;\\n#else\\nview_scale=projected_center.w;\\n#endif\\n#endif\\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\\n#ifdef TERRAIN\\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\\n#ifdef PITCH_WITH_MAP\\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\\n#else\\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\\n#endif\\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\\n#else\\nvisibility=1.0;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nvisibility=1.0;\\n#endif\\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\\n#ifdef FOG\\nv_fog_pos=fog_position(world_center.xyz);\\n#endif\\n}'),\n      clippingMask: Jo(\"void main() {glFragColor=vec4(1.0);}\", \"in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      heatmap: Jo('#include \"_prelude_fog.fragment.glsl\"\\nuniform highp float u_intensity;in vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef FOG\\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nout vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#else\\npos=vec3(tilePos+extrude,elevation(tilePos));\\n#endif\\ngl_Position=u_matrix*vec4(pos,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      heatmapTexture: Jo(\"uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(0.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}\", \"in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}\"),\n      collisionBox: Jo(\"in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),\n      collisionCircle: Jo(\"in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}\", \"in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}\"),\n      debug: Jo(\"uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;\\n#endif\\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\\n#else\\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\\n#endif\\n}'),\n      fill: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nuniform float u_emissive_strength;void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\nvec4 out_color=color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nin vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillOutline: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin highp vec2 v_pos;uniform float u_emissive_strength;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillOutlinePattern: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;out highp vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillPattern: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillExtrusion: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec4 v_color;in vec4 v_flat;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\\n#endif\\nuniform lowp float u_opacity;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;in vec2 v_ao;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nin vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nin highp vec3 v_normal;\\n#endif\\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\\nin float v_flood_radius;in float v_has_floodlight;\\n#endif\\nuniform float u_emissive_strength;in float v_height;void main() {\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nvec3 normal=normalize(v_normal);\\n#endif\\nfloat z;vec4 color=v_color;\\n#ifdef ZERO_ROOF_RADIUS\\nz=float(normal.z > 0.00001);\\n#ifdef LIGHTING_3D_MODE\\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\\n#else\\ncolor=mix(v_color,v_roof_color,z);\\n#endif\\n#endif\\nfloat h=max(0.0,v_height);float ao_shade=1.0;\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\\n#ifdef ZERO_ROOF_RADIUS\\nconcave*=(1.0-z);\\n#endif\\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef FLOOD_LIGHT\\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\\n#else\\ncolor.rgb*=ao_shade;\\n#endif\\n#else\\ncolor.rgb*=ao_shade;\\n#endif\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nfloat flood_radiance=0.0;\\n#ifdef FLOOD_LIGHT\\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\\n#endif\\n#ifdef RENDER_SHADOWS\\n#ifdef FLOOD_LIGHT\\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\\n#else\\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\\n#endif\\n#else\\ncolor.rgb=apply_lighting(color.rgb,normal);\\n#ifdef FLOOD_LIGHT\\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\\n#endif\\n#endif\\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\\n#endif\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color);\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nout vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nout highp vec3 v_normal;\\n#endif\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;out vec2 v_ao;\\n#endif\\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\\nout float v_flood_radius;out float v_has_floodlight;\\n#endif\\nout float v_height;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define highp float flood_light_wall_radius\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize highp float flood_light_wall_radius\\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nv_normal=normal;\\n#endif\\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\\n#else\\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat cutoff=1.0;vec3 scaled_pos=pos;\\n#ifdef RENDER_CUTOFF\\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=max(0.01,cutoff_opacity(u_cutoff_params,ground.z));if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff < 0.01 && centroid_pos.x !=0.0));gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\\n#endif\\nfloat NdotL=0.0;float colorvalue=0.0;\\n#ifndef LIGHTING_3D_MODE\\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#endif\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\n#ifdef FLOOD_LIGHT\\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\\n#endif\\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\\n#else\\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      fillExtrusionDepth: Jo(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", '#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\nout highp float v_depth;void main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nvec3 pos;\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\\n#else\\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\\n#endif\\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),\n      fillExtrusionPattern: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;in vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nin vec3 v_normal;\\n#endif\\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define mediump vec4 pattern\\n#pragma mapbox: define highp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize highp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\\n#else\\nout_color=out_color*v_lighting;\\n#endif\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\nout vec2 v_pos;out vec4 v_lighting;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;out vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout vec3 v_normal;\\n#endif\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define mediump vec4 pattern\\n#pragma mapbox: define highp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize highp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\\n#else\\np=vec3(pos_nx.xy,z);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\\n? pos_nx.xy\\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\\n#ifdef LIGHTING_3D_MODE\\nNdotL=calculate_NdotL(normal);\\n#else\\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\\n#endif\\nif (normal.y !=0.0) {float r=0.84;\\n#ifndef LIGHTING_3D_MODE\\nr=mix(0.7,0.98,1.0-u_lightintensity);\\n#endif\\nNdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nv_normal=normal;\\n#else\\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\\n#endif \\n#ifdef FOG\\nv_fog_pos=fog_position(p);\\n#endif\\n}'),\n      groundShadow: Jo('#include \"_prelude_shadow.fragment.glsl\"\\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\\n#ifdef FOG\\nin float v_fog_opacity;\\n#endif\\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#ifdef RENDER_CUTOFF\\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\\n#endif\\n#ifdef FOG\\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\\n#endif\\nglFragColor=vec4(shadow,1.0);}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\\n#ifdef FOG\\nout float v_fog_opacity;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\\n#endif\\n}'),\n      fillExtrusionGroundEffect: Jo(\"uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\\n#ifdef SDF_SUBPASS\\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\\n#ifdef FOG\\nin highp float v_fog;\\n#endif\\n#endif\\nvoid main() {\\n#ifdef CLEAR_SUBPASS\\nvec4 color=vec4(1.0);\\n#ifdef CLEAR_FROM_TEXTURE\\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\\n#endif\\nglFragColor=color;\\n#else\\n#ifdef SDF_SUBPASS\\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\\n#ifdef FOG\\nfog=v_fog;\\n#endif\\n#ifdef RENDER_CUTOFF\\nfog*=v_cutoff_opacity;\\n#endif\\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\\n#else\\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\\n#ifdef OVERDRAW_INSPECTOR\\ncolor=vec4(1.0);\\n#endif\\nglFragColor=color;\\n#endif\\nHANDLE_WIREFRAME_DEBUG;\\n#endif\\n}\", '#include \"_prelude_fog.vertex.glsl\"\\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\\n#ifdef SDF_SUBPASS\\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\\n#ifdef FOG\\nout highp float v_fog;\\n#endif\\n#endif\\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\\n#pragma mapbox: define highp float flood_light_ground_radius\\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\\n#pragma mapbox: initialize highp float flood_light_ground_radius\\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\\n#ifdef SDF_SUBPASS\\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\\n#endif\\n#endif\\nfloat hidden_by_landmark=0.0;\\n#ifdef HAS_CENTROID\\nhidden_by_landmark=a_hidden_by_landmark;\\n#endif\\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\\n#ifdef RENDER_CUTOFF\\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\\n#endif\\n}'),\n      hillshadePrepare: Jo(\"precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}\", \"uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}\"),\n      hillshade: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef LIGHTING_3D_MODE\\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      line: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\\n#ifdef RENDER_LINE_DASH\\nuniform sampler2D u_dash_image;in vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform sampler2D u_gradient_image;\\n#endif\\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float border_width\\n#pragma mapbox: define lowp vec4 border_color\\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float border_width\\n#pragma mapbox: initialize lowp vec4 border_color\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\\n#ifdef RENDER_LINE_DASH\\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\\n#endif\\nhighp vec4 out_color;\\n#ifdef RENDER_LINE_GRADIENT\\nout_color=texture(u_gradient_image,v_uv.xy);\\n#else\\nout_color=color;\\n#endif\\nfloat trimmed=1.0;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\\n#endif\\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\\n#ifdef RENDER_LINE_BORDER\\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nout_color*=(alpha*opacity);\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#define EXTRUDE_SCALE 0.015873016\\nin vec2 a_pos_normal;in vec4 a_data;\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nin highp vec4 a_packed;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nin float a_linesofar;\\n#endif\\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\\n#ifdef RENDER_LINE_DASH\\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform float u_image_height;\\n#endif\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float border_width\\n#pragma mapbox: define lowp vec4 border_color\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float border_width\\n#pragma mapbox: initialize lowp vec4 border_color\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\\n#ifdef RENDER_LINE_GRADIENT\\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\\n#else\\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\\n#endif\\n#endif\\n#ifdef RENDER_LINE_DASH\\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\\n#endif\\nv_width2=vec2(outset,inset);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      linePattern: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nin highp vec4 v_uv;\\n#endif\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float pattern_x=v_linesofar/pattern_size.x*aspect;float x=mod(pattern_x,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {color=vec4(0,0,0,0);}}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\ncolor=apply_lighting_ground(color);\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ncolor*=(alpha*opacity);\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color);\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#define scale 0.015873016\\nin vec2 a_pos_normal;in vec4 a_data;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nin highp vec4 a_packed;\\n#endif\\nin float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nout highp vec4 v_uv;\\n#endif\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\\n#endif\\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      raster: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_raster_array.glsl\"\\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin float v_split_fade;\\n#endif\\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\\n#ifndef RASTER_ARRAY\\nuniform sampler2D u_image0;uniform sampler2D u_image1;\\n#endif\\n#ifdef RASTER_COLOR\\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\\n#endif\\nvoid main() {vec4 color0,color1,color;vec2 value;\\n#ifdef RASTER_COLOR\\n#ifdef RASTER_ARRAY\\n#ifdef RASTER_ARRAY_LINEAR\\nvalue=mix(\\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\\n);\\n#else\\nvalue=mix(\\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\\n);\\n#endif\\nif (value.y > 0.0) value.x/=value.y;\\n#else\\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\\n#endif\\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\\n#else\\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\\n#endif\\ncolor.a*=u_opacity;\\n#ifdef GLOBE_POLES\\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\\n#endif\\nvec3 rgb=color.rgb;rgb=vec3(\\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\\n#endif\\n#ifdef FOG\\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\\n#endif\\nglFragColor=vec4(out_color*color.a,color.a);\\n#ifdef PROJECTION_GLOBE_VIEW\\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\\n#endif\\n#ifdef RENDER_CUTOFF\\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\\n#ifdef GLOBE_POLES\\nin vec3 a_globe_pos;in vec2 a_uv;\\n#else\\nin vec2 a_pos;in vec2 a_texture_pos;\\n#endif\\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\\n#ifdef PROJECTION_GLOBE_VIEW\\nout float v_split_fade;\\n#endif\\nvoid main() {vec2 uv;\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\\n#endif\\n#else\\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \\nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n#else\\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#endif\\n#endif\\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\\n#ifdef RENDER_CUTOFF\\nv_depth=gl_Position.z;\\n#endif\\n}'),\n      rasterParticle: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\\n#endif\\n#ifdef FOG\\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\\n#endif\\nglFragColor=vec4(out_color*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;vec2 uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n#else\\nvec2 uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#endif\\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),\n      rasterParticleDraw: Jo(\"precision highp float;uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}\", 'precision highp float;\\n#include \"_prelude_raster_array.glsl\"\\n#include \"_prelude_raster_particle.glsl\"\\nin vec3 a_pos;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {vec2 pos=a_pos.xy+u_tile_offset;vec2 tex_coords=fract(pos);gl_PointSize=1.0;vec2 velocity=lookup_velocity(tex_coords);if (velocity==INVALID_VELOCITY) {v_particle_speed=0.0;gl_Position=vec4(2.0,2.0,2.0,1.0);} else {v_particle_speed=length(velocity);gl_Position=vec4(2.0*pos-vec2(1.0),0.0,1.0);}}'),\n      rasterParticleTexture: Jo(\"uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}\", \"in vec2 a_pos;out vec2 v_tex_pos;void main() {v_tex_pos=0.5*a_pos+vec2(0.5);gl_Position=vec4(a_pos,0.0,1.0);}\"),\n      rasterParticleUpdate: Jo(\"void main() {}\", '#include \"_prelude_raster_array.glsl\"\\n#include \"_prelude_raster_particle.glsl\"\\nin vec3 a_pos;uniform float u_speed_factor;uniform float u_lifetime_delta;uniform float u_rand_seed;out vec3 v_new_particle;const vec3 rand_constants=vec3(12.9898,78.233,4375.85453);float rand(const vec2 co) {float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {float lifetime=a_pos.z;vec2 pos=a_pos.xy;vec2 uv=clamp(pos,vec2(0.0),vec2(1.0));vec2 velocity=lookup_velocity(uv);float next_lifetime=lifetime-u_lifetime_delta;float t=step(0.0,next_lifetime);\\n#ifdef DATA_FORMAT_UINT32\\nvec2 dp=vec2(0);\\n#else\\nvec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;\\n#endif\\nvec2 seed=pos*u_rand_seed;vec2 next_pos=pos+dp;vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));v_new_particle=vec3(\\nvec2(mix(random_pos,next_pos,t)),mix(1.0,next_lifetime,t)\\n);}'),\n      symbolIcon: Jo('#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_texture;\\n#ifdef ICON_TRANSITION\\nuniform float u_icon_transition;\\n#endif\\nin float v_fade_opacity;in vec2 v_tex_a;\\n#ifdef ICON_TRANSITION\\nin vec2 v_tex_b;\\n#endif\\nuniform mediump float u_icon_saturation;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float emissive_strength\\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\\n#ifdef ICON_TRANSITION\\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b)*alpha;\\n#else\\nout_color=texture(u_texture,v_tex_a)*alpha;\\n#endif\\n#ifdef SATURATION\\nvec3 luma=vec3(dot(out_color.rgb,vec3(0.2126,0.7152,0.0722)));out_color.rgb=mix(luma,out_color.rgb,u_icon_saturation);\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\\n#ifdef Z_OFFSET\\nin float a_z_offset;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\\n#endif\\n#ifdef ICON_TRANSITION\\nin vec2 a_texb;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nout vec2 v_tex_a;\\n#ifdef ICON_TRANSITION\\nout vec2 v_tex_b;\\n#endif\\nout float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float emissive_strength\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\\n#ifdef Z_OFFSET\\ne+=a_z_offset;\\n#endif\\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\\n#else\\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\\n#endif\\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\\n#endif\\nv_tex_a=a_tex/u_texsize;\\n#ifdef ICON_TRANSITION\\nv_tex_b=a_texb/u_texsize;\\n#endif\\nv_fade_opacity=out_fade_opacity;}'),\n      symbolSDF: Jo('#include \"_prelude_lighting.glsl\"\\n#define SDF_PX 8.0\\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\\n#ifdef Z_OFFSET\\nin float a_z_offset;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\\n#ifdef Z_OFFSET\\ne+=a_z_offset;\\n#endif\\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\\n#else\\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\\n#endif\\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\\n#endif\\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'),\n      symbolTextAndIcon: Jo('#include \"_prelude_lighting.glsl\"\\n#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\\n#ifdef Z_OFFSET\\nin float a_z_offset;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\\n#ifdef Z_OFFSET\\ne+=a_z_offset;\\n#endif\\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\\n#endif\\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'),\n      terrainRaster: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image0;in vec2 v_pos0;\\n#ifdef FOG\\nin float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\\n#endif\\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\\n#ifdef LIGHTING_3D_MODE\\nconst vec3 normal=vec3(0.0,0.0,1.0);\\n#ifdef RENDER_SHADOWS\\nfloat cutoffOpacity=1.0;\\n#ifdef RENDER_CUTOFF\\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\\n#endif\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\\n#else\\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\\n#endif\\n#else\\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\\n#endif\\n#endif\\n#else\\ncolor=image_color;\\n#endif\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#else\\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\\n#endif\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\\n#ifdef FOG\\nout float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\\n#endif\\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\nv_fog_pos=fog_position(decodedPos);\\n#else\\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\\n#endif\\n}'),\n      terrainDepth: Jo(\"precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}\", '#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),\n      skybox: Jo('#include \"_prelude_fog.fragment.glsl\"\\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\\n#ifdef FOG\\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\\n#endif\\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', Bo),\n      skyboxGradient: Jo('#include \"_prelude_fog.fragment.glsl\"\\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\\n#ifdef FOG\\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\\n#endif\\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', Bo),\n      skyboxCapture: Jo(\"\\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\\n#define MIE_G                   0.76\\n#define DENSITY_HEIGHT_SCALE_R  8000.0\\n#define DENSITY_HEIGHT_SCALE_M  1200.0\\n#define PLANET_RADIUS           6360e3\\n#define ATMOSPHERE_RADIUS       6420e3\\n#define SAMPLE_STEPS            10\\n#define DENSITY_STEPS           4\\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}\", \"in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}\"),\n      globeRaster: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\\n#ifndef FOG\\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\\n#endif\\nvoid main() {vec4 color;\\n#ifdef CUSTOM_ANTIALIASING\\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\\n#else\\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\\n#endif\\n#else\\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\\n#endif\\n#else\\ncolor=texture(u_image0,v_pos0);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\\n#else\\ncolor=apply_lighting_ground(color);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\\n#ifdef GLOBE_POLES\\nin vec3 a_globe_pos;in vec2 a_uv;\\n#else\\nin vec2 a_pos;\\n#endif\\nout vec2 v_pos0;void main() {\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\\n#else\\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\\n#endif\\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\\n#ifdef GLOBE_POLES\\nvec3 up_vector=globe_derived_up_vector;\\n#else\\nvec3 up_vector=elevationVector(tile_pos);\\n#endif\\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\\n#ifndef GLOBE_POLES\\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\\n#endif\\n#ifdef GLOBE_POLES\\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\\n#else\\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\\n#endif\\ngl_Position=u_proj_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n}'),\n      globeAtmosphere: Jo('#include \"_prelude_fog.fragment.glsl\"\\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\\n#ifdef PROJECTION_GLOBE_VIEW\\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\\n#ifdef ALPHA_PASS\\nglFragColor=vec4(0,0,0,0);return;\\n#else\\n#ifdef NATIVE\\nglFragColor=vec4(1,1,1,1);\\n#else\\nglFragColor=vec4(0,0,0,1);\\n#endif\\nreturn;\\n#endif\\n}\\n#endif\\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\\n#ifdef PROJECTION_GLOBE_VIEW\\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\\n#else\\nhorizon_angle=horizon_angle_mercator;\\n#endif\\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\\n#ifdef ALPHA_PASS\\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\\n#else\\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\\n#ifndef NATIVE\\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\\n#endif\\nglFragColor=vec4(c*t,t);\\n#endif\\n}', \"in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}\"),\n      model: Jo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\\n#ifdef RENDER_SHADOWS\\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\\n#endif\\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\\nuniform vec4 u_occlusionTextureTransform;\\n#endif\\n#pragma mapbox: define-attribute highp vec3 normal_3f\\n#pragma mapbox: define-attribute highp vec3 color_3f\\n#pragma mapbox: define-attribute highp vec4 color_4f\\n#pragma mapbox: define-attribute highp vec2 uv_2f\\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\\n#pragma mapbox: initialize-attribute highp vec3 color_3f\\n#pragma mapbox: initialize-attribute highp vec4 color_4f\\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\\n#endif\\n#ifdef HAS_TEXTURE_u_baseColorTexture\\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\\n#endif\\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\\nuniform sampler2D u_metallicRoughnessTexture;\\n#endif\\n#ifdef HAS_TEXTURE_u_occlusionTexture\\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\\n#endif\\n#ifdef HAS_TEXTURE_u_normalTexture\\nuniform sampler2D u_normalTexture;\\n#endif\\n#ifdef HAS_TEXTURE_u_emissionTexture\\nuniform sampler2D u_emissionTexture;\\n#endif\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nin highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}\\n#endif\\n#define saturate(_x) clamp(_x,0.,1.)\\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\\n{\\n#ifdef LIGHTING_3D_MODE\\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\\n#ifdef RENDER_SHADOWS\\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\\n#endif\\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\\n#else\\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\\n#endif\\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\\n#ifdef HAS_ATTRIBUTE_a_color_3f\\nalbedo*=vec4(color_3f,1.0);\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\n#else\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nalbedo*=color_4f;\\n#endif\\n#endif\\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\\n#endif\\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\\n#endif\\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\\n#ifdef HAS_TEXTURE_u_normalTexture\\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\\n#else\\nreturn mat3(1.0);\\n#endif\\n}highp vec3 getNormal(){highp vec3 n;\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\nn=normalize(normal_3f);\\n#else\\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\\n#endif\\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\\n#endif\\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\\n#endif\\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \\nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\\n#endif\\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\\n{\\n#ifdef LIGHTING_3D_MODE\\nreturn mat.diffuseColor;\\n#else\\nreturn mat.diffuseColor/PI;\\n#endif\\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\\n{vec3 env_light=vec3(0.65,0.65,0.65);\\n#ifdef LIGHTING_3D_MODE\\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\\n#endif\\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\\n#ifdef RENDER_SHADOWS\\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nlighting_factor=NdotL;\\n#endif\\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\\n#if !defined(LIGHTING_3D_MODE)\\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\\n#endif\\ncolor*=intensityFactor;return color;}void main() {\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nif (isOccluded()) {discard;}\\n#endif\\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\\n#ifdef LIGHTING_3D_MODE\\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\\n#endif\\nvec4 finalColor;\\n#ifdef DIFFUSE_SHADED\\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\\n#ifdef HAS_TEXTURE_u_occlusionTexture\\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\\n#endif\\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\\n#else\\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\\n#else\\nvec2 uv=uv_2f;\\n#endif\\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\\n#endif\\nvec4 emissive=u_emissiveFactor;\\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\\n#endif\\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\\n#endif\\n#endif\\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\\n#endif\\n#ifdef FOG\\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\\n#endif\\n#ifdef RENDER_CUTOFF\\nfinalColor*=v_cutoff_opacity;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nfinalColor=applyCutout(finalColor);\\n#endif\\nglFragColor=finalColor;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec3 a_pos_3f;\\n#pragma mapbox: define-attribute highp vec3 normal_3f\\n#pragma mapbox: define-attribute highp vec2 uv_2f\\n#pragma mapbox: define-attribute highp vec3 color_3f\\n#pragma mapbox: define-attribute highp vec4 color_4f\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\\nuniform mat4 u_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\\n#else\\nuniform highp mat4 u_normal_matrix;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\\n#endif\\nout vec4 v_position_height;out lowp vec4 v_color_mix;\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nout highp float v_depth;\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\\n#endif\\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\\n#pragma mapbox: initialize-attribute highp vec3 color_3f\\n#pragma mapbox: initialize-attribute highp vec4 color_4f\\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\\nhighp mat4 normal_matrix;\\n#ifdef INSTANCED_ARRAYS\\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\\n#else\\nnormal_matrix=u_normal_matrix;\\n#endif\\nvec3 local_pos;mat3 rs;\\n#ifdef MODEL_POSITION_ON_GPU\\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\\n#else\\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\\n#endif\\nv_position_height.w=a_pos_3f.z;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(local_pos);\\n#endif\\n#ifdef RENDER_CUTOFF\\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\\n#endif\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nv_depth=gl_Position.z/gl_Position.w;\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\n#ifdef MODEL_POSITION_ON_GPU\\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\\n#else\\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\\n#endif\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 shadow_pos=local_pos;\\n#ifdef NORMAL_OFFSET\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\n#ifdef MODEL_POSITION_ON_GPU\\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos+=offset*shadow_normal_offset_multiplier0();\\n#else\\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos+=offset*shadow_normal_offset_multiplier0();\\n#endif\\n#endif\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1);v_depth_shadows=gl_Position.w;\\n#endif\\n}'),\n      modelDepth: Jo(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", \"in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\\n#ifdef MODEL_POSITION_ON_GPU\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\\n#else\\nuniform highp mat4 u_instance;\\n#endif\\nuniform highp mat4 u_node_matrix;\\n#endif\\nvoid main() {\\n#ifdef MODEL_POSITION_ON_GPU\\nhighp mat4 instance;\\n#ifdef INSTANCED_ARRAYS\\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\\n#else\\ninstance=u_instance;\\n#endif\\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\\n#else\\ngl_Position=u_matrix*vec4(a_pos_3f,1);\\n#endif\\nv_depth=gl_Position.z/gl_Position.w;}\"),\n      stars: Jo(\"in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}\", \"\\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}\")\n    };\n    function Yo(e, t) {\n      const i = e.replace(/\\s*\\/\\/[^\\n]*\\n/g, \"\\n\").split(\"\\n\");\n      for (let e of i) if (e = e.trim(), \"#\" === e[0] && e.includes(\"if\") && !e.includes(\"endif\")) {\n        e = e.replace(\"#\", \"\").replace(/ifdef|ifndef|elif|if/g, \"\").replace(/!|defined|\\(|\\)|\\|\\||&&/g, \"\").replace(/\\s+/g, \" \").trim();\n        const i = e.split(\" \");\n        for (const e of i) t.includes(e) || t.push(e);\n      }\n    }\n    function Jo(e, t) {\n      const i = /#include\\s+\"([^\"]+)\"/g,\n        o = /#pragma mapbox: ([\\w\\-]+) ([\\w]+) ([\\w]+) ([\\w]+)/g;\n      let r = t.match(/(attribute(\\S*)|(^\\s*|;)in) (highp |mediump |lowp )?([\\w]+) ([\\w]+)/gm);\n      r && (r = r.map(e => {\n        const t = e.split(\" \");\n        return t[t.length - 1];\n      }), r = [...new Set(r)]);\n      const s = {},\n        n = [],\n        a = [];\n      if (e = e.replace(i, (e, t) => (a.push(t), \"\")), (t = t.replace(i, (e, t) => (n.push(t), \"\"))).includes(\"flat out\")) return void console.error('The usage of \"flat\" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');\n      let l = [...Ho];\n      Yo(e, l), Yo(t, l);\n      for (const e of [...n, ...a]) Wo[e] || console.error(`Undefined include: ${e}`), qo[e] || (qo[e] = [], Yo(Wo[e], qo[e])), l = [...l, ...qo[e]];\n      return {\n        fragmentSource: e = e.replace(o, (e, t, i, o, r) => (s[r] = !0, \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${r}\\nin ${i} ${o} ${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : \"initialize\" === t ? `\\n#ifdef HAS_UNIFORM_u_${r}\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : \"define-attribute\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${r}\\n    in ${i} ${o} ${r};\\n#endif\\n` : \"initialize-attribute\" === t ? \"\" : void 0)),\n        vertexSource: t = t.replace(o, (e, t, i, o, r) => {\n          const n = \"float\" === o ? \"vec2\" : o,\n            a = r.match(/color/) ? \"color\" : n;\n          return \"define-attribute-vertex-shader-only\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${r}\\nin ${i} ${o} a_${r};\\n#endif\\n` : s[r] ? \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${r}\\nuniform lowp float u_${r}_t;\\nin ${i} ${n} a_${r};\\nout ${i} ${o} ${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : \"initialize\" === t ? \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${r} = a_${r};\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : \"define-attribute\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${r}\\n    in ${i} ${o} a_${r};\\n    out ${i} ${o} ${r};\\n#endif\\n` : \"initialize-attribute\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${r}\\n    ${r} = a_${r};\\n#endif\\n` : void 0 : \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${r}\\nuniform lowp float u_${r}_t;\\nin ${i} ${n} a_${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : \"define-instanced\" === t ? \"mat4\" === a ? `\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_${r}0;\\nin vec4 a_${r}1;\\nin vec4 a_${r}2;\\nin vec4 a_${r}3;\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : `\\n#ifdef INSTANCED_ARRAYS\\nin ${i} ${n} a_${r};\\n#else\\nuniform ${i} ${o} u_${r};\\n#endif\\n` : \"initialize-attribute-custom\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${r}\\n    ${i} ${o} ${r} = a_${r};\\n#endif\\n` : \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${i} ${o} ${r} = a_${r};\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${r}\\n    ${i} ${o} ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\\n#else\\n    ${i} ${o} ${r} = u_${r};\\n#endif\\n`;\n        }),\n        staticAttributes: r,\n        usedDefines: l,\n        vertexIncludes: n,\n        fragmentIncludes: a\n      };\n    }\n    class Qo {\n      constructor() {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;\n      }\n      bind(e, t, i, o, r, s, n, a) {\n        this.context = e;\n        let l = this.boundPaintVertexBuffers.length !== o.length;\n        for (let e = 0; !l && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);\n        let c = this.boundDynamicVertexBuffers.length !== n.length;\n        for (let e = 0; !c && e < n.length; e++) this.boundDynamicVertexBuffers[e] !== n[e] && (c = !0);\n        if (!this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== r || this.boundVertexOffset !== s) this.freshBind(t, i, o, r, s, n, a);else {\n          e.bindVertexArrayOES.set(this.vao);\n          for (const i of n) i && (i.bind(), a && i.instanceCount && i.setVertexAttribDivisor(e.gl, t, a));\n          r && r.dynamicDraw && r.bind();\n        }\n      }\n      freshBind(e, t, i, o, r, s, n) {\n        const a = e.numAttributes,\n          l = this.context,\n          c = l.gl;\n        this.vao && this.destroy(), this.vao = l.gl.createVertexArray(), l.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = s, t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);\n        for (const t of i) t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);\n        for (const t of s) t && (t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r), n && t.instanceCount && t.setVertexAttribDivisor(c, e, n));\n        o && o.bind(), l.currentNumAttributes = a;\n      }\n      destroy() {\n        this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);\n      }\n    }\n    function er(t, i) {\n      const o = Math.pow(2, i.canonical.z),\n        r = i.canonical.y;\n      return [new e.L(0, r / o).toLngLat().lat, new e.L(0, (r + 1) / o).toLngLat().lat];\n    }\n    function tr(t, i, o, r, s, n, a) {\n      const l = t.context,\n        c = l.gl,\n        h = o.hillshadeFBO;\n      if (!h) return;\n      t.prepareDrawTile();\n      const u = t.isTileAffectedByFog(i),\n        d = t.getOrCreateProgram(\"hillshade\", {\n          overrideFog: u\n        });\n      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());\n      const _ = ((t, i, o, r) => {\n        const s = o.paint.get(\"hillshade-shadow-color\"),\n          n = o.paint.get(\"hillshade-highlight-color\"),\n          a = o.paint.get(\"hillshade-accent-color\"),\n          l = o.paint.get(\"hillshade-emissive-strength\");\n        let c = e.bj(o.paint.get(\"hillshade-illumination-direction\"));\n        if (\"viewport\" === o.paint.get(\"hillshade-illumination-anchor\")) c -= t.transform.angle;else if (t.style && t.style.enable3dLights() && t.style.directionalLight) {\n          const i = t.style.directionalLight.properties.get(\"direction\"),\n            o = e.bQ(i.x, i.y, i.z);\n          c = e.bj(o[1]);\n        }\n        const h = !t.options.moving;\n        return {\n          u_matrix: r || t.transform.calculateProjMatrix(i.tileID.toUnwrapped(), h),\n          u_image: 0,\n          u_latrange: er(0, i.tileID),\n          u_light: [o.paint.get(\"hillshade-exaggeration\"), c],\n          u_shadow: s,\n          u_highlight: n,\n          u_emissive_strength: l,\n          u_accent: a\n        };\n      })(t, o, r, t.terrain ? i.projMatrix : null);\n      t.uploadCommonUniforms(l, d, i.toUnwrapped());\n      const {\n        tileBoundsBuffer: p,\n        tileBoundsIndexBuffer: f,\n        tileBoundsSegments: m\n      } = t.getTileBoundsBuffers(o);\n      d.draw(t, c.TRIANGLES, s, n, a, Ft.disabled, _, r.id, p, f, m);\n    }\n    function ir(t, i, o) {\n      if (!i.needsDEMTextureUpload) return;\n      const r = t.context,\n        s = r.gl;\n      r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);\n      const n = o.getPixels();\n      i.demTexture ? i.demTexture.update(n, {\n        premultiply: !1\n      }) : i.demTexture = new e.T(r, n, s.R32F, {\n        premultiply: !1\n      }), i.needsDEMTextureUpload = !1;\n    }\n    function or(t, i, o) {\n      const r = t.context,\n        s = r.gl;\n      if (!i.dem) return;\n      const n = i.dem;\n      if (r.activeTexture.set(s.TEXTURE1), ir(t, i, n), !i.demTexture) return;\n      i.demTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE);\n      const a = n.dim;\n      r.activeTexture.set(s.TEXTURE0);\n      let l = i.hillshadeFBO;\n      if (!l) {\n        const t = new e.T(r, {\n          width: a,\n          height: a,\n          data: null\n        }, s.RGBA);\n        t.bind(s.LINEAR, s.CLAMP_TO_EDGE), l = i.hillshadeFBO = r.createFramebuffer(a, a, !0, \"renderbuffer\"), l.colorAttachment.set(t.texture);\n      }\n      r.bindFramebuffer.set(l.framebuffer), r.viewport.set([0, 0, a, a]);\n      const {\n          tileBoundsBuffer: c,\n          tileBoundsIndexBuffer: h,\n          tileBoundsSegments: u\n        } = t.getMercatorTileBoundsBuffers(),\n        d = [];\n      t.linearFloatFilteringSupported() && d.push(\"TERRAIN_DEM_FLOAT_FORMAT\"), t.getOrCreateProgram(\"hillshadePrepare\", {\n        defines: d\n      }).draw(t, s.TRIANGLES, Lt.disabled, Rt.disabled, Mt.unblended, Ft.disabled, ((t, i) => {\n        const o = i.stride,\n          r = e.a6.create();\n        return e.a6.ortho(r, 0, e.V, -e.V, 0, 0, 1), e.a6.translate(r, r, [0, -e.V, 0]), {\n          u_matrix: r,\n          u_image: 1,\n          u_dimension: [o, o],\n          u_zoom: t.overscaledZ\n        };\n      })(i.tileID, n), o.id, c, h, u), i.needsHillshadePrepare = !1;\n    }\n    const rr = t => ({\n        u_matrix: new e.bK(t),\n        u_image0: new e.bO(t),\n        u_skirt_height: new e.bN(t),\n        u_ground_shadow_factor: new e.bM(t)\n      }),\n      sr = (e, t, i) => ({\n        u_matrix: e,\n        u_image0: 0,\n        u_skirt_height: t,\n        u_ground_shadow_factor: i\n      }),\n      nr = (e, t, i, o, r, s, n, a, l, c, h, u, d, _, p, f) => ({\n        u_proj_matrix: Float32Array.from(e),\n        u_globe_matrix: t,\n        u_normalize_matrix: Float32Array.from(o),\n        u_merc_matrix: i,\n        u_zoom_transition: r,\n        u_merc_center: s,\n        u_image0: 0,\n        u_frustum_tl: n,\n        u_frustum_tr: a,\n        u_frustum_br: l,\n        u_frustum_bl: c,\n        u_globe_pos: h,\n        u_globe_radius: u,\n        u_viewport: d,\n        u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),\n        u_skirt_height: _,\n        u_far_z_cutoff: p\n      });\n    function ar(e, t) {\n      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;\n    }\n    const lr = new class {\n        constructor() {\n          this.operations = {};\n        }\n        newMorphing(e, t, i, o, r) {\n          if (e in this.operations) {\n            const t = this.operations[e];\n            t.to.tileID.key !== i.tileID.key && (t.queued = i);\n          } else this.operations[e] = {\n            startTime: o,\n            phase: 0,\n            duration: r,\n            from: t,\n            to: i,\n            queued: null\n          };\n        }\n        getMorphValuesForProxy(e) {\n          if (!(e in this.operations)) return null;\n          const t = this.operations[e];\n          return {\n            from: t.from,\n            to: t.to,\n            phase: t.phase\n          };\n        }\n        update(e) {\n          for (const t in this.operations) {\n            const i = this.operations[t];\n            for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {\n              delete this.operations[t];\n              break;\n            }\n          }\n        }\n        _nextOp(e, t) {\n          return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);\n        }\n        _validOp(e) {\n          return e.from.hasData() && e.to.hasData();\n        }\n      }(),\n      cr = {\n        0: null,\n        1: \"TERRAIN_VERTEX_MORPHING\"\n      };\n    function hr(e, t, i) {\n      if (0 === t) return 0;\n      const o = t < 1 && 514 === i ? .25 / t : 1;\n      return 6 * Math.pow(1.5, 22 - e) * Math.max(t, 1) * o;\n    }\n    function ur(e, t) {\n      const i = 1 << e.z;\n      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;\n    }\n    const dr = e => ({\n      u_matrix: e\n    });\n    function _r(t, i, o, r, s) {\n      if (s > 0) {\n        const n = e.f.now(),\n          a = (n - t.timeAdded) / s,\n          l = i ? (n - i.timeAdded) / s : -1,\n          c = o.getSource(),\n          h = r.coveringZoomLevel({\n            tileSize: c.tileSize,\n            roundZoom: c.roundZoom\n          }),\n          u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),\n          d = u && t.refreshedUponExpiration ? 1 : e.aa(u ? a : 1 - l, 0, 1);\n        return t.refreshedUponExpiration && a >= 1 && (t.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - d\n        } : {\n          opacity: d,\n          mix: 0\n        };\n      }\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n    class pr extends Kt {\n      constructor(t) {\n        const i = {\n            type: \"raster-dem\",\n            maxzoom: t.transform.maxZoom\n          },\n          o = new e.bW(e.bX(), null),\n          r = Vt(\"mock-dem\", i, o, t.style);\n        super(\"mock-dem\", r, !1), r.setEventedParent(this), this._sourceLoaded = !0;\n      }\n      _loadTile(e, t) {\n        e.state = \"loaded\", t(null);\n      }\n    }\n    class fr extends Kt {\n      constructor(t) {\n        const i = Vt(\"proxy\", {\n          type: \"geojson\",\n          maxzoom: t.transform.maxZoom\n        }, new e.bW(e.bX(), null), t.style);\n        super(\"proxy\", i, !1), i.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n      update(e, t, i) {\n        if (e.freezeTileCoverage) return;\n        this.transform = e;\n        const o = e.coveringTiles({\n          tileSize: this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom,\n          reparseOverscaled: this._source.reparseOverscaled\n        }).reduce((t, i) => {\n          if (t[i.key] = \"\", !this._tiles[i.key]) {\n            const t = new Gt(i, this._source.tileSize * i.overscaleFactor(), e.tileZoom);\n            t.state = \"loaded\", this._tiles[i.key] = t;\n          }\n          return t;\n        }, {});\n        for (const e in this._tiles) e in o || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);\n      }\n      freeFBO(e) {\n        const t = this.proxyCachedFBO[e];\n        if (void 0 !== t) {\n          const i = Object.values(t);\n          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];\n        }\n      }\n      deallocRenderCache() {\n        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n    }\n    class mr extends e.am {\n      constructor(e, t, i) {\n        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;\n      }\n    }\n    class gr extends e.ck {\n      constructor(t, i) {\n        super(), this._debugParams = {\n          sortTilesHiZFirst: !0,\n          disableRenderCache: !1\n        }, t.tp.registerParameter(this._debugParams, [\"Terrain\"], \"sortTilesHiZFirst\", {}, () => {\n          this._style.map.triggerRepaint();\n        }), t.tp.registerParameter(this._debugParams, [\"Terrain\"], \"disableRenderCache\", {}, () => {\n          this._style.map.triggerRepaint();\n        }), t.tp.registerButton([\"Terrain\"], \"Invalidate Render Cache\", () => {\n          this.invalidateRenderCache = !0, this._style.map.triggerRepaint();\n        }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};\n        const [o, r, s] = function (t) {\n            const i = new e.aN(),\n              o = new e.aw(),\n              r = 131;\n            i.reserve(17161), o.reserve(33800);\n            const s = e.V / 128,\n              n = e.V + s / 2,\n              a = n + s;\n            for (let t = -s; t < a; t += s) for (let o = -s; o < a; o += s) {\n              const r = o < 0 || o > n || t < 0 || t > n ? 24575 : 0,\n                s = e.aa(Math.round(o), 0, e.V),\n                a = e.aa(Math.round(t), 0, e.V);\n              i.emplaceBack(s + r, a);\n            }\n            const l = (e, t) => {\n              const i = t * r + e;\n              o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);\n            };\n            for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);\n            return [0, 129].forEach(e => {\n              for (let t = 0; t < 130; t++) l(t, e), l(e, t);\n            }), [i, o, 32768];\n          }(),\n          n = t.context;\n        this.gridBuffer = n.createVertexBuffer(o, e.aP.members), this.gridIndexBuffer = n.createIndexBuffer(r), this.gridSegments = e.aB.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.aB.simpleSegment(0, 0, o.length, s), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new fr(i.map), this.orthoMatrix = e.a6.create(), e.a6.ortho(this.orthoMatrix, \"globe\" === this.painter.transform.projection.name ? .015 : 0, e.V, 0, e.V, 0, 1);\n        const a = n.gl;\n        this._overlapStencilMode = new Rt({\n          func: a.GEQUAL,\n          mask: 255\n        }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new pr(i.map), this._pendingGroundEffectLayers = [];\n      }\n      set style(e) {\n        e.on(\"data\", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on(\"moveend\", () => {\n          this._clearLineLayersFromRenderCache();\n        });\n      }\n      update(t, i, o) {\n        if (t && t.terrain) {\n          this._style !== t && (this.style = t, this._evaluationZoom = void 0);\n          const r = t.terrain.properties,\n            s = 0 === t.terrain.drapeRenderMode,\n            n = t.terrain.isZoomDependent();\n          this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.f.now();\n          const a = t.terrain && t.terrain.scope,\n            l = r.get(\"source\"),\n            c = s ? this._mockSourceCache : t.getSourceCache(l, a);\n          if (!c) return void e.w(`Couldn't find terrain source \"${l}\".`);\n          if (this.sourceCache = c, this._exaggeration = n ? this.calculateExaggeration(i) : r.get(\"exaggeration\"), !i.projection.requiresDraping && n && 0 === this._exaggeration) return void this._disable();\n          this.enabled = !0;\n          const h = () => {\n            this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);\n            const t = this.getScaledDemTileSize();\n            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);\n          };\n          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;\n        } else this._disable();\n      }\n      calculateExaggeration(t) {\n        const i = this._previousCameraAltitude,\n          o = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;\n        this._previousCameraAltitude = o;\n        const r = null != i ? o - i : Number.MAX_VALUE;\n        if (Math.abs(r) < 2) return this._exaggeration;\n        const s = t.zoom,\n          n = this._style.terrain;\n        if (!this._previousUpdateTimestamp) return n.getExaggeration(s);\n        let a = s - this._previousZoom;\n        const l = this._previousUpdateTimestamp;\n        let c = s;\n        null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(s - c) > .5 && (a = .5 * (s - c + a)), a * r < 0 && (c += a)), this._evaluationZoom = c;\n        const h = n.getExaggeration(c),\n          u = h === n.getExaggeration(Math.max(0, c - .1));\n        if (u && Math.abs(h - this._exaggeration) < .01) return h;\n        let d = Math.min(.1, .00375 * (this._updateTimestamp - l));\n        return (u || h < .1 || Math.abs(a) < 1e-4) && (d = Math.min(.2, 4 * d)), e.U(this._exaggeration, h, d);\n      }\n      resetTileLookupCache(e) {\n        this._findCoveringTileCache[e] = {};\n      }\n      getScaledDemTileSize() {\n        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;\n      }\n      _onStyleDataEvent(e) {\n        e.coord && \"source\" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : \"style\" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);\n      }\n      _disable() {\n        if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e].usedForTerrain = !1;\n      }\n      destroy() {\n        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();\n      }\n      _source() {\n        return this.enabled ? this.sourceCache : null;\n      }\n      isUsingMockSource() {\n        return this.sourceCache === this._mockSourceCache;\n      }\n      exaggeration() {\n        return this._exaggeration;\n      }\n      get visibleDemTiles() {\n        return this._visibleDemTiles;\n      }\n      get drapeBufferSize() {\n        const e = 2 * this.proxySourceCache.getSource().tileSize;\n        return [e, e];\n      }\n      set useVertexMorphing(e) {\n        this._useVertexMorphing = e;\n      }\n      updateTileBinding(t) {\n        if (!this.enabled) return;\n        this.prevTerrainTileForTile = this.terrainTileForTile;\n        const i = this.proxySourceCache,\n          o = this.painter.transform;\n        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.L.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);\n        const r = this.proxyCoords = i.getIds().map(e => {\n          const t = i.getTileByID(e).tileID;\n          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;\n        });\n        !function (t, i) {\n          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),\n            r = new e.P(o.x, o.y);\n          t.sort((t, i) => {\n            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;\n            const o = new e.P(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),\n              s = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),\n              n = r.mult(1 << t.canonical.z);\n            return n.x -= .5, n.y -= .5, n.distSqr(o) - n.distSqr(s);\n          });\n        }(r, this.painter);\n        const s = this.proxyToSource || {};\n        this.proxyToSource = {}, r.forEach(e => {\n          this.proxyToSource[e.key] = {};\n        }), this.terrainTileForTile = {};\n        const n = this._style._mergedSourceCaches;\n        for (const e in n) {\n          const i = n[e];\n          if (!i.used) continue;\n          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], s), i.usedForTerrain) continue;\n          const o = t[e];\n          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);\n        }\n        this.proxiedCoords[i.id] = r.map(e => new mr(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s), this.renderingToTexture = !1;\n        const a = {};\n        this._visibleDemTiles = [];\n        for (const e of this.proxyCoords) {\n          const t = this.terrainTileForTile[e.key];\n          if (!t) continue;\n          const i = t.tileID.key;\n          i in a || (this._visibleDemTiles.push(t), a[i] = i);\n        }\n      }\n      _assignTerrainTiles(e) {\n        this._initializing || e.forEach(e => {\n          if (this.terrainTileForTile[e.key]) return;\n          const t = this._findTileCoveringTileID(e, this.sourceCache);\n          t && (this.terrainTileForTile[e.key] = t);\n        });\n      }\n      _prepareDEMTextures() {\n        const e = this.painter.context,\n          t = e.gl;\n        for (const i in this.terrainTileForTile) {\n          const o = this.terrainTileForTile[i],\n            r = o.dem;\n          !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), ir(this.painter, o, r));\n        }\n      }\n      _prepareDemTileUniforms(e, t, i, o) {\n        if (!t || null == t.demTexture) return !1;\n        const r = e.tileID.canonical,\n          s = Math.pow(2, t.tileID.canonical.z - r.z),\n          n = o || \"\";\n        return i[`u_dem_tl${n}`] = [r.x * s % 1, r.y * s % 1], i[`u_dem_scale${n}`] = s, !0;\n      }\n      get emptyDEMTexture() {\n        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();\n      }\n      get emptyDepthBufferTexture() {\n        const t = this.painter.context,\n          i = t.gl;\n        if (!this._emptyDepthBufferTexture) {\n          const o = new e.h({\n            width: 1,\n            height: 1\n          }, Uint8Array.of(255, 255, 255, 255));\n          this._emptyDepthBufferTexture = new e.T(t, o, i.RGBA, {\n            premultiply: !1\n          });\n        }\n        return this._emptyDepthBufferTexture;\n      }\n      _getLoadedAreaMinimum() {\n        let e = 0;\n        const t = this._visibleDemTiles.reduce((t, i) => {\n          if (!i.dem) return t;\n          const o = i.dem.tree.minimums[0];\n          return o > 0 && e++, t + o;\n        }, 0);\n        return e ? t / e : 0;\n      }\n      _updateEmptyDEMTexture() {\n        const t = this.painter.context,\n          i = t.gl;\n        t.activeTexture.set(i.TEXTURE2);\n        const o = this._getLoadedAreaMinimum(),\n          [r, s] = (() => {\n            const t = new e.cm({\n              width: 1,\n              height: 1\n            }, new Float32Array([o]));\n            return [i.R32F, t];\n          })();\n        this._emptyDEMTextureDirty = !1;\n        let n = this._emptyDEMTexture;\n        return n ? n.update(s, {\n          premultiply: !1\n        }) : n = this._emptyDEMTexture = new e.T(t, s, r, {\n          premultiply: !1\n        }), n;\n      }\n      setupElevationDraw(t, i, o) {\n        const r = this.painter.context,\n          s = r.gl,\n          n = {\n            u_dem: 2,\n            u_dem_prev: 4,\n            u_dem_tl: [0, 0],\n            u_dem_tl_prev: [0, 0],\n            u_dem_scale: 0,\n            u_dem_scale_prev: 0,\n            u_dem_size: 0,\n            u_dem_lerp: 1,\n            u_depth: 3,\n            u_depth_size_inv: [0, 0],\n            u_exaggeration: 0\n          };\n        n.u_exaggeration = this.exaggeration();\n        let a = null,\n          l = null,\n          c = 1;\n        if (o && o.morphing && this._useVertexMorphing) {\n          const e = o.morphing.srcDemTile,\n            i = o.morphing.dstDemTile;\n          c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, n, \"_prev\") && (l = e), this._prepareDemTileUniforms(t, i, n) && (a = i));\n        }\n        const h = e => e && e.demTexture && this.painter.linearFloatFilteringSupported() ? s.LINEAR : s.NEAREST,\n          u = e => {\n            n.u_dem_size = 1 === e.size[0] ? 1 : e.size[0] - 2;\n          };\n        if (l && a) r.activeTexture.set(s.TEXTURE2), a.demTexture.bind(h(a), s.CLAMP_TO_EDGE), r.activeTexture.set(s.TEXTURE4), l.demTexture.bind(h(l), s.CLAMP_TO_EDGE), a.demTexture && u(a.demTexture), n.u_dem_lerp = c;else {\n          a = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(s.TEXTURE2);\n          const e = this._prepareDemTileUniforms(t, a, n) ? a.demTexture : this.emptyDEMTexture;\n          e.bind(h(a), s.CLAMP_TO_EDGE), u(e);\n        }\n        if (r.activeTexture.set(s.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), this._depthFBO && (n.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), n.u_depth_size_inv = [1, 1]), o && o.useMeterToDem && a) {\n          const t = (1 << a.tileID.canonical.z) * e.bl(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;\n          n.u_meter_to_dem = t;\n        }\n        if (o && o.labelPlaneMatrixInv && (n.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, n), \"globe\" === this.painter.transform.projection.name) {\n          const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);\n          i.setGlobeUniformValues(r, e);\n        }\n      }\n      globeUniformValues(t, i, o) {\n        const r = t.projection;\n        return {\n          u_tile_tl_up: r.upVector(i, 0, 0),\n          u_tile_tr_up: r.upVector(i, e.V, 0),\n          u_tile_br_up: r.upVector(i, e.V, e.V),\n          u_tile_bl_up: r.upVector(i, 0, e.V),\n          u_tile_up_scale: o ? e.cl(1) : r.upVectorScale(i, t.center.lat, t.worldSize).metersToTile\n        };\n      }\n      renderToBackBuffer(t) {\n        const i = this.painter,\n          o = this.painter.context;\n        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, i, o, r, s) {\n          if (\"globe\" === t.transform.projection.name) !function (t, i, o, r, s) {\n            const n = t.context,\n              a = n.gl;\n            let l, c;\n            const h = t.transform,\n              u = e.cd(t, n, h),\n              d = (e, i) => {\n                if (c === i) return;\n                const o = [cr[i], \"PROJECTION_GLOBE_VIEW\"];\n                u && o.push(\"CUSTOM_ANTIALIASING\");\n                const r = t.isTileAffectedByFog(e);\n                l = t.getOrCreateProgram(\"globeRaster\", {\n                  defines: o,\n                  overrideFog: r\n                }), c = i;\n              },\n              _ = t.colorModeForRenderPass(),\n              p = new Lt(a.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D);\n            lr.update(s);\n            const f = e.ce(h),\n              m = [e.a5(h.center.lng), e.ae(h.center.lat)],\n              g = t.globeSharedBuffers,\n              v = [h.width * e.f.devicePixelRatio, h.height * e.f.devicePixelRatio],\n              x = Float32Array.from(h.globeMatrix),\n              y = {\n                useDenormalizedUpVectorScale: !0\n              };\n            {\n              const h = t.transform,\n                u = hr(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);\n              c = -1;\n              const b = a.TRIANGLES;\n              for (const c of r) {\n                const r = o.getTile(c),\n                  w = Rt.disabled,\n                  T = i.prevTerrainTileForTile[c.key],\n                  E = i.terrainTileForTile[c.key];\n                ar(T, E) && lr.newMorphing(c.key, T, E, s, 250), n.activeTexture.set(a.TEXTURE0), r.texture && r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const S = lr.getMorphValuesForProxy(c.key),\n                  C = S ? 1 : 0;\n                S && e.j(y, {\n                  morphing: {\n                    srcDemTile: S.from,\n                    dstDemTile: S.to,\n                    phase: e.cc(S.phase)\n                  }\n                });\n                const I = e.cf(c.canonical),\n                  D = e.cg(I.getCenter().lat),\n                  L = e.ch(c.canonical, I, D, h.worldSize / h._pixelsPerMercatorPixel),\n                  A = e.aT(e.ci(c.canonical)),\n                  R = nr(h.expandedFarZProjMatrix, x, f, A, e.S(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, u, h._farZ, L);\n                if (d(c, C), l && (i.setupElevationDraw(r, l, y), t.uploadCommonUniforms(n, l, c.toUnwrapped()), g)) {\n                  const [e, i, o] = g.getGridBuffers(D, 0 !== u);\n                  l.draw(t, b, p, w, _, Ft.backCCW, R, \"globe_raster\", e, i, o);\n                }\n              }\n            }\n            if (g && (t.renderDefaultNorthPole || t.renderDefaultSouthPole)) {\n              const s = [\"GLOBE_POLES\", \"PROJECTION_GLOBE_VIEW\"];\n              u && s.push(\"CUSTOM_ANTIALIASING\"), l = t.getOrCreateProgram(\"globeRaster\", {\n                defines: s\n              });\n              for (const s of r) {\n                const {\n                    x: r,\n                    y: c,\n                    z: u\n                  } = s.canonical,\n                  d = 0 === c,\n                  f = c === (1 << u) - 1,\n                  [x, b, w, T] = g.getPoleBuffers(u, !1);\n                if (T && (d || f)) {\n                  const c = o.getTile(s);\n                  n.activeTexture.set(a.TEXTURE0), c.texture && c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                  let g = e.cj(u, r, h);\n                  const E = e.aT(e.ci(s.canonical)),\n                    S = (e, i) => e.draw(t, a.TRIANGLES, p, Rt.disabled, _, Ft.disabled, nr(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ), \"globe_pole_raster\", i, w, T);\n                  i.setupElevationDraw(c, l, y), t.uploadCommonUniforms(n, l, s.toUnwrapped()), d && t.renderDefaultNorthPole && S(l, x), f && t.renderDefaultSouthPole && (g = e.a6.scale(e.a6.create(), g, [1, -1, 1]), S(l, b));\n                }\n              }\n            }\n          }(t, i, o, r, s);else {\n            const n = t.context,\n              a = n.gl;\n            let l, c;\n            const h = t.shadowRenderer,\n              u = vo(t, t.longestCutoffRange),\n              d = e => {\n                if (c === e) return;\n                const i = [];\n                i.push(cr[e]), u.shouldRenderCutoff && i.push(\"RENDER_CUTOFF\"), l = t.getOrCreateProgram(\"terrainRaster\", {\n                  defines: i\n                }), c = e;\n              },\n              _ = t.colorModeForRenderPass(),\n              p = new Lt(a.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D);\n            lr.update(s);\n            const f = t.transform,\n              m = hr(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);\n            let g = [0, 0, 0];\n            if (h) {\n              const e = t.style.directionalLight,\n                i = t.style.ambientLight;\n              e && i && (g = So(e, i));\n            }\n            {\n              c = -1;\n              const v = a.TRIANGLES,\n                [x, y] = [i.gridIndexBuffer, i.gridSegments];\n              for (const c of r) {\n                const r = o.getTile(c),\n                  b = Rt.disabled,\n                  w = i.prevTerrainTileForTile[c.key],\n                  T = i.terrainTileForTile[c.key];\n                ar(w, T) && lr.newMorphing(c.key, w, T, s, 250), n.activeTexture.set(a.TEXTURE0), r.texture && r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const E = lr.getMorphValuesForProxy(c.key),\n                  S = E ? 1 : 0;\n                let C;\n                E && (C = {\n                  morphing: {\n                    srcDemTile: E.from,\n                    dstDemTile: E.to,\n                    phase: e.cc(E.phase)\n                  }\n                });\n                const I = sr(c.projMatrix, ur(c.canonical, f.renderWorldCopies) ? m / 10 : m, g);\n                if (d(S), !l) continue;\n                i.setupElevationDraw(r, l, C);\n                const D = c.toUnwrapped();\n                h && h.setupShadows(D, l), t.uploadCommonUniforms(n, l, D, null, u), l.draw(t, v, p, b, _, Ft.backCCW, I, \"terrain_raster\", i.gridBuffer, x, y);\n              }\n            }\n          }\n        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));\n      }\n      renderBatch(t) {\n        if (0 === this._drapedRenderBatches.length) return t + 1;\n        this.renderingToTexture = !0;\n        const i = this.painter,\n          o = this.painter.context,\n          r = this.proxySourceCache,\n          s = this.proxiedCoords[r.id],\n          n = this._drapedRenderBatches.shift(),\n          a = i.style.order,\n          l = [];\n        let c = 0;\n        for (const h of s) {\n          const s = r.getTileByID(h.proxyTileKey),\n            u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t] : void 0,\n            d = void 0 !== u ? r.renderCache[u] : this.pool[c++],\n            _ = void 0 !== u;\n          if (s.texture = d.tex, _ && !d.dirty) {\n            l.push(s.tileID);\n            continue;\n          }\n          let p;\n          o.bindFramebuffer.set(d.fb.framebuffer), this.renderedToTile = !1, d.dirty && (o.clear({\n            color: e.ax.transparent,\n            stencil: 0\n          }), d.dirty = !1);\n          for (let e = n.start; e <= n.end; ++e) {\n            const t = i.style._mergedLayers[a[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const r = i.style.getLayerSourceCache(t),\n              s = r ? this.proxyToSource[h.key][r.id] : [h];\n            if (!s) continue;\n            const n = s;\n            o.viewport.set([0, 0, d.fb.width, d.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(d, s, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, n);\n          }\n          if (0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers) {\n            const t = i.style._mergedLayers[a[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const r = i.style.getLayerSourceCache(t),\n              s = r ? this.proxyToSource[h.key][r.id] : [h];\n            if (!s) continue;\n            const n = s;\n            o.viewport.set([0, 0, d.fb.width, d.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(d, s, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, n);\n          }\n          this.renderedToTile ? (d.dirty = !0, l.push(s.tileID)) : _ || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));\n        }\n        return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), n.end + 1;\n      }\n      postRender() {}\n      isLayerOrderingCorrect(e) {\n        const t = e.order.length;\n        let i = -1,\n          o = t;\n        for (let r = 0; r < t; ++r) this._style.isLayerDraped(e._mergedLayers[e.order[r]]) ? i = Math.max(i, r) : o = Math.min(o, r);\n        return o > i;\n      }\n      getMinElevationBelowMSL() {\n        let e = 0;\n        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {\n          e = Math.min(e, t.dem.tree.minimums[0]);\n        }), 0 === e ? e : (e - 30) * this._exaggeration;\n      }\n      raycast(e, t, i) {\n        if (!this._visibleDemTiles) return null;\n        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {\n          const r = o.tileID,\n            s = 1 << r.overscaledZ,\n            {\n              x: n,\n              y: a\n            } = r.canonical,\n            l = n / s,\n            c = (n + 1) / s,\n            h = a / s,\n            u = (a + 1) / s;\n          return {\n            minx: l,\n            miny: h,\n            maxx: c,\n            maxy: u,\n            t: o.dem.tree.raycastRoot(l, h, c, u, e, t, i),\n            tile: o\n          };\n        });\n        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));\n        for (const r of o) {\n          if (null == r.t) return null;\n          const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, i);\n          if (null != o) return o;\n        }\n        return null;\n      }\n      _createFBO() {\n        const t = this.painter.context,\n          i = t.gl,\n          o = this.drapeBufferSize;\n        t.activeTexture.set(i.TEXTURE0);\n        const r = new e.T(t, {\n          width: o[0],\n          height: o[1],\n          data: null\n        }, i.RGBA);\n        r.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n        const s = t.createFramebuffer(o[0], o[1], !0, null);\n        return s.colorAttachment.set(r.texture), s.depthAttachment = new It(t, s.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, s.depthAttachment.set(this._sharedDepthStencil), t.clear({\n          stencil: 0\n        })) : s.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {\n          fb: s,\n          tex: r,\n          dirty: !1\n        };\n      }\n      _initFBOPool() {\n        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());\n      }\n      _shouldDisableRenderCache() {\n        if (this._debugParams.disableRenderCache) return !0;\n        if (this._style.hasLightTransitions()) return !0;\n        for (const e in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e].hasTransition()) return !0;\n        return this._style.order.some(e => {\n          const t = this._style._mergedLayers[e],\n            i = t.isHidden(this.painter.transform.zoom);\n          return \"custom\" === t.type ? !i && t.shouldRedrape() : !i && t.hasTransition();\n        });\n      }\n      _clearLineLayersFromRenderCache() {\n        let t = !1;\n        for (const e of this._style.getSources()) if (e instanceof Pe) {\n          t = !0;\n          break;\n        }\n        if (!t) return;\n        const i = {};\n        for (let t = 0; t < this._style.order.length; ++t) {\n          const o = this._style._mergedLayers[this._style.order[t]],\n            r = this._style.getLayerSourceCache(o);\n          if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && \"line\" === o.type && o.widthExpression() instanceof e.Z) {\n            i[r.id] = !0;\n            for (const e of this.proxyCoords) {\n              const t = this.proxyToSource[e.key][r.id];\n              if (t) for (const e of t) this._clearRenderCacheForTile(r.id, e);\n            }\n          }\n        }\n      }\n      _clearRasterLayersFromRenderCache() {\n        let e = !1;\n        for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t]._source instanceof Me) {\n          e = !0;\n          break;\n        }\n        if (!e) return;\n        const t = {};\n        for (let e = 0; e < this._style.order.length; ++e) {\n          const i = this._style._mergedLayers[this._style.order[e]],\n            o = this._style.getLayerSourceCache(i);\n          if (!o || t[o.id]) continue;\n          if (i.isHidden(this.painter.transform.zoom) || \"raster\" !== i.type) continue;\n          const r = i.paint.get(\"raster-fade-duration\");\n          for (const e of this.proxyCoords) {\n            const t = this.proxyToSource[e.key][o.id];\n            if (t) for (const e of t) {\n              const t = _r(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);\n              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);\n            }\n          }\n        }\n      }\n      _setupDrapedRenderBatches() {\n        const t = this._style.order,\n          i = t.length;\n        if (0 === i) return;\n        const o = [];\n        this._pendingGroundEffectLayers = [];\n        let r,\n          s = 0,\n          n = this._style._mergedLayers[t[s]];\n        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++s < i;) n = this._style._mergedLayers[t[s]];\n        for (; s < i; ++s) {\n          const e = this._style._mergedLayers[t[s]];\n          e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === r && (r = s) : (\"fill-extrusion\" === e.type && this._pendingGroundEffectLayers.push(s), void 0 !== r && (o.push({\n            start: r,\n            end: s - 1\n          }), r = void 0)));\n        }\n        if (void 0 !== r && o.push({\n          start: r,\n          end: s - 1\n        }), 0 !== o.length) {\n          const t = o[o.length - 1];\n          this._pendingGroundEffectLayers.every(e => e > t.end) || e.w(\"fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.\");\n        }\n        this._drapedRenderBatches = o;\n      }\n      _setupRenderCache(e) {\n        const t = this.proxySourceCache;\n        if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {\n          if (this.invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {\n            const e = Object.values(t.proxyCachedFBO);\n            t.proxyCachedFBO = {};\n            for (let i = 0; i < e.length; ++i) {\n              const o = Object.values(e[i]);\n              t.renderCachePool.push(...o);\n            }\n          }\n          return;\n        }\n        this._clearRasterLayersFromRenderCache();\n        const i = this.proxyCoords,\n          o = this._tilesDirty;\n        for (let r = i.length - 1; r >= 0; r--) {\n          const s = i[r];\n          if (t.getTileByID(s.key), void 0 !== t.proxyCachedFBO[s.key]) {\n            const i = e[s.key],\n              r = this.proxyToSource[s.key];\n            let n = 0;\n            for (const e in r) {\n              const t = r[e],\n                s = i[e];\n              if (!s || s.length !== t.length || t.some((t, i) => t !== s[i] || o[e] && o[e].hasOwnProperty(t.key))) {\n                n = -1;\n                break;\n              }\n              ++n;\n            }\n            for (const e in t.proxyCachedFBO[s.key]) t.renderCache[t.proxyCachedFBO[s.key][e]].dirty = n < 0 || n !== Object.values(i).length;\n          }\n        }\n        const r = [...this._drapedRenderBatches];\n        r.sort((e, t) => t.end - t.start - (e.end - e.start));\n        for (const e of r) for (const o of i) {\n          if (t.proxyCachedFBO[o.key]) continue;\n          let i = t.renderCachePool.pop();\n          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);\n        }\n        this._tilesDirty = {};\n      }\n      _setupStencil(e, t, i, o) {\n        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));\n        const r = this.painter.context,\n          s = r.gl;\n        if (t.length <= 1) return void (this._overlapStencilType = !1);\n        let n;\n        if (i.isTileClipped()) n = t.length, this._overlapStencilMode.test = {\n          func: s.EQUAL,\n          mask: 255\n        }, this._overlapStencilType = \"Clip\";else {\n          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);\n          n = 1, this._overlapStencilMode.test = {\n            func: s.GREATER,\n            mask: 255\n          }, this._overlapStencilType = \"Mask\";\n        }\n        this._stencilRef + n > 255 && (r.clear({\n          stencil: 0\n        }), this._stencilRef = 0), this._stencilRef += n, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);\n      }\n      clipOrMaskOverlapStencilType() {\n        return \"Clip\" === this._overlapStencilType || \"Mask\" === this._overlapStencilType;\n      }\n      stencilModeForRTTOverlap(e) {\n        return this.renderingToTexture && this._overlapStencilType ? (\"Clip\" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]), this._overlapStencilMode) : Rt.disabled;\n      }\n      _renderTileClippingMasks(e, t) {\n        const i = this.painter,\n          o = this.painter.context,\n          r = o.gl;\n        i._tileClippingMaskIDs = {}, o.setColorMode(Mt.disabled), o.setDepthMode(Lt.disabled);\n        const s = i.getOrCreateProgram(\"clippingMask\");\n        for (const o of e) {\n          const e = i._tileClippingMaskIDs[o.key] = --t;\n          s.draw(i, r.TRIANGLES, Lt.disabled, new Rt({\n            func: r.ALWAYS,\n            mask: 0\n          }, e, 255, r.KEEP, r.KEEP, r.REPLACE), Mt.disabled, Ft.disabled, dr(o.projMatrix), \"$clipping\", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments);\n        }\n      }\n      pointCoordinate(t) {\n        const i = this.painter.transform;\n        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;\n        const o = [t.x, t.y, 1, 1];\n        e.a7.transformMat4(o, o, i.pixelMatrixInverse), e.a7.scale(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;\n        const r = i._camera.position,\n          s = e.bl(1, i.center.lat),\n          n = [r[0], r[1], r[2] / s, 0],\n          a = e.N.subtract([], o.slice(0, 3), n);\n        e.N.normalize(a, a);\n        const l = this.raycast(n, a, this._exaggeration);\n        return null !== l && l ? (e.N.scaleAndAdd(n, n, a, l), n[3] = n[2], n[2] *= s, n) : null;\n      }\n      drawDepth() {\n        const t = this.painter,\n          i = t.context,\n          o = this.proxySourceCache,\n          r = Math.ceil(t.width),\n          s = Math.ceil(t.height);\n        if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === s || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {\n          const t = i.gl,\n            o = i.createFramebuffer(r, s, !0, \"renderbuffer\");\n          i.activeTexture.set(t.TEXTURE0);\n          const n = new e.T(i, {\n            width: r,\n            height: s,\n            data: null\n          }, t.RGBA);\n          n.bind(t.NEAREST, t.CLAMP_TO_EDGE), o.colorAttachment.set(n.texture);\n          const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, s);\n          o.depthAttachment.set(a), this._depthFBO = o, this._depthTexture = n;\n        }\n        i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([0, 0, r, s]), function (e, t, i, o) {\n          if (\"globe\" === e.transform.projection.name) return;\n          const r = e.context,\n            s = r.gl;\n          r.clear({\n            depth: 1\n          });\n          const n = e.getOrCreateProgram(\"terrainDepth\"),\n            a = new Lt(s.LESS, Lt.ReadWrite, e.depthRangeFor3D);\n          for (const r of o) {\n            const o = i.getTile(r),\n              l = sr(r.projMatrix, 0, [0, 0, 0]);\n            t.setupElevationDraw(o, n), n.draw(e, s.TRIANGLES, a, Rt.disabled, Mt.unblended, Ft.backCCW, l, \"terrain_depth\", t.gridBuffer, t.gridIndexBuffer, t.gridNoSkirtSegments);\n          }\n        }(t, this, o, this.proxyCoords);\n      }\n      _setupProxiedCoordsForOrtho(t, i, o) {\n        if (t.getSource() instanceof e.ap) return this._setupProxiedCoordsForImageSource(t, i, o);\n        this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};\n        const r = this.proxiedCoords[t.id] = [],\n          s = this.proxyCoords;\n        for (let e = 0; e < s.length; e++) {\n          const i = s[e],\n            n = this._findTileCoveringTileID(i, t);\n          if (n) {\n            const e = this._createProxiedId(i, n, o[i.key] && o[i.key][t.id]);\n            r.push(e), this.proxyToSource[i.key][t.id] = [e];\n          }\n        }\n        let n = !1;\n        const a = new Set();\n        for (let e = 0; e < i.length; e++) {\n          const s = t.getTile(i[e]);\n          if (!s || !s.hasData()) continue;\n          const l = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);\n          if (l && l.tileID.canonical.z !== s.tileID.canonical.z) {\n            const e = this.proxyToSource[l.tileID.key][t.id],\n              i = this._createProxiedId(l.tileID, s, o[l.tileID.key] && o[l.tileID.key][t.id]);\n            e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t.id] = [i];\n            const c = this.proxyToSource[l.tileID.key][t.id];\n            a.has(c) || a.add(c), r.push(i), n = !0;\n          }\n        }\n        if (this._sourceTilesOverlap[t.id] = n, n && this._debugParams.sortTilesHiZFirst) for (const e of a) e.sort((e, t) => t.overscaledZ - e.overscaledZ);\n      }\n      _setupProxiedCoordsForImageSource(t, i, o) {\n        if (!t.getSource().loaded()) return;\n        const r = this.proxiedCoords[t.id] = [],\n          s = this.proxyCoords,\n          n = t.getSource(),\n          a = n.tileID;\n        if (!a) return;\n        const l = new e.P(a.x, a.y)._div(1 << a.z),\n          c = n.coordinates.map(e.L.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - l.x), e.min.y = Math.min(e.min.y, t.y - l.y), e.max.x = Math.max(e.max.x, t.x - l.x), e.max.y = Math.max(e.max.y, t.y - l.y), e), {\n            min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)\n          }),\n          h = (t, i) => {\n            const o = t.wrap + t.canonical.x / (1 << t.canonical.z),\n              r = t.canonical.y / (1 << t.canonical.z),\n              s = e.V / (1 << t.canonical.z),\n              n = i.wrap + i.canonical.x / (1 << i.canonical.z),\n              a = i.canonical.y / (1 << i.canonical.z);\n            return o + s < n + c.min.x || o > n + c.max.x || r + s < a + c.min.y || r > a + c.max.y;\n          };\n        for (let e = 0; e < s.length; e++) {\n          const n = s[e];\n          for (let e = 0; e < i.length; e++) {\n            const s = t.getTile(i[e]);\n            if (!s || !s.hasData()) continue;\n            if (h(n, s.tileID)) continue;\n            const a = this._createProxiedId(n, s, o[n.key] && o[n.key][t.id]),\n              l = this.proxyToSource[n.key][t.id];\n            l ? l.push(a) : this.proxyToSource[n.key][t.id] = [a], r.push(a);\n          }\n        }\n      }\n      _createProxiedId(t, i, o) {\n        let r = this.orthoMatrix;\n        if (o) {\n          const e = o.find(e => e.key === i.tileID.key);\n          if (e) return e;\n        }\n        if (i.tileID.key !== t.key) {\n          const o = t.canonical.z - i.tileID.canonical.z;\n          let s, n, a;\n          r = e.a6.create();\n          const l = i.tileID.wrap - t.wrap << t.overscaledZ;\n          o > 0 ? (s = e.V >> o, n = s * ((i.tileID.canonical.x << o) - t.canonical.x + l), a = s * ((i.tileID.canonical.y << o) - t.canonical.y)) : (s = e.V << -o, n = e.V * (i.tileID.canonical.x - (t.canonical.x + l << -o)), a = e.V * (i.tileID.canonical.y - (t.canonical.y << -o))), e.a6.ortho(r, 0, s, 0, s, 0, 1), e.a6.translate(r, r, [n, a, 0]);\n        }\n        return new mr(i.tileID, t.key, r);\n      }\n      _findTileCoveringTileID(t, i) {\n        let o = i.getTile(t);\n        if (o && o.hasData()) return o;\n        const r = this._findCoveringTileCache[i.id],\n          s = r[t.key];\n        if (o = s ? i.getTileByID(s) : null, o && o.hasData() || null === s) return o;\n        let n = o ? o.tileID : t,\n          a = n.overscaledZ;\n        const l = i.getSource().minzoom,\n          c = [];\n        if (!s) {\n          const r = i.getSource().maxzoom;\n          if (t.canonical.z >= r) {\n            const o = t.canonical.z - r;\n            i.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, i.transform.tileZoom), n = new e.am(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (a = r, n = new e.am(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o));\n          }\n          n.key !== t.key && (c.push(n.key), o = i.getTile(n));\n        }\n        const h = e => {\n          c.forEach(t => {\n            r[t] = e;\n          }), c.length = 0;\n        };\n        for (a -= 1; a >= l && (!o || !o.hasData()); a--) {\n          o && h(o.tileID.key);\n          const e = n.calculateScaledKey(a);\n          if (o = i.getTileByID(e), o && o.hasData()) break;\n          const t = r[e];\n          if (null === t) break;\n          void 0 === t ? c.push(e) : o = i.getTileByID(t);\n        }\n        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;\n      }\n      findDEMTileFor(e) {\n        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;\n      }\n      prepareDrawTile() {\n        this.renderedToTile = !0;\n      }\n      _clearRenderCacheForTile(e, t) {\n        let i = this._tilesDirty[e];\n        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;\n      }\n    }\n    function vr(t, i, o) {\n      const r = function (t, i, o) {\n          const r = e.N.dot(i, t),\n            s = e.N.dot(o, [.2126, .7152, .0722]),\n            n = (e, t, i) => (1 - i) * e + i * t,\n            a = n(1 - .3 * Math.min(s, 1), 1, Math.min(r + 1, 1));\n          return n(.92, 1, Math.asin(e.aa(i[2], -1, 1)) / Math.PI + .5) * a;\n        }(t, [0, 0, 1], i),\n        s = [0, 0, 0];\n      e.N.scale(s, o.slice(0, 3), r);\n      const n = [0, 0, 0];\n      e.N.scale(n, i.slice(0, 3), t[2]);\n      const a = [0, 0, 0];\n      return e.N.add(a, s, n), e.bU(a);\n    }\n    const xr = [\"fill\", \"fillOutline\", \"fillPattern\", \"line\", \"linePattern\", \"background\", \"backgroundPattern\", \"hillshade\", \"raster\"],\n      yr = [\"stars\", \"fillExtrusion\", \"fillExtrusionGroundEffect\", \"model\", \"symbolSDF\", \"symbolIcon\", \"symbolTextAndIcon\"];\n    class br {\n      static cacheKey(e, t, i, o) {\n        let r = `${t}${o ? o.cacheKey : \"\"}`;\n        for (const t of i) e.usedDefines.includes(t) && (r += `/${t}`);\n        return r;\n      }\n      constructor(t, i, o, r, s, n, a) {\n        const l = t.gl;\n        this.program = l.createProgram(), this.configuration = r, this.name = i, this.fixedDefines = [...n];\n        const c = r ? r.getBinderAttributes() : [],\n          h = (o.staticAttributes || []).concat(c);\n        let u = r ? r.defines() : [];\n        u = u.concat(n.map(e => `#define ${e}`));\n        const d = \"#version 300 es\\n\";\n        let _ = d + u.concat(\"precision mediump float;\", Xo, $o.fragmentSource).join(\"\\n\");\n        for (const e of o.fragmentIncludes) _ += `\\n${Wo[e]}`;\n        _ += `\\n${o.fragmentSource}`;\n        let p = d + u.concat(\"precision highp float;\", Xo, $o.vertexSource).join(\"\\n\");\n        for (const e of o.vertexIncludes) p += `\\n${Wo[e]}`;\n        p += `\\n${o.vertexSource}`;\n        const f = l.createShader(l.FRAGMENT_SHADER);\n        if (l.isContextLost()) return void (this.failedToCreate = !0);\n        l.shaderSource(f, _), l.compileShader(f), l.attachShader(this.program, f);\n        const m = l.createShader(l.VERTEX_SHADER);\n        if (l.isContextLost()) this.failedToCreate = !0;else {\n          l.shaderSource(m, p), l.compileShader(m), l.attachShader(this.program, m), this.attributes = {}, this.numAttributes = h.length;\n          for (let e = 0; e < this.numAttributes; e++) if (h[e]) {\n            const t = h[e].startsWith(\"a_\") ? h[e] : `a_${h[e]}`;\n            l.bindAttribLocation(this.program, e, t), this.attributes[t] = e;\n          }\n          a && a.shaderVaryings.length > 0 && l.transformFeedbackVaryings(this.program, a.shaderVaryings, a.bufferMode), l.linkProgram(this.program), l.deleteShader(m), l.deleteShader(f), this.fixedUniforms = s(t), this.binderUniforms = r ? r.getUniforms(t) : [], n.includes(\"TERRAIN\") && (this.terrainUniforms = (t => ({\n            u_dem: new e.bO(t),\n            u_dem_prev: new e.bO(t),\n            u_dem_tl: new e.bL(t),\n            u_dem_scale: new e.bN(t),\n            u_dem_tl_prev: new e.bL(t),\n            u_dem_scale_prev: new e.bN(t),\n            u_dem_size: new e.bN(t),\n            u_dem_lerp: new e.bN(t),\n            u_exaggeration: new e.bN(t),\n            u_depth: new e.bO(t),\n            u_depth_size_inv: new e.bL(t),\n            u_meter_to_dem: new e.bN(t),\n            u_label_plane_matrix_inv: new e.bK(t)\n          }))(t)), n.includes(\"GLOBE\") && (this.globeUniforms = (t => ({\n            u_tile_tl_up: new e.bM(t),\n            u_tile_tr_up: new e.bM(t),\n            u_tile_br_up: new e.bM(t),\n            u_tile_bl_up: new e.bM(t),\n            u_tile_up_scale: new e.bN(t)\n          }))(t)), n.includes(\"FOG\") && (this.fogUniforms = (t => ({\n            u_fog_matrix: new e.bK(t),\n            u_fog_range: new e.bL(t),\n            u_fog_color: new e.bP(t),\n            u_fog_horizon_blend: new e.bN(t),\n            u_fog_vertical_limit: new e.bL(t),\n            u_fog_temporal_offset: new e.bN(t),\n            u_frustum_tl: new e.bM(t),\n            u_frustum_tr: new e.bM(t),\n            u_frustum_br: new e.bM(t),\n            u_frustum_bl: new e.bM(t),\n            u_globe_pos: new e.bM(t),\n            u_globe_radius: new e.bN(t),\n            u_globe_transition: new e.bN(t),\n            u_is_globe: new e.bO(t),\n            u_viewport: new e.bL(t)\n          }))(t)), n.includes(\"RENDER_CUTOFF\") && (this.cutoffUniforms = (t => ({\n            u_cutoff_params: new e.bP(t)\n          }))(t)), n.includes(\"LIGHTING_3D_MODE\") && (this.lightsUniforms = (t => ({\n            u_lighting_ambient_color: new e.bM(t),\n            u_lighting_directional_dir: new e.bM(t),\n            u_lighting_directional_color: new e.bM(t),\n            u_ground_radiance: new e.bM(t)\n          }))(t)), n.includes(\"RENDER_SHADOWS\") && (this.shadowUniforms = (t => ({\n            u_light_matrix_0: new e.bK(t),\n            u_light_matrix_1: new e.bK(t),\n            u_fade_range: new e.bL(t),\n            u_shadow_normal_offset: new e.bM(t),\n            u_shadow_intensity: new e.bN(t),\n            u_shadow_texel_size: new e.bN(t),\n            u_shadow_map_resolution: new e.bN(t),\n            u_shadow_direction: new e.bM(t),\n            u_shadow_bias: new e.bM(t),\n            u_shadowmap_0: new e.bO(t),\n            u_shadowmap_1: new e.bO(t)\n          }))(t));\n        }\n      }\n      setTerrainUniformValues(e, t) {\n        if (!this.terrainUniforms) return;\n        const i = this.terrainUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setGlobeUniformValues(e, t) {\n        if (!this.globeUniforms) return;\n        const i = this.globeUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setFogUniformValues(e, t) {\n        if (!this.fogUniforms) return;\n        const i = this.fogUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setCutoffUniformValues(e, t) {\n        if (!this.cutoffUniforms) return;\n        const i = this.cutoffUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setLightsUniformValues(e, t) {\n        if (!this.lightsUniforms) return;\n        const i = this.lightsUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setShadowUniformValues(e, t) {\n        if (this.failedToCreate || !this.shadowUniforms) return;\n        const i = this.shadowUniforms;\n        e.program.set(this.program);\n        for (const e in t) i[e].set(this.program, e, t[e]);\n      }\n      _drawDebugWireframe(t, i, o, r, s, n, a, l, c, h) {\n        const u = t.options.wireframe;\n        if (!1 === u.terrain && !1 === u.layers2D && !1 === u.layers3D) return;\n        const d = t.context;\n        if (!(() => !(!u.terrain || \"terrainRaster\" !== this.name && \"globeRaster\" !== this.name) || !(!u.layers2D || t._terrain && t._terrain.renderingToTexture || !xr.includes(this.name)) || !(!u.layers3D || !yr.includes(this.name)))()) return;\n        const _ = d.gl,\n          p = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, s, d);\n        if (!p) return;\n        const f = [...this.fixedDefines];\n        f.push(\"DEBUG_WIREFRAME\");\n        const m = t.getOrCreateProgram(this.name, {\n          config: this.configuration,\n          defines: f\n        });\n        d.program.set(m.program);\n        const g = (e, t, i) => {\n          if (t[e] && i[e]) for (const o in t[e]) i[e][o] && i[e][o].set(i.program, o, t[e][o].current);\n        };\n        c && c.setUniforms(m.program, d, m.binderUniforms, a, {\n          zoom: l\n        }), g(\"fixedUniforms\", this, m), g(\"terrainUniforms\", this, m), g(\"globeUniforms\", this, m), g(\"fogUniforms\", this, m), g(\"lightsUniforms\", this, m), g(\"shadowUniforms\", this, m), p.bind(), d.setColorMode(new Mt([_.ONE, _.ONE_MINUS_SRC_ALPHA, _.ZERO, _.ONE], e.ax.transparent, [!0, !0, !0, !1])), d.setDepthMode(new Lt(i.func === _.LESS ? _.LEQUAL : i.func, Lt.ReadOnly, i.range)), d.setStencilMode(Rt.disabled);\n        const v = 3 * n.primitiveLength * 2,\n          x = 3 * n.primitiveOffset * 2 * 2;\n        h && h > 1 ? _.drawElementsInstanced(_.LINES, v, _.UNSIGNED_SHORT, x, h) : _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, x), s.bind(), d.program.set(this.program), d.setDepthMode(i), d.setStencilMode(o), d.setColorMode(r);\n      }\n      draw(e, t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m) {\n        const g = e.context,\n          v = g.gl;\n        if (this.failedToCreate) return;\n        g.program.set(this.program), g.setDepthMode(i), g.setStencilMode(o), g.setColorMode(r), g.setCullFace(s);\n        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(this.program, e, n[e]);\n        _ && _.setUniforms(this.program, g, this.binderUniforms, u, {\n          zoom: d\n        });\n        const x = {\n            [v.POINTS]: 1,\n            [v.LINES]: 2,\n            [v.TRIANGLES]: 3,\n            [v.LINE_STRIP]: 1\n          }[t],\n          y = m && m.length > 0;\n        if (y) {\n          for (const e of m) v.bindBufferBase(v.TRANSFORM_FEEDBACK_BUFFER, e.targetIndex, e.buffer.buffer);\n          v.beginTransformFeedback(t);\n        }\n        const b = f && f > 0 ? 1 : void 0;\n        for (const s of h.get()) {\n          const n = s.vaos || (s.vaos = {});\n          (n[a] || (n[a] = new Qo())).bind(g, this, l, _ ? _.getPaintVertexBuffers() : [], c, s.vertexOffset, p || [], b), f && f > 1 ? v.drawElementsInstanced(t, s.primitiveLength * x, v.UNSIGNED_SHORT, s.primitiveOffset * x * 2, f) : c ? v.drawElements(t, s.primitiveLength * x, v.UNSIGNED_SHORT, s.primitiveOffset * x * 2) : v.drawArrays(t, s.vertexOffset, s.vertexLength), t === v.TRIANGLES && c && this._drawDebugWireframe(e, i, o, r, c, s, u, d, _, f);\n        }\n        y && v.endTransformFeedback();\n      }\n    }\n    function wr(t, i) {\n      const o = Math.pow(2, i.tileID.overscaledZ),\n        r = i.tileSize * Math.pow(2, t.transform.tileZoom) / o,\n        s = r * (i.tileID.canonical.x + i.tileID.wrap * o),\n        n = r * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [0, 0],\n        u_tile_units_to_pixels: 1 / e.a3(i, 1, t.transform.tileZoom),\n        u_pixel_coord_upper: [s >> 16, n >> 16],\n        u_pixel_coord_lower: [65535 & s, 65535 & n]\n      };\n    }\n    const Tr = e.a6.create(),\n      Er = (t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m) => {\n        const g = i.style.light,\n          v = g.properties.get(\"position\"),\n          x = [v.x, v.y, v.z],\n          y = e.co.create();\n        \"viewport\" === g.properties.get(\"anchor\") && (e.co.fromRotation(y, -i.transform.angle), e.N.transformMat3(x, x, y));\n        const b = g.properties.get(\"color\"),\n          w = i.transform,\n          T = {\n            u_matrix: t,\n            u_lightpos: x,\n            u_lightintensity: g.properties.get(\"intensity\"),\n            u_lightcolor: [b.r, b.g, b.b],\n            u_vertical_gradient: +o,\n            u_opacity: r,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: Tr,\n            u_merc_center: [0, 0],\n            u_up_dir: [0, 0, 0],\n            u_height_lift: 0,\n            u_ao: s,\n            u_edge_radius: n,\n            u_flood_light_color: d,\n            u_vertical_scale: _,\n            u_flood_light_intensity: p,\n            u_ground_shadow_factor: f,\n            u_emissive_strength: m\n          };\n        return \"globe\" === w.projection.name && (T.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z], T.u_zoom_transition = c, T.u_inv_rot_matrix = u, T.u_merc_center = h, T.u_up_dir = w.projection.upVector(new e.bs(0, 0, 0), h[0] * e.V, h[1] * e.V), T.u_height_lift = l), T;\n      },\n      Sr = (e, t, i) => ({\n        u_matrix: e,\n        u_edge_radius: t,\n        u_vertical_scale: i\n      }),\n      Cr = (t, i, o, r, s, n, a, l, c, h, u, d, _, p) => {\n        const f = Er(t, i, o, r, s, n, a, c, h, u, d, _, p, 1, [0, 0, 0], 0),\n          m = {\n            u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8\n          };\n        return e.e(f, wr(i, l), m);\n      },\n      Ir = (e, t) => ({\n        u_matrix: e,\n        u_emissive_strength: t\n      }),\n      Dr = (t, i, o, r) => e.e(Ir(t, i), wr(o, r)),\n      Lr = (e, t, i) => ({\n        u_matrix: e,\n        u_world: i,\n        u_emissive_strength: t\n      }),\n      Ar = (t, i, o, r, s) => e.e(Dr(t, i, o, r), {\n        u_world: s\n      }),\n      Rr = (t, i, o, r) => {\n        const s = e.V / o.tileSize;\n        return {\n          u_matrix: t,\n          u_camera_to_center_distance: i.getCameraToCenterDistance(r),\n          u_extrude_scale: [i.pixelsToGLUnits[0] / s, i.pixelsToGLUnits[1] / s]\n        };\n      },\n      Pr = (e, t, i = 1) => ({\n        u_matrix: e,\n        u_color: t,\n        u_overlay: 0,\n        u_overlay_scale: i\n      }),\n      Mr = e.a6.create(),\n      zr = (t, i, o, r, s, n, a) => {\n        const l = t.transform,\n          c = \"globe\" === l.projection.name,\n          h = c ? e.cp(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.a3(o, 1, n),\n          u = {\n            u_matrix: i.projMatrix,\n            u_extrude_scale: h,\n            u_intensity: a,\n            u_inv_rot_matrix: Mr,\n            u_merc_center: [0, 0],\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_up_dir: [0, 0, 0]\n          };\n        if (c) {\n          u.u_inv_rot_matrix = r, u.u_merc_center = s, u.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], u.u_zoom_transition = e.S(l.zoom);\n          const t = s[0] * e.V,\n            o = s[1] * e.V;\n          u.u_up_dir = l.projection.upVector(new e.bs(0, 0, 0), t, o);\n        }\n        return u;\n      };\n    function Or(e, [t, i, o, r], [s, n]) {\n      if (s === n) return [0, 0, 0, 0];\n      const a = 255 * (e - 1) / (e * (n - s));\n      return [t * a, i * a, o * a, r * a];\n    }\n    function Fr(e, t, [i, o]) {\n      return i === o ? 0 : .5 / e + (t - i) * (e - 1) / (e * (o - i));\n    }\n    const Br = (t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g, v, x, y, b) => {\n      return {\n        u_matrix: t,\n        u_normalize_matrix: i,\n        u_globe_matrix: o,\n        u_merc_matrix: r,\n        u_grid_matrix: s,\n        u_tl_parent: n,\n        u_scale_parent: h,\n        u_fade_t: u.mix,\n        u_opacity: u.opacity * d.paint.get(\"raster-opacity\"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: d.paint.get(\"raster-brightness-min\"),\n        u_brightness_high: d.paint.get(\"raster-brightness-max\"),\n        u_saturation_factor: (T = d.paint.get(\"raster-saturation\"), T > 0 ? 1 - 1 / (1.001 - T) : -T),\n        u_contrast_factor: (w = d.paint.get(\"raster-contrast\"), w > 0 ? 1 / (1 - w) : 1 + w),\n        u_spin_weights: kr(d.paint.get(\"raster-hue-rotate\")),\n        u_perspective_transform: _,\n        u_raster_elevation: p,\n        u_zoom_transition: a,\n        u_merc_center: l,\n        u_cutoff_params: c,\n        u_colorization_mix: Or(e.cq, m, v),\n        u_colorization_offset: Fr(e.cq, g, v),\n        u_color_ramp: f,\n        u_texture_offset: [y / (x + 2 * y), x / (x + 2 * y)],\n        u_texture_res: [x + 2 * y, x + 2 * y],\n        u_emissive_strength: b\n      };\n      var w, T;\n    };\n    function kr(e) {\n      e *= Math.PI / 180;\n      const t = Math.sin(e),\n        i = Math.cos(e);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];\n    }\n    const Nr = (e, t, i, o, r, s, n, a, l, c, h, u) => ({\n        u_matrix: e,\n        u_normalize_matrix: t,\n        u_globe_matrix: i,\n        u_merc_matrix: o,\n        u_grid_matrix: r,\n        u_tl_parent: s,\n        u_scale_parent: c,\n        u_fade_t: h.mix,\n        u_opacity: h.opacity,\n        u_image0: 0,\n        u_image1: 1,\n        u_raster_elevation: u,\n        u_zoom_transition: n,\n        u_merc_center: a,\n        u_cutoff_params: l\n      }),\n      Ur = (e, t, i, o, r, s, n, a) => ({\n        u_tile_offset: e,\n        u_velocity: t,\n        u_color_ramp: o,\n        u_velocity_res: i,\n        u_max_speed: r,\n        u_texture_offset: s,\n        u_data_scale: n,\n        u_data_offset: a\n      }),\n      Gr = (e, t, i, o, r, s, n, a) => ({\n        u_velocity: e,\n        u_velocity_res: t,\n        u_max_speed: i,\n        u_speed_factor: o,\n        u_lifetime_delta: r,\n        u_rand_seed: Math.random(),\n        u_texture_offset: s,\n        u_data_scale: n,\n        u_data_offset: a\n      }),\n      jr = e.a6.create(),\n      Vr = (t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g, v) => {\n        const x = s.transform,\n          y = {\n            u_is_size_zoom_constant: +(\"constant\" === t || \"source\" === t),\n            u_is_size_feature_constant: +(\"constant\" === t || \"camera\" === t),\n            u_size_t: i ? i.uSizeT : 0,\n            u_size: i ? i.uSize : 0,\n            u_camera_to_center_distance: x.getCameraToCenterDistance(m),\n            u_rotate_symbol: +o,\n            u_aspect_ratio: x.width / x.height,\n            u_fade_change: s.options.fadeDuration ? s.symbolFadeChange : 1,\n            u_matrix: n,\n            u_label_plane_matrix: a,\n            u_coord_matrix: l,\n            u_is_text: +c,\n            u_pitch_with_map: +r,\n            u_texsize: h,\n            u_texture: 0,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: jr,\n            u_merc_center: [0, 0],\n            u_camera_forward: [0, 0, 0],\n            u_ecef_origin: [0, 0, 0],\n            u_tile_matrix: jr,\n            u_up_vector: [0, -1, 0],\n            u_icon_transition: v || 0,\n            u_icon_saturation: g\n          };\n        return \"globe\" === m.name && (y.u_tile_id = [u.canonical.x, u.canonical.y, 1 << u.canonical.z], y.u_zoom_transition = d, y.u_inv_rot_matrix = p, y.u_merc_center = _, y.u_camera_forward = x._camera.forward(), y.u_ecef_origin = e.cr(x.globeMatrix, u.toUnwrapped()), y.u_tile_matrix = Float32Array.from(x.globeMatrix), y.u_up_vector = f), y;\n      },\n      Zr = (t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g) => e.e(Vr(t, i, o, r, s, n, a, l, c, h, d, _, p, f, m, g, 1), {\n        u_gamma_scale: r ? s.transform.getCameraToCenterDistance(g) * Math.cos(s.terrain ? 0 : s.transform._pitch) : 1,\n        u_device_pixel_ratio: e.f.devicePixelRatio,\n        u_is_halo: +u,\n        undefined: void 0\n      }),\n      Hr = (t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m) => e.e(Zr(t, i, o, r, s, n, a, l, !0, c, !0, u, d, _, p, f, m), {\n        u_texsize_icon: h,\n        u_texture_icon: 1\n      }),\n      Wr = (e, t, i, o) => ({\n        u_matrix: e,\n        u_emissive_strength: t,\n        u_opacity: i,\n        u_color: o\n      }),\n      qr = (t, i, o, r, s, n, a) => e.e(function (t, i, o, r) {\n        const s = o.imageManager.getPattern(t.toString(), i),\n          {\n            width: n,\n            height: a\n          } = o.imageManager.getPixelSize(i),\n          l = Math.pow(2, r.tileID.overscaledZ),\n          c = r.tileSize * Math.pow(2, o.transform.tileZoom) / l,\n          h = c * (r.tileID.canonical.x + r.tileID.wrap * l),\n          u = c * r.tileID.canonical.y;\n        return {\n          u_image: 0,\n          u_pattern_tl: s.tl,\n          u_pattern_br: s.br,\n          u_texsize: [n, a],\n          u_pattern_size: s.displaySize,\n          u_tile_units_to_pixels: 1 / e.a3(r, 1, o.transform.tileZoom),\n          u_pixel_coord_upper: [h >> 16, u >> 16],\n          u_pixel_coord_lower: [65535 & h, 65535 & u]\n        };\n      }(s, n, r, a), {\n        u_matrix: t,\n        u_emissive_strength: i,\n        u_opacity: o\n      }),\n      $r = (t, i, o, r, s, n, a, l, c, h, u, d, _ = [0, 0, 0], p) => {\n        const f = r.style.light,\n          m = f.properties.get(\"position\"),\n          g = [-m.x, -m.y, m.z],\n          v = e.co.create();\n        \"viewport\" === f.properties.get(\"anchor\") && (e.co.fromRotation(v, -r.transform.angle), e.N.transformMat3(g, g, v));\n        const x = \"MASK\" === h.alphaMode,\n          y = f.properties.get(\"color\"),\n          b = d.paint.get(\"model-ambient-occlusion-intensity\"),\n          w = d.paint.get(\"model-color\").constantOr(e.ax.white),\n          T = d.paint.get(\"model-color-mix-intensity\").constantOr(0);\n        return {\n          u_matrix: t,\n          u_lighting_matrix: i,\n          u_normal_matrix: o,\n          u_lightpos: g,\n          u_lightintensity: f.properties.get(\"intensity\"),\n          u_lightcolor: [y.r, y.g, y.b],\n          u_camera_pos: _,\n          u_opacity: s,\n          u_baseTextureIsAlpha: 0,\n          u_alphaMask: +x,\n          u_alphaCutoff: h.alphaCutoff,\n          u_baseColorFactor: [n.r, n.g, n.b, n.a],\n          u_emissiveFactor: [a[0], a[1], a[2], 1],\n          u_metallicFactor: l,\n          u_roughnessFactor: c,\n          u_baseColorTexture: go.BaseColor,\n          u_metallicRoughnessTexture: go.MetallicRoughness,\n          u_normalTexture: go.Normal,\n          u_occlusionTexture: go.Occlusion,\n          u_emissionTexture: go.Emission,\n          u_color_mix: [w.r, w.g, w.b, T],\n          u_aoIntensity: b,\n          u_emissive_strength: u,\n          u_occlusionTextureTransform: p || [0, 0, 0, 0]\n        };\n      },\n      Xr = new Float32Array(16),\n      Kr = (e, t = Xr, i = Xr) => ({\n        u_matrix: e,\n        u_instance: t,\n        u_node_matrix: i\n      }),\n      Yr = {\n        fillExtrusion: t => ({\n          u_matrix: new e.bK(t),\n          u_lightpos: new e.bM(t),\n          u_lightintensity: new e.bN(t),\n          u_lightcolor: new e.bM(t),\n          u_vertical_gradient: new e.bN(t),\n          u_opacity: new e.bN(t),\n          u_edge_radius: new e.bN(t),\n          u_ao: new e.bL(t),\n          u_tile_id: new e.bM(t),\n          u_zoom_transition: new e.bN(t),\n          u_inv_rot_matrix: new e.bK(t),\n          u_merc_center: new e.bL(t),\n          u_up_dir: new e.bM(t),\n          u_height_lift: new e.bN(t),\n          u_flood_light_color: new e.bM(t),\n          u_vertical_scale: new e.bN(t),\n          u_flood_light_intensity: new e.bN(t),\n          u_ground_shadow_factor: new e.bM(t),\n          u_emissive_strength: new e.bN(t)\n        }),\n        fillExtrusionDepth: t => ({\n          u_matrix: new e.bK(t),\n          u_edge_radius: new e.bN(t),\n          u_vertical_scale: new e.bN(t)\n        }),\n        fillExtrusionPattern: t => ({\n          u_matrix: new e.bK(t),\n          u_lightpos: new e.bM(t),\n          u_lightintensity: new e.bN(t),\n          u_lightcolor: new e.bM(t),\n          u_vertical_gradient: new e.bN(t),\n          u_height_factor: new e.bN(t),\n          u_edge_radius: new e.bN(t),\n          u_ao: new e.bL(t),\n          u_tile_id: new e.bM(t),\n          u_zoom_transition: new e.bN(t),\n          u_inv_rot_matrix: new e.bK(t),\n          u_merc_center: new e.bL(t),\n          u_up_dir: new e.bM(t),\n          u_height_lift: new e.bN(t),\n          u_image: new e.bO(t),\n          u_texsize: new e.bL(t),\n          u_pixel_coord_upper: new e.bL(t),\n          u_pixel_coord_lower: new e.bL(t),\n          u_tile_units_to_pixels: new e.bN(t),\n          u_opacity: new e.bN(t)\n        }),\n        fillExtrusionGroundEffect: t => ({\n          u_matrix: new e.bK(t),\n          u_opacity: new e.bN(t),\n          u_ao_pass: new e.bN(t),\n          u_meter_to_tile: new e.bN(t),\n          u_ao: new e.bL(t),\n          u_flood_light_intensity: new e.bN(t),\n          u_flood_light_color: new e.bM(t),\n          u_attenuation: new e.bN(t),\n          u_edge_radius: new e.bN(t),\n          u_fb: new e.bO(t),\n          u_fb_size: new e.bN(t)\n        }),\n        fill: t => ({\n          u_matrix: new e.bK(t),\n          u_emissive_strength: new e.bN(t)\n        }),\n        fillPattern: t => ({\n          u_matrix: new e.bK(t),\n          u_emissive_strength: new e.bN(t),\n          u_image: new e.bO(t),\n          u_texsize: new e.bL(t),\n          u_pixel_coord_upper: new e.bL(t),\n          u_pixel_coord_lower: new e.bL(t),\n          u_tile_units_to_pixels: new e.bN(t)\n        }),\n        fillOutline: t => ({\n          u_matrix: new e.bK(t),\n          u_emissive_strength: new e.bN(t),\n          u_world: new e.bL(t)\n        }),\n        fillOutlinePattern: t => ({\n          u_matrix: new e.bK(t),\n          u_emissive_strength: new e.bN(t),\n          u_world: new e.bL(t),\n          u_image: new e.bO(t),\n          u_texsize: new e.bL(t),\n          u_pixel_coord_upper: new e.bL(t),\n          u_pixel_coord_lower: new e.bL(t),\n          u_tile_units_to_pixels: new e.bN(t)\n        }),\n        circle: e.cs,\n        collisionBox: t => ({\n          u_matrix: new e.bK(t),\n          u_camera_to_center_distance: new e.bN(t),\n          u_extrude_scale: new e.bL(t)\n        }),\n        collisionCircle: t => ({\n          u_matrix: new e.bK(t),\n          u_inv_matrix: new e.bK(t),\n          u_camera_to_center_distance: new e.bN(t),\n          u_viewport_size: new e.bL(t)\n        }),\n        debug: t => ({\n          u_color: new e.ca(t),\n          u_matrix: new e.bK(t),\n          u_overlay: new e.bO(t),\n          u_overlay_scale: new e.bN(t)\n        }),\n        clippingMask: t => ({\n          u_matrix: new e.bK(t)\n        }),\n        heatmap: t => ({\n          u_extrude_scale: new e.bN(t),\n          u_intensity: new e.bN(t),\n          u_matrix: new e.bK(t),\n          u_inv_rot_matrix: new e.bK(t),\n          u_merc_center: new e.bL(t),\n          u_tile_id: new e.bM(t),\n          u_zoom_transition: new e.bN(t),\n          u_up_dir: new e.bM(t)\n        }),\n        heatmapTexture: t => ({\n          u_image: new e.bO(t),\n          u_color_ramp: new e.bO(t),\n          u_opacity: new e.bN(t)\n        }),\n        hillshade: t => ({\n          u_matrix: new e.bK(t),\n          u_image: new e.bO(t),\n          u_latrange: new e.bL(t),\n          u_light: new e.bL(t),\n          u_shadow: new e.ca(t),\n          u_highlight: new e.ca(t),\n          u_emissive_strength: new e.bN(t),\n          u_accent: new e.ca(t)\n        }),\n        hillshadePrepare: t => ({\n          u_matrix: new e.bK(t),\n          u_image: new e.bO(t),\n          u_dimension: new e.bL(t),\n          u_zoom: new e.bN(t)\n        }),\n        line: e.ct,\n        linePattern: e.cu,\n        raster: t => ({\n          u_matrix: new e.bK(t),\n          u_normalize_matrix: new e.bK(t),\n          u_globe_matrix: new e.bK(t),\n          u_merc_matrix: new e.bK(t),\n          u_grid_matrix: new e.cb(t),\n          u_tl_parent: new e.bL(t),\n          u_scale_parent: new e.bN(t),\n          u_fade_t: new e.bN(t),\n          u_opacity: new e.bN(t),\n          u_image0: new e.bO(t),\n          u_image1: new e.bO(t),\n          u_brightness_low: new e.bN(t),\n          u_brightness_high: new e.bN(t),\n          u_saturation_factor: new e.bN(t),\n          u_contrast_factor: new e.bN(t),\n          u_spin_weights: new e.bM(t),\n          u_perspective_transform: new e.bL(t),\n          u_raster_elevation: new e.bN(t),\n          u_zoom_transition: new e.bN(t),\n          u_merc_center: new e.bL(t),\n          u_cutoff_params: new e.bP(t),\n          u_colorization_mix: new e.bP(t),\n          u_colorization_offset: new e.bN(t),\n          u_color_ramp: new e.bO(t),\n          u_texture_offset: new e.bL(t),\n          u_texture_res: new e.bL(t),\n          u_emissive_strength: new e.bN(t)\n        }),\n        rasterParticle: t => ({\n          u_matrix: new e.bK(t),\n          u_normalize_matrix: new e.bK(t),\n          u_globe_matrix: new e.bK(t),\n          u_merc_matrix: new e.bK(t),\n          u_grid_matrix: new e.cb(t),\n          u_tl_parent: new e.bL(t),\n          u_scale_parent: new e.bN(t),\n          u_fade_t: new e.bN(t),\n          u_opacity: new e.bN(t),\n          u_image0: new e.bO(t),\n          u_image1: new e.bO(t),\n          u_raster_elevation: new e.bN(t),\n          u_zoom_transition: new e.bN(t),\n          u_merc_center: new e.bL(t),\n          u_cutoff_params: new e.bP(t)\n        }),\n        rasterParticleTexture: t => ({\n          u_texture: new e.bO(t),\n          u_opacity: new e.bN(t)\n        }),\n        rasterParticleDraw: t => ({\n          u_tile_offset: new e.bL(t),\n          u_velocity: new e.bO(t),\n          u_color_ramp: new e.bO(t),\n          u_velocity_res: new e.bL(t),\n          u_max_speed: new e.bN(t),\n          u_texture_offset: new e.bL(t),\n          u_data_scale: new e.bP(t),\n          u_data_offset: new e.bN(t)\n        }),\n        rasterParticleUpdate: t => ({\n          u_velocity: new e.bO(t),\n          u_velocity_res: new e.bL(t),\n          u_max_speed: new e.bN(t),\n          u_speed_factor: new e.bN(t),\n          u_lifetime_delta: new e.bN(t),\n          u_rand_seed: new e.bN(t),\n          u_texture_offset: new e.bL(t),\n          u_data_scale: new e.bP(t),\n          u_data_offset: new e.bN(t)\n        }),\n        symbolIcon: t => ({\n          u_is_size_zoom_constant: new e.bO(t),\n          u_is_size_feature_constant: new e.bO(t),\n          u_size_t: new e.bN(t),\n          u_size: new e.bN(t),\n          u_camera_to_center_distance: new e.bN(t),\n          u_rotate_symbol: new e.bO(t),\n          u_aspect_ratio: new e.bN(t),\n          u_fade_change: new e.bN(t),\n          u_matrix: new e.bK(t),\n          u_label_plane_matrix: new e.bK(t),\n          u_coord_matrix: new e.bK(t),\n          u_is_text: new e.bO(t),\n          u_pitch_with_map: new e.bO(t),\n          u_texsize: new e.bL(t),\n          u_tile_id: new e.bM(t),\n          u_zoom_transition: new e.bN(t),\n          u_inv_rot_matrix: new e.bK(t),\n          u_merc_center: new e.bL(t),\n          u_camera_forward: new e.bM(t),\n          u_tile_matrix: new e.bK(t),\n          u_up_vector: new e.bM(t),\n          u_ecef_origin: new e.bM(t),\n          u_texture: new e.bO(t),\n          u_icon_transition: new e.bN(t),\n          u_icon_saturation: new e.bN(t)\n        }),\n        symbolSDF: t => ({\n          u_is_size_zoom_constant: new e.bO(t),\n          u_is_size_feature_constant: new e.bO(t),\n          u_size_t: new e.bN(t),\n          u_size: new e.bN(t),\n          u_camera_to_center_distance: new e.bN(t),\n          u_rotate_symbol: new e.bO(t),\n          u_aspect_ratio: new e.bN(t),\n          u_fade_change: new e.bN(t),\n          u_matrix: new e.bK(t),\n          u_label_plane_matrix: new e.bK(t),\n          u_coord_matrix: new e.bK(t),\n          u_is_text: new e.bO(t),\n          u_pitch_with_map: new e.bO(t),\n          u_texsize: new e.bL(t),\n          u_texture: new e.bO(t),\n          u_gamma_scale: new e.bN(t),\n          u_device_pixel_ratio: new e.bN(t),\n          u_tile_id: new e.bM(t),\n          u_zoom_transition: new e.bN(t),\n          u_inv_rot_matrix: new e.bK(t),\n          u_merc_center: new e.bL(t),\n          u_camera_forward: new e.bM(t),\n          u_tile_matrix: new e.bK(t),\n          u_up_vector: new e.bM(t),\n          u_ecef_origin: new e.bM(t),\n          u_is_halo: new e.bO(t)\n        }),\n        symbolTextAndIcon: t => ({\n          u_is_size_zoom_constant: new e.bO(t),\n          u_is_size_feature_constant: new e.bO(t),\n          u_size_t: new e.bN(t),\n          u_size: new e.bN(t),\n          u_camera_to_center_distance: new e.bN(t),\n          u_rotate_symbol: new e.bO(t),\n          u_aspect_ratio: new e.bN(t),\n          u_fade_change: new e.bN(t),\n          u_matrix: new e.bK(t),\n          u_label_plane_matrix: new e.bK(t),\n          u_coord_matrix: new e.bK(t),\n          u_is_text: new e.bO(t),\n          u_pitch_with_map: new e.bO(t),\n          u_texsize: new e.bL(t),\n          u_texsize_icon: new e.bL(t),\n          u_texture: new e.bO(t),\n          u_texture_icon: new e.bO(t),\n          u_gamma_scale: new e.bN(t),\n          u_device_pixel_ratio: new e.bN(t),\n          u_is_halo: new e.bO(t)\n        }),\n        background: t => ({\n          u_matrix: new e.bK(t),\n          u_emissive_strength: new e.bN(t),\n          u_opacity: new e.bN(t),\n          u_color: new e.ca(t)\n        }),\n        backgroundPattern: t => ({\n          u_matrix: new e.bK(t),\n          u_emissive_strength: new e.bN(t),\n          u_opacity: new e.bN(t),\n          u_image: new e.bO(t),\n          u_pattern_tl: new e.bL(t),\n          u_pattern_br: new e.bL(t),\n          u_texsize: new e.bL(t),\n          u_pattern_size: new e.bL(t),\n          u_pixel_coord_upper: new e.bL(t),\n          u_pixel_coord_lower: new e.bL(t),\n          u_tile_units_to_pixels: new e.bN(t)\n        }),\n        terrainRaster: rr,\n        terrainDepth: rr,\n        skybox: t => ({\n          u_matrix: new e.bK(t),\n          u_sun_direction: new e.bM(t),\n          u_cubemap: new e.bO(t),\n          u_opacity: new e.bN(t),\n          u_temporal_offset: new e.bN(t)\n        }),\n        skyboxGradient: t => ({\n          u_matrix: new e.bK(t),\n          u_color_ramp: new e.bO(t),\n          u_center_direction: new e.bM(t),\n          u_radius: new e.bN(t),\n          u_opacity: new e.bN(t),\n          u_temporal_offset: new e.bN(t)\n        }),\n        skyboxCapture: t => ({\n          u_matrix_3f: new e.cb(t),\n          u_sun_direction: new e.bM(t),\n          u_sun_intensity: new e.bN(t),\n          u_color_tint_r: new e.bP(t),\n          u_color_tint_m: new e.bP(t),\n          u_luminance: new e.bN(t)\n        }),\n        globeRaster: t => ({\n          u_proj_matrix: new e.bK(t),\n          u_globe_matrix: new e.bK(t),\n          u_normalize_matrix: new e.bK(t),\n          u_merc_matrix: new e.bK(t),\n          u_zoom_transition: new e.bN(t),\n          u_merc_center: new e.bL(t),\n          u_image0: new e.bO(t),\n          u_grid_matrix: new e.cb(t),\n          u_skirt_height: new e.bN(t),\n          u_far_z_cutoff: new e.bN(t),\n          u_frustum_tl: new e.bM(t),\n          u_frustum_tr: new e.bM(t),\n          u_frustum_br: new e.bM(t),\n          u_frustum_bl: new e.bM(t),\n          u_globe_pos: new e.bM(t),\n          u_globe_radius: new e.bN(t),\n          u_viewport: new e.bL(t)\n        }),\n        globeAtmosphere: t => ({\n          u_frustum_tl: new e.bM(t),\n          u_frustum_tr: new e.bM(t),\n          u_frustum_br: new e.bM(t),\n          u_frustum_bl: new e.bM(t),\n          u_horizon: new e.bN(t),\n          u_transition: new e.bN(t),\n          u_fadeout_range: new e.bN(t),\n          u_color: new e.bP(t),\n          u_high_color: new e.bP(t),\n          u_space_color: new e.bP(t),\n          u_temporal_offset: new e.bN(t),\n          u_horizon_angle: new e.bN(t)\n        }),\n        model: t => ({\n          u_matrix: new e.bK(t),\n          u_lighting_matrix: new e.bK(t),\n          u_normal_matrix: new e.bK(t),\n          u_lightpos: new e.bM(t),\n          u_lightintensity: new e.bN(t),\n          u_lightcolor: new e.bM(t),\n          u_camera_pos: new e.bM(t),\n          u_opacity: new e.bN(t),\n          u_baseColorFactor: new e.bP(t),\n          u_emissiveFactor: new e.bP(t),\n          u_metallicFactor: new e.bN(t),\n          u_roughnessFactor: new e.bN(t),\n          u_baseTextureIsAlpha: new e.bO(t),\n          u_alphaMask: new e.bO(t),\n          u_alphaCutoff: new e.bN(t),\n          u_baseColorTexture: new e.bO(t),\n          u_metallicRoughnessTexture: new e.bO(t),\n          u_normalTexture: new e.bO(t),\n          u_occlusionTexture: new e.bO(t),\n          u_emissionTexture: new e.bO(t),\n          u_color_mix: new e.bP(t),\n          u_aoIntensity: new e.bN(t),\n          u_emissive_strength: new e.bN(t),\n          u_occlusionTextureTransform: new e.bP(t)\n        }),\n        modelDepth: t => ({\n          u_matrix: new e.bK(t),\n          u_instance: new e.bK(t),\n          u_node_matrix: new e.bK(t)\n        }),\n        groundShadow: t => ({\n          u_matrix: new e.bK(t),\n          u_ground_shadow_factor: new e.bM(t)\n        }),\n        stars: t => ({\n          u_matrix: new e.bK(t),\n          u_up: new e.bM(t),\n          u_right: new e.bM(t),\n          u_intensity_multiplier: new e.bN(t)\n        })\n      };\n    let Jr;\n    function Qr(t, i, o, r, s, n, a) {\n      const l = t.context,\n        c = l.gl,\n        h = t.transform,\n        u = t.getOrCreateProgram(\"collisionBox\"),\n        d = [];\n      let _ = 0,\n        p = 0;\n      for (let l = 0; l < r.length; l++) {\n        const f = r[l],\n          m = i.getTile(f),\n          g = m.getBucket(o);\n        if (!g) continue;\n        const v = Mi(f, g, h);\n        let x = v;\n        0 === s[0] && 0 === s[1] || (x = t.translatePosMatrix(v, m, s, n));\n        const y = a ? g.textCollisionBox : g.iconCollisionBox,\n          b = g.collisionCircleArray;\n        if (b.length > 0) {\n          const t = e.a6.create(),\n            i = x;\n          e.a6.mul(t, g.placementInvProjMatrix, h.glCoordMatrix), e.a6.mul(t, t, g.placementViewportMatrix), d.push({\n            circleArray: b,\n            circleOffset: p,\n            transform: i,\n            invTransform: t,\n            projection: g.getProjection()\n          }), _ += b.length / 4, p = _;\n        }\n        y && (t.terrain && t.terrain.setupElevationDraw(m, u), u.draw(t, c.LINES, Lt.disabled, Rt.disabled, t.colorModeForRenderPass(), Ft.disabled, Rr(x, h, m, g.getProjection()), o.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, null, h.zoom, null, [y.collisionVertexBuffer, y.collisionVertexBufferExt]));\n      }\n      if (!a || !d.length) return;\n      const f = t.getOrCreateProgram(\"collisionCircle\"),\n        m = new e.cv();\n      m.resize(4 * _), m._trim();\n      let g = 0;\n      for (const e of d) for (let t = 0; t < e.circleArray.length / 4; t++) {\n        const i = 4 * t,\n          o = e.circleArray[i + 0],\n          r = e.circleArray[i + 1],\n          s = e.circleArray[i + 2],\n          n = e.circleArray[i + 3];\n        m.emplace(g++, o, r, s, n, 0), m.emplace(g++, o, r, s, n, 1), m.emplace(g++, o, r, s, n, 2), m.emplace(g++, o, r, s, n, 3);\n      }\n      (!Jr || Jr.length < 2 * _) && (Jr = function (t) {\n        const i = 2 * t,\n          o = new e.aw();\n        o.resize(i), o._trim();\n        for (let e = 0; e < i; e++) {\n          const t = 6 * e;\n          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;\n        }\n        return o;\n      }(_));\n      const v = l.createIndexBuffer(Jr, !0),\n        x = l.createVertexBuffer(m, e.cw.members, !0);\n      for (const i of d) {\n        const r = {\n          u_matrix: i.transform,\n          u_inv_matrix: i.invTransform,\n          u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection),\n          u_viewport_size: [y.width, y.height]\n        };\n        f.draw(t, c.TRIANGLES, Lt.disabled, Rt.disabled, t.colorModeForRenderPass(), Ft.disabled, r, o.id, x, v, e.aB.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);\n      }\n      var y;\n      x.destroy(), v.destroy();\n    }\n    const es = e.a6.create();\n    function ts(t) {\n      const i = t._camera.getWorldToCamera(t.worldSize, 1),\n        o = e.a6.multiply([], i, t.globeMatrix);\n      e.a6.invert(o, o);\n      const r = [0, 0, 0],\n        s = [0, 1, 0, 0];\n      return e.a7.transformMat4(s, s, o), r[0] = s[0], r[1] = s[1], r[2] = s[2], e.N.normalize(r, r), r;\n    }\n    function is({\n      width: t,\n      height: i,\n      anchor: o,\n      textOffset: r,\n      textScale: s\n    }, n) {\n      const {\n          horizontalAlign: a,\n          verticalAlign: l\n        } = e.bf(o),\n        c = -(a - .5) * t,\n        h = -(l - .5) * i,\n        u = e.bd(o, r);\n      return new e.P((c / s + u[0]) * n, (h / s + u[1]) * n);\n    }\n    function os(t, i, o, r, s, n, a, l, c, h, u) {\n      const d = t.text.placedSymbolArray,\n        _ = t.text.dynamicLayoutVertexArray,\n        p = t.icon.dynamicLayoutVertexArray,\n        f = {},\n        m = t.getProjection(),\n        g = zi(l, m, n),\n        v = n.elevation,\n        x = m.upVectorScale(l.canonical, n.center.lat, n.worldSize).metersToTile;\n      _.clear();\n      for (let p = 0; p < d.length; p++) {\n        const y = d.get(p),\n          {\n            tileAnchorX: b,\n            tileAnchorY: w,\n            numGlyphs: T\n          } = y,\n          E = y.hidden || !y.crossTileID || t.allowVerticalPlacement && !y.placedOrientation ? null : r[y.crossTileID];\n        if (E) {\n          let r = 0,\n            d = 0,\n            p = 0;\n          if (v) {\n            const e = v ? v.getAtTileOffset(l, b, w) : 0,\n              [t, i, o] = m.upVector(l.canonical, b, w);\n            r = e * t * x, d = e * i * x, p = e * o * x;\n          }\n          let [S, C, I, D] = vi(y.projectedAnchorX + r, y.projectedAnchorY + d, y.projectedAnchorZ + p, o ? g : a);\n          const L = xi(n.getCameraToCenterDistance(m), D);\n          let A = s.evaluateSizeForFeature(t.textSizeData, h, y) * L / e.bc;\n          o && (A *= t.tilePixelRatio / c);\n          const R = is(E, A);\n          o ? (({\n            x: S,\n            y: C,\n            z: I\n          } = m.projectTilePoint(b + R.x, w + R.y, l.canonical)), [S, C, I] = vi(S + r, C + d, I + p, a)) : (i && R._rotate(-n.angle), S += R.x, C += R.y, I = 0);\n          const P = t.allowVerticalPlacement && y.placedOrientation === e.b6.vertical ? Math.PI / 2 : 0;\n          for (let t = 0; t < T; t++) e.b9(_, S, C, I, P);\n          u && y.associatedIconIndex >= 0 && (f[y.associatedIconIndex] = {\n            x: S,\n            y: C,\n            z: I,\n            angle: P\n          });\n        } else Di(T, _);\n      }\n      if (u) {\n        p.clear();\n        const i = t.icon.placedSymbolArray;\n        for (let t = 0; t < i.length; t++) {\n          const o = i.get(t),\n            {\n              numGlyphs: r\n            } = o,\n            s = f[t];\n          if (o.hidden || !s) Di(r, p);else {\n            const {\n              x: t,\n              y: i,\n              z: o,\n              angle: n\n            } = s;\n            for (let s = 0; s < r; s++) e.b9(p, t, i, o, n);\n          }\n        }\n        t.icon.dynamicLayoutVertexBuffer.updateData(p);\n      }\n      t.text.dynamicLayoutVertexBuffer.updateData(_);\n    }\n    function rs(t, i, o, r, s, n, a = {}) {\n      const l = o.paint.get(\"icon-translate\"),\n        c = o.paint.get(\"text-translate\"),\n        h = o.paint.get(\"icon-translate-anchor\"),\n        u = o.paint.get(\"text-translate-anchor\"),\n        d = o.layout.get(\"icon-rotation-alignment\"),\n        _ = o.layout.get(\"text-rotation-alignment\"),\n        p = o.layout.get(\"icon-pitch-alignment\"),\n        f = o.layout.get(\"text-pitch-alignment\"),\n        m = o.layout.get(\"icon-keep-upright\"),\n        g = o.layout.get(\"text-keep-upright\"),\n        v = o.paint.get(\"icon-color-saturation\"),\n        x = t.context,\n        y = x.gl,\n        b = t.transform,\n        w = \"map\" === d,\n        T = \"map\" === _,\n        E = \"map\" === p,\n        S = \"map\" === f,\n        C = void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1);\n      let I = !1;\n      const D = t.depthModeForSublayer(0, Lt.ReadOnly),\n        L = [e.a5(b.center.lng), e.ae(b.center.lat)],\n        A = o.layout.get(\"text-variable-anchor\"),\n        R = \"globe\" === b.projection.name,\n        P = [],\n        M = [0, -1, 0];\n      for (const s of r) {\n        const r = i.getTile(s),\n          n = r.getBucket(o);\n        if (!n) continue;\n        if (\"mercator\" === n.projection.name && R) continue;\n        if (n.fullyClipped) continue;\n        const d = \"globe\" === n.projection.name,\n          _ = d ? e.S(b.zoom) : 0,\n          p = zi(s, n.getProjection(), b),\n          f = b.calculatePixelsToTileUnitsMatrix(r),\n          x = A && n.hasTextData(),\n          D = n.hasIconTextFit() && x && n.hasIconData(),\n          z = n.getProjection().createInversionMatrix(b, s.canonical),\n          O = () => {\n            const i = w && \"point\" !== o.layout.get(\"symbol-placement\"),\n              a = [],\n              c = i || D,\n              u = o.paint.get(\"icon-image-cross-fade\").constantOr(0);\n            t.terrainRenderModeElevated() && E && a.push(\"PITCH_WITH_MAP_TERRAIN\"), d && (a.push(\"PROJECTION_GLOBE_VIEW\"), c && a.push(\"PROJECTED_POS_ON_VIEWPORT\")), u > 0 && a.push(\"ICON_TRANSITION\"), n.icon.zOffsetVertexBuffer && a.push(\"Z_OFFSET\"), v < 1 && a.push(\"SATURATION\");\n            const g = n.icon.programConfigurations.get(o.id),\n              x = t.getOrCreateProgram(n.sdfIcons ? \"symbolSDF\" : \"symbolIcon\", {\n                config: g,\n                defines: a\n              });\n            let T;\n            const S = r.imageAtlasTexture ? r.imageAtlasTexture.size : [0, 0],\n              C = n.iconSizeData,\n              I = e.b5(C, b.zoom),\n              A = E || 0 !== b.pitch,\n              P = fi(p, r.tileID.canonical, E, w, b, n.getProjection(), f),\n              O = gi(p, r.tileID.canonical, E, w, b, n.getProjection(), f),\n              F = t.translatePosMatrix(O, r, l, h, !0),\n              B = t.translatePosMatrix(p, r, l, h),\n              k = c ? es : P,\n              N = w && !E && !i;\n            let U = M;\n            !R && !b.mercatorFromTransition || w || (U = ts(b));\n            const G = d ? U : M;\n            T = n.sdfIcons && !n.iconsInText ? Zr(C.kind, I, N, E, t, B, k, F, !1, S, !0, s, _, L, z, G, n.getProjection()) : Vr(C.kind, I, N, E, t, B, k, F, !1, S, s, _, L, z, G, n.getProjection(), v, u);\n            const j = r.imageAtlasTexture ? r.imageAtlasTexture : null,\n              V = 1 !== o.layout.get(\"icon-size\").constantOr(0) || n.iconsNeedLinear,\n              Z = n.sdfIcons || t.options.rotating || t.options.zooming || V || A ? y.LINEAR : y.NEAREST,\n              H = n.sdfIcons && 0 !== o.paint.get(\"icon-halo-width\").constantOr(1),\n              W = t.terrain && E && i ? e.a6.invert(e.a6.create(), P) : es;\n            if (i && n.icon) {\n              const e = b.elevation,\n                i = e ? e.getAtTileOffsetFunc(s, b.center.lat, b.worldSize, n.getProjection()) : null,\n                o = mi(p, r.tileID.canonical, E, w, b, n.getProjection(), f);\n              bi(n, p, t, !1, o, O, E, m, i, s);\n            }\n            return {\n              program: x,\n              buffers: n.icon,\n              uniformValues: T,\n              atlasTexture: j,\n              atlasTextureIcon: null,\n              atlasInterpolation: Z,\n              atlasInterpolationIcon: null,\n              isSDF: n.sdfIcons,\n              hasHalo: H,\n              tile: r,\n              labelPlaneMatrixInv: W\n            };\n          },\n          F = () => {\n            const i = T && \"point\" !== o.layout.get(\"symbol-placement\"),\n              a = [],\n              l = i || A || D;\n            t.terrainRenderModeElevated() && S && a.push(\"PITCH_WITH_MAP_TERRAIN\"), d && (a.push(\"PROJECTION_GLOBE_VIEW\"), l && a.push(\"PROJECTED_POS_ON_VIEWPORT\")), n.text.zOffsetVertexBuffer && a.push(\"Z_OFFSET\");\n            const h = n.text.programConfigurations.get(o.id),\n              m = t.getOrCreateProgram(n.iconsInText ? \"symbolTextAndIcon\" : \"symbolSDF\", {\n                config: h,\n                defines: a\n              });\n            let v,\n              x = [0, 0],\n              w = null;\n            const E = n.textSizeData;\n            n.iconsInText && (x = r.imageAtlasTexture ? r.imageAtlasTexture.size : [0, 0], w = r.imageAtlasTexture ? r.imageAtlasTexture : null, v = S || 0 !== b.pitch || t.options.rotating || t.options.zooming || \"composite\" === E.kind || \"camera\" === E.kind ? y.LINEAR : y.NEAREST);\n            const C = r.glyphAtlasTexture ? r.glyphAtlasTexture.size : [0, 0],\n              I = e.b5(E, b.zoom),\n              P = fi(p, r.tileID.canonical, S, T, b, n.getProjection(), f),\n              O = gi(p, r.tileID.canonical, S, T, b, n.getProjection(), f),\n              F = t.translatePosMatrix(O, r, c, u, !0),\n              B = t.translatePosMatrix(p, r, c, u),\n              k = l ? es : P,\n              N = T && !S && !i;\n            let U = M;\n            !R && !b.mercatorFromTransition || T || (U = ts(b));\n            const G = d ? U : M;\n            let j;\n            j = n.iconsInText ? Hr(E.kind, I, N, S, t, B, k, F, C, x, s, _, L, z, G, n.getProjection()) : Zr(E.kind, I, N, S, t, B, k, F, !0, C, !0, s, _, L, z, G, n.getProjection());\n            const V = r.glyphAtlasTexture ? r.glyphAtlasTexture : null,\n              Z = y.LINEAR,\n              H = 0 !== o.paint.get(\"text-halo-width\").constantOr(1),\n              W = t.terrain && S && i ? e.a6.invert(e.a6.create(), P) : es;\n            if (i && n.text) {\n              const e = b.elevation,\n                i = e ? e.getAtTileOffsetFunc(s, b.center.lat, b.worldSize, n.getProjection()) : null,\n                o = mi(p, r.tileID.canonical, S, T, b, n.getProjection(), f);\n              bi(n, p, t, !0, o, O, S, g, i, s);\n            }\n            return {\n              program: m,\n              buffers: n.text,\n              uniformValues: j,\n              atlasTexture: V,\n              atlasTextureIcon: w,\n              atlasInterpolation: Z,\n              atlasInterpolationIcon: v,\n              isSDF: !0,\n              hasHalo: H,\n              tile: r,\n              labelPlaneMatrixInv: W\n            };\n          },\n          B = n.icon.segments.get().length,\n          k = n.text.segments.get().length,\n          N = B && !a.onlyText ? O() : null,\n          U = k && !a.onlyIcons ? F() : null,\n          G = o.paint.get(\"icon-opacity\").constantOr(1),\n          j = o.paint.get(\"text-opacity\").constantOr(1);\n        if (C && n.canOverlap) {\n          I = !0;\n          const t = G && !a.onlyText ? n.icon.segments.get() : [],\n            i = j && !a.onlyIcons ? n.text.segments.get() : [];\n          for (const i of t) P.push({\n            segments: new e.aB([i]),\n            sortKey: i.sortKey,\n            state: N\n          });\n          for (const t of i) P.push({\n            segments: new e.aB([t]),\n            sortKey: t.sortKey,\n            state: U\n          });\n        } else a.onlyText || P.push({\n          segments: G ? n.icon.segments : new e.aB([]),\n          sortKey: 0,\n          state: N\n        }), a.onlyIcons || P.push({\n          segments: j ? n.text.segments : new e.aB([]),\n          sortKey: 0,\n          state: U\n        });\n      }\n      I && P.sort((e, t) => e.sortKey - t.sortKey);\n      for (const e of P) {\n        const i = e.state;\n        if (i) if (t.terrain && t.terrain.setupElevationDraw(i.tile, i.program, {\n          useDepthForOcclusion: b.depthOcclusionForSymbolsAndCircles,\n          labelPlaneMatrixInv: i.labelPlaneMatrixInv\n        }), x.activeTexture.set(y.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, y.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (x.activeTexture.set(y.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, y.CLAMP_TO_EDGE, !0)), t.uploadCommonLightUniforms(t.context, i.program), i.hasHalo) {\n          const r = i.uniformValues;\n          r.u_is_halo = 1, ss(i.buffers, e.segments, o, t, i.program, D, s, n, r, 2), r.u_is_halo = 0;\n        } else {\n          if (i.isSDF) {\n            const r = i.uniformValues;\n            i.hasHalo && (r.u_is_halo = 1, ss(i.buffers, e.segments, o, t, i.program, D, s, n, r, 1)), r.u_is_halo = 0;\n          }\n          ss(i.buffers, e.segments, o, t, i.program, D, s, n, i.uniformValues, 1);\n        }\n      }\n    }\n    function ss(e, t, i, o, r, s, n, a, l, c) {\n      const h = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.iconTransitioningVertexBuffer, e.globeExtVertexBuffer, e.zOffsetVertexBuffer];\n      r.draw(o, o.context.gl.TRIANGLES, s, n, a, Ft.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t, i.paint, o.transform.zoom, e.programConfigurations.get(i.id), h, c);\n    }\n    function ns(e, t, i, o, r, s, n) {\n      const a = e.context.gl,\n        l = i.paint.get(\"fill-pattern\"),\n        c = l && l.constantOr(1);\n      let h, u, d, _, p;\n      n ? (u = c && !i.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\", h = a.LINES) : (u = c ? \"fillPattern\" : \"fill\", h = a.TRIANGLES);\n      for (const f of o) {\n        const o = t.getTile(f);\n        if (c && !o.patternsLoaded()) continue;\n        const m = o.getBucket(i);\n        if (!m) continue;\n        e.prepareDrawTile();\n        const g = m.programConfigurations.get(i.id),\n          v = e.isTileAffectedByFog(f),\n          x = e.getOrCreateProgram(u, {\n            config: g,\n            overrideFog: v\n          });\n        c && (e.context.activeTexture.set(a.TEXTURE0), o.imageAtlasTexture && o.imageAtlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), g.updatePaintBuffers());\n        const y = l.constantOr(null);\n        if (y && o.imageAtlas) {\n          const e = o.imageAtlas.patternPositions[y.toString()];\n          e && g.setConstantPatternPositions(e);\n        }\n        const b = e.translatePosMatrix(f.projMatrix, o, i.paint.get(\"fill-translate\"), i.paint.get(\"fill-translate-anchor\")),\n          w = i.paint.get(\"fill-emissive-strength\");\n        if (n) {\n          _ = m.indexBuffer2, p = m.segments2;\n          const t = e.terrain && e.terrain.renderingToTexture ? e.terrain.drapeBufferSize : [a.drawingBufferWidth, a.drawingBufferHeight];\n          d = \"fillOutlinePattern\" === u && c ? Ar(b, w, e, o, t) : Lr(b, w, t);\n        } else _ = m.indexBuffer, p = m.segments, d = c ? Dr(b, w, e, o) : Ir(b, w);\n        e.uploadCommonUniforms(e.context, x, f.toUnwrapped()), x.draw(e, h, r, e.stencilModeForClipping(f), s, Ft.disabled, d, i.id, m.layoutVertexBuffer, _, p, i.paint, e.transform.zoom, g, void 0);\n      }\n    }\n    function as(t, i, o, r, s, n, a, l) {\n      o.resetLayerRenderingStats(t);\n      const c = t.context,\n        h = c.gl,\n        u = t.transform,\n        d = o.paint.get(\"fill-extrusion-pattern\"),\n        _ = d.constantOr(1),\n        p = o.paint.get(\"fill-extrusion-opacity\"),\n        f = t.style.enable3dLights(),\n        m = o.paint.get(f && !_ ? \"fill-extrusion-ambient-occlusion-wall-radius\" : \"fill-extrusion-ambient-occlusion-radius\"),\n        g = [o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"), m],\n        v = o.layout.get(\"fill-extrusion-edge-radius\"),\n        x = v > 0 && !o.paint.get(\"fill-extrusion-rounded-roof\"),\n        y = x ? 0 : v,\n        b = \"globe\" === u.projection.name ? e.cF() : 0,\n        w = \"globe\" === u.projection.name,\n        T = w ? e.S(u.zoom) : 0,\n        E = [e.a5(u.center.lng), e.ae(u.center.lat)],\n        S = o.paint.get(\"fill-extrusion-flood-light-color\").toArray01().slice(0, 3),\n        C = o.paint.get(\"fill-extrusion-flood-light-intensity\"),\n        I = o.paint.get(\"fill-extrusion-vertical-scale\"),\n        D = vo(t, o.paint.get(\"fill-extrusion-cutoff-fade-range\")),\n        L = o.paint.get(\"fill-extrusion-emissive-strength\"),\n        A = [];\n      let R;\n      w && A.push(\"PROJECTION_GLOBE_VIEW\"), g[0] > 0 && A.push(\"FAUX_AO\"), x && A.push(\"ZERO_ROOF_RADIUS\"), l && A.push(\"HAS_CENTROID\"), C > 0 && A.push(\"FLOOD_LIGHT\"), D.shouldRenderCutoff && A.push(\"RENDER_CUTOFF\");\n      const P = \"shadow\" === t.renderPass,\n        M = t.shadowRenderer,\n        z = P && !!M;\n      t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !0);\n      let O = [0, 0, 0];\n      if (M) {\n        const e = t.style.directionalLight,\n          i = t.style.ambientLight;\n        e && i && (O = So(e, i)), R = A.concat([\"SHADOWS_SINGLE_CASCADE\"]);\n      }\n      const F = z ? \"fillExtrusionDepth\" : _ ? \"fillExtrusionPattern\" : \"fillExtrusion\",\n        B = o.getLayerRenderingStats();\n      for (const e of r) {\n        const r = i.getTile(e),\n          f = r.getBucket(o);\n        if (!f || f.projection.name !== u.projection.name) continue;\n        let m = !1;\n        M && (m = 0 === M.getMaxCascadeForTile(e.toUnwrapped()));\n        const v = t.isTileAffectedByFog(e),\n          x = f.programConfigurations.get(o.id),\n          z = t.getOrCreateProgram(F, {\n            config: x,\n            defines: m ? R : A,\n            overrideFog: v\n          });\n        if (t.terrain && t.terrain.setupElevationDraw(r, z, {\n          useMeterToDem: !0\n        }), !f.centroidVertexBuffer) {\n          const e = z.attributes.a_centroid_pos;\n          void 0 !== e && h.vertexAttrib2f(e, 0, 0);\n        }\n        !P && M && M.setupShadows(r.tileID.toUnwrapped(), z, \"vector-tile\", r.tileID.overscaledZ), _ && (t.context.activeTexture.set(h.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), x.updatePaintBuffers());\n        const k = d.constantOr(null);\n        if (k && r.imageAtlas) {\n          const e = r.imageAtlas.patternPositions[k.toString()];\n          e && x.setConstantPatternPositions(e);\n        }\n        const N = o.paint.get(\"fill-extrusion-vertical-gradient\");\n        let U;\n        if (P && M) {\n          if (_s(r.tileID, f, t)) continue;\n          const e = M.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());\n          U = Sr(e, y, I);\n        } else {\n          const i = t.translatePosMatrix(e.expandedProjMatrix, r, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n            s = u.projection.createInversionMatrix(u, e.canonical);\n          U = _ ? Cr(i, t, N, p, g, y, e, r, b, T, E, s, S, I) : Er(i, t, N, p, g, y, e, b, T, E, s, S, I, C, O, L);\n        }\n        t.uploadCommonUniforms(c, z, e.toUnwrapped(), null, D);\n        let G = f.segments;\n        if (\"mercator\" === u.projection.name && !P && (G = f.getVisibleSegments(r.tileID, t.terrain, t.transform.getFrustum(0)), !G.get().length)) continue;\n        if (B) if (P) for (const e of G.get()) B.numRenderedVerticesInShadowPass += e.primitiveLength;else for (const e of G.get()) B.numRenderedVerticesInTransparentPass += e.primitiveLength;\n        const j = [];\n        (t.terrain || l) && j.push(f.centroidVertexBuffer), w && j.push(f.layoutVertexExtBuffer), z.draw(t, c.gl.TRIANGLES, s, n, a, Ft.backCCW, U, o.id, f.layoutVertexBuffer, f.indexBuffer, G, o.paint, t.transform.zoom, x, j);\n      }\n      t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !1);\n    }\n    function ls(t, i, o, r, s, n, a, l, c, h, u, d, _, p, f, m, g, v, x) {\n      const y = t.context,\n        b = y.gl,\n        w = t.transform,\n        T = t.transform.zoom,\n        E = [],\n        S = vo(t, o.paint.get(\"fill-extrusion-cutoff-fade-range\"));\n      \"clear\" === h ? (E.push(\"CLEAR_SUBPASS\"), x && (E.push(\"CLEAR_FROM_TEXTURE\"), y.activeTexture.set(b.TEXTURE0), x.bind(b.LINEAR, b.CLAMP_TO_EDGE))) : \"sdf\" === h && E.push(\"SDF_SUBPASS\"), g && E.push(\"HAS_CENTROID\"), S.shouldRenderCutoff && E.push(\"RENDER_CUTOFF\");\n      const C = o.layout.get(\"fill-extrusion-edge-radius\"),\n        I = (e, i, r, h, v) => {\n          const b = i.programConfigurations.get(o.id),\n            w = t.isTileAffectedByFog(e),\n            I = t.getOrCreateProgram(\"fillExtrusionGroundEffect\", {\n              config: b,\n              defines: E,\n              overrideFog: w\n            }),\n            D = ((e, t, i, o, r, s, n, a, l, c, h) => ({\n              u_matrix: t,\n              u_opacity: i,\n              u_ao_pass: o ? 1 : 0,\n              u_meter_to_tile: r,\n              u_ao: s,\n              u_flood_light_intensity: n,\n              u_flood_light_color: a,\n              u_attenuation: l,\n              u_edge_radius: c,\n              u_fb: 0,\n              u_fb_size: h\n            }))(0, h, u, c, v, [d, _ * v], p, f, m, T >= 17 ? 0 : C * v, x ? x.size[0] : 0),\n            L = [];\n          g && L.push(i.hiddenByLandmarkVertexBuffer), t.uploadCommonUniforms(y, I, e.toUnwrapped(), null, S), I.draw(t, y.gl.TRIANGLES, s, n, a, l, D, o.id, i.vertexBuffer, i.indexBuffer, r, o.paint, T, b, L);\n        };\n      for (const s of r) {\n        const r = i.getTile(s),\n          n = r.getBucket(o);\n        if (!n || n.projection.name !== w.projection.name || !n.groundEffect || n.groundEffect && !n.groundEffect.hasData()) continue;\n        const a = n.groundEffect,\n          l = 1 / n.tileToMeter;\n        {\n          const e = t.translatePosMatrix(s.projMatrix, r, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n            i = a.getDefaultSegment();\n          I(s, a, i, e, l);\n        }\n        if (v) for (let n = 0; n < 4; n++) {\n          const a = e.cG[n](s),\n            c = i.getTile(a);\n          if (!c) continue;\n          const h = c.getBucket(o);\n          if (!h || h.projection.name !== w.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;\n          const u = h.groundEffect;\n          let d, _;\n          0 === n ? (d = [-e.V, 0, 0], _ = 1) : 1 === n ? (d = [e.V, 0, 0], _ = 0) : 2 === n ? (d = [0, -e.V, 0], _ = 3) : (d = [0, e.V, 0], _ = 2);\n          const p = u.regionSegments[_];\n          if (!p) continue;\n          const f = new Float32Array(16);\n          e.a6.translate(f, s.projMatrix, d), I(s, u, p, t.translatePosMatrix(f, r, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")), l);\n        }\n      }\n    }\n    function cs(t, i, o, r, s, n, a) {\n      0 === r.centroidVertexArray.length && r.createCentroidsBuffer();\n      const l = n ? n.findDEMTileFor(o) : null;\n      if (!(l && l.dem || a)) return;\n      const c = t => new e.P(Math.ceil((t + e.cJ) * e.cK), 0),\n        h = e => {\n          const t = i.getSource().minzoom,\n            o = e => {\n              const t = i.getTileByID(e);\n              if (t && t.hasData()) return t.getBucket(s);\n            },\n            r = [0, -1, 1];\n          for (const i of r) {\n            if (e.overscaledZ + i < t) continue;\n            const r = o(e.calculateScaledKey(e.overscaledZ + i));\n            if (r) return r;\n          }\n        },\n        u = [0, 0, 0],\n        d = (t, i) => (u[0] = Math.min(t.min.y, i.min.y), u[1] = Math.max(t.max.y, i.max.y), u[2] = e.V - i.min.x > t.max.x ? i.min.x - e.V : t.max.x, u),\n        _ = (t, i) => (u[0] = Math.min(t.min.x, i.min.x), u[1] = Math.max(t.max.x, i.max.x), u[2] = e.V - i.min.y > t.max.y ? i.min.y - e.V : t.max.y, u),\n        p = [(e, t) => d(e, t), (e, t) => d(t, e), (e, t) => _(e, t), (e, t) => _(t, e)],\n        f = (t, i, r, s, a, c, h) => {\n          if (!n) return 0;\n          const u = [[c ? r : t, c ? t : r, 0], [c ? r : i, c ? i : r, 0]],\n            d = h < 0 ? e.V + h : h,\n            _ = [c ? d : (t + i) / 2, c ? (t + i) / 2 : d, 0];\n          return 0 === r && h < 0 || 0 !== r && h > 0 ? n.getForTilePoints(a, [_], !0, s) : u.push(_), n.getForTilePoints(o, u, !0, l), Math.max(u[0][2], u[1][2], _[2]) / n.exaggeration();\n        };\n      for (let t = 0; t < 4; t++) {\n        const i = r.borderFeatureIndices[t];\n        if (0 === i.length) continue;\n        const s = e.cG[t](o),\n          l = h(s);\n        if (!(l && l instanceof e.cH)) continue;\n        if (r.borderDoneWithNeighborZ[t] === l.canonical.z) continue;\n        0 === l.centroidVertexArray.length && l.createCentroidsBuffer();\n        const u = n ? n.findDEMTileFor(s) : null;\n        if (!(u && u.dem || a)) continue;\n        const d = (t < 2 ? 1 : 5) - t,\n          _ = l.borderDoneWithNeighborZ[d] !== r.canonical.z,\n          v = l.borderFeatureIndices[d];\n        let x = 0;\n        if (r.canonical.z !== l.canonical.z) {\n          for (const e of i) r.showCentroid(r.featuresOnBorder[e]);\n          if (_) for (const e of v) l.showCentroid(l.featuresOnBorder[e]);\n          r.borderDoneWithNeighborZ[t] = l.canonical.z, l.borderDoneWithNeighborZ[d] = r.canonical.z;\n        }\n        for (const o of i) {\n          const i = r.featuresOnBorder[o],\n            n = r.centroidData[i.centroidDataIndex],\n            h = i.borders[t];\n          let _;\n          for (; x < v.length;) {\n            _ = l.featuresOnBorder[v[x]];\n            const e = _.borders[d];\n            if (e[1] > h[0] + 3 || e[0] > h[0] - 3) break;\n            l.showCentroid(_), x++;\n          }\n          if (_ && x < v.length) {\n            const o = x;\n            let y = 0;\n            for (; !(_.borders[d][0] > h[1] - 3) && (y++, ++x !== v.length);) _ = l.featuresOnBorder[v[x]];\n            if (_ = l.featuresOnBorder[v[o]], y > 1) {\n              const e = _.borders[d];\n              Math.abs(h[0] - e[0]) < 3 && Math.abs(h[1] - e[1]) < 3 && (y = 1, x = o + 1);\n            } else if (0 === y) {\n              r.showCentroid(i);\n              continue;\n            }\n            const b = l.centroidData[_.centroidDataIndex];\n            a && 1 === y && (((m = n).flags | (g = b).flags) & e.cI ? (m.flags |= e.cI, g.flags |= e.cI) : (m.flags &= ~e.cI, g.flags &= ~e.cI));\n            const w = i.intersectsCount() > 1 || _.intersectsCount() > 1;\n            if (y > 1) x = o, n.centroidXY = b.centroidXY = new e.P(0, 0);else if (u && u.dem && !w) {\n              const i = p[t](n, b),\n                o = t % 2 ? e.V - 1 : 0,\n                r = f(i[0], Math.min(e.V - 1, i[1]), o, u, s, t < 2, i[2]);\n              n.centroidXY = b.centroidXY = c(r);\n            } else w ? n.centroidXY = b.centroidXY = new e.P(0, 0) : (n.centroidXY = r.encodeBorderCentroid(i), b.centroidXY = l.encodeBorderCentroid(_));\n            r.writeCentroidToBuffer(n), l.writeCentroidToBuffer(b);\n          } else r.showCentroid(i);\n        }\n        r.borderDoneWithNeighborZ[t] = l.canonical.z, l.borderDoneWithNeighborZ[d] = r.canonical.z;\n      }\n      var m, g;\n      (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t);\n    }\n    const hs = [1, 0, 0],\n      us = [0, 1, 0],\n      ds = [0, 0, 1];\n    function _s(t, i, o) {\n      const r = o.transform,\n        s = o.shadowRenderer;\n      if (!s) return !0;\n      const n = t.toUnwrapped(),\n        a = r.tileSize * s._cascades[o.currentShadowCascade].scale;\n      let l = i.maxHeight;\n      if (r.elevation) {\n        const e = r.elevation.getMinMaxForTile(t);\n        e && (l += e.max);\n      }\n      const c = [...s.shadowDirection];\n      c[2] = -c[2];\n      const h = s.computeSimplifiedTileShadowVolume(n, l, a, c);\n      if (!h) return !1;\n      const u = [hs, us, ds, c, [c[0], 0, c[2]], [0, c[1], c[2]]],\n        d = \"globe\" === r.projection.name,\n        _ = r.scaleZoom(a),\n        p = e.bq.fromInvProjectionMatrix(r.invProjMatrix, r.worldSize, _, !d),\n        f = s.getCurrentCascadeFrustum();\n      return 0 === p.intersectsPrecise(h.vertices, h.planes, u) || 0 === f.intersectsPrecise(h.vertices, h.planes, u);\n    }\n    function ps(t) {\n      return [t[0] * e.cL, t[1] * e.cL, t[2] * e.cL, 0];\n    }\n    function fs(t, i, o, r, s, n, a, l, c) {\n      const h = r.getSource(),\n        u = o.globeSharedBuffers;\n      if (!u) return;\n      let d, _, p;\n      if (i && (d = r.getTile(i)), h instanceof e.ap ? (_ = h.texture, p = e.cj(0, 0, o.transform)) : d && i && (_ = d.texture, p = e.cj(i.canonical.z, i.canonical.x, o.transform)), !_ || !p) return;\n      t || (p = e.a6.scale(e.a6.create(), p, [1, -1, 1]));\n      const f = o.context,\n        m = f.gl,\n        g = \"nearest\" === s.paint.get(\"raster-resampling\") ? m.NEAREST : m.LINEAR,\n        v = o.colorModeForDrapableLayerRenderPass(n),\n        x = a.defines;\n      x.push(\"GLOBE_POLES\");\n      const y = new Lt(m.LEQUAL, Lt.ReadWrite, o.depthRangeFor3D),\n        b = Float32Array.from(o.transform.expandedFarZProjMatrix),\n        w = Float32Array.from(e.aT(e.ci(new e.bs(0, 0, 0))));\n      o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), _.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), _.bind(g, m.CLAMP_TO_EDGE), _.useMipmap && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);\n      const [T, E, S, C] = i ? u.getPoleBuffers(i.canonical.z, !1) : u.getPoleBuffers(0, !0),\n        I = s.paint.get(\"raster-elevation\");\n      let D;\n      t ? (D = T, o.renderDefaultNorthPole = 0 !== I) : (D = E, o.renderDefaultSouthPole = 0 !== I);\n      const L = ps(a.mix),\n        A = ((e, t, i, o, r, s, n, a, l, c, h, u, d) => Br(e, t, i, new Float32Array(16), new Float32Array(9), [0, 0], o, [0, 0], [0, 0, 0, 0], 1, {\n          opacity: 1,\n          mix: 0\n        }, s, [0, 0] || [0, 0], a, 2, c, h, u, 1, 0, d))(b, w, p, e.S(o.transform.zoom), 0, s, 0, I, 0, L, a.offset, a.range, n),\n        R = o.getOrCreateProgram(\"raster\", {\n          defines: x\n        });\n      o.uploadCommonUniforms(f, R, null), R.draw(o, m.TRIANGLES, y, c, v, l, A, s.id, D, S, C);\n    }\n    function ms(e) {\n      const t = e._nearZ,\n        i = e.projection.farthestPixelDistance(e),\n        o = i - t,\n        r = .2 * e.height,\n        s = t + r;\n      return [t, i, (s - r - t) / o, (s - t) / o];\n    }\n    function gs(e, t, i, o) {\n      if (e) return t instanceof ze && e instanceof $t ? t.getTextureDescriptor(e, i, !0) : {\n        texture: e.texture,\n        mix: ps(o.mix),\n        offset: o.offset,\n        buffer: 0,\n        tileSize: 1\n      };\n    }\n    function vs(t, i, o) {\n      if (!t) return null;\n      const r = i.getTextureDescriptor(t, o, !0);\n      if (!r) return null;\n      let {\n        texture: s,\n        mix: n,\n        offset: a,\n        tileSize: l,\n        buffer: c,\n        format: h\n      } = r;\n      if (!s || !h) return null;\n      let u = !1;\n      return \"uint32\" === h && (u = !0, n[3] = 0, n = Or(e.cM, n, [0, o.paint.get(\"raster-particle-max-speed\")]), a = Fr(e.cM, a, [0, o.paint.get(\"raster-particle-max-speed\")])), {\n        texture: s,\n        textureOffset: [c / (l + 2 * c), l / (l + 2 * c)],\n        tileSize: l,\n        scalarData: u,\n        scale: n,\n        offset: a,\n        defines: [\"RASTER_ARRAY\", {\n          uint8: \"DATA_FORMAT_UINT8\",\n          uint16: \"DATA_FORMAT_UINT16\",\n          uint32: \"DATA_FORMAT_UINT32\"\n        }[h]]\n      };\n    }\n    function xs(e) {\n      const t = e._nearZ,\n        i = e.projection.farthestPixelDistance(e),\n        o = i - t,\n        r = .2 * e.height,\n        s = t + r;\n      return [t, i, (s - r - t) / o, (s - t) / o];\n    }\n    const ys = new e.ax(1, 0, 0, 1),\n      bs = new e.ax(0, 1, 0, 1),\n      ws = new e.ax(0, 0, 1, 1),\n      Ts = new e.ax(1, 0, 1, 1),\n      Es = new e.ax(0, 1, 1, 1);\n    function Ss(t, i, o, r, s, n, a) {\n      const l = t.context,\n        c = t.transform,\n        h = l.gl,\n        u = \"globe\" === c.projection.name,\n        d = u ? [\"PROJECTION_GLOBE_VIEW\"] : [];\n      let _ = e.a6.clone(o.projMatrix);\n      if (u && e.S(c.zoom) > 0) {\n        const t = e.aS(o.canonical, c),\n          i = e.cN(t);\n        _ = e.a6.multiply(new Float32Array(16), c.globeMatrix, i), e.a6.multiply(_, c.projMatrix, _);\n      }\n      const p = e.a6.create();\n      p[12] += 2 * s / (e.f.devicePixelRatio * c.width), p[13] += 2 * n / (e.f.devicePixelRatio * c.height), e.a6.multiply(_, p, _);\n      const f = t.getOrCreateProgram(\"debug\", {\n          defines: d\n        }),\n        m = i.getTileByID(o.key);\n      t.terrain && t.terrain.setupElevationDraw(m, f);\n      const g = Lt.disabled,\n        v = Rt.disabled,\n        x = t.colorModeForRenderPass(),\n        y = \"$debug\";\n      l.activeTexture.set(h.TEXTURE0), t.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), u ? m._makeGlobeTileDebugBuffers(t.context, c) : m._makeDebugTileBoundsBuffers(t.context, c.projection);\n      const b = m._tileDebugBuffer || t.debugBuffer,\n        w = m._tileDebugIndexBuffer || t.debugIndexBuffer,\n        T = m._tileDebugSegments || t.debugSegments;\n      if (f.draw(t, h.LINE_STRIP, g, v, x, Ft.disabled, Pr(_, r), y, b, w, T, null, null, null, [m._globeTileDebugBorderBuffer]), a) {\n        const e = m.latestRawTileData,\n          i = Math.floor((e && e.byteLength || 0) / 1024);\n        let r = o.canonical.toString();\n        o.overscaledZ !== o.canonical.z && (r += ` => ${o.overscaledZ}`), r += ` ${m.state}`, r += ` ${i}kb`, function (e, t) {\n          e.initDebugOverlayCanvas();\n          const i = e.debugOverlayCanvas,\n            o = e.context.gl,\n            r = e.debugOverlayCanvas.getContext(\"2d\");\n          r.clearRect(0, 0, i.width, i.height), r.shadowColor = \"white\", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = \"white\", r.textBaseline = \"top\", r.font = \"bold 36px Open Sans, sans-serif\", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n        }(t, r);\n      }\n      const E = i.getTile(o).tileSize,\n        S = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5,\n        C = m._tileDebugTextBuffer || t.debugBuffer,\n        I = m._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,\n        D = m._tileDebugTextSegments || t.debugSegments;\n      f.draw(t, h.TRIANGLES, g, v, Mt.alphaBlended, Ft.disabled, Pr(_, e.ax.transparent, S), y, C, I, D, null, null, null, [m._globeTileDebugTextBuffer]);\n    }\n    function Cs(e, t, i, o) {\n      Ds(e, 0, t + i / 2, e.transform.width, i, o);\n    }\n    function Is(e, t, i, o) {\n      Ds(e, t - i / 2, 0, i, e.transform.height, o);\n    }\n    function Ds(t, i, o, r, s, n) {\n      const a = t.context,\n        l = a.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * e.f.devicePixelRatio, o * e.f.devicePixelRatio, r * e.f.devicePixelRatio, s * e.f.devicePixelRatio), a.clear({\n        color: n\n      }), l.disable(l.SCISSOR_TEST);\n    }\n    const Ls = e.ay([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: As\n      } = Ls;\n    function Rs(e, t, i, o) {\n      e.emplaceBack(t, i, o);\n    }\n    class Ps {\n      constructor(t) {\n        this.vertexArray = new e.az(), this.indices = new e.aw(), Rs(this.vertexArray, -1, -1, 1), Rs(this.vertexArray, 1, -1, 1), Rs(this.vertexArray, -1, 1, 1), Rs(this.vertexArray, 1, 1, 1), Rs(this.vertexArray, -1, -1, -1), Rs(this.vertexArray, 1, -1, -1), Rs(this.vertexArray, -1, 1, -1), Rs(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, As), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.aB.simpleSegment(0, 0, 36, 12);\n      }\n    }\n    function Ms(t, i, o, r, s, n) {\n      const a = t.context.gl,\n        l = i.paint.get(\"sky-atmosphere-color\"),\n        c = i.paint.get(\"sky-atmosphere-halo-color\"),\n        h = i.paint.get(\"sky-atmosphere-sun-intensity\"),\n        u = ((e, t, i, o, r) => ({\n          u_matrix_3f: e,\n          u_sun_direction: t,\n          u_sun_intensity: i,\n          u_color_tint_r: [o.r, o.g, o.b, o.a],\n          u_color_tint_m: [r.r, r.g, r.b, r.a],\n          u_luminance: 5e-5\n        }))(e.co.fromMat4(e.co.create(), r), s, h, l, c);\n      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + n, i.skyboxTexture, 0), o.draw(t, a.TRIANGLES, Lt.disabled, Rt.disabled, Mt.unblended, Ft.frontCW, u, \"skyboxCapture\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n    }\n    const zs = e.ay([{\n      type: \"Float32\",\n      name: \"a_pos\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }]);\n    class Os {\n      constructor(t) {\n        const i = new e.cO();\n        i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);\n        const o = new e.aw();\n        o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(i, zs.members), this.indexBuffer = t.createIndexBuffer(o), this.segments = e.aB.simpleSegment(0, 0, 4, 2);\n      }\n      destroy() {\n        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();\n      }\n    }\n    const Fs = e.ay([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_size_scale\",\n      components: 1\n    }, {\n      type: \"Float32\",\n      name: \"a_fade_opacity\",\n      components: 1\n    }]);\n    class Bs {\n      constructor() {\n        this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;\n      }\n    }\n    class ks {\n      constructor(t) {\n        this.colorModeAlphaBlendedWriteRGB = new Mt([1, Pt, 1, Pt], e.ax.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new Mt([1, 0, 1, 0], e.ax.transparent, [!1, !1, !1, !0]), this.params = new Bs(), this.updateNeeded = !0, t.tp.registerParameter(this.params, [\"Stars\"], \"starsCount\", {\n          min: 100,\n          max: 16e3,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"sizeMultiplier\", {\n          min: .01,\n          max: 2,\n          step: .01\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"sizeRange\", {\n          min: 0,\n          max: 200,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"intensityRange\", {\n          min: 0,\n          max: 200,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        });\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.atmosphereBuffer || this.updateNeeded) {\n          this.updateNeeded = !1, this.atmosphereBuffer = new Os(i);\n          const t = this.params.sizeRange,\n            o = this.params.intensityRange,\n            r = function (t) {\n              const i = e.aA(30),\n                o = [];\n              for (let r = 0; r < t; ++r) {\n                const t = 2 * Math.PI * i(),\n                  r = Math.acos(1 - 2 * i()) - .5 * Math.PI;\n                o.push(e.N.fromValues(Math.cos(r) * Math.cos(t), Math.cos(r) * Math.sin(t), Math.sin(r)));\n              }\n              return o;\n            }(this.params.starsCount),\n            s = e.aA(300),\n            n = new e.cP(),\n            a = new e.aw();\n          let l = 0;\n          for (let i = 0; i < r.length; ++i) {\n            const c = e.N.scale([], r[i], 200),\n              h = Math.max(0, 1 + .01 * t * (1 * s() - .5)),\n              u = Math.max(0, 1 + .01 * o * (1 * s() - .5));\n            n.emplaceBack(c[0], c[1], c[2], -1, -1, h, u), n.emplaceBack(c[0], c[1], c[2], 1, -1, h, u), n.emplaceBack(c[0], c[1], c[2], 1, 1, h, u), n.emplaceBack(c[0], c[1], c[2], -1, 1, h, u), a.emplaceBack(l + 0, l + 1, l + 2), a.emplaceBack(l + 0, l + 2, l + 3), l += 4;\n          }\n          this.starsVx = i.createVertexBuffer(n, Fs.members), this.starsIdx = i.createIndexBuffer(a), this.starsSegments = e.aB.simpleSegment(0, 0, n.length, a.length);\n        }\n      }\n      destroy() {\n        this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();\n      }\n      drawAtmosphereGlow(t, i) {\n        const o = t.context,\n          r = o.gl,\n          s = t.transform,\n          n = new Lt(r.LEQUAL, Lt.ReadOnly, [0, 1]),\n          a = e.S(s.zoom),\n          l = i.properties.get(\"color\").toArray01(),\n          c = i.properties.get(\"high-color\").toArray01(),\n          h = i.properties.get(\"space-color\").toArray01PremultipliedAlpha(),\n          u = 5e-4,\n          d = e.cQ(i.properties.get(\"horizon-blend\"), 0, 1, u, .25),\n          _ = e.cd(t, o, s) && d === u ? s.worldSize / (2 * Math.PI * 1.025) - 1 : s.globeRadius,\n          p = t.frameCounter / 1e3 % 1,\n          f = e.N.length(s.globeCenterInViewSpace),\n          m = Math.sqrt(Math.pow(f, 2) - Math.pow(_, 2)),\n          g = Math.acos(m / f),\n          v = e => {\n            const i = \"globe\" === s.projection.name ? [\"PROJECTION_GLOBE_VIEW\", \"FOG\"] : [\"FOG\"];\n            e && i.push(\"ALPHA_PASS\");\n            const u = t.getOrCreateProgram(\"globeAtmosphere\", {\n                defines: i\n              }),\n              _ = ((e, t, i, o, r, s, n, a, l, c, h, u) => ({\n                u_frustum_tl: e,\n                u_frustum_tr: t,\n                u_frustum_br: i,\n                u_frustum_bl: o,\n                u_horizon: r,\n                u_transition: s,\n                u_fadeout_range: n,\n                u_color: a,\n                u_high_color: l,\n                u_space_color: c,\n                u_temporal_offset: h,\n                u_horizon_angle: u\n              }))(s.frustumCorners.TL, s.frustumCorners.TR, s.frustumCorners.BR, s.frustumCorners.BL, s.frustumCorners.horizon, a, d, l, c, h, p, g);\n            t.uploadCommonUniforms(o, u);\n            const f = this.atmosphereBuffer;\n            f && u.draw(t, r.TRIANGLES, n, Rt.disabled, e ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Ft.backCW, _, e ? \"atmosphere_glow_alpha\" : \"atmosphere_glow\", f.vertexBuffer, f.indexBuffer, f.segments);\n          };\n        v(!1), v(!0);\n      }\n      drawStars(t, i) {\n        const o = e.aa(i.properties.get(\"star-intensity\"), 0, 1);\n        if (0 === o) return;\n        const r = t.context,\n          s = r.gl,\n          n = t.transform,\n          a = t.getOrCreateProgram(\"stars\"),\n          l = e.bi.identity([]);\n        e.bi.rotateX(l, l, -n._pitch), e.bi.rotateZ(l, l, -n.angle), e.bi.rotateX(l, l, e.bj(n._center.lat)), e.bi.rotateY(l, l, -e.bj(n._center.lng));\n        const c = e.a6.fromQuat(new Float32Array(16), l),\n          h = e.a6.multiply([], n.starsProjMatrix, c),\n          u = e.co.fromMat4([], c),\n          d = e.co.invert([], u),\n          _ = [0, 1, 0];\n        e.N.transformMat3(_, _, d), e.N.scale(_, _, this.params.sizeMultiplier);\n        const p = [1, 0, 0];\n        e.N.transformMat3(p, p, d), e.N.scale(p, p, this.params.sizeMultiplier);\n        const f = (m = _, g = p, v = o, {\n          u_matrix: Float32Array.from(h),\n          u_up: m,\n          u_right: g,\n          u_intensity_multiplier: v\n        });\n        var m, g, v;\n        t.uploadCommonUniforms(r, a), this.starsVx && this.starsIdx && a.draw(t, s.TRIANGLES, Lt.disabled, Rt.disabled, this.colorModeAlphaBlendedWriteRGB, Ft.disabled, f, \"atmosphere_stars\", this.starsVx, this.starsIdx, this.starsSegments);\n      }\n    }\n    function Ns(t, i) {\n      const o = [...t],\n        r = i.cameraWorldSizeForFog / i.worldSize,\n        s = e.a6.identity([]);\n      return e.a6.scale(s, s, [r, r, 1]), e.a6.multiply(o, s, o), e.a6.multiply(o, i.worldToFogMatrix, o), o;\n    }\n    function Us(e, t, i, o) {\n      const r = i.material,\n        s = o.context,\n        {\n          baseColorTexture: n,\n          metallicRoughnessTexture: a\n        } = r.pbrMetallicRoughness,\n        {\n          normalTexture: l,\n          occlusionTexture: c,\n          emissionTexture: h\n        } = r;\n      function u(t, i, o) {\n        if (t && (e.push(i), s.activeTexture.set(s.gl.TEXTURE0 + o), t.gfxTexture)) {\n          const {\n            minFilter: e,\n            magFilter: i,\n            wrapS: o,\n            wrapT: r\n          } = t.sampler;\n          t.gfxTexture.bindExtraParam(e, i, o, r);\n        }\n      }\n      u(n, \"HAS_TEXTURE_u_baseColorTexture\", go.BaseColor), u(a, \"HAS_TEXTURE_u_metallicRoughnessTexture\", go.MetallicRoughness), u(l, \"HAS_TEXTURE_u_normalTexture\", go.Normal), u(c, \"HAS_TEXTURE_u_occlusionTexture\", go.Occlusion), u(h, \"HAS_TEXTURE_u_emissionTexture\", go.Emission), i.texcoordBuffer && (e.push(\"HAS_ATTRIBUTE_a_uv_2f\"), t.push(i.texcoordBuffer)), i.colorBuffer && (e.push(12 === i.colorBuffer.itemSize ? \"HAS_ATTRIBUTE_a_color_3f\" : \"HAS_ATTRIBUTE_a_color_4f\"), t.push(i.colorBuffer)), i.normalBuffer && (e.push(\"HAS_ATTRIBUTE_a_normal_3f\"), t.push(i.normalBuffer)), i.pbrBuffer && (e.push(\"HAS_ATTRIBUTE_a_pbr\"), e.push(\"HAS_ATTRIBUTE_a_heightBasedEmissiveStrength\"), t.push(i.pbrBuffer)), \"OPAQUE\" !== r.alphaMode && \"MASK\" !== r.alphaMode || e.push(\"UNPREMULT_TEXTURE_IN_SHADER\"), r.defined || e.push(\"DIFFUSE_SHADED\"), e.push(\"USE_STANDARD_DERIVATIVES\");\n    }\n    function Gs(t, i, o, r, s, n) {\n      const a = o.paint.get(\"model-opacity\"),\n        l = i.context,\n        c = new Lt(i.context.gl.LEQUAL, Lt.ReadWrite, i.depthRangeFor3D),\n        h = i.transform,\n        u = t.mesh,\n        d = u.material,\n        _ = d.pbrMetallicRoughness,\n        p = i.style.fog;\n      let f;\n      f = \"pixels\" === i.transform.projection.zAxisUnit ? [...t.nodeModelMatrix] : e.a6.multiply([], r.zScaleMatrix, t.nodeModelMatrix), e.a6.multiply(f, r.negCameraPosMatrix, f);\n      const m = e.a6.invert([], f);\n      e.a6.transpose(m, m);\n      const g = o.paint.get(\"model-emissive-strength\").constantOr(0),\n        v = $r(new Float32Array(t.worldViewProjection), new Float32Array(f), new Float32Array(m), i, a, _.baseColorFactor, d.emissiveFactor, _.metallicFactor, _.roughnessFactor, d, g, o),\n        x = {\n          defines: []\n        },\n        y = [];\n      Us(x.defines, y, u, i);\n      const b = i.shadowRenderer;\n      b && (b.useNormalOffset = !1);\n      let w = null;\n      if (p) {\n        const e = Ns(t.nodeModelMatrix, i.transform);\n        if (w = new Float32Array(e), \"globe\" !== h.projection.name) {\n          const t = u.aabb.min,\n            i = u.aabb.max,\n            [o, r] = p.getOpacityForBounds(e, t[0], t[1], i[0], i[1]);\n          x.overrideFog = o >= me || r >= me;\n        }\n      }\n      const T = vo(i, o.paint.get(\"model-cutoff-fade-range\"));\n      T.shouldRenderCutoff && x.defines.push(\"RENDER_CUTOFF\");\n      const E = i.getOrCreateProgram(\"model\", x);\n      i.uploadCommonUniforms(l, E, null, w, T), \"shadow\" !== i.renderPass && b && b.setupShadowsFromMatrix(t.nodeModelMatrix, E), E.draw(i, l.gl.TRIANGLES, c, s, n, u.material.doubleSided ? Ft.disabled : Ft.backCCW, v, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, i.transform.zoom, void 0, y);\n    }\n    function js(t, i, o, r, s, n, a) {\n      let l;\n      l = \"globe\" === t.projection.name ? e.cS(o, t) : [...o], e.a6.multiply(l, l, i.matrix);\n      const c = e.a6.multiply([], r, l);\n      if (i.meshes) for (const t of i.meshes) {\n        if (\"BLEND\" !== t.material.alphaMode) {\n          a.push({\n            mesh: t,\n            depth: 0,\n            modelIndex: s,\n            worldViewProjection: c,\n            nodeModelMatrix: l\n          });\n          continue;\n        }\n        const i = e.N.transformMat4([], t.centroid, c);\n        i[2] > 0 && n.push({\n          mesh: t,\n          depth: i[2],\n          modelIndex: s,\n          worldViewProjection: c,\n          nodeModelMatrix: l\n        });\n      }\n      if (i.children) for (const e of i.children) js(t, e, o, r, s, n, a);\n    }\n    function Vs(e, t, i, o) {\n      const r = i.shadowRenderer;\n      if (!r) return;\n      const s = r.getShadowPassDepthMode(),\n        n = r.getShadowPassColorMode(),\n        a = r.calculateShadowPassMatrixFromMatrix(t),\n        l = Kr(a);\n      i.getOrCreateProgram(\"modelDepth\", {\n        defines: i._shadowMapDebug ? [] : [\"DEPTH_TEXTURE\"]\n      }).draw(i, i.context.gl.TRIANGLES, s, Rt.disabled, n, Ft.backCCW, l, o.id, e.vertexBuffer, e.indexBuffer, e.segments, o.paint, i.transform.zoom, void 0, void 0);\n    }\n    function Zs(t, i, o) {\n      const r = i.updateZoomBasedPaintProperties(),\n        s = function (t, i, o) {\n          let r,\n            s,\n            n,\n            a = t.terrain ? t.terrain.exaggeration() : 0;\n          if (t.terrain && a > 0) {\n            const i = t.terrain,\n              s = i.findDEMTileFor(o);\n            s && s.dem ? r = e.cU.create(i, o, s) : a = 0;\n          }\n          if (0 === a && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), a === i.validForExaggeration && (0 === a || r && r._demTile && r._demTile.tileID === i.validForDEMTile.id && r._dem._timestamp === i.validForDEMTile.timestamp)) return !1;\n          for (const e in i.instancesPerModel) {\n            const t = i.instancesPerModel[e];\n            for (let e = 0; e < t.instancedDataArray.length; ++e) {\n              const o = (r ? a * r.getElevationAt(0 | t.instancedDataArray.float32[16 * e], 0 | t.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t.instancesEvaluatedElevation[e];\n              t.instancedDataArray.float32[16 * e + 6] = o, s = s ? Math.min(i.terrainElevationMin, o) : o, n = n ? Math.max(i.terrainElevationMax, o) : o;\n            }\n          }\n          return i.terrainElevationMin = s || 0, i.terrainElevationMax = n || 0, i.validForExaggeration = a, i.validForDEMTile = r && r._demTile ? {\n            id: r._demTile.tileID,\n            timestamp: r._dem._timestamp\n          } : {\n            id: void 0,\n            timestamp: 0\n          }, !0;\n        }(t, i, o);\n      (r || s) && (i.uploaded = !1, i.upload(t.context));\n    }\n    const Hs = {\n      shadowUniformsInitialized: !1,\n      useSingleShadowCascade: !1,\n      tileMatrix: new Float64Array(16),\n      shadowTileMatrix: new Float32Array(16),\n      aabb: new e.bS([0, 0, 0], [e.V, e.V, 0])\n    };\n    function Ws(t, i) {\n      const o = 1 << t.canonical.z,\n        r = i.getFreeCameraOptions().position,\n        s = i.elevation,\n        n = t.canonical.x / o,\n        a = (t.canonical.x + 1) / o,\n        l = t.canonical.y / o,\n        c = (t.canonical.y + 1) / o;\n      let h = i._centerAltitude;\n      if (s) {\n        const e = s.getMinMaxForTile(t);\n        e && e.max > h && (h = e.max);\n      }\n      const u = e.aa(r.x, n, a) - r.x,\n        d = e.aa(r.y, l, c) - r.y,\n        _ = e.bl(h, i.center.lat) - r.z;\n      return i._zoomFromMercatorZ(Math.sqrt(u * u + d * d + _ * _));\n    }\n    function qs(e, t, i, o, r, s, n) {\n      const a = e.context,\n        l = \"shadow\" === e.renderPass,\n        c = e.shadowRenderer,\n        h = l && c ? c.getShadowPassDepthMode() : new Lt(a.gl.LEQUAL, Lt.ReadWrite, e.depthRangeFor3D),\n        u = e.isTileAffectedByFog(s);\n      if (i.meshes) for (const d of i.meshes) {\n        const _ = [\"MODEL_POSITION_ON_GPU\"],\n          p = [];\n        let f, m, g;\n        o.instancedDataArray.length > 20 && _.push(\"INSTANCED_ARRAYS\");\n        const v = vo(e, t.paint.get(\"model-cutoff-fade-range\"));\n        if (v.shouldRenderCutoff && _.push(\"RENDER_CUTOFF\"), l && c) f = e.getOrCreateProgram(\"modelDepth\", {\n          defines: _\n        }), m = Kr(n.shadowTileMatrix, n.shadowTileMatrix, Float32Array.from(i.matrix)), g = c.getShadowPassColorMode();else {\n          Us(_, p, d, e), f = e.getOrCreateProgram(\"model\", {\n            defines: _,\n            overrideFog: u\n          });\n          const o = d.material,\n            l = o.pbrMetallicRoughness,\n            h = t.paint.get(\"model-opacity\"),\n            x = t.paint.get(\"model-emissive-strength\").constantOr(0);\n          m = $r(s.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), e, h, l.baseColorFactor, o.emissiveFactor, l.metallicFactor, l.roughnessFactor, o, x, t, r), c && (n.shadowUniformsInitialized ? f.setShadowUniformValues(a, c.getShadowUniformValues()) : (c.setupShadows(s.toUnwrapped(), f, \"model-tile\", s.overscaledZ), n.shadowUniformsInitialized = !0)), g = v.shouldRenderCutoff || h < 1 || \"OPAQUE\" !== o.alphaMode ? Mt.alphaBlended : Mt.unblended;\n        }\n        e.uploadCommonUniforms(a, f, s.toUnwrapped(), null, v);\n        const x = d.material.doubleSided ? Ft.disabled : Ft.backCCW;\n        if (o.instancedDataArray.length > 20) p.push(o.instancedDataBuffer), f.draw(e, a.gl.TRIANGLES, h, Rt.disabled, g, x, m, t.id, d.vertexBuffer, d.indexBuffer, d.segments, t.paint, e.transform.zoom, void 0, p, o.instancedDataArray.length);else {\n          const i = l ? \"u_instance\" : \"u_normal_matrix\";\n          for (let r = 0; r < o.instancedDataArray.length; ++r) m[i] = new Float32Array(o.instancedDataArray.arrayBuffer, 64 * r, 16), f.draw(e, a.gl.TRIANGLES, h, Rt.disabled, g, x, m, t.id, d.vertexBuffer, d.indexBuffer, d.segments, t.paint, e.transform.zoom, void 0, p);\n        }\n      }\n      if (i.children) for (const a of i.children) qs(e, t, a, o, r, s, n);\n    }\n    const $s = [1, -1, 1];\n    function Xs(t, i, o, r) {\n      if (!o.modelManager) return !0;\n      const s = o.modelManager;\n      if (!o.shadowRenderer) return !0;\n      const n = o.shadowRenderer,\n        a = i.aabb;\n      let l = !0,\n        c = t.maxHeight;\n      if (0 === c) {\n        let e = 0;\n        for (const i in t.instancesPerModel) {\n          const t = s.getModel(i, r);\n          t ? e = Math.max(e, Math.max(Math.max(t.aabb.max[0], t.aabb.max[1]), t.aabb.max[2])) : l = !1;\n        }\n        c = t.maxScale * e * 1.41 + t.maxVerticalOffset, l && (t.maxHeight = c);\n      }\n      a.max[2] = c, a.min[2] += t.terrainElevationMin, a.max[2] += t.terrainElevationMax, e.N.transformMat4(a.min, a.min, i.tileMatrix), e.N.transformMat4(a.max, a.max, i.tileMatrix);\n      const h = a.intersects(n.getCurrentCascadeFrustum());\n      return 0 === o.currentShadowCascade && (t.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;\n    }\n    class Ks {}\n    class Ys {\n      constructor() {\n        this._storage = new Map();\n      }\n      getLinesFromTrianglesBuffer(t, i, o) {\n        {\n          const e = this._storage.get(i.id);\n          if (e) return e.lastUsedFrameIdx = t, e.buf;\n        }\n        const r = o.gl,\n          s = r.getBufferParameter(r.ELEMENT_ARRAY_BUFFER, r.BUFFER_SIZE),\n          n = new ArrayBuffer(s),\n          a = new Int16Array(n);\n        r.getBufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n));\n        const l = new e.cW();\n        for (let e = 0; e < s / 2; e += 3) {\n          const t = a[e],\n            i = a[e + 1],\n            o = a[e + 2];\n          l.emplaceBack(t, i), l.emplaceBack(i, o), l.emplaceBack(o, t);\n        }\n        const c = o.bindVertexArrayOES.current,\n          h = new Ks();\n        return h.buf = new je(o, l), h.lastUsedFrameIdx = t, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;\n      }\n      update(e) {\n        for (const [t, i] of this._storage) e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t));\n      }\n      destroy() {\n        for (const [e, t] of this._storage) t.buf.destroy(), this._storage.delete(e);\n      }\n    }\n    class Js {\n      registerParameter(e, t, i, o, r) {}\n      registerButton(e, t, i) {}\n    }\n    const Qs = {\n        symbol: function (t, i, o, r, s) {\n          if (\"translucent\" !== t.renderPass) return;\n          const n = Rt.disabled,\n            a = t.colorModeForRenderPass();\n          o.layout.get(\"text-variable-anchor\") && function (t, i, o, r, s, n, a) {\n            const l = i.transform,\n              c = \"map\" === s,\n              h = \"map\" === n;\n            for (const i of t) {\n              const t = r.getTile(i),\n                s = t.getBucket(o);\n              if (!s || !s.text || !s.text.segments.get().length) continue;\n              const n = e.b5(s.textSizeData, l.zoom),\n                u = zi(i, s.getProjection(), l),\n                d = l.calculatePixelsToTileUnitsMatrix(t),\n                _ = fi(u, t.tileID.canonical, h, c, l, s.getProjection(), d),\n                p = s.hasIconTextFit() && s.hasIconData();\n              if (n) {\n                const o = Math.pow(2, l.zoom - t.tileID.overscaledZ);\n                os(s, c, h, a, e.cx, l, _, i, o, n, p);\n              }\n            }\n          }(r, t, o, i, o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), s);\n          const l = 0 !== o.paint.get(\"icon-opacity\").constantOr(1),\n            c = 0 !== o.paint.get(\"text-opacity\").constantOr(1);\n          void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1) && (l || c) ? rs(t, i, o, r, n, a) : (l && rs(t, i, o, r, n, a, {\n            onlyIcons: !0\n          }), c && rs(t, i, o, r, n, a, {\n            onlyText: !0\n          })), i.map.showCollisionBoxes && (Qr(t, i, o, r, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), !0), Qr(t, i, o, r, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), !1));\n        },\n        circle: function (t, i, o, r) {\n          if (\"translucent\" !== t.renderPass) return;\n          const s = o.paint.get(\"circle-opacity\"),\n            n = o.paint.get(\"circle-stroke-width\"),\n            a = o.paint.get(\"circle-stroke-opacity\"),\n            l = void 0 !== o.layout.get(\"circle-sort-key\").constantOr(1),\n            c = o.paint.get(\"circle-emissive-strength\");\n          if (0 === s.constantOr(1) && (0 === n.constantOr(1) || 0 === a.constantOr(1))) return;\n          const h = t.context,\n            u = h.gl,\n            d = t.transform,\n            _ = t.depthModeForSublayer(0, Lt.ReadOnly),\n            p = Rt.disabled,\n            f = t.colorModeForDrapableLayerRenderPass(c),\n            m = \"globe\" === d.projection.name,\n            g = [e.a5(d.center.lng), e.ae(d.center.lat)],\n            v = [];\n          for (let s = 0; s < r.length; s++) {\n            const n = r[s],\n              a = i.getTile(n),\n              c = a.getBucket(o);\n            if (!c || c.projection.name !== d.projection.name) continue;\n            const h = c.programConfigurations.get(o.id),\n              u = e.cy(o),\n              _ = t.isTileAffectedByFog(n);\n            m && u.push(\"PROJECTION_GLOBE_VIEW\");\n            const p = t.getOrCreateProgram(\"circle\", {\n                config: h,\n                defines: u,\n                overrideFog: _\n              }),\n              f = c.layoutVertexBuffer,\n              x = c.globeExtVertexBuffer,\n              y = c.indexBuffer,\n              b = d.projection.createInversionMatrix(d, n.canonical),\n              w = {\n                programConfiguration: h,\n                program: p,\n                layoutVertexBuffer: f,\n                globeExtVertexBuffer: x,\n                indexBuffer: y,\n                uniformValues: e.cz(t, n, a, b, g, o),\n                tile: a\n              };\n            if (l) {\n              const t = c.segments.get();\n              for (const i of t) v.push({\n                segments: new e.aB([i]),\n                sortKey: i.sortKey,\n                state: w\n              });\n            } else v.push({\n              segments: c.segments,\n              sortKey: 0,\n              state: w\n            });\n          }\n          l && v.sort((e, t) => e.sortKey - t.sortKey);\n          const x = {\n            useDepthForOcclusion: d.depthOcclusionForSymbolsAndCircles\n          };\n          for (const e of v) {\n            const {\n                programConfiguration: i,\n                program: r,\n                layoutVertexBuffer: s,\n                globeExtVertexBuffer: n,\n                indexBuffer: a,\n                uniformValues: l,\n                tile: c\n              } = e.state,\n              m = e.segments;\n            t.terrain && t.terrain.setupElevationDraw(c, r, x), t.uploadCommonUniforms(h, r, c.tileID.toUnwrapped()), r.draw(t, u.TRIANGLES, _, p, f, Ft.disabled, l, o.id, s, a, m, o.paint, d.zoom, i, [n]);\n          }\n        },\n        heatmap: function (t, i, o, r) {\n          if (0 !== o.paint.get(\"heatmap-opacity\")) if (\"offscreen\" === t.renderPass) {\n            const s = t.context,\n              n = s.gl,\n              a = Rt.disabled,\n              l = new Mt([n.ONE, n.ONE, n.ONE, n.ONE], e.ax.transparent, [!0, !0, !0, !0]);\n            !function (e, t, i, o) {\n              const r = e.gl,\n                s = t.width * o,\n                n = t.height * o;\n              e.activeTexture.set(r.TEXTURE1), e.viewport.set([0, 0, s, n]);\n              let a = i.heatmapFbo;\n              if (!a || a && (a.width !== s || a.height !== n)) {\n                a && a.destroy();\n                const t = r.createTexture();\n                r.bindTexture(r.TEXTURE_2D, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e.createFramebuffer(s, n, !0, null), function (e, t, i, o, r, s) {\n                  const n = e.gl;\n                  n.texImage2D(n.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? n.RGBA16F : n.RGBA, r, s, 0, n.RGBA, e.extRenderToTextureHalfFloat ? n.HALF_FLOAT : n.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n                }(e, 0, t, a, s, n);\n              } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);\n            }(s, t, o, \"globe\" === t.transform.projection.name ? .5 : .25), s.clear({\n              color: e.ax.transparent\n            });\n            const c = t.transform,\n              h = \"globe\" === c.projection.name,\n              u = h ? [\"PROJECTION_GLOBE_VIEW\"] : [],\n              d = h ? Ft.frontCCW : Ft.disabled,\n              _ = [e.a5(c.center.lng), e.ae(c.center.lat)];\n            for (let e = 0; e < r.length; e++) {\n              const p = r[e];\n              if (i.hasRenderableParent(p)) continue;\n              const f = i.getTile(p),\n                m = f.getBucket(o);\n              if (!m || m.projection.name !== c.projection.name) continue;\n              const g = t.isTileAffectedByFog(p),\n                v = m.programConfigurations.get(o.id),\n                x = t.getOrCreateProgram(\"heatmap\", {\n                  config: v,\n                  defines: u,\n                  overrideFog: g\n                }),\n                {\n                  zoom: y\n                } = t.transform;\n              t.terrain && t.terrain.setupElevationDraw(f, x), t.uploadCommonUniforms(s, x, p.toUnwrapped());\n              const b = c.projection.createInversionMatrix(c, p.canonical);\n              x.draw(t, n.TRIANGLES, Lt.disabled, a, l, d, zr(t, p, f, b, _, y, o.paint.get(\"heatmap-intensity\")), o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t.transform.zoom, v, h ? [m.globeExtVertexBuffer] : null);\n            }\n            s.viewport.set([0, 0, t.width, t.height]);\n          } else \"translucent\" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {\n            const o = t.context,\n              r = o.gl,\n              s = i.heatmapFbo;\n            if (!s) return;\n            o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, s.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);\n            let n = i.colorRampTexture;\n            n || (n = i.colorRampTexture = new e.T(o, i.colorRamp, r.RGBA)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.getOrCreateProgram(\"heatmapTexture\").draw(t, r.TRIANGLES, Lt.disabled, Rt.disabled, t.colorModeForRenderPass(), Ft.disabled, ((e, t, i, o) => ({\n              u_image: 0,\n              u_color_ramp: 1,\n              u_opacity: t.paint.get(\"heatmap-opacity\")\n            }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);\n          }(t, o));\n        },\n        line: function (t, i, o, r) {\n          if (\"translucent\" !== t.renderPass) return;\n          const s = o.paint.get(\"line-opacity\"),\n            n = o.paint.get(\"line-width\");\n          if (0 === s.constantOr(1) || 0 === n.constantOr(1)) return;\n          const a = o.paint.get(\"line-emissive-strength\"),\n            l = t.depthModeForSublayer(0, Lt.ReadOnly),\n            c = t.colorModeForDrapableLayerRenderPass(a),\n            h = t.terrain && t.terrain.renderingToTexture ? 1 : e.f.devicePixelRatio,\n            u = o.paint.get(\"line-dasharray\"),\n            d = u.constantOr(1),\n            _ = o.layout.get(\"line-cap\"),\n            p = o.paint.get(\"line-pattern\"),\n            f = p.constantOr(1),\n            m = o.paint.get(\"line-pattern\").constantOr(1),\n            g = 1 !== o.paint.get(\"line-opacity\").constantOr(1);\n          let v = !m && g;\n          const x = o.paint.get(\"line-gradient\"),\n            y = f ? \"linePattern\" : \"line\",\n            b = t.context,\n            w = b.gl,\n            T = e.cA(o);\n          t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (v = !1);\n          for (const s of r) {\n            const r = i.getTile(s);\n            if (f && !r.patternsLoaded()) continue;\n            const n = r.getBucket(o);\n            if (!n) continue;\n            t.prepareDrawTile();\n            const a = n.programConfigurations.get(o.id),\n              m = t.isTileAffectedByFog(s),\n              g = t.getOrCreateProgram(y, {\n                config: a,\n                defines: T,\n                overrideFog: m\n              }),\n              E = p.constantOr(null);\n            if (E && r.imageAtlas) {\n              const e = r.imageAtlas.patternPositions[E.toString()];\n              e && a.setConstantPatternPositions(e);\n            }\n            const S = u.constantOr(null),\n              C = _.constantOr(null);\n            if (!f && S && C && r.lineAtlas) {\n              const e = r.lineAtlas.getDash(S, C);\n              e && a.setConstantPatternPositions(e);\n            }\n            let [I, D] = o.paint.get(\"line-trim-offset\");\n            if (\"round\" === C || \"square\" === C) {\n              const e = 1;\n              I !== D && (0 === I && (I -= e), 1 === D && (D += e));\n            }\n            const L = t.terrain ? s.projMatrix : null,\n              A = f ? e.cB(t, r, o, L, h, [I, D]) : e.cC(t, r, o, L, n.lineClipsArray.length, h, [I, D]);\n            if (x) {\n              const r = n.gradients[o.id];\n              let a = r.texture;\n              if (o.gradientVersion !== r.version) {\n                let l = 256;\n                if (o.stepInterpolant) {\n                  const o = i.getSource().maxzoom,\n                    r = s.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - s.canonical.z) : 1;\n                  l = e.aa(e.cD(n.maxLineLength / e.V * 1024 * r), 256, b.maxTextureSize);\n                }\n                r.gradient = e.cE({\n                  expression: o.gradientExpression(),\n                  evaluationKey: \"lineProgress\",\n                  resolution: l,\n                  image: r.gradient || void 0,\n                  clips: n.lineClipsArray\n                }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.T(b, r.gradient, w.RGBA), r.version = o.gradientVersion, a = r.texture;\n              }\n              b.activeTexture.set(w.TEXTURE1), a.bind(o.stepInterpolant ? w.NEAREST : w.LINEAR, w.CLAMP_TO_EDGE);\n            }\n            d && (b.activeTexture.set(w.TEXTURE0), r.lineAtlasTexture && r.lineAtlasTexture.bind(w.LINEAR, w.REPEAT), a.updatePaintBuffers()), f && (b.activeTexture.set(w.TEXTURE0), r.imageAtlasTexture && r.imageAtlasTexture.bind(w.LINEAR, w.CLAMP_TO_EDGE), a.updatePaintBuffers()), t.uploadCommonUniforms(b, g, s.toUnwrapped());\n            const R = e => {\n              g.draw(t, w.TRIANGLES, l, e, c, Ft.disabled, A, o.id, n.layoutVertexBuffer, n.indexBuffer, n.segments, o.paint, t.transform.zoom, a, [n.layoutVertexBuffer2]);\n            };\n            if (v) {\n              const e = t.stencilModeForClipping(s).ref;\n              0 === e && t.terrain && b.clear({\n                stencil: 0\n              });\n              const i = {\n                func: w.EQUAL,\n                mask: 255\n              };\n              A.u_alpha_discard_threshold = .8, R(new Rt(i, e, 255, w.KEEP, w.KEEP, w.INVERT)), A.u_alpha_discard_threshold = 0, R(new Rt(i, e, 255, w.KEEP, w.KEEP, w.KEEP));\n            } else R(t.stencilModeForClipping(s));\n          }\n          v && (t.resetStencilClippingMasks(), t.terrain && b.clear({\n            stencil: 0\n          }));\n        },\n        fill: function (t, i, o, r) {\n          const s = o.paint.get(\"fill-color\"),\n            n = o.paint.get(\"fill-opacity\");\n          if (0 === n.constantOr(1)) return;\n          const a = o.paint.get(\"fill-emissive-strength\"),\n            l = t.colorModeForDrapableLayerRenderPass(a),\n            c = o.paint.get(\"fill-pattern\"),\n            h = t.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === s.constantOr(e.ax.transparent).a && 1 === n.constantOr(0) ? \"opaque\" : \"translucent\";\n          if (t.renderPass === h) {\n            const e = t.depthModeForSublayer(1, \"opaque\" === t.renderPass ? Lt.ReadWrite : Lt.ReadOnly);\n            ns(t, i, o, r, e, l, !1);\n          }\n          if (\"translucent\" === t.renderPass && o.paint.get(\"fill-antialias\")) {\n            const e = t.depthModeForSublayer(o.getPaintProperty(\"fill-outline-color\") ? 2 : 0, Lt.ReadOnly);\n            ns(t, i, o, r, e, l, !0);\n          }\n        },\n        \"fill-extrusion\": function (t, i, o, r) {\n          const s = o.paint.get(\"fill-extrusion-opacity\"),\n            n = t.context,\n            a = n.gl,\n            l = t.terrain,\n            c = l && l.renderingToTexture;\n          if (0 === s) return;\n          const h = t.conflationActive && t.layerUsedInConflation(o, i.getSource());\n          if (h && function (e, t, i, o) {\n            for (const r of o) {\n              const o = t.getTile(r).getBucket(i);\n              o && (o.updateReplacement(r, e.replacementSource), o.uploadCentroid(e.context));\n            }\n          }(t, i, o, r), l || h) for (const e of r) {\n            const r = i.getTile(e).getBucket(o);\n            r && cs(t.context, i, e, r, o, l, h);\n          }\n          if (\"shadow\" === t.renderPass && t.shadowRenderer) {\n            const n = t.shadowRenderer;\n            if (l && s < .65 && o._transitionablePaint._values[\"fill-extrusion-opacity\"].value.expression instanceof e.Z) return;\n            const a = n.getShadowPassDepthMode(),\n              c = n.getShadowPassColorMode();\n            as(t, i, o, r, a, Rt.disabled, c, h);\n          } else if (\"translucent\" === t.renderPass) {\n            const u = !o.paint.get(\"fill-extrusion-pattern\").constantOr(1),\n              d = o.paint.get(\"fill-extrusion-color\").constantOr(e.ax.white);\n            if (!c && 0 !== d.a) {\n              const e = new Lt(t.context.gl.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D);\n              1 === s && u ? as(t, i, o, r, e, Rt.disabled, Mt.unblended, h) : (as(t, i, o, r, e, Rt.disabled, Mt.disabled, h), as(t, i, o, r, e, t.stencilModeFor3D(), t.colorModeForRenderPass(), h), t.resetStencilClippingMasks());\n            }\n            if (t.style.enable3dLights() && u && (!l && \"globe\" !== t.transform.projection.name || c)) {\n              const s = o.paint.get(\"fill-extrusion-opacity\"),\n                u = o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"),\n                d = o.paint.get(\"fill-extrusion-ambient-occlusion-ground-radius\"),\n                _ = o.paint.get(\"fill-extrusion-flood-light-intensity\"),\n                p = o.paint.get(\"fill-extrusion-flood-light-color\").toArray01().slice(0, 3),\n                f = u > 0 && d > 0,\n                m = _ > 0,\n                g = (e, t, i) => (1 - i) * e + i * t,\n                v = n => {\n                  const l = t.depthModeForSublayer(1, Lt.ReadOnly, a.LEQUAL, !0),\n                    c = o.paint.get(n ? \"fill-extrusion-ambient-occlusion-ground-attenuation\" : \"fill-extrusion-flood-light-ground-attenuation\"),\n                    f = g(.1, 3, c),\n                    m = t._showOverdrawInspector;\n                  if (!m) {\n                    const c = new Rt({\n                        func: a.ALWAYS,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.KEEP, a.REPLACE),\n                      m = new Mt([a.ONE, a.ONE, a.ONE, a.ONE], e.ax.transparent, [!1, !1, !1, !0], a.MIN);\n                    ls(t, i, o, r, l, c, m, Ft.disabled, n, \"sdf\", s, u, d, _, p, f, h, !1);\n                  }\n                  {\n                    const c = m ? Rt.disabled : new Rt({\n                        func: a.EQUAL,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.DECR, a.DECR),\n                      g = m ? t.colorModeForRenderPass() : new Mt([a.ONE_MINUS_DST_ALPHA, a.DST_ALPHA, a.ONE, a.ONE], e.ax.transparent, [!0, !0, !0, !0]);\n                    ls(t, i, o, r, l, c, g, Ft.disabled, n, \"color\", s, u, d, _, p, f, h, !1);\n                  }\n                };\n              if (c) {\n                const c = (n, l, c) => {\n                  const f = t.depthModeForSublayer(1, Lt.ReadOnly, a.LEQUAL, !1),\n                    m = o.paint.get(n ? \"fill-extrusion-ambient-occlusion-ground-attenuation\" : \"fill-extrusion-flood-light-ground-attenuation\"),\n                    v = g(.1, 3, m);\n                  {\n                    const c = new Mt([a.ONE, a.ONE, a.ONE, a.ONE], e.ax.transparent, [!1, !1, !1, !0]);\n                    ls(t, i, o, r, f, Rt.disabled, c, Ft.disabled, n, \"clear\", s, u, d, _, p, v, h, l);\n                  }\n                  {\n                    const c = new Rt({\n                        func: a.ALWAYS,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.KEEP, a.REPLACE),\n                      m = new Mt([a.ONE, a.ONE, a.ONE, a.ONE], e.ax.transparent, [!1, !1, !1, !0], a.MIN);\n                    ls(t, i, o, r, f, c, m, Ft.disabled, n, \"sdf\", s, u, d, _, p, v, h, l);\n                  }\n                  {\n                    const c = n ? a.ZERO : a.ONE_MINUS_DST_ALPHA,\n                      m = new Rt({\n                        func: a.EQUAL,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.DECR, a.DECR),\n                      g = new Mt([c, a.DST_ALPHA, a.ONE_MINUS_DST_ALPHA, a.ZERO], e.ax.transparent, [!0, !0, !0, !0]);\n                    ls(t, i, o, r, f, m, g, Ft.disabled, n, \"color\", s, u, d, _, p, v, h, l);\n                  }\n                  {\n                    const m = new Mt([a.ONE, a.ONE, a.ONE, n ? a.ZERO : a.ONE], e.ax.transparent, [!1, !1, !1, !0], n ? a.FUNC_ADD : a.MAX);\n                    ls(t, i, o, r, f, Rt.disabled, m, Ft.disabled, n, \"clear\", s, u, d, _, p, v, h, l, c);\n                  }\n                };\n                if (f || m) {\n                  let i;\n                  if (t.prepareDrawTile(), l) {\n                    const t = l.drapeBufferSize[0],\n                      o = l.drapeBufferSize[1];\n                    i = l.framebufferCopyTexture, i && (!i || i.size[0] === t && i.size[1] === o) || (i && i.destroy(), i = l.framebufferCopyTexture = new e.T(n, new e.h({\n                      width: t,\n                      height: o\n                    }), a.RGBA)), i.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.copyTexImage2D(a.TEXTURE_2D, 0, a.RGBA, 0, 0, t, o, 0);\n                  }\n                  f && c(!0, !1, i), m && c(!1, !0, i);\n                }\n              } else f && v(!0), m && v(!1);\n            }\n          }\n        },\n        hillshade: function (e, t, i, o) {\n          if (\"offscreen\" !== e.renderPass && \"translucent\" !== e.renderPass) return;\n          if (e.style.disableElevatedTerrain) return;\n          const r = e.context,\n            s = e.terrain && e.terrain.renderingToTexture,\n            [n, a] = \"translucent\" !== e.renderPass || s ? [{}, o] : e.stencilConfigForOverlap(o);\n          for (const o of a) {\n            const r = t.getTile(o);\n            if (r.needsHillshadePrepare && \"offscreen\" === e.renderPass) or(e, r, i);else if (\"translucent\" === e.renderPass) {\n              const t = e.depthModeForSublayer(0, Lt.ReadOnly),\n                a = i.paint.get(\"hillshade-emissive-strength\"),\n                l = e.colorModeForDrapableLayerRenderPass(a),\n                c = s && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : n[o.overscaledZ];\n              tr(e, o, r, i, t, c, l);\n            }\n          }\n          r.viewport.set([0, 0, e.width, e.height]), e.resetStencilClippingMasks();\n        },\n        raster: function (t, i, o, r, s, n) {\n          if (\"translucent\" !== t.renderPass) return;\n          if (0 === o.paint.get(\"raster-opacity\")) return;\n          const a = \"globe\" === t.transform.projection.name,\n            l = 0 !== o.paint.get(\"raster-elevation\"),\n            c = l && a;\n          if (t.renderElevatedRasterBackface && !c) return;\n          const h = t.context,\n            u = h.gl,\n            d = i.getSource(),\n            _ = function (t, i, o, r) {\n              const s = i.paint.get(\"raster-color\"),\n                n = \"raster-array\" === t.type,\n                a = [],\n                l = i.paint.get(\"raster-resampling\"),\n                c = i.paint.get(\"raster-color-mix\");\n              let h = i.paint.get(\"raster-color-range\");\n              const u = [c[0], c[1], c[2], 0],\n                d = c[3];\n              let _ = \"nearest\" === l ? r.NEAREST : r.LINEAR;\n              if (n && (a.push(\"RASTER_ARRAY\"), s || a.push(\"RASTER_COLOR\"), \"linear\" === l && a.push(\"RASTER_ARRAY_LINEAR\"), _ = r.NEAREST, !h && t.rasterLayers)) {\n                const e = t.rasterLayers.find(({\n                  id: e\n                }) => e === i.sourceLayer);\n                e && e.fields && e.fields.range && (h = e.fields.range);\n              }\n              if (h = h || [0, 1], s) {\n                a.push(\"RASTER_COLOR\"), o.activeTexture.set(r.TEXTURE2), i.updateColorRamp(h);\n                let t = i.colorRampTexture;\n                t || (t = i.colorRampTexture = new e.T(o, i.colorRamp, r.RGBA)), t.bind(r.LINEAR, r.CLAMP_TO_EDGE);\n              }\n              return {\n                mix: u,\n                range: h,\n                offset: d,\n                defines: a,\n                resampling: _\n              };\n            }(d, o, h, u);\n          if (d instanceof e.ap && !r.length && !a) return;\n          const p = o.paint.get(\"raster-emissive-strength\"),\n            f = t.colorModeForDrapableLayerRenderPass(p),\n            m = t.terrain && t.terrain.renderingToTexture,\n            g = !t.options.moving,\n            v = \"nearest\" === o.paint.get(\"raster-resampling\") ? u.NEAREST : u.LINEAR;\n          if (d instanceof e.ap && !r.length && (d.onNorthPole || d.onSouthPole)) {\n            const e = l ? t.stencilModeFor3D() : Rt.disabled;\n            return void fs(!!d.onNorthPole, null, t, i, o, p, _, Ft.disabled, e);\n          }\n          if (!r.length) return;\n          const [x, y] = d instanceof e.ap || m ? [{}, r] : t.stencilConfigForOverlap(r),\n            b = y[y.length - 1].overscaledZ;\n          c && _.defines.push(\"PROJECTION_GLOBE_VIEW\"), l && _.defines.push(\"RENDER_CUTOFF\");\n          const w = (r, s, y) => {\n            for (const w of r) {\n              const r = w.toUnwrapped(),\n                T = i.getTile(w);\n              if (m && (!T || !T.hasData())) continue;\n              h.activeTexture.set(u.TEXTURE0);\n              const E = gs(T, d, o, _);\n              if (!E || !E.texture) continue;\n              const {\n                texture: S,\n                mix: C,\n                offset: I,\n                tileSize: D,\n                buffer: L\n              } = E;\n              let A, R;\n              m ? (A = Lt.disabled, R = w.projMatrix) : l ? (A = new Lt(u.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D), R = a ? Float32Array.from(t.transform.expandedFarZProjMatrix) : t.transform.calculateProjMatrix(r, g)) : (A = t.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get(\"raster-opacity\") ? Lt.ReadWrite : Lt.ReadOnly, u.LESS), R = t.transform.calculateProjMatrix(r, g));\n              const P = t.terrain && m ? t.terrain.stencilModeForRTTOverlap(w) : x[w.overscaledZ],\n                M = n ? 0 : o.paint.get(\"raster-fade-duration\");\n              T.registerFadeDuration(M);\n              const z = i.findLoadedParent(w, 0),\n                O = _r(T, z, i, t.transform, M);\n              let F, B;\n              t.terrain && t.terrain.prepareDrawTile(), h.activeTexture.set(u.TEXTURE0), S.bind(v, u.CLAMP_TO_EDGE), h.activeTexture.set(u.TEXTURE1), z ? (z.texture && z.texture.bind(v, u.CLAMP_TO_EDGE), F = Math.pow(2, z.tileID.overscaledZ - T.tileID.overscaledZ), B = [T.tileID.canonical.x * F % 1, T.tileID.canonical.y * F % 1]) : S.bind(v, u.CLAMP_TO_EDGE), S.useMipmap && h.extTextureFilterAnisotropic && t.transform.pitch > 20 && u.texParameterf(u.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);\n              const k = t.transform;\n              let N;\n              const U = l ? ms(k) : [0, 0, 0, 0];\n              let G,\n                j,\n                V,\n                Z,\n                H,\n                W = 0;\n              if (c && d instanceof e.ap && d.coordinates.length > 3) G = Float32Array.from(e.aT(e.ci(new e.bs(0, 0, 0)))), j = Float32Array.from(k.globeMatrix), V = Float32Array.from(e.ce(k)), Z = [e.a5(k.center.lng), e.ae(k.center.lat)], N = d.elevatedGlobePerspectiveTransform, H = d.elevatedGlobeGridMatrix || new Float32Array(9);else if (c) {\n                const t = e.cf(w.canonical);\n                W = e.cg(t.getCenter().lat), G = Float32Array.from(e.aT(e.ci(w.canonical))), j = Float32Array.from(k.globeMatrix), V = Float32Array.from(e.ce(k)), Z = [e.a5(k.center.lng), e.ae(k.center.lat)], N = [0, 0], H = Float32Array.from(e.ch(w.canonical, t, W, k.worldSize / k._pixelsPerMercatorPixel));\n              } else N = d instanceof e.ap ? d.perspectiveTransform : [0, 0], G = new Float32Array(16), j = new Float32Array(9), V = new Float32Array(16), Z = [0, 0], H = new Float32Array(9);\n              const q = Br(R, G, j, V, H, B || [0, 0], e.S(t.transform.zoom), Z, U, F || 1, O, o, N, l ? o.paint.get(\"raster-elevation\") : 0, 2, C, I, _.range, D, L, p),\n                $ = t.isTileAffectedByFog(w),\n                X = t.getOrCreateProgram(\"raster\", {\n                  defines: _.defines,\n                  overrideFog: $\n                });\n              if (t.uploadCommonUniforms(h, X, r), d instanceof e.ap) {\n                const i = d.elevatedGlobeVertexBuffer,\n                  r = d.elevatedGlobeIndexBuffer;\n                if (m || !a) d.boundsBuffer && d.boundsSegments && X.draw(t, u.TRIANGLES, A, Rt.disabled, f, Ft.disabled, q, o.id, d.boundsBuffer, t.quadTriangleIndexBuffer, d.boundsSegments);else if (i && r) {\n                  const n = k.zoom <= e.bG ? d.elevatedGlobeSegments : d.getSegmentsForLongitude(k.center.lng);\n                  n && X.draw(t, u.TRIANGLES, A, Rt.disabled, f, s, q, o.id, i, r, n);\n                }\n              } else if (c) {\n                A = new Lt(u.LEQUAL, Lt.ReadOnly, t.depthRangeFor3D);\n                const e = t.globeSharedBuffers;\n                if (e) {\n                  const [i, r, n] = e.getGridBuffers(W, !1);\n                  X.draw(t, u.TRIANGLES, A, y || P, t.colorModeForRenderPass(), s, q, o.id, i, r, n);\n                }\n              } else {\n                const {\n                  tileBoundsBuffer: e,\n                  tileBoundsIndexBuffer: i,\n                  tileBoundsSegments: r\n                } = t.getTileBoundsBuffers(T);\n                X.draw(t, u.TRIANGLES, A, P, f, Ft.disabled, q, o.id, e, i, r);\n              }\n            }\n            if (!(d instanceof e.ap) && c) for (const e of r) {\n              const r = e.canonical.y === (1 << e.canonical.z) - 1;\n              0 === e.canonical.y && fs(!0, e, t, i, o, p, _, s, y || Rt.disabled), r && fs(!1, e, t, i, o, p, _, s === Ft.frontCW ? Ft.backCW : Ft.frontCW, y || Rt.disabled);\n            }\n          };\n          c ? w(y, t.renderElevatedRasterBackface ? Ft.backCW : Ft.frontCW, t.stencilModeFor3D()) : w(y, Ft.disabled, void 0), t.resetStencilClippingMasks();\n        },\n        \"raster-particle\": function (t, i, o, r, s, n) {\n          \"offscreen\" === t.renderPass && function (t, i, o, r) {\n            if (!r.length) return;\n            const s = t.context,\n              n = s.gl,\n              a = i.getSource();\n            if (!(a instanceof ze)) return;\n            const l = [];\n            for (const e of r) {\n              const t = i.getTile(e);\n              if (!(t instanceof $t)) continue;\n              const r = vs(t, a, o);\n              if (!r) continue;\n              const n = [r.tileSize, r.tileSize];\n              let c = o.tileFramebuffer;\n              c || (c = o.tileFramebuffer = s.createFramebuffer(n[0], n[1], !0, null));\n              let h = t.rasterParticleState;\n              const u = o.paint.get(\"raster-particle-count\");\n              h || (h = t.rasterParticleState = new Nt(s, e, n, u));\n              const d = h.update(o.lastInvalidatedAt);\n              h.numParticles !== u && h.setNumParticles(e, u);\n              const _ = h.targetColorTexture;\n              h.targetColorTexture = h.backgroundColorTexture, h.backgroundColorTexture = _;\n              const p = h.particleVertices0;\n              h.particleVertices0 = h.particleVertices1, h.particleVertices1 = p, l.push([e, r, h, d]);\n            }\n            if (0 === l.length) return;\n            const c = e.f.now(),\n              h = o.previousDrawTimestamp ? .001 * (c - o.previousDrawTimestamp) : .0167;\n            if (o.previousDrawTimestamp = c, o.hasColorMap()) {\n              s.activeTexture.set(n.TEXTURE0 + 2);\n              let t = o.colorRampTexture;\n              t || (t = o.colorRampTexture = new e.T(s, o.colorRamp, n.RGBA)), t.bind(n.LINEAR, n.CLAMP_TO_EDGE);\n            }\n            s.bindFramebuffer.set(o.tileFramebuffer.framebuffer), s.activeTexture.set(n.TEXTURE0), function (t, i, o) {\n              const r = t.context,\n                s = r.gl,\n                n = i.tileFramebuffer;\n              r.activeTexture.set(s.TEXTURE0);\n              const a = {\n                  u_texture: 0,\n                  u_opacity: 1.05 * (c = i.paint.get(\"raster-particle-fade-opacity-factor\")) / (c + .05)\n                },\n                l = t.getOrCreateProgram(\"rasterParticleTexture\", {\n                  defines: [],\n                  overrideFog: !1\n                });\n              var c;\n              for (const c of o) {\n                const [,, o, h] = c;\n                n.colorAttachment.set(o.targetColorTexture.texture), r.viewport.set([0, 0, n.width, n.height]), r.clear({\n                  color: e.ax.transparent\n                }), h && (o.backgroundColorTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), l.draw(t, s.TRIANGLES, Lt.disabled, Rt.disabled, Mt.alphaBlended, Ft.disabled, a, i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments));\n              }\n            }(t, o, l), function (t, i, o, r) {\n              const s = t.context.gl,\n                n = o.tileFramebuffer,\n                a = \"globe\" === t.transform.projection.name,\n                l = o.paint.get(\"raster-particle-max-speed\");\n              for (const c of r) {\n                const [r, h, u] = c;\n                h.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE), n.colorAttachment.set(u.targetColorTexture.texture);\n                const d = t.getOrCreateProgram(\"rasterParticleDraw\", {\n                    defines: h.defines,\n                    overrideFog: !1\n                  }),\n                  _ = h.scalarData ? [] : [0, 1, 2, 3].map(t => e.cG[t](r));\n                _.push(r);\n                const p = r.canonical.x,\n                  f = r.canonical.y;\n                for (const e of _) {\n                  const n = i.getTile(a ? e.wrapped() : e);\n                  if (!n) continue;\n                  const c = n.rasterParticleState;\n                  if (!c) continue;\n                  const u = Ur([e.canonical.x + (1 << e.canonical.z) * (e.wrap - r.wrap) - p, e.canonical.y - f], 0, h.texture.size, 2, l, h.textureOffset, h.scale, h.offset);\n                  d.draw(t, s.POINTS, Lt.disabled, Rt.disabled, Mt.alphaBlended, Ft.disabled, u, o.id, c.particleVertices0, void 0, c.particleSegment);\n                }\n              }\n            }(t, i, o, l), function (e, t, i, o) {\n              const r = e.context.gl;\n              let s = t.transformFeedbackObject;\n              s || (s = t.transformFeedbackObject = r.createTransformFeedback()), r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, t.transformFeedbackObject);\n              const n = t.paint.get(\"raster-particle-max-speed\"),\n                a = o * t.paint.get(\"raster-particle-speed-factor\") * .3,\n                l = (c = t.paint.get(\"raster-particle-reset-rate-factor\"), Math.pow(c, 6));\n              var c;\n              for (const o of i) {\n                const [, i, s] = o;\n                i.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE);\n                const c = Gr(0, i.texture.size, n, a, l, i.textureOffset, i.scale, i.offset);\n                e.getOrCreateProgram(\"rasterParticleUpdate\", {\n                  defines: i.defines,\n                  transformFeedback: {\n                    bufferMode: r.SEPARATE_ATTRIBS,\n                    shaderVaryings: [\"v_new_particle\"]\n                  }\n                }).draw(e, r.POINTS, Lt.disabled, Rt.disabled, Mt.disabled, Ft.disabled, c, t.id, s.particleVertices0, void 0, s.particleSegment, {}, void 0, void 0, void 0, void 0, [{\n                  buffer: s.particleVertices1,\n                  targetIndex: 0\n                }]);\n              }\n              r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, null);\n            }(t, o, l, h);\n          }(t, i, o, r), \"translucent\" === t.renderPass && (function (t, i, o, r, s) {\n            const n = t.context,\n              a = n.gl,\n              l = !t.options.moving,\n              c = \"globe\" === t.transform.projection.name;\n            if (!r.length) return;\n            const [h, u] = t.stencilConfigForOverlap(r),\n              d = [];\n            c && d.push(\"PROJECTION_GLOBE_VIEW\");\n            for (const r of u) {\n              const s = r.toUnwrapped(),\n                u = i.getTile(r);\n              if (!u.rasterParticleState) continue;\n              const _ = u.rasterParticleState,\n                p = 100;\n              u.registerFadeDuration(p);\n              const f = i.findLoadedParent(r, 0),\n                m = _r(u, f, i, t.transform, p);\n              let g, v;\n              t.terrain && t.terrain.prepareDrawTile(), n.activeTexture.set(a.TEXTURE0), _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), n.activeTexture.set(a.TEXTURE1), f && f.rasterParticleState ? (f.rasterParticleState.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), g = Math.pow(2, f.tileID.overscaledZ - u.tileID.overscaledZ), v = [u.tileID.canonical.x * g % 1, u.tileID.canonical.y * g % 1]) : _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n              const x = c ? Float32Array.from(t.transform.expandedFarZProjMatrix) : t.transform.calculateProjMatrix(s, l),\n                y = t.transform,\n                b = xs(y),\n                w = e.cf(r.canonical),\n                T = e.cg(w.getCenter().lat);\n              let E, S, C, I, D;\n              c ? (E = Float32Array.from(e.aT(e.ci(r.canonical))), S = Float32Array.from(y.globeMatrix), C = Float32Array.from(e.ce(y)), I = [e.a5(y.center.lng), e.ae(y.center.lat)], D = Float32Array.from(e.ch(r.canonical, w, T, y.worldSize / y._pixelsPerMercatorPixel))) : (E = new Float32Array(16), S = new Float32Array(9), C = new Float32Array(16), I = [0, 0], D = new Float32Array(9));\n              const L = Nr(x, E, S, C, D, v || [0, 0], e.S(t.transform.zoom), I, b, g || 1, m, 250),\n                A = t.isTileAffectedByFog(r),\n                R = t.getOrCreateProgram(\"rasterParticle\", {\n                  defines: d,\n                  overrideFog: A\n                });\n              if (t.uploadCommonUniforms(n, R, s), c) {\n                const e = new Lt(a.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D),\n                  i = 0,\n                  r = t.globeSharedBuffers;\n                if (r) {\n                  const [s, n, l] = r.getGridBuffers(T, 0 !== i);\n                  R.draw(t, a.TRIANGLES, e, Rt.disabled, Mt.alphaBlended, Ft.backCCW, L, o.id, s, n, l);\n                }\n              } else {\n                const e = t.depthModeForSublayer(0, Lt.ReadOnly),\n                  i = h[r.overscaledZ],\n                  {\n                    tileBoundsBuffer: s,\n                    tileBoundsIndexBuffer: n,\n                    tileBoundsSegments: l\n                  } = t.getTileBoundsBuffers(u);\n                R.draw(t, a.TRIANGLES, e, i, Mt.alphaBlended, Ft.disabled, L, o.id, s, n, l);\n              }\n            }\n            t.resetStencilClippingMasks();\n          }(t, i, o, r), t.style.map.triggerRepaint());\n        },\n        background: function (e, t, i, o) {\n          const r = i.paint.get(\"background-color\"),\n            s = i.paint.get(\"background-opacity\"),\n            n = i.paint.get(\"background-emissive-strength\");\n          if (0 === s) return;\n          const a = e.context,\n            l = a.gl,\n            c = e.transform,\n            h = c.tileSize,\n            u = i.paint.get(\"background-pattern\");\n          if (e.isPatternMissing(u, i.scope)) return;\n          const d = !u && 1 === r.a && 1 === s && e.opaquePassEnabledForLayer() ? \"opaque\" : \"translucent\";\n          if (e.renderPass !== d) return;\n          const _ = Rt.disabled,\n            p = e.depthModeForSublayer(0, \"opaque\" === d ? Lt.ReadWrite : Lt.ReadOnly),\n            f = e.colorModeForDrapableLayerRenderPass(n),\n            m = u ? \"backgroundPattern\" : \"background\";\n          let g,\n            v = o;\n          v || (g = e.getBackgroundTiles(), v = Object.values(g).map(e => e.tileID)), u && (a.activeTexture.set(l.TEXTURE0), e.imageManager.bind(e.context, i.scope));\n          for (const d of v) {\n            const v = e.isTileAffectedByFog(d),\n              x = e.getOrCreateProgram(m, {\n                overrideFog: v\n              }),\n              y = d.toUnwrapped(),\n              b = o ? d.projMatrix : e.transform.calculateProjMatrix(y);\n            e.prepareDrawTile();\n            const w = t ? t.getTile(d) : g ? g[d.key] : new Gt(d, h, c.zoom, e),\n              T = u ? qr(b, n, s, e, u, i.scope, {\n                tileID: d,\n                tileSize: h\n              }) : Wr(b, n, s, r);\n            e.uploadCommonUniforms(a, x, y);\n            const {\n              tileBoundsBuffer: E,\n              tileBoundsIndexBuffer: S,\n              tileBoundsSegments: C\n            } = e.getTileBoundsBuffers(w);\n            x.draw(e, l.TRIANGLES, p, _, f, Ft.disabled, T, i.id, E, S, C);\n          }\n        },\n        sky: function (t, i, o) {\n          const r = t._atmosphere ? e.S(t.transform.zoom) : 1,\n            s = o.paint.get(\"sky-opacity\") * r;\n          if (0 === s) return;\n          const n = t.context,\n            a = o.paint.get(\"sky-type\"),\n            l = new Lt(n.gl.LEQUAL, Lt.ReadOnly, [0, 1]),\n            c = t.frameCounter / 1e3 % 1;\n          \"atmosphere\" === a ? \"offscreen\" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, r) {\n            const s = t.context,\n              n = s.gl;\n            let a = i.skyboxFbo;\n            if (!a) {\n              a = i.skyboxFbo = s.createFramebuffer(32, 32, !0, null), i.skyboxGeometry = new Ps(s), i.skyboxTexture = s.gl.createTexture(), n.bindTexture(n.TEXTURE_CUBE_MAP, i.skyboxTexture), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, n.LINEAR);\n              for (let e = 0; e < 6; ++e) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, n.RGBA, 32, 32, 0, n.RGBA, n.UNSIGNED_BYTE, null);\n            }\n            s.bindFramebuffer.set(a.framebuffer), s.viewport.set([0, 0, 32, 32]);\n            const l = i.getCenter(t, !0),\n              c = t.getOrCreateProgram(\"skyboxCapture\"),\n              h = new Float64Array(16);\n            e.a6.identity(h), e.a6.rotateY(h, h, .5 * -Math.PI), Ms(t, i, c, h, l, 0), e.a6.identity(h), e.a6.rotateY(h, h, .5 * Math.PI), Ms(t, i, c, h, l, 1), e.a6.identity(h), e.a6.rotateX(h, h, .5 * -Math.PI), Ms(t, i, c, h, l, 2), e.a6.identity(h), e.a6.rotateX(h, h, .5 * Math.PI), Ms(t, i, c, h, l, 3), e.a6.identity(h), Ms(t, i, c, h, l, 4), e.a6.identity(h), e.a6.rotateY(h, h, Math.PI), Ms(t, i, c, h, l, 5), s.viewport.set([0, 0, t.width, t.height]);\n          }(t, o), o.markSkyboxValid(t)) : \"sky\" === t.renderPass && function (e, t, i, o, r) {\n            const s = e.context,\n              n = s.gl,\n              a = e.transform,\n              l = e.getOrCreateProgram(\"skybox\");\n            s.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_CUBE_MAP, t.skyboxTexture);\n            const c = ((e, t, i, o, r) => ({\n              u_matrix: e,\n              u_sun_direction: t,\n              u_cubemap: 0,\n              u_opacity: o,\n              u_temporal_offset: r\n            }))(a.skyboxMatrix, t.getCenter(e, !1), 0, o, r);\n            e.uploadCommonUniforms(s, l), l.draw(e, n.TRIANGLES, i, Rt.disabled, e.colorModeForRenderPass(), Ft.backCW, c, \"skybox\", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);\n          }(t, o, l, s, c) : \"gradient\" === a && \"sky\" === t.renderPass && function (t, i, o, r, s) {\n            const n = t.context,\n              a = n.gl,\n              l = t.transform,\n              c = t.getOrCreateProgram(\"skyboxGradient\");\n            i.skyboxGeometry || (i.skyboxGeometry = new Ps(n)), n.activeTexture.set(a.TEXTURE0);\n            let h = i.colorRampTexture;\n            h || (h = i.colorRampTexture = new e.T(n, i.colorRamp, a.RGBA)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n            const u = ((t, i, o, r, s) => ({\n              u_matrix: t,\n              u_color_ramp: 0,\n              u_center_direction: i,\n              u_radius: e.bj(o),\n              u_opacity: r,\n              u_temporal_offset: s\n            }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get(\"sky-gradient-radius\"), r, s);\n            t.uploadCommonUniforms(n, c), c.draw(t, a.TRIANGLES, o, Rt.disabled, t.colorModeForRenderPass(), Ft.backCW, u, \"skyboxGradient\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n          }(t, o, l, s, c);\n        },\n        debug: function (t, i, o, r, s, n) {\n          for (let a = 0; a < o.length; a++) if (s) {\n            const s = 1,\n              l = .8,\n              c = new e.ax(r.r * l, r.g * l, r.b * l, 1);\n            Ss(t, i, o[a], r, -s, -s, n), Ss(t, i, o[a], r, -s, s, n), Ss(t, i, o[a], r, s, s, n), Ss(t, i, o[a], r, s, -s, n), Ss(t, i, o[a], c, 0, 0, n);\n          } else Ss(t, i, o[a], r, 0, 0, n);\n        },\n        custom: function (t, i, o, r) {\n          const s = t.context,\n            n = o.implementation;\n          if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(\"custom\") || t.terrain && (t.terrain.renderingToTexture || \"offscreen\" === t.renderPass) && o.isLayerDraped(i)) {\n            if (\"offscreen\" === t.renderPass) {\n              const i = n.prerender;\n              if (i) {\n                if (t.setCustomLayerDefaults(), s.setColorMode(t.colorModeForRenderPass()), \"globe\" === t.transform.projection.name) {\n                  const o = t.transform.pointMerc;\n                  i.call(n, s.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.S(t.transform.zoom), [o.x, o.y], t.transform.pixelsPerMeterRatio);\n                } else i.call(n, s.gl, t.transform.customLayerMatrix());\n                s.setDirty(), t.setBaseState();\n              }\n            } else if (\"translucent\" === t.renderPass) {\n              if (t.terrain && t.terrain.renderingToTexture) {\n                const i = n.renderToTile;\n                if (i) {\n                  const o = r[0].canonical,\n                    a = new e.L(o.x + r[0].wrap * (1 << o.z), o.y, o.z);\n                  s.setDepthMode(Lt.disabled), s.setStencilMode(Rt.disabled), s.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), i.call(n, s.gl, a), s.setDirty(), t.setBaseState();\n                }\n                return;\n              }\n              t.setCustomLayerDefaults(), s.setColorMode(t.colorModeForRenderPass()), s.setStencilMode(Rt.disabled);\n              const i = \"3d\" === n.renderingMode ? new Lt(t.context.gl.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, Lt.ReadOnly);\n              if (s.setDepthMode(i), \"globe\" === t.transform.projection.name) {\n                const i = t.transform.pointMerc;\n                n.render(s.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.S(t.transform.zoom), [i.x, i.y], t.transform.pixelsPerMeterRatio);\n              } else n.render(s.gl, t.transform.customLayerMatrix());\n              s.setDirty(), t.setBaseState(), s.bindFramebuffer.set(null);\n            }\n          } else e.w(\"Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.\");\n        },\n        model: function (t, i, o, r) {\n          if (\"opaque\" === t.renderPass) return;\n          const s = o.paint.get(\"model-opacity\");\n          if (0 === s) return;\n          const n = o.paint.get(\"model-cast-shadows\");\n          if (\"shadow\" === t.renderPass) {\n            if (!n) return;\n            if (t.terrain && s < .65 && o._transitionablePaint._values[\"model-opacity\"].value.expression instanceof e.Z) return;\n          }\n          const a = t.shadowRenderer,\n            l = o.paint.get(\"model-receive-shadows\");\n          a && (a.useNormalOffset = !0, l || (a.enabled = !1));\n          const c = () => {\n              a && (a.useNormalOffset = !0, l || (a.enabled = !0));\n            },\n            h = i.getSource();\n          if (\"light-beam\" === t.renderPass && \"batched-model\" !== h.type) return;\n          if (\"vector\" === h.type || \"geojson\" === h.type) return function (t, i, o, r) {\n            const s = t.transform;\n            if (\"mercator\" !== s.projection.name) return void e.w(`Drawing 3D models for ${s.projection.name} projection is not yet implemented`);\n            const n = s.getFreeCameraOptions().position;\n            if (!t.modelManager) return;\n            const a = t.modelManager;\n            o.modelManager = a;\n            const l = t.shadowRenderer;\n            if (!o._unevaluatedLayout._values.hasOwnProperty(\"model-id\")) return;\n            const c = o._unevaluatedLayout._values[\"model-id\"],\n              h = {\n                ...o.layout.get(\"model-id\").parameters\n              };\n            for (const u of r) {\n              const r = i.getTile(u).getBucket(o);\n              if (!r || r.projection.name !== s.projection.name) continue;\n              const d = Ws(u, s);\n              h.zoom = d;\n              const _ = c.possiblyEvaluate(h);\n              if (Zs(t, r, u), Hs.shadowUniformsInitialized = !1, Hs.useSingleShadowCascade = !!l && 0 === l.getMaxCascadeForTile(u.toUnwrapped()), \"shadow\" === t.renderPass && l) {\n                if (1 === t.currentShadowCascade && r.isInsideFirstShadowMapFrustum) continue;\n                const i = s.calculatePosMatrix(u.toUnwrapped(), s.worldSize);\n                if (Hs.tileMatrix.set(i), Hs.shadowTileMatrix = Float32Array.from(l.calculateShadowPassMatrixFromMatrix(i)), Hs.aabb.min.fill(0), Hs.aabb.max[0] = Hs.aabb.max[1] = e.V, Hs.aabb.max[2] = 0, Xs(r, Hs, t, o.scope)) continue;\n              }\n              const p = 1 << u.canonical.z,\n                f = [((n.x - u.wrap) * p - u.canonical.x) * e.V, (n.y * p - u.canonical.y) * e.V, n.z * p * e.V];\n              for (let e in r.instancesPerModel) {\n                const i = r.instancesPerModel[e];\n                i.features.length > 0 && (e = _.evaluate(i.features[0].feature, {}));\n                const s = a.getModel(e, o.scope);\n                if (s && s.uploaded) for (const e of s.nodes) qs(t, o, e, i, f, u, Hs);\n              }\n            }\n          }(t, i, o, r), void c();\n          if (!h.loaded()) return;\n          if (\"batched-model\" === h.type) return function (t, i, o, r) {\n            o.resetLayerRenderingStats(t);\n            const s = t.context,\n              n = t.transform,\n              a = t.style.fog,\n              l = t.shadowRenderer;\n            if (\"mercator\" !== n.projection.name) return void e.w(`Drawing 3D landmark models for ${n.projection.name} projection is not yet implemented`);\n            const c = t.transform.getFreeCameraOptions().position,\n              h = e.N.scale([], [c.x, c.y, c.z], t.transform.worldSize);\n            e.N.negate(h, h);\n            const u = e.a6.identity([]),\n              d = e.cR(n.center.lat, n.zoom),\n              _ = e.a6.fromScaling([], [1, 1, 1 / d]);\n            e.a6.translate(u, u, h);\n            const p = o.paint.get(\"model-opacity\"),\n              f = new Lt(s.gl.LEQUAL, Lt.ReadWrite, t.depthRangeFor3D),\n              m = new Lt(s.gl.LEQUAL, Lt.ReadOnly, t.depthRangeFor3D),\n              g = new e.bS([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]),\n              v = \"shadow\" === t.renderPass,\n              x = v && l ? l.getCurrentCascadeFrustum() : n.getFrustum(n.scaleZoom(n.worldSize)),\n              y = o.getLayerRenderingStats(),\n              b = function (c, h) {\n                for (const d of r) {\n                  const r = i.getTile(d).getBucket(o);\n                  if (!r || !r.uploaded) continue;\n                  let b = !1;\n                  l && (b = 0 === l.getMaxCascadeForTile(d.toUnwrapped()));\n                  const w = n.calculatePosMatrix(d.toUnwrapped(), n.worldSize),\n                    T = r.modelTraits;\n                  for (const i of r.getNodesInfo()) {\n                    if (i.hiddenByReplacement) continue;\n                    if (!i.node.meshes) continue;\n                    const r = i.evaluatedScale,\n                      E = i.node;\n                    let S = 0;\n                    if (t.terrain && E.elevation && (S = E.elevation * t.terrain.exaggeration()), r[0] <= 1 && r[1] <= 1 && r[2] <= 1 && 0 === (() => {\n                      const t = i.getLocalBounds();\n                      return g.min = [...t.min], g.max = [...t.max], g.min[2] += S, g.max[2] += S, e.N.transformMat4(g.min, g.min, w), e.N.transformMat4(g.max, g.max, w), g;\n                    })().intersects(x)) continue;\n                    const C = \"light-beam\" === t.renderPass,\n                      I = [...w];\n                    e.a6.translate(I, I, [(E.anchor ? E.anchor[0] : 0) * (r[0] - 1), (E.anchor ? E.anchor[1] : 0) * (r[1] - 1), S]), e.N.exactEquals(r, e.cT) || e.a6.scale(I, I, r), e.a6.multiply(I, I, E.matrix);\n                    const D = e.a6.multiply([], _, I);\n                    e.a6.multiply(D, u, D);\n                    const L = e.a6.invert([], D);\n                    e.a6.transpose(L, L), e.a6.scale(L, L, $s);\n                    const A = e.a6.multiply([], n.expandedFarZProjMatrix, I),\n                      R = T & e.cV.HasMapboxMeshFeatures,\n                      P = R ? 0 : i.evaluatedRMEA[0][2];\n                    for (let e = 0; e < E.meshes.length; ++e) {\n                      const r = E.meshes[e],\n                        u = e === E.lightMeshIndex;\n                      if (u) {\n                        if (!C && !t.terrain && t.shadowRenderer) {\n                          t.currentLayer < t.firstLightBeamLayer && (t.firstLightBeamLayer = t.currentLayer);\n                          continue;\n                        }\n                      } else if (C) continue;\n                      const _ = {\n                          defines: []\n                        },\n                        g = [];\n                      if (Us(_.defines, g, r, t), R || _.defines.push(\"DIFFUSE_SHADED\"), b && _.defines.push(\"SHADOWS_SINGLE_CASCADE\"), y && (v ? y.numRenderedVerticesInShadowPass += r.vertexArray.length : y.numRenderedVerticesInTransparentPass += r.vertexArray.length), v) {\n                        Vs(r, I, t, o);\n                        continue;\n                      }\n                      let x = null;\n                      if (a) {\n                        const e = Ns(I, t.transform);\n                        if (x = new Float32Array(e), \"globe\" !== n.projection.name) {\n                          const t = r.aabb.min,\n                            i = r.aabb.max,\n                            [o, s] = a.getOpacityForBounds(e, t[0], t[1], i[0], i[1]);\n                          _.overrideFog = o >= me || s >= me;\n                        }\n                      }\n                      const w = r.material;\n                      let T;\n                      w.occlusionTexture && w.occlusionTexture.offsetScale && (T = w.occlusionTexture.offsetScale, _.defines.push(\"OCCLUSION_TEXTURE_TRANSFORM\")), !v && l && (l.useNormalOffset = !!r.normalBuffer);\n                      const S = t.getOrCreateProgram(\"model\", _);\n                      !v && l && l.setupShadowsFromMatrix(I, S, l.useNormalOffset), t.uploadCommonUniforms(s, S, d.toUnwrapped(), x);\n                      const M = w.pbrMetallicRoughness;\n                      M.metallicFactor = .9, M.roughnessFactor = .5;\n                      const z = $r(new Float32Array(A), new Float32Array(D), new Float32Array(L), t, p, M.baseColorFactor, w.emissiveFactor, M.metallicFactor, M.roughnessFactor, w, P, o, [0, 0, 0], T);\n                      S.draw(t, s.gl.TRIANGLES, h && !u ? f : m, Rt.disabled, c ? u || p < 1 || i.hasTranslucentParts ? Mt.alphaBlended : Mt.unblended : Mt.disabled, Ft.backCCW, z, o.id, r.vertexBuffer, r.indexBuffer, r.segments, o.paint, t.transform.zoom, void 0, g);\n                    }\n                  }\n                }\n              };\n            (function (e, t, i, o) {\n              const r = e.terrain ? e.terrain.exaggeration() : 0,\n                s = e.transform.zoom;\n              for (const n of o) {\n                const o = t.getTile(n).getBucket(i);\n                o && (e.conflationActive && o.updateReplacement(n, e.replacementSource), o.evaluateScale(e, i), e.terrain && r > 0 && o.elevationUpdate(e.terrain, r, n, i.source), o.needsReEvaluation(e, s, i) && o.evaluate(i));\n              }\n            })(t, i, o, r), 1 === p ? b(!0, !0) : (b(!1, !0), b(!0, !1));\n          }(t, i, o, r), void c();\n          const u = h.getModels(),\n            d = [],\n            _ = t.transform.getFreeCameraOptions().position,\n            p = e.N.scale([], [_.x, _.y, _.z], t.transform.worldSize);\n          e.N.negate(p, p);\n          const f = [],\n            m = [];\n          let g = 0;\n          for (const i of u) {\n            const r = o.paint.get(\"model-rotation\").constantOr(null),\n              s = o.paint.get(\"model-scale\").constantOr(null),\n              n = o.paint.get(\"model-translation\").constantOr(null);\n            i.computeModelMatrix(t, r, s, n, !0, !0, !1);\n            const a = e.a6.identity([]),\n              l = e.cR(i.position.lat, t.transform.zoom),\n              c = e.a6.fromScaling([], [1, 1, 1 / l]);\n            e.a6.translate(a, a, p), d.push({\n              zScaleMatrix: c,\n              negCameraPosMatrix: a\n            });\n            for (const e of i.nodes) js(t.transform, e, i.matrix, t.transform.expandedFarZProjMatrix, g, f, m);\n            g++;\n          }\n          if (f.sort((e, t) => t.depth - e.depth), \"shadow\" !== t.renderPass) {\n            if (1 === s) for (const e of m) Gs(e, t, o, d[e.modelIndex], Rt.disabled, t.colorModeForRenderPass());else {\n              for (const e of m) Gs(e, t, o, d[e.modelIndex], Rt.disabled, Mt.disabled);\n              for (const e of m) Gs(e, t, o, d[e.modelIndex], t.stencilModeFor3D(), t.colorModeForRenderPass());\n              t.resetStencilClippingMasks();\n            }\n            for (const e of f) Gs(e, t, o, d[e.modelIndex], Rt.disabled, t.colorModeForRenderPass());\n            c();\n          } else {\n            for (const e of m) Vs(e.mesh, e.nodeModelMatrix, t, o);\n            for (const e of f) Vs(e.mesh, e.nodeModelMatrix, t, o);\n            c();\n          }\n        }\n      },\n      en = {\n        model: function (e, t, i) {\n          const o = e.scope,\n            r = t.getSource();\n          if (!r.loaded()) return;\n          if (\"vector\" === r.type || \"geojson\" === r.type) return void (i.modelManager && i.modelManager.upload(i, o));\n          if (\"batched-model\" === r.type) return;\n          const s = r.getModels();\n          for (const e of s) e.upload(i.context);\n        },\n        raster: function (e, t, i) {\n          const o = t.getSource();\n          if (!(o instanceof ze && o.loaded())) return;\n          const r = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];\n          if (!r) return;\n          const s = e.paint.get(\"raster-array-band\") || o.getInitialBand(r);\n          if (null == s) return;\n          const n = t.getIds().map(e => t.getTileByID(e));\n          for (const e of n) e.updateNeeded(r, s) && o.prepareTile(e, r, s);\n        },\n        \"raster-particle\": function (e, t, i) {\n          const o = t.getSource();\n          if (!(o instanceof ze && o.loaded())) return;\n          const r = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];\n          if (!r) return;\n          const s = e.paint.get(\"raster-particle-array-band\") || o.getInitialBand(r);\n          if (null == s) return;\n          const n = t.getIds().map(e => t.getTileByID(e));\n          for (const e of n) e.updateNeeded(r, s) && o.prepareTile(e, r, s);\n        }\n      };\n    class tn {\n      constructor(t, i, o, r) {\n        this.context = new Bt(t, i), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r, this._debugParams = {\n          showTerrainProxyTiles: !1\n        }, r.registerParameter(this._debugParams, [\"Terrain\"], \"showTerrainProxyTiles\", {}, () => {\n          this.style.map.triggerRepaint();\n        }), this.setup(), this.numSublayers = Kt.maxUnderzooming + Kt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.cX(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new wo(this), this._wireframeDebugCache = new Ys(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0;\n      }\n      updateTerrain(e, t) {\n        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;\n        if (!(i || this._terrain && this._terrain.enabled)) return;\n        this._terrain || (this._terrain = new gr(this, e));\n        const o = this._terrain;\n        this.transform.elevation = i ? o : null, o.update(e, this.transform, t), this.transform.elevation && !o.enabled && (this.transform.elevation = null);\n      }\n      _updateFog(e) {\n        const t = e.fog;\n        if (!t || \"globe\" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get(\"horizon-blend\") < .03) return void (this.transform.fogCullDistSq = null);\n        const [i, o] = t.getFovAdjustedRange(this.transform._fov);\n        if (i > o) return void (this.transform.fogCullDistSq = null);\n        const r = i + .78 * (o - i);\n        this.transform.fogCullDistSq = r * r;\n      }\n      get terrain() {\n        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;\n      }\n      get shadowRenderer() {\n        return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;\n      }\n      get wireframeDebugCache() {\n        return this._wireframeDebugCache;\n      }\n      resize(t, i) {\n        if (this.width = t * e.f.devicePixelRatio, this.height = i * e.f.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._mergedLayers[e].resize();\n      }\n      setup() {\n        const t = this.context,\n          i = new e.aN();\n        i.emplaceBack(0, 0), i.emplaceBack(e.V, 0), i.emplaceBack(0, e.V), i.emplaceBack(e.V, e.V), this.tileExtentBuffer = t.createVertexBuffer(i, e.aP.members), this.tileExtentSegments = e.aB.simpleSegment(0, 0, 4, 2);\n        const o = new e.aN();\n        o.emplaceBack(0, 0), o.emplaceBack(e.V, 0), o.emplaceBack(0, e.V), o.emplaceBack(e.V, e.V), this.debugBuffer = t.createVertexBuffer(o, e.aP.members), this.debugSegments = e.aB.simpleSegment(0, 0, 4, 5);\n        const r = new e.aN();\n        r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.aP.members), this.viewportSegments = e.aB.simpleSegment(0, 0, 4, 2);\n        const s = new e.av();\n        s.emplaceBack(0, 0, 0, 0), s.emplaceBack(e.V, 0, e.V, 0), s.emplaceBack(0, e.V, 0, e.V), s.emplaceBack(e.V, e.V, e.V, e.V), this.mercatorBoundsBuffer = t.createVertexBuffer(s, e.aR.members), this.mercatorBoundsSegments = e.aB.simpleSegment(0, 0, 4, 2);\n        const n = new e.aw();\n        n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(n);\n        const a = new e.aO();\n        for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e);\n        this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.T(t, new e.h({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.a6.create();\n        const l = this.context.gl;\n        this.stencilClearMode = new Rt({\n          func: l.ALWAYS,\n          mask: 0\n        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());\n      }\n      getMercatorTileBoundsBuffers() {\n        return {\n          tileBoundsBuffer: this.mercatorBoundsBuffer,\n          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,\n          tileBoundsSegments: this.mercatorBoundsSegments\n        };\n      }\n      getTileBoundsBuffers(e) {\n        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {\n          tileBoundsBuffer: e._tileBoundsBuffer,\n          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,\n          tileBoundsSegments: e._tileBoundsSegments\n        } : this.getMercatorTileBoundsBuffers();\n      }\n      clearStencil() {\n        const e = this.context.gl;\n        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram(\"clippingMask\").draw(this, e.TRIANGLES, Lt.disabled, this.stencilClearMode, Mt.disabled, Ft.disabled, dr(this.identityMat), \"$clipping\", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n      }\n      resetStencilClippingMasks() {\n        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});\n      }\n      _renderTileClippingMasks(e, t, i) {\n        if (!t || this.currentStencilSource === t.id || !e.isTileClipped() || !i || 0 === i.length) return;\n        if (this._tileClippingMaskIDs && !this.terrain) {\n          let e = !1;\n          for (const t of i) if (void 0 === this._tileClippingMaskIDs[t.key]) {\n            e = !0;\n            break;\n          }\n          if (!e) return;\n        }\n        this.currentStencilSource = t.id;\n        const o = this.context,\n          r = o.gl;\n        this.nextStencilID + i.length > 256 && this.clearStencil(), o.setColorMode(Mt.disabled), o.setDepthMode(Lt.disabled);\n        const s = this.getOrCreateProgram(\"clippingMask\");\n        this._tileClippingMaskIDs = {};\n        for (const e of i) {\n          const i = t.getTile(e),\n            o = this._tileClippingMaskIDs[e.key] = this.nextStencilID++,\n            {\n              tileBoundsBuffer: n,\n              tileBoundsIndexBuffer: a,\n              tileBoundsSegments: l\n            } = this.getTileBoundsBuffers(i);\n          s.draw(this, r.TRIANGLES, Lt.disabled, new Rt({\n            func: r.ALWAYS,\n            mask: 0\n          }, o, 255, r.KEEP, r.KEEP, r.REPLACE), Mt.disabled, Ft.disabled, dr(e.projMatrix), \"$clipping\", n, a, l);\n        }\n      }\n      stencilModeFor3D() {\n        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n        const e = this.nextStencilID++,\n          t = this.context.gl;\n        return new Rt({\n          func: t.NOTEQUAL,\n          mask: 255\n        }, e, 255, t.KEEP, t.KEEP, t.REPLACE);\n      }\n      stencilModeForClipping(e) {\n        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e);\n        const t = this.context.gl;\n        return new Rt({\n          func: t.EQUAL,\n          mask: 255\n        }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);\n      }\n      stencilConfigForOverlap(e) {\n        const t = this.context.gl,\n          i = e.sort((e, t) => t.overscaledZ - e.overscaledZ),\n          o = i[i.length - 1].overscaledZ,\n          r = i[0].overscaledZ - o + 1;\n        if (r > 1) {\n          this.currentStencilSource = void 0, this.nextStencilID + r > 256 && this.clearStencil();\n          const e = {};\n          for (let i = 0; i < r; i++) e[i + o] = new Rt({\n            func: t.GEQUAL,\n            mask: 255\n          }, i + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);\n          return this.nextStencilID += r, [e, i];\n        }\n        return [{\n          [o]: Rt.disabled\n        }, i];\n      }\n      colorModeForRenderPass() {\n        const t = this.context.gl;\n        if (this._showOverdrawInspector) {\n          const i = 1 / 8;\n          return new Mt([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new e.ax(i, i, i, 0), [!0, !0, !0, !0]);\n        }\n        return \"opaque\" === this.renderPass ? Mt.unblended : Mt.alphaBlended;\n      }\n      colorModeForDrapableLayerRenderPass(t) {\n        const i = this.context.gl;\n        return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && \"translucent\" === this.renderPass ? new Mt([i.ONE, i.ONE_MINUS_SRC_ALPHA, i.CONSTANT_ALPHA, i.ONE_MINUS_SRC_ALPHA], new e.ax(0, 0, 0, void 0 === t ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();\n      }\n      depthModeForSublayer(e, t, i, o = !1) {\n        if (!this.opaquePassEnabledForLayer() && !o) return Lt.disabled;\n        const r = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;\n        return new Lt(i || this.context.gl.LEQUAL, t, [r, r]);\n      }\n      opaquePassEnabledForLayer() {\n        return this.currentLayer < this.opaquePassCutoff;\n      }\n      render(t, i) {\n        this._wireframeDebugCache.update(this.frameCounter), this.style = t, this.options = i;\n        const o = this.style._mergedLayers,\n          r = this.style.order,\n          s = r.map(e => o[e]),\n          n = this.style._mergedSourceCaches;\n        this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.f.now()), this.imageManager.beginFrame();\n        let a = 0,\n          l = !1;\n        for (const e in n) {\n          const t = n[e];\n          t.used && (t.prepare(this.context), t.getSource().usedInConflation && ++a);\n        }\n        for (const e of s) e.isHidden(this.transform.zoom) || this.prepareLayer(e);\n        const c = {},\n          h = {},\n          u = {},\n          d = {},\n          _ = {};\n        for (const e in n) {\n          const t = n[e];\n          c[e] = t.getVisibleCoordinates(), h[e] = c[e].slice().reverse(), u[e] = t.getVisibleCoordinates(!0).reverse(), d[e] = t.getShadowCasterCoordinates(), _[e] = t.sortCoordinatesByDistance(c[e]);\n        }\n        const p = e => {\n          const t = this.style.getLayerSourceCache(e);\n          return t && t.used ? t.getSource() : null;\n        };\n        if (a) {\n          const e = [];\n          for (const t of s) this.layerUsedInConflation(t, p(t)) && e.push(t);\n          if (e && e.length > 1) {\n            const t = [];\n            for (const i of e) {\n              const e = this.style.getLayerSourceCache(i);\n              e && e.used && e.getSource().usedInConflation && t.push({\n                layer: i.fqid,\n                cache: e\n              });\n            }\n            this.replacementSource.setSources(t), l = !0;\n          }\n        }\n        l || this.replacementSource.clear(), this.conflationActive = l, this.minCutoffZoom = 0, this.longestCutoffRange = 0;\n        for (const e of s) {\n          const t = e.cutoffRange();\n          if (this.longestCutoffRange = Math.max(t, this.longestCutoffRange), t > 0) {\n            const t = p(e);\n            t && (this.minCutoffZoom = Math.max(t.minzoom, this.minCutoffZoom)), e.minzoom && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom));\n          }\n        }\n        this.opaquePassCutoff = 1 / 0;\n        for (let e = 0; e < s.length; e++) if (s[e].is3D()) {\n          this.opaquePassCutoff = e;\n          break;\n        }\n        const f = this.style && this.style.fog;\n        f ? (this._fogVisible = 0 !== f.getOpacity(this.transform.pitch), this._fogVisible && \"globe\" !== this.transform.projection.name && (this._fogVisible = f.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(u), this.opaquePassCutoff = 0);\n        const m = this._shadowRenderer;\n        if (m) {\n          m.updateShadowParameters(this.transform, this.style.directionalLight);\n          for (const e in n) for (const t of c[e]) {\n            let e = {\n              min: 0,\n              max: 0\n            };\n            this.terrain && (e = this.terrain.getMinMaxForTile(t) || e), m.addShadowReceiver(t.toUnwrapped(), e.min, e.max);\n          }\n        }\n        if (\"globe\" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.cY(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new ks(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !e.cZ(this.context.gl)) return;\n        this.renderPass = \"offscreen\";\n        for (const e of s) {\n          const i = t.getLayerSourceCache(e);\n          if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;\n          const o = i ? h[i.id] : void 0;\n          (\"custom\" === e.type || \"raster\" === e.type || \"raster-particle\" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);\n        }\n        this.depthRangeFor3D = [0, 1 - (s.length + 2) * this.numSublayers * this.depthEpsilon];\n        const g = this.terrain;\n        g && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && !this.transform.isOrthographic && g.drawDepth(), this._shadowRenderer && (this.renderPass = \"shadow\", this._shadowRenderer.drawShadowPass(this.style, d)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);\n        const v = \"globe\" === this.transform.projection.name || this.transform.isHorizonVisible(),\n          x = (() => {\n            if (i.showOverdrawInspector) return e.ax.black;\n            if (this.style.fog && this.transform.projection.supportsFog && !v) {\n              const t = this.style.fog.properties.get(\"color\").toArray01();\n              return new e.ax(...t);\n            }\n            if (this.style.fog && this.transform.projection.supportsFog && v) {\n              const t = this.style.fog.properties.get(\"space-color\").toArray01();\n              return new e.ax(...t);\n            }\n            return e.ax.transparent;\n          })();\n        if (this.context.clear({\n          color: x,\n          depth: 1\n        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = \"opaque\", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n          const e = s[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          if (e.isSky()) continue;\n          const o = i ? (e.is3D() ? _ : h)[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);\n        }\n        if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = \"sky\", (!this._atmosphere || e.S(this.transform.zoom) > 0) && (\"globe\" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {\n          const e = s[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          e.isSky() && this.renderLayer(this, i, e, i ? h[i.id] : void 0);\n        }\n        function y(e, t) {\n          let i;\n          return t && (i = (\"symbol\" === e.type ? u : e.is3D() ? _ : h)[t.id]), i;\n        }\n        if (this.renderPass = \"translucent\", \"globe\" === this.transform.projection.name) {\n          for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < r.length;) {\n            const e = s[this.currentLayer];\n            if (\"raster\" === e.type) {\n              const i = t.getLayerSourceCache(e);\n              this.renderLayer(this, i, e, y(e, i));\n            }\n            ++this.currentLayer;\n          }\n          this.renderElevatedRasterBackface = !1;\n        }\n        this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;\n        let b = 0;\n        for (m && (b = m.getShadowCastingLayerCount()); this.currentLayer < r.length;) {\n          const e = s[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          if (e.isSky()) ++this.currentLayer;else if (g && this.style.isLayerDraped(e)) {\n            if (e.isHidden(this.transform.zoom)) {\n              ++this.currentLayer;\n              continue;\n            }\n            this.currentLayer = g.renderBatch(this.currentLayer);\n          } else {\n            if (this._renderTileClippingMasks(e, i, i ? c[i.id] : void 0), this.renderLayer(this, i, e, y(e, i)), !g && m && b > 0 && e.hasShadowPass() && 0 == --b && (m.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {\n              const e = this.currentLayer;\n              for (this.renderPass = \"light-beam\", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++) {\n                const e = s[this.currentLayer];\n                if (!e.hasLightBeamPass()) continue;\n                const i = t.getLayerSourceCache(e);\n                this.renderLayer(this, i, e, i ? h[i.id] : void 0);\n              }\n              this.currentLayer = e, this.renderPass = \"translucent\";\n            }\n            ++this.currentLayer;\n          }\n        }\n        if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {\n          let i = null;\n          s.forEach(e => {\n            const o = t.getLayerSourceCache(e);\n            o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);\n          }), i && this.options.showTileBoundaries && Qs.debug(this, i, i.getVisibleCoordinates(), e.ax.red, !1, this.options.showParseStatus);\n        }\n        this.terrain && this._debugParams.showTerrainProxyTiles && Qs.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.ax(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function (e) {\n          const t = e.transform.padding;\n          Cs(e, e.transform.height - (t.top || 0), 3, ys), Cs(e, t.bottom || 0, 3, bs), Is(e, t.left || 0, 3, ws), Is(e, e.transform.width - (t.right || 0), 3, Ts);\n          const i = e.transform.centerPoint;\n          !function (e, t, i, o) {\n            Ds(e, t - 1, i - 10, 2, 20, o), Ds(e, t - 10, i - 1, 20, 2, o);\n          }(e, i.x, e.transform.height - i.y, Es);\n        }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), l || (this.conflationActive = !1);\n      }\n      prepareLayer(e) {\n        this.gpuTimingStart(e);\n        const {\n            unsupportedLayers: t\n          } = this.transform.projection,\n          i = !t || !t.includes(e.type);\n        if (en[e.type] && (i || this.terrain && \"custom\" === e.type)) {\n          const t = this.style.getLayerSourceCache(e);\n          en[e.type](e, t, this);\n        }\n        this.gpuTimingEnd();\n      }\n      renderLayer(e, t, i, o) {\n        i.isHidden(this.transform.zoom) || (\"background\" === i.type || \"sky\" === i.type || \"custom\" === i.type || \"model\" === i.type || \"raster\" === i.type || \"raster-particle\" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes(i.type) || e.terrain && \"custom\" === i.type) && Qs[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());\n      }\n      gpuTimingStart(e) {\n        if (!this.options.gpuTiming) return;\n        const t = this.context.extTimerQuery,\n          i = this.context.gl;\n        let o = this.gpuTimers[e.id];\n        o || (o = this.gpuTimers[e.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: i.createQuery()\n        }), o.calls++, i.beginQuery(t.TIME_ELAPSED_EXT, o.query);\n      }\n      gpuTimingDeferredRenderStart() {\n        if (this.options.gpuTimingDeferredRender) {\n          const e = this.context.extTimerQuery,\n            t = this.context.gl,\n            i = t.createQuery();\n          this.deferredRenderGpuTimeQueries.push(i), t.beginQuery(e.TIME_ELAPSED_EXT, i);\n        }\n      }\n      gpuTimingDeferredRenderEnd() {\n        this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);\n      }\n      gpuTimingEnd() {\n        this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);\n      }\n      collectGpuTimers() {\n        const e = this.gpuTimers;\n        return this.gpuTimers = {}, e;\n      }\n      collectDeferredRenderGpuQueries() {\n        const e = this.deferredRenderGpuTimeQueries;\n        return this.deferredRenderGpuTimeQueries = [], e;\n      }\n      queryGpuTimers(e) {\n        const t = {};\n        for (const i in e) {\n          const o = e[i],\n            r = this.context.extTimerQuery,\n            s = r.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;\n          r.deleteQueryEXT(o.query), t[i] = s;\n        }\n        return t;\n      }\n      queryGpuTimeDeferredRender(e) {\n        if (!this.options.gpuTimingDeferredRender) return 0;\n        const t = this.context.extTimerQuery,\n          i = this.context.gl;\n        let o = 0;\n        for (const r of e) o += t.getQueryParameter(r, i.QUERY_RESULT) / 1e6, t.deleteQueryEXT(r);\n        return o;\n      }\n      translatePosMatrix(t, i, o, r, s) {\n        if (!o[0] && !o[1]) return t;\n        const n = s ? \"map\" === r ? this.transform.angle : 0 : \"viewport\" === r ? -this.transform.angle : 0;\n        if (n) {\n          const e = Math.sin(n),\n            t = Math.cos(n);\n          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];\n        }\n        const a = [s ? o[0] : e.a3(i, o[0], this.transform.zoom), s ? o[1] : e.a3(i, o[1], this.transform.zoom), 0],\n          l = new Float32Array(16);\n        return e.a6.translate(l, t, a), l;\n      }\n      saveTileTexture(e) {\n        const t = e.size[0],\n          i = this._tileTextures[t];\n        i ? i.push(e) : this._tileTextures[t] = [e];\n      }\n      getTileTexture(e) {\n        const t = this._tileTextures[e];\n        return t && t.length > 0 ? t.pop() : null;\n      }\n      isPatternMissing(e, t) {\n        return null === e || void 0 !== e && !this.imageManager.getPattern(e.toString(), t);\n      }\n      terrainRenderModeElevated() {\n        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;\n      }\n      linearFloatFilteringSupported() {\n        return null != this.context.extTextureFloatLinear;\n      }\n      currentGlobalDefines(e, t, i) {\n        const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i,\n          r = this.terrain && 0 === this.terrain.exaggeration(),\n          s = [];\n        return this.style && this.style.enable3dLights() && (\"globeRaster\" === e || \"terrainRaster\" === e ? (s.push(\"LIGHTING_3D_MODE\"), s.push(\"LIGHTING_3D_ALPHA_EMISSIVENESS\")) : o || s.push(\"LIGHTING_3D_MODE\")), \"shadow\" === this.renderPass ? this._shadowMapDebug || s.push(\"DEPTH_TEXTURE\") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? s.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\", \"NORMAL_OFFSET\") : s.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\")), this.terrainRenderModeElevated() && (s.push(\"TERRAIN\"), this.linearFloatFilteringSupported() && s.push(\"TERRAIN_DEM_FLOAT_FORMAT\"), r && s.push(\"ZERO_EXAGGERATION\")), \"globe\" === this.transform.projection.name && s.push(\"GLOBE\"), !this._fogVisible || o || void 0 !== t && !t || s.push(\"FOG\", \"FOG_DITHERING\"), o && s.push(\"RENDER_TO_TEXTURE\"), this._showOverdrawInspector && s.push(\"OVERDRAW_INSPECTOR\"), s;\n      }\n      getOrCreateProgram(e, t) {\n        this.cache = this.cache || {};\n        const i = t && t.defines || [],\n          o = t && t.config,\n          r = t && t.transformFeedback,\n          s = this.currentGlobalDefines(e, t && t.overrideFog, t && t.overrideRtt).concat(i),\n          n = br.cacheKey(Ko[e], e, s, o);\n        return this.cache[n] || (this.cache[n] = new br(this.context, e, Ko[e], o, Yr[e], s, r)), this.cache[n];\n      }\n      setCustomLayerDefaults() {\n        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n      }\n      setBaseState() {\n        const e = this.context.gl;\n        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);\n      }\n      initDebugOverlayCanvas() {\n        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement(\"canvas\"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n      }\n      destroy() {\n        this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy();\n      }\n      prepareDrawTile() {\n        this.terrain && this.terrain.prepareDrawTile();\n      }\n      uploadCommonLightUniforms(t, i) {\n        if (this.style.enable3dLights()) {\n          const o = this.style.directionalLight,\n            r = this.style.ambientLight;\n          if (o && r) {\n            const s = ((t, i) => {\n              const o = t.properties.get(\"direction\"),\n                r = t.properties.get(\"color\").toArray01(),\n                s = t.properties.get(\"intensity\"),\n                n = i.properties.get(\"color\").toArray01(),\n                a = i.properties.get(\"intensity\"),\n                l = [o.x, o.y, o.z],\n                c = e.cn(n, a),\n                h = e.cn(r, s);\n              return {\n                u_lighting_ambient_color: c,\n                u_lighting_directional_dir: l,\n                u_lighting_directional_color: h,\n                u_ground_radiance: vr(l, h, c)\n              };\n            })(o, r);\n            i.setLightsUniformValues(t, s);\n          }\n        }\n      }\n      uploadCommonUniforms(t, i, o, r, s) {\n        if (this.uploadCommonLightUniforms(t, i), this.terrain && this.terrain.renderingToTexture) return;\n        const n = this.style.fog;\n        if (n) {\n          const s = n.getOpacity(this.transform.pitch),\n            a = ((t, i, o, r, s, n, a, l, c, h, u, d) => {\n              const _ = t.transform,\n                p = i.properties.get(\"color\").toArray01();\n              p[3] = r;\n              const f = t.frameCounter / 1e3 % 1,\n                [m, g] = i.properties.get(\"vertical-range\");\n              return {\n                u_fog_matrix: o ? _.calculateFogTileMatrix(o) : d || t.identityMat,\n                u_fog_range: i.getFovAdjustedRange(_._fov),\n                u_fog_color: p,\n                u_fog_horizon_blend: i.properties.get(\"horizon-blend\"),\n                u_fog_vertical_limit: [Math.min(m, g), g],\n                u_fog_temporal_offset: f,\n                u_frustum_tl: s,\n                u_frustum_tr: n,\n                u_frustum_br: a,\n                u_frustum_bl: l,\n                u_globe_pos: c,\n                u_globe_radius: h,\n                u_viewport: u,\n                u_globe_transition: e.S(_.zoom),\n                u_is_globe: +(\"globe\" === _.projection.name)\n              };\n            })(this, n, o, s, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.f.devicePixelRatio, this.transform.height * e.f.devicePixelRatio], r);\n          i.setFogUniformValues(t, a);\n        }\n        s && i.setCutoffUniformValues(t, s.uniformValues);\n      }\n      setTileLoadedFlag(e) {\n        this.tileLoaded = e;\n      }\n      saveCanvasCopy() {\n        const e = this.canvasCopy();\n        e && (this.frameCopies.push(e), this.tileLoaded = !1);\n      }\n      canvasCopy() {\n        const e = this.context.gl,\n          t = e.createTexture();\n        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;\n      }\n      getCanvasCopiesAndTimestamps() {\n        return {\n          canvasCopies: this.frameCopies,\n          timeStamps: this.loadTimeStamps\n        };\n      }\n      averageElevationNeedsEasing() {\n        if (!this.transform._elevation) return !1;\n        const e = this.style && this.style.fog;\n        return !!e && 0 !== e.getOpacity(this.transform.pitch);\n      }\n      getBackgroundTiles() {\n        const e = this._backgroundTiles,\n          t = this._backgroundTiles = {},\n          i = this.transform.coveringTiles({\n            tileSize: 512\n          });\n        for (const o of i) t[o.key] = e[o.key] || new Gt(o, 512, this.transform.tileZoom, this);\n        return t;\n      }\n      clearBackgroundTiles() {\n        this._backgroundTiles = {};\n      }\n      layerUsedInConflation(e, t) {\n        return !(!e.is3D() || e.minzoom && e.minzoom > this.transform.zoom || \"building\" !== e.sourceLayer && (!t || \"batched-model\" !== t.type));\n      }\n      isTileAffectedByFog(e) {\n        if (!this.style || !this.style.fog) return !1;\n        if (\"globe\" === this.transform.projection.name) return !0;\n        let t = this._cachedTileFogOpacities[e.key];\n        return t || (this._cachedTileFogOpacities[e.key] = t = this.style.fog.getOpacityForTile(e)), t[0] >= me || t[1] >= me;\n      }\n    }\n    function on(e, t) {\n      let i = !1,\n        o = null;\n      const r = () => {\n        o = null, i && (e(), o = setTimeout(r, t), i = !1);\n      };\n      return () => (i = !0, o || r(), o);\n    }\n    class rn {\n      constructor(t) {\n        this._hashName = t && encodeURIComponent(t), e.aY([\"_getCurrentHash\", \"_onHashChange\", \"_updateHash\"], this), this._updateHash = on(this._updateHashUnthrottled.bind(this), 300);\n      }\n      addTo(e) {\n        return this._map = e, window.addEventListener(\"hashchange\", this._onHashChange, !1), e.on(\"moveend\", this._updateHash), this;\n      }\n      remove() {\n        return this._map ? (this._map.off(\"moveend\", this._updateHash), window.removeEventListener(\"hashchange\", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;\n      }\n      getHashString() {\n        const e = this._map;\n        if (!e) return \"\";\n        const t = sn(e);\n        if (this._hashName) {\n          const e = this._hashName;\n          let i = !1;\n          const o = location.hash.slice(1).split(\"&\").map(o => {\n            const r = o.split(\"=\")[0];\n            return r === e ? (i = !0, `${r}=${t}`) : o;\n          }).filter(e => e);\n          return i || o.push(`${e}=${t}`), `#${o.join(\"&\")}`;\n        }\n        return `#${t}`;\n      }\n      _getCurrentHash() {\n        const e = location.hash.replace(\"#\", \"\");\n        if (this._hashName) {\n          let t;\n          return e.split(\"&\").map(e => e.split(\"=\")).forEach(e => {\n            e[0] === this._hashName && (t = e);\n          }), (t && t[1] || \"\").split(\"/\");\n        }\n        return e.split(\"/\");\n      }\n      _onHashChange() {\n        const e = this._map;\n        if (!e) return !1;\n        const t = this._getCurrentHash();\n        if (t.length >= 3 && !t.some(e => isNaN(e))) {\n          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();\n          return e.jumpTo({\n            center: [+t[2], +t[1]],\n            zoom: +t[0],\n            bearing: i,\n            pitch: +(t[4] || 0)\n          }), !0;\n        }\n        return !1;\n      }\n      _updateHashUnthrottled() {\n        history.replaceState(history.state, \"\", location.href.replace(/(#.+)?$/, this.getHashString()));\n      }\n    }\n    function sn(e, t) {\n      const i = e.getCenter(),\n        o = Math.round(100 * e.getZoom()) / 100,\n        r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n        s = Math.pow(10, r),\n        n = Math.round(i.lng * s) / s,\n        a = Math.round(i.lat * s) / s,\n        l = e.getBearing(),\n        c = e.getPitch();\n      let h = t ? `/${n}/${a}/${o}` : `${o}/${a}/${n}`;\n      return (l || c) && (h += \"/\" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;\n    }\n    const nn = {\n        linearity: .3,\n        easing: e.c_(0, 0, .3, 1)\n      },\n      an = e.e({\n        deceleration: 2500,\n        maxSpeed: 1400\n      }, nn),\n      ln = e.e({\n        deceleration: 20,\n        maxSpeed: 1400\n      }, nn),\n      cn = e.e({\n        deceleration: 1e3,\n        maxSpeed: 360\n      }, nn),\n      hn = e.e({\n        deceleration: 1e3,\n        maxSpeed: 90\n      }, nn);\n    class un {\n      constructor(e) {\n        this._map = e, this.clear();\n      }\n      clear() {\n        this._inertiaBuffer = [];\n      }\n      record(t) {\n        this._drainInertiaBuffer(), this._inertiaBuffer.push({\n          time: e.f.now(),\n          settings: t\n        });\n      }\n      _drainInertiaBuffer() {\n        const t = this._inertiaBuffer,\n          i = e.f.now();\n        for (; t.length > 0 && i - t[0].time > 160;) t.shift();\n      }\n      _onMoveEnd(t) {\n        if (this._map._prefersReducedMotion()) return;\n        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;\n        const i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new e.P(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        };\n        for (const {\n          settings: e\n        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);\n        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n          r = {};\n        if (i.pan.mag()) {\n          const s = _n(i.pan.mag(), o, e.e({}, an, t || {}));\n          r.offset = i.pan.mult(s.amount / i.pan.mag()), r.center = this._map.transform.center, dn(r, s);\n        }\n        if (i.zoom) {\n          const e = _n(i.zoom, o, ln);\n          r.zoom = this._map.transform.zoom + e.amount, dn(r, e);\n        }\n        if (i.bearing) {\n          const t = _n(i.bearing, o, cn);\n          r.bearing = this._map.transform.bearing + e.aa(t.amount, -179, 179), dn(r, t);\n        }\n        if (i.pitch) {\n          const e = _n(i.pitch, o, hn);\n          r.pitch = this._map.transform.pitch + e.amount, dn(r, e);\n        }\n        if (r.zoom || r.bearing) {\n          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          r.around = e ? this._map.unproject(e) : this._map.getCenter();\n        }\n        return this.clear(), r.noMoveStart = !0, r;\n      }\n    }\n    function dn(e, t) {\n      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);\n    }\n    function _n(t, i, o) {\n      const {\n          maxSpeed: r,\n          linearity: s,\n          deceleration: n\n        } = o,\n        a = e.aa(t * s / (i / 1e3), -r, r),\n        l = Math.abs(a) / (n * s);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: a * (l / 2)\n      };\n    }\n    class pn extends e.b {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o, r = {}) {\n        const s = p(i.getCanvasContainer(), o),\n          n = i.unproject(s);\n        super(t, e.e({\n          point: s,\n          lngLat: n,\n          originalEvent: o\n        }, r)), this._defaultPrevented = !1, this.target = i;\n      }\n    }\n    class fn extends e.b {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o) {\n        const r = \"touchend\" === t ? o.changedTouches : o.touches,\n          s = f(i.getCanvasContainer(), r),\n          n = s.map(e => i.unproject(e)),\n          a = s.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.P(0, 0));\n        super(t, {\n          points: s,\n          point: a,\n          lngLats: n,\n          lngLat: i.unproject(a),\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class mn extends e.b {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(e, t, i) {\n        super(e, {\n          originalEvent: i\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class gn {\n      constructor(e, t) {\n        this._map = e, this._clickTolerance = t.clickTolerance;\n      }\n      reset() {\n        this._mousedownPos = void 0;\n      }\n      wheel(e) {\n        return this._firePreventable(new mn(e.type, this._map, e));\n      }\n      mousedown(e, t) {\n        return this._mousedownPos = t, this._firePreventable(new pn(e.type, this._map, e));\n      }\n      mouseup(e) {\n        this._map.fire(new pn(e.type, this._map, e));\n      }\n      preclick(t) {\n        const i = e.e({}, t);\n        i.type = \"preclick\", this._map.fire(new pn(i.type, this._map, i));\n      }\n      click(e, t) {\n        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new pn(e.type, this._map, e)));\n      }\n      dblclick(e) {\n        return this._firePreventable(new pn(e.type, this._map, e));\n      }\n      mouseover(e) {\n        this._map.fire(new pn(e.type, this._map, e));\n      }\n      mouseout(e) {\n        this._map.fire(new pn(e.type, this._map, e));\n      }\n      touchstart(e) {\n        return this._firePreventable(new fn(e.type, this._map, e));\n      }\n      touchmove(e) {\n        this._map.fire(new fn(e.type, this._map, e));\n      }\n      touchend(e) {\n        this._map.fire(new fn(e.type, this._map, e));\n      }\n      touchcancel(e) {\n        this._map.fire(new fn(e.type, this._map, e));\n      }\n      _firePreventable(e) {\n        if (this._map.fire(e), e.defaultPrevented) return {};\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class vn {\n      constructor(e) {\n        this._map = e;\n      }\n      reset() {\n        this._delayContextMenu = !1, this._contextMenuEvent = void 0;\n      }\n      mousemove(e) {\n        this._map.fire(new pn(e.type, this._map, e));\n      }\n      mousedown() {\n        this._delayContextMenu = !0;\n      }\n      mouseup() {\n        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new pn(\"contextmenu\", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n      }\n      contextmenu(e) {\n        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new pn(e.type, this._map, e)), this._map.listens(\"contextmenu\") && e.preventDefault();\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class xn {\n      constructor(e, t) {\n        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      enable() {\n        this.isEnabled() || (this._enabled = !0);\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n      mousedown(e, t) {\n        this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t, this._active = !0);\n      }\n      mousemoveWindow(e, t) {\n        if (!this._active) return;\n        const i = t,\n          o = this._startPos,\n          r = this._lastPos;\n        if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;\n        this._lastPos = i, this._box || (this._box = s(\"div\", \"mapboxgl-boxzoom\", this._container), this._container.classList.add(\"mapboxgl-crosshair\"), this._fireEvent(\"boxzoomstart\", e));\n        const n = Math.min(o.x, i.x),\n          a = Math.max(o.x, i.x),\n          l = Math.min(o.y, i.y),\n          c = Math.max(o.y, i.y);\n        this._map._requestDomTask(() => {\n          this._box && (this._box.style.transform = `translate(${n}px,${l}px)`, this._box.style.width = a - n + \"px\", this._box.style.height = c - l + \"px\");\n        });\n      }\n      mouseupWindow(t, i) {\n        if (!this._active) return;\n        const o = this._startPos,\n          r = i;\n        if (o && 0 === t.button) {\n          if (this.reset(), _(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.b(\"boxzoomend\", {\n            originalEvent: t\n          })), {\n            cameraAnimation: e => e.fitScreenCoordinates(o, r, this._map.getBearing(), {\n              linear: !1\n            })\n          };\n          this._fireEvent(\"boxzoomcancel\", t);\n        }\n      }\n      keydown(e) {\n        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent(\"boxzoomcancel\", e));\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._container.classList.remove(\"mapboxgl-crosshair\"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;\n      }\n      _fireEvent(t, i) {\n        return this._map.fire(new e.b(t, {\n          originalEvent: i\n        }));\n      }\n    }\n    function yn(e, t) {\n      const i = {};\n      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];\n      return i;\n    }\n    class bn {\n      constructor(e) {\n        this.reset(), this.numTouches = e.numTouches;\n      }\n      reset() {\n        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;\n      }\n      touchstart(t, i, o) {\n        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {\n          const i = new e.P(0, 0);\n          for (const e of t) i._add(e);\n          return i.div(t.length);\n        }(i), this.touches = yn(o, i)));\n      }\n      touchmove(e, t, i) {\n        if (this.aborted || !this.centroid) return;\n        const o = yn(i, t);\n        for (const e in this.touches) {\n          const t = o[e];\n          (!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0);\n        }\n      }\n      touchend(e, t, i) {\n        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n          const e = !this.aborted && this.centroid;\n          if (this.reset(), e) return e;\n        }\n      }\n    }\n    class wn {\n      constructor(e) {\n        this.singleTap = new bn(e), this.numTaps = e.numTaps, this.reset();\n      }\n      reset() {\n        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();\n      }\n      touchstart(e, t, i) {\n        this.singleTap.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this.singleTap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this.singleTap.touchend(e, t, i);\n        if (o) {\n          const t = e.timeStamp - this.lastTime < 500,\n            i = !this.lastTap || this.lastTap.dist(o) < 30;\n          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n        }\n      }\n    }\n    class Tn {\n      constructor() {\n        this._zoomIn = new wn({\n          numTouches: 1,\n          numTaps: 2\n        }), this._zoomOut = new wn({\n          numTouches: 2,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n      }\n      touchstart(e, t, i) {\n        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this._zoomIn.touchend(e, t, i),\n          r = this._zoomOut.touchend(e, t, i);\n        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() + 1,\n            around: t.unproject(o)\n          }, {\n            originalEvent: e\n          })\n        }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() - 1,\n            around: t.unproject(r)\n          }, {\n            originalEvent: e\n          })\n        }) : void 0;\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    const En = {\n      0: 1,\n      2: 2\n    };\n    class Sn {\n      constructor(e) {\n        this.reset(), this._clickTolerance = e.clickTolerance || 1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;\n      }\n      _correctButton(e, t) {\n        return !1;\n      }\n      _move(e, t) {\n        return {};\n      }\n      mousedown(e, t) {\n        if (this._lastPoint) return;\n        const i = m(e);\n        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);\n      }\n      mousemoveWindow(e, t) {\n        const i = this._lastPoint;\n        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {\n          const i = En[t];\n          return void 0 === e.buttons || (e.buttons & i) !== i;\n        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);\n      }\n      mouseupWindow(e) {\n        this._lastPoint && m(e) === this._eventButton && (this._moved && _(), this.reset());\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Cn extends Sn {\n      mousedown(e, t) {\n        super.mousedown(e, t), this._lastPoint && (this._active = !0);\n      }\n      _correctButton(e, t) {\n        return 0 === t && !e.ctrlKey;\n      }\n      _move(e, t) {\n        return {\n          around: t,\n          panDelta: t.sub(e)\n        };\n      }\n    }\n    class In extends Sn {\n      _correctButton(e, t) {\n        return 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = .8 * (t.x - e.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }\n      contextmenu(e) {\n        e.preventDefault();\n      }\n    }\n    class Dn extends Sn {\n      _correctButton(e, t) {\n        return 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = -.5 * (t.y - e.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }\n      contextmenu(e) {\n        e.preventDefault();\n      }\n    }\n    class Ln {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.aY([\"_addTouchPanBlocker\", \"_showTouchPanBlockerAlert\"], this);\n      }\n      reset() {\n        this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);\n      }\n      touchstart(e, t, i) {\n        return this._calculateTransform(e, t, i);\n      }\n      touchmove(t, i, o) {\n        if (this._active && !(o.length < this._minTouches)) {\n          if (this._map._cooperativeGestures && !this._map.isMoving()) {\n            if (1 === o.length && !e.c$()) return void this._showTouchPanBlockerAlert();\n            \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n          }\n          return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);\n        }\n      }\n      touchend(e, t, i) {\n        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();\n      }\n      touchcancel() {\n        this.reset();\n      }\n      _calculateTransform(t, i, o) {\n        o.length > 0 && (this._active = !0);\n        const r = yn(o, i),\n          s = new e.P(0, 0),\n          n = new e.P(0, 0);\n        let a = 0;\n        for (const e in r) {\n          const t = r[e],\n            i = this._touches[e];\n          i && (s._add(t), n._add(t.sub(i)), a++, r[e] = t);\n        }\n        if (this._touches = r, a < this._minTouches || !n.mag()) return;\n        const l = n.div(a);\n        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {\n          around: s.div(a),\n          panDelta: l\n        };\n      }\n      enable() {\n        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\"));\n      }\n      disable() {\n        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\")), this.reset();\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      _addTouchPanBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = s(\"div\", \"mapboxgl-touch-pan-blocker\", this._map._container), this._alertContainer.textContent = this._map._getUIString(\"TouchPanBlocker.Message\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n      _showTouchPanBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.removeAttribute(\"role\");\n        }, 500);\n      }\n    }\n    class An {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._firstTwoTouches = void 0;\n      }\n      _start(e) {}\n      _move(e, t, i) {\n        return {};\n      }\n      touchstart(e, t, i) {\n        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));\n      }\n      touchmove(e, t, i) {\n        const o = this._firstTwoTouches;\n        if (!o) return;\n        e.preventDefault();\n        const [r, s] = o,\n          n = Rn(i, t, r),\n          a = Rn(i, t, s);\n        if (!n || !a) return;\n        const l = this._aroundCenter ? null : n.add(a).div(2);\n        return this._move([n, a], l, e);\n      }\n      touchend(e, t, i) {\n        if (!this._firstTwoTouches) return;\n        const [o, r] = this._firstTwoTouches,\n          s = Rn(i, t, o),\n          n = Rn(i, t, r);\n        s && n || (this._active && _(), this.reset());\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable(e) {\n        this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    function Rn(e, t, i) {\n      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];\n    }\n    function Pn(e, t) {\n      return Math.log(e / t) / Math.LN2;\n    }\n    class Mn extends An {\n      reset() {\n        super.reset(), this._distance = 0, this._startDistance = 0;\n      }\n      _start(e) {\n        this._startDistance = this._distance = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._distance;\n        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Pn(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Pn(this._distance, i),\n          pinchAround: t\n        };\n      }\n    }\n    function zn(e, t) {\n      return 180 * e.angleWith(t) / Math.PI;\n    }\n    class On extends An {\n      reset() {\n        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;\n      }\n      _start(e) {\n        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._vector;\n        if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {\n          bearingDelta: zn(this._vector, i),\n          pinchAround: t\n        };\n      }\n      _isBelowThreshold(e) {\n        this._minDiameter = Math.min(this._minDiameter, e.mag());\n        const t = 25 / (Math.PI * this._minDiameter) * 360,\n          i = this._startVector;\n        if (!i) return !1;\n        const o = zn(e, i);\n        return Math.abs(o) < t;\n      }\n    }\n    function Fn(e) {\n      return Math.abs(e.y) > Math.abs(e.x);\n    }\n    class Bn extends An {\n      constructor(e) {\n        super(), this._map = e;\n      }\n      reset() {\n        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;\n      }\n      _start(e) {\n        this._lastPoints = e, Fn(e[0].sub(e[1])) && (this._valid = !1);\n      }\n      _move(t, i, o) {\n        const r = this._lastPoints;\n        if (!r) return;\n        const s = t[0].sub(r[0]),\n          n = t[1].sub(r[1]);\n        return this._map._cooperativeGestures && !e.c$() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s, n, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {\n          pitchDelta: (s.y + n.y) / 2 * -.5\n        });\n      }\n      gestureBeginsVertically(e, t, i) {\n        if (void 0 !== this._valid) return this._valid;\n        const o = e.mag() >= 2,\n          r = t.mag() >= 2;\n        if (!o && !r) return;\n        if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n        const s = e.y > 0 == t.y > 0;\n        return Fn(e) && Fn(t) && s;\n      }\n    }\n    const kn = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    };\n    class Nn {\n      constructor() {\n        const e = kn;\n        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      keydown(e) {\n        if (e.altKey || e.ctrlKey || e.metaKey) return;\n        let t = 0,\n          i = 0,\n          o = 0,\n          r = 0,\n          s = 0;\n        switch (e.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            t = 1;\n            break;\n          case 189:\n          case 109:\n          case 173:\n            t = -1;\n            break;\n          case 37:\n            e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);\n            break;\n          case 39:\n            e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);\n            break;\n          case 38:\n            e.shiftKey ? o = 1 : (e.preventDefault(), s = -1);\n            break;\n          case 40:\n            e.shiftKey ? o = -1 : (e.preventDefault(), s = 1);\n            break;\n          default:\n            return;\n        }\n        return this._rotationDisabled && (i = 0, o = 0), {\n          cameraAnimation: n => {\n            const a = n.getZoom();\n            n.easeTo({\n              duration: 300,\n              easeId: \"keyboardHandler\",\n              easing: Un,\n              zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a,\n              bearing: n.getBearing() + i * this._bearingStep,\n              pitch: n.getPitch() + o * this._pitchStep,\n              offset: [-r * this._panStep, -s * this._panStep],\n              center: n.getCenter()\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n      disableRotation() {\n        this._rotationDisabled = !0;\n      }\n      enableRotation() {\n        this._rotationDisabled = !1;\n      }\n    }\n    function Un(e) {\n      return e * (2 - e);\n    }\n    const Gn = 4.000244140625,\n      jn = 1 / 450;\n    class Vn {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = jn, e.aY([\"_onTimeout\", \"_addScrollZoomBlocker\", \"_showBlockerAlert\"], this);\n      }\n      setZoomRate(e) {\n        this._defaultZoomRate = e;\n      }\n      setWheelZoomRate(e) {\n        this._wheelZoomRate = e;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return this._active || void 0 !== this._finishTimeout;\n      }\n      isZooming() {\n        return !!this._zooming;\n      }\n      enable(e) {\n        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));\n      }\n      wheel(t) {\n        if (!this.isEnabled()) return;\n        if (this._map._cooperativeGestures) {\n          if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.c$())) return void this._showBlockerAlert();\n          \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n        }\n        let i = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;\n        const o = e.f.now(),\n          r = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % Gn == 0 ? this._type = \"wheel\" : 0 !== i && Math.abs(i) < 4 ? this._type = \"trackpad\" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * i) < 200 ? \"trackpad\" : \"wheel\", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();\n      }\n      _onTimeout(e) {\n        this._type = \"wheel\", this._delta -= this._lastValue, this._active || this._start(e);\n      }\n      _start(e) {\n        if (!this._delta) return;\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        const t = p(this._el, e);\n        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n      renderFrame() {\n        if (!this._frameId) return;\n        if (this._frameId = null, !this.isActive()) return;\n        const t = this._map.transform;\n        \"wheel\" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);\n        const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;\n        if (0 !== this._delta) {\n          const e = \"wheel\" === this._type && Math.abs(this._delta) > Gn ? this._wheelZoomRate : this._defaultZoomRate;\n          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));\n          this._delta < 0 && 0 !== o && (o = 1 / o);\n          const r = i(),\n            s = Math.pow(2, r),\n            n = \"number\" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : s;\n          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(n * o))), \"wheel\" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;\n        }\n        const o = \"number\" == typeof this._targetZoom ? this._targetZoom : i(),\n          r = this._startZoom,\n          s = this._easing;\n        let n,\n          a = !1;\n        if (\"wheel\" === this._type && r && s) {\n          const t = Math.min((e.f.now() - this._lastWheelEventTime) / 200, 1),\n            i = s(t);\n          n = e.U(r, o, i), t < 1 ? this._frameId || (this._frameId = !0) : a = !0;\n        } else n = o, a = !0;\n        this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout(() => {\n          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;\n        }, 200));\n        let l = n - i();\n        return l * this._lastDelta < 0 && (l = 0), {\n          noInertia: !0,\n          needsRenderFrame: !a,\n          zoomDelta: l,\n          around: this._aroundPoint,\n          aroundCoord: this._aroundCoord,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n      _smoothOutEasing(t) {\n        let i = e.d0;\n        if (this._prevEase) {\n          const t = this._prevEase,\n            o = (e.f.now() - t.start) / t.duration,\n            r = t.easing(o + .01) - t.easing(o),\n            s = .27 / Math.sqrt(r * r + 1e-4) * .01,\n            n = Math.sqrt(.0729 - s * s);\n          i = e.c_(s, n, .25, 1);\n        }\n        return this._prevEase = {\n          start: e.f.now(),\n          duration: t,\n          easing: i\n        }, i;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      _addScrollZoomBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = s(\"div\", \"mapboxgl-scroll-zoom-blocker\", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString(\"ScrollZoomBlocker.CmdMessage\") : this._map._getUIString(\"ScrollZoomBlocker.CtrlMessage\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n      _showBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.removeAttribute(\"role\");\n        }, 200);\n      }\n    }\n    class Zn {\n      constructor(e, t) {\n        this._clickZoom = e, this._tapZoom = t;\n      }\n      enable() {\n        this._clickZoom.enable(), this._tapZoom.enable();\n      }\n      disable() {\n        this._clickZoom.disable(), this._tapZoom.disable();\n      }\n      isEnabled() {\n        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n      }\n      isActive() {\n        return this._clickZoom.isActive() || this._tapZoom.isActive();\n      }\n    }\n    class Hn {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      dblclick(e, t) {\n        return e.preventDefault(), {\n          cameraAnimation: i => {\n            i.easeTo({\n              duration: 300,\n              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),\n              around: i.unproject(t)\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Wn {\n      constructor() {\n        this._tap = new wn({\n          numTouches: 1,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();\n      }\n      touchstart(e, t, i) {\n        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));\n      }\n      touchmove(e, t, i) {\n        if (this._tapTime) {\n          if (this._swipePoint) {\n            if (i[0].identifier !== this._swipeTouch) return;\n            const o = t[0],\n              r = o.y - this._swipePoint.y;\n            return this._swipePoint = o, e.preventDefault(), this._active = !0, {\n              zoomDelta: r / 128\n            };\n          }\n        } else this._tap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class qn {\n      constructor(e, t, i) {\n        this._el = e, this._mousePan = t, this._touchPan = i;\n      }\n      enable(e) {\n        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(\"mapboxgl-touch-drag-pan\");\n      }\n      disable() {\n        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(\"mapboxgl-touch-drag-pan\");\n      }\n      isEnabled() {\n        return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n      }\n      isActive() {\n        return this._mousePan.isActive() || this._touchPan.isActive();\n      }\n    }\n    class $n {\n      constructor(e, t, i) {\n        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;\n      }\n      enable() {\n        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n      }\n      disable() {\n        this._mouseRotate.disable(), this._mousePitch.disable();\n      }\n      isEnabled() {\n        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n      }\n      isActive() {\n        return this._mouseRotate.isActive() || this._mousePitch.isActive();\n      }\n    }\n    class Xn {\n      constructor(e, t, i, o) {\n        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n      }\n      enable(e) {\n        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add(\"mapboxgl-touch-zoom-rotate\");\n      }\n      disable() {\n        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(\"mapboxgl-touch-zoom-rotate\");\n      }\n      isEnabled() {\n        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n      }\n      isActive() {\n        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n      }\n      disableRotation() {\n        this._rotationDisabled = !0, this._touchRotate.disable();\n      }\n      enableRotation() {\n        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n      }\n    }\n    const Kn = e => e.zoom || e.drag || e.pitch || e.rotate;\n    class Yn extends e.b {}\n    class Jn {\n      constructor() {\n        this.constants = [1, 1, .01], this.radius = 0;\n      }\n      setup(t, i) {\n        const o = e.N.sub([], i, t);\n        this.radius = e.N.length(o[2] < 0 ? e.N.div([], o, this.constants) : [o[0], o[1], 0]);\n      }\n      projectRay(t) {\n        e.N.div(t, t, this.constants), e.N.normalize(t, t), e.N.mul(t, t, this.constants);\n        const i = e.N.scale([], t, this.radius);\n        if (i[2] > 0) {\n          const t = e.N.scale([], [0, 0, 1], e.N.dot(i, [0, 0, 1])),\n            o = e.N.scale([], e.N.normalize([], [i[0], i[1], 0]), this.radius),\n            r = e.N.add([], i, e.N.scale([], e.N.sub([], e.N.add([], o, t), i), 2));\n          i[0] = r[0], i[1] = r[1];\n        }\n        return i;\n      }\n    }\n    function Qn(e) {\n      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;\n    }\n    class ea {\n      constructor(t, i) {\n        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new un(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Jn(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.aY([\"handleEvent\", \"handleWindowEvent\"], this);\n        const o = this._el;\n        this._listeners = [[o, \"touchstart\", {\n          passive: !0\n        }], [o, \"touchmove\", {\n          passive: !1\n        }], [o, \"touchend\", void 0], [o, \"touchcancel\", void 0], [o, \"mousedown\", void 0], [o, \"mousemove\", void 0], [o, \"mouseup\", void 0], [document, \"mousemove\", {\n          capture: !0\n        }], [document, \"mouseup\", void 0], [o, \"mouseover\", void 0], [o, \"mouseout\", void 0], [o, \"dblclick\", void 0], [o, \"click\", void 0], [o, \"keydown\", {\n          capture: !1\n        }], [o, \"keyup\", void 0], [o, \"wheel\", {\n          passive: !1\n        }], [o, \"contextmenu\", void 0], [window, \"blur\", void 0]];\n        for (const [e, t, i] of this._listeners) {\n          const o = e === document ? this.handleWindowEvent : this.handleEvent;\n          e.addEventListener(t, o, i);\n        }\n      }\n      destroy() {\n        for (const [e, t, i] of this._listeners) {\n          const o = e === document ? this.handleWindowEvent : this.handleEvent;\n          e.removeEventListener(t, o, i);\n        }\n      }\n      _addDefaultHandlers(e) {\n        const t = this._map,\n          i = t.getCanvasContainer();\n        this._add(\"mapEvent\", new gn(t, e));\n        const o = t.boxZoom = new xn(t, e);\n        this._add(\"boxZoom\", o);\n        const r = new Tn(),\n          s = new Hn();\n        t.doubleClickZoom = new Zn(s, r), this._add(\"tapZoom\", r), this._add(\"clickZoom\", s);\n        const n = new Wn();\n        this._add(\"tapDragZoom\", n);\n        const a = t.touchPitch = new Bn(t);\n        this._add(\"touchPitch\", a);\n        const l = new In(e),\n          c = new Dn(e);\n        t.dragRotate = new $n(e, l, c), this._add(\"mouseRotate\", l, [\"mousePitch\"]), this._add(\"mousePitch\", c, [\"mouseRotate\"]);\n        const h = new Cn(e),\n          u = new Ln(t, e);\n        t.dragPan = new qn(i, h, u), this._add(\"mousePan\", h), this._add(\"touchPan\", u, [\"touchZoom\", \"touchRotate\"]);\n        const d = new On(),\n          _ = new Mn();\n        t.touchZoomRotate = new Xn(i, _, d, n), this._add(\"touchRotate\", d, [\"touchPan\", \"touchZoom\"]), this._add(\"touchZoom\", _, [\"touchPan\", \"touchRotate\"]), this._add(\"blockableMapEvent\", new vn(t));\n        const p = t.scrollZoom = new Vn(t, this);\n        this._add(\"scrollZoom\", p, [\"mousePan\"]);\n        const f = t.keyboard = new Nn();\n        this._add(\"keyboard\", f);\n        for (const i of [\"boxZoom\", \"doubleClickZoom\", \"tapDragZoom\", \"touchPitch\", \"dragRotate\", \"dragPan\", \"touchZoomRotate\", \"scrollZoom\", \"keyboard\"]) e.interactive && e[i] && t[i].enable(e[i]);\n      }\n      _add(e, t, i) {\n        this._handlers.push({\n          handlerName: e,\n          handler: t,\n          allowed: i\n        }), this._handlersById[e] = t;\n      }\n      stop(e) {\n        if (!this._updatingCamera) {\n          for (const {\n            handler: e\n          } of this._handlers) e.reset();\n          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;\n        }\n      }\n      isActive() {\n        for (const {\n          handler: e\n        } of this._handlers) if (e.isActive()) return !0;\n        return !1;\n      }\n      isZooming() {\n        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n      }\n      isRotating() {\n        return !!this._eventsInProgress.rotate;\n      }\n      isMoving() {\n        return !!Kn(this._eventsInProgress) || this.isZooming();\n      }\n      _isDragging() {\n        return !!this._eventsInProgress.drag;\n      }\n      _blockedByActive(e, t, i) {\n        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;\n        return !1;\n      }\n      handleWindowEvent(e) {\n        this.handleEvent(e, `${e.type}Window`);\n      }\n      _getMapTouches(e) {\n        const t = [];\n        for (const i of e) this._el.contains(i.target) && t.push(i);\n        return t;\n      }\n      handleEvent(e, t) {\n        this._updatingCamera = !0;\n        const i = \"renderFrame\" === e.type,\n          o = i ? void 0 : e,\n          r = {\n            needsRenderFrame: !1\n          },\n          s = {},\n          n = {},\n          a = e.touches ? this._getMapTouches(e.touches) : void 0,\n          l = a ? f(this._el, a) : i ? void 0 : p(this._el, e);\n        for (const {\n          handlerName: i,\n          handler: c,\n          allowed: h\n        } of this._handlers) {\n          if (!c.isEnabled()) continue;\n          let u;\n          this._blockedByActive(n, h, i) ? c.reset() : c[t || e.type] && (u = c[t || e.type](e, l, a), this.mergeHandlerResult(r, s, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (n[i] = c);\n        }\n        const c = {};\n        for (const e in this._previousActiveHandlers) n[e] || (c[e] = o);\n        this._previousActiveHandlers = n, (Object.keys(c).length || Qn(r)) && (this._changes.push([r, s, c]), this._triggerRenderFrame()), (Object.keys(n).length || Qn(r)) && this._map._stop(!0), this._updatingCamera = !1;\n        const {\n          cameraAnimation: h\n        } = r;\n        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));\n      }\n      mergeHandlerResult(t, i, o, r, s) {\n        if (!o) return;\n        e.e(t, o);\n        const n = {\n          handlerName: r,\n          originalEvent: o.originalEvent || s\n        };\n        void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);\n      }\n      _applyChanges() {\n        const t = {},\n          i = {},\n          o = {};\n        for (const [r, s, n] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.P(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.e(i, s), e.e(o, n);\n        this._updateMapTransform(t, i, o), this._changes = [];\n      }\n      _updateMapTransform(t, i, o) {\n        const r = this._map,\n          s = r.transform,\n          n = e => [e.x, e.y, e.z];\n        if ((e => {\n          const t = this._eventsInProgress.drag;\n          return t && !this._handlersById[t.handlerName].isActive();\n        })() && !Qn(t)) {\n          const e = s.zoom;\n          s.cameraElevationReference = \"sea\", null != this._originalZoom && s._orthographicProjectionAtLowPitch && \"globe\" !== s.projection.name && 0 === s.pitch ? (s.cameraElevationReference = \"ground\", s.zoom = this._originalZoom) : (s.recenterOnTerrain(), s.cameraElevationReference = \"ground\"), e !== s.zoom && this._map._update(!0);\n        }\n        if (s._isCameraConstrained && r._stop(!0), !Qn(t)) return void this._fireEvents(i, o, !0);\n        let {\n          panDelta: a,\n          zoomDelta: l,\n          bearingDelta: c,\n          pitchDelta: h,\n          around: u,\n          aroundCoord: d,\n          pinchAround: _\n        } = t;\n        s._isCameraConstrained && (l > 0 && (l = 0), s._isCameraConstrained = !1), void 0 !== _ && (u = _), (l || (e => i[e] && !this._eventsInProgress[e])(\"drag\")) && u && (this._dragOrigin = n(s.pointCoordinate3D(u)), this._originalZoom = s.zoom, this._trackingEllipsoid.setup(s._camera.position, this._dragOrigin)), s.cameraElevationReference = \"sea\", r._stop(!0), u = u || r.transform.centerPoint, c && (s.bearing += c), h && (s.pitch += h), s._updateCameraState();\n        const p = [0, 0, 0];\n        if (a) if (\"mercator\" === s.projection.name) {\n          const e = this._trackingEllipsoid.projectRay(s.screenPointToMercatorRay(u).dir),\n            t = this._trackingEllipsoid.projectRay(s.screenPointToMercatorRay(u.sub(a)).dir);\n          p[0] = t[0] - e[0], p[1] = t[1] - e[1];\n        } else {\n          const t = s.pointCoordinate(u);\n          if (\"globe\" === s.projection.name) {\n            a = a.rotate(-s.angle);\n            const i = s._pixelsPerMercatorPixel / s.worldSize;\n            p[0] = -a.x * e.d1(e.au(t.y)) * i, p[1] = -a.y * e.d1(s.center.lat) * i;\n          } else {\n            const e = s.pointCoordinate(u.sub(a));\n            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);\n          }\n        }\n        const f = s.zoom,\n          m = [0, 0, 0];\n        if (l) {\n          const t = n(d || s.pointCoordinate3D(u)),\n            i = {\n              dir: e.N.normalize([], e.N.sub([], t, s._camera.position))\n            };\n          if (i.dir[2] < 0) {\n            const o = s.zoomDeltaToMovement(t, l);\n            e.N.scale(m, i.dir, o);\n          }\n        }\n        const g = e.N.add(p, p, m);\n        s._translateCameraConstrained(g), l && Math.abs(s.zoom - f) > 1e-4 && s.recenterOnTerrain(), s.cameraElevationReference = \"ground\", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);\n      }\n      _fireEvents(t, i, o) {\n        const r = Kn(this._eventsInProgress),\n          s = Kn(t),\n          n = {};\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._eventsInProgress[e] || (n[`${e}start`] = i), this._eventsInProgress[e] = t[e];\n        }\n        !r && s && this._fireEvent(\"movestart\", s.originalEvent);\n        for (const e in n) this._fireEvent(e, n[e]);\n        s && this._fireEvent(\"move\", s.originalEvent);\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._fireEvent(e, i);\n        }\n        const a = {};\n        let l;\n        for (const e in this._eventsInProgress) {\n          const {\n            handlerName: t,\n            originalEvent: o\n          } = this._eventsInProgress[e];\n          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, a[`${e}end`] = l);\n        }\n        for (const e in a) this._fireEvent(e, a[e]);\n        const c = Kn(this._eventsInProgress);\n        if (o && (r || s) && !c) {\n          this._updatingCamera = !0;\n          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n            i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;\n          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {\n            originalEvent: l\n          })) : (this._map.fire(new e.b(\"moveend\", {\n            originalEvent: l\n          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n        }\n      }\n      _fireEvent(t, i) {\n        this._map.fire(new e.b(t, i ? {\n          originalEvent: i\n        } : {}));\n      }\n      _requestFrame() {\n        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {\n          this._frameId = void 0, this.handleEvent(new Yn(\"renderFrame\", {\n            timeStamp: e\n          })), this._applyChanges();\n        });\n      }\n      _triggerRenderFrame() {\n        void 0 === this._frameId && (this._frameId = this._requestFrame());\n      }\n    }\n    const ta = \"map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.\";\n    class ia extends e.E {\n      constructor(t, i) {\n        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.aY([\"_renderFrameCallback\"], this);\n      }\n      getCenter() {\n        return new e.bn(this.transform.center.lng, this.transform.center.lat);\n      }\n      setCenter(e, t) {\n        return this.jumpTo({\n          center: e\n        }, t);\n      }\n      panBy(t, i, o) {\n        return t = e.P.convert(t).mult(-1), this.panTo(this.transform.center, e.e({\n          offset: t\n        }, i), o);\n      }\n      panTo(t, i, o) {\n        return this.easeTo(e.e({\n          center: t\n        }, i), o);\n      }\n      getZoom() {\n        return this.transform.zoom;\n      }\n      setZoom(e, t) {\n        return this.jumpTo({\n          zoom: e\n        }, t), this;\n      }\n      zoomTo(t, i, o) {\n        return this.easeTo(e.e({\n          zoom: t\n        }, i), o);\n      }\n      zoomIn(e, t) {\n        return this.zoomTo(this.getZoom() + 1, e, t), this;\n      }\n      zoomOut(e, t) {\n        return this.zoomTo(this.getZoom() - 1, e, t), this;\n      }\n      getBearing() {\n        return this.transform.bearing;\n      }\n      setBearing(e, t) {\n        return this.jumpTo({\n          bearing: e\n        }, t), this;\n      }\n      getPadding() {\n        return this.transform.padding;\n      }\n      setPadding(e, t) {\n        return this.jumpTo({\n          padding: e\n        }, t), this;\n      }\n      rotateTo(t, i, o) {\n        return this.easeTo(e.e({\n          bearing: t\n        }, i), o);\n      }\n      resetNorth(t, i) {\n        return this.rotateTo(0, e.e({\n          duration: 1e3\n        }, t), i), this;\n      }\n      resetNorthPitch(t, i) {\n        return this.easeTo(e.e({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, t), i), this;\n      }\n      snapToNorth(e, t) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;\n      }\n      getPitch() {\n        return this.transform.pitch;\n      }\n      setPitch(e, t) {\n        return this.jumpTo({\n          pitch: e\n        }, t), this;\n      }\n      cameraForBounds(t, i) {\n        t = e.ad.convert(t);\n        const o = i && i.bearing || 0,\n          r = i && i.pitch || 0,\n          s = t.getNorthWest(),\n          n = t.getSouthEast();\n        return this._cameraForBounds(this.transform, s, n, o, r, i);\n      }\n      _extendCameraOptions(t) {\n        const i = {\n          top: 0,\n          bottom: 0,\n          right: 0,\n          left: 0\n        };\n        if (\"number\" == typeof (t = e.e({\n          padding: i,\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, t)).padding) {\n          const e = t.padding;\n          t.padding = {\n            top: e,\n            bottom: e,\n            right: e,\n            left: e\n          };\n        }\n        return t.padding = e.e(i, t.padding), t;\n      }\n      _minimumAABBFrustumDistance(e, t) {\n        const i = t.max[0] - t.min[0],\n          o = t.max[1] - t.min[1];\n        return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);\n      }\n      _cameraForBoundsOnGlobe(t, i, o, r, s, n) {\n        const a = t.clone(),\n          l = this._extendCameraOptions(n);\n        a.bearing = r, a.pitch = s;\n        const c = e.bn.convert(i),\n          h = e.bn.convert(o),\n          u = .5 * (c.lat + h.lat),\n          d = .5 * (c.lng + h.lng),\n          _ = e.d2(u, d),\n          p = e.N.normalize([], _),\n          f = e.N.normalize([], e.N.cross([], p, [0, 1, 0])),\n          m = e.N.cross([], f, p),\n          g = [f[0], f[1], f[2], 0, m[0], m[1], m[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],\n          v = [_, e.d2(c.lat, c.lng), e.d2(h.lat, c.lng), e.d2(h.lat, h.lng), e.d2(c.lat, h.lng), e.d2(u, c.lng), e.d2(u, h.lng), e.d2(c.lat, d), e.d2(h.lat, d)];\n        let x = e.bS.fromPoints(v.map(t => [e.N.dot(f, t), e.N.dot(m, t), e.N.dot(p, t)]));\n        const y = e.N.transformMat4([], x.center, g);\n        0 === e.N.squaredLength(y) && e.N.set(y, 0, 0, 1), e.N.normalize(y, y), e.N.scale(y, y, e.ab), a.center = e.d3(y);\n        const b = a.getWorldToCameraMatrix(),\n          w = e.a6.invert(new Float64Array(16), b);\n        x = e.bS.applyTransform(x, e.a6.multiply([], b, g)), e.N.transformMat4(y, y, b);\n        const T = .5 * (x.max[2] - x.min[2]),\n          E = this._minimumAABBFrustumDistance(a, x),\n          S = e.N.scale([], [0, 0, 1], T),\n          C = e.N.add(S, y, S),\n          I = E + (0 === a.pitch ? 0 : e.N.distance(y, C)),\n          D = a.globeCenterInViewSpace,\n          L = e.N.sub([], y, [D[0], D[1], D[2]]);\n        e.N.normalize(L, L), e.N.scale(L, L, I);\n        const A = e.N.add([], y, L);\n        e.N.transformMat4(A, A, w);\n        const R = e.d4 / e.ab,\n          P = e.N.length(A),\n          M = e.bl(Math.max(P * R - e.d4, Number.EPSILON), 0),\n          z = Math.min(a.zoomFromMercatorZAdjusted(M), l.maxZoom);\n        return z > .5 * (e.bG + e.bx) ? (a.setProjection({\n          name: \"mercator\"\n        }), a.zoom = z, this._cameraForBounds(a, i, o, r, s, n)) : {\n          center: a.center,\n          zoom: z,\n          bearing: r,\n          pitch: s\n        };\n      }\n      queryTerrainElevation(t, i) {\n        const o = this.transform.elevation;\n        return o ? (i = e.e({}, {\n          exaggerated: !0\n        }, i), o.getAtPoint(e.L.fromLngLat(t), null, i.exaggerated)) : null;\n      }\n      _cameraForBounds(t, i, o, r, s, n) {\n        if (\"globe\" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, r, s, n);\n        const a = t.clone(),\n          l = this._extendCameraOptions(n),\n          c = a.padding;\n        a.bearing = r, a.pitch = s;\n        const h = e.bn.convert(i),\n          u = e.bn.convert(o),\n          d = new e.bn(h.lng, u.lat),\n          _ = new e.bn(u.lng, h.lat),\n          p = a.project(h),\n          f = a.project(u),\n          m = this.queryTerrainElevation(h),\n          g = this.queryTerrainElevation(u),\n          v = this.queryTerrainElevation(d),\n          x = this.queryTerrainElevation(_),\n          y = [[p.x, p.y, Math.min(m || 0, g || 0, v || 0, x || 0)], [f.x, f.y, Math.max(m || 0, g || 0, v || 0, x || 0)]];\n        let b = e.bS.fromPoints(y);\n        const w = a.getWorldToCameraMatrix(),\n          T = e.a6.invert(new Float64Array(16), w);\n        b = e.bS.applyTransform(b, w);\n        const E = e.N.sub([], b.max, b.min),\n          S = c.left || 0,\n          C = c.right || 0,\n          I = c.bottom || 0,\n          D = c.top || 0,\n          {\n            left: L,\n            right: A,\n            top: R,\n            bottom: P\n          } = l.padding,\n          M = .5 * (S + C),\n          z = .5 * (D + I),\n          O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (S + C + L + A)) / E[0], (a.height - (I + D + P + R)) / E[1])), l.maxZoom),\n          F = a.scale / a.zoomScale(O);\n        b = new e.bS([b.min[0] - (L + M) * F, b.min[1] - (P + z) * F, b.min[2]], [b.max[0] + (A + M) * F, b.max[1] + (R + z) * F, b.max[2]]);\n        const B = .5 * E[2],\n          k = this._minimumAABBFrustumDistance(a, b),\n          N = [0, 0, 1, 0];\n        e.a7.transformMat4(N, N, w), e.a7.normalize(N, N);\n        const U = e.N.scale([], N, k + B),\n          G = e.N.add([], b.center, U),\n          j = (\"number\" == typeof l.offset.x && \"number\" == typeof l.offset.y ? new e.P(l.offset.x, l.offset.y) : e.P.convert(l.offset)).rotate(-e.bj(r));\n        b.center[0] -= j.x * F, b.center[1] += j.y * F, e.N.transformMat4(b.center, b.center, T), e.N.transformMat4(G, G, T);\n        const V = [b.center[0], b.center[1], G[2] * a.pixelsPerMeter];\n        e.N.scale(V, V, 1 / a.worldSize);\n        const Z = e.at(V[0]),\n          H = e.au(V[1]),\n          W = Math.min(a._zoomFromMercatorZ(V[2]), l.maxZoom),\n          q = new e.bn(Z, H);\n        return a.mercatorFromTransition && W < .5 * (e.bG + e.bx) ? (a.setProjection({\n          name: \"globe\"\n        }), a.zoom = W, this._cameraForBounds(a, i, o, r, s, n)) : {\n          center: q,\n          zoom: W,\n          bearing: r,\n          pitch: s\n        };\n      }\n      fitBounds(e, t, i) {\n        const o = this.cameraForBounds(e, t);\n        return this._fitInternal(o, t, i);\n      }\n      fitScreenCoordinates(t, i, o, r, s) {\n        const n = e.P.convert(t),\n          a = e.P.convert(i),\n          l = new e.P(Math.min(n.x, a.x), Math.min(n.y, a.y)),\n          c = new e.P(Math.max(n.x, a.x), Math.max(n.y, a.y));\n        if (\"mercator\" === this.transform.projection.name && this.transform.anyCornerOffEdge(n, a)) return this;\n        const h = this.transform.pointLocation3D(l),\n          u = this.transform.pointLocation3D(c),\n          d = this.transform.pointLocation3D(new e.P(l.x, c.y)),\n          _ = this.transform.pointLocation3D(new e.P(c.x, l.y)),\n          p = [Math.min(h.lng, u.lng, d.lng, _.lng), Math.min(h.lat, u.lat, d.lat, _.lat)],\n          f = [Math.max(h.lng, u.lng, d.lng, _.lng), Math.max(h.lat, u.lat, d.lat, _.lat)],\n          m = r && r.pitch ? r.pitch : this.getPitch(),\n          g = this._cameraForBounds(this.transform, p, f, o, m, r);\n        return this._fitInternal(g, r, s);\n      }\n      _fitInternal(t, i, o) {\n        return t ? (delete (i = e.e(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n      }\n      jumpTo(t, i) {\n        this.stop();\n        const o = t.preloadOnly ? this.transform.clone() : this.transform;\n        let r = !1,\n          s = !1,\n          n = !1;\n        return \"zoom\" in t && o.zoom !== +t.zoom && (r = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.bn.convert(t.center)), \"bearing\" in t && o.bearing !== +t.bearing && (s = !0, o.bearing = +t.bearing), \"pitch\" in t && o.pitch !== +t.pitch && (n = !0, o.pitch = +t.pitch), null == t.padding || o.isPaddingEqual(t.padding) || (o.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.b(\"movestart\", i)).fire(new e.b(\"move\", i)), r && this.fire(new e.b(\"zoomstart\", i)).fire(new e.b(\"zoom\", i)).fire(new e.b(\"zoomend\", i)), s && this.fire(new e.b(\"rotatestart\", i)).fire(new e.b(\"rotate\", i)).fire(new e.b(\"rotateend\", i)), n && this.fire(new e.b(\"pitchstart\", i)).fire(new e.b(\"pitch\", i)).fire(new e.b(\"pitchend\", i)), this.fire(new e.b(\"moveend\", i)));\n      }\n      getFreeCameraOptions() {\n        return this.transform.projection.supportsFreeCamera || e.w(ta), this.transform.getFreeCameraOptions();\n      }\n      setFreeCameraOptions(t, i) {\n        const o = this.transform;\n        if (!o.projection.supportsFreeCamera) return e.w(ta), this;\n        this.stop();\n        const r = o.zoom,\n          s = o.pitch,\n          n = o.bearing;\n        o.setFreeCameraOptions(t);\n        const a = r !== o.zoom,\n          l = s !== o.pitch,\n          c = n !== o.bearing;\n        return this.fire(new e.b(\"movestart\", i)).fire(new e.b(\"move\", i)), a && this.fire(new e.b(\"zoomstart\", i)).fire(new e.b(\"zoom\", i)).fire(new e.b(\"zoomend\", i)), c && this.fire(new e.b(\"rotatestart\", i)).fire(new e.b(\"rotate\", i)).fire(new e.b(\"rotateend\", i)), l && this.fire(new e.b(\"pitchstart\", i)).fire(new e.b(\"pitch\", i)).fire(new e.b(\"pitchend\", i)), this.fire(new e.b(\"moveend\", i)), this;\n      }\n      easeTo(t, i) {\n        this._stop(!1, t.easeId), (!1 === (t = e.e({\n          offset: [0, 0],\n          duration: 500,\n          easing: e.d0\n        }, t)).animate || this._prefersReducedMotion(t)) && (t.duration = 0);\n        const o = this.transform,\n          r = this.getZoom(),\n          s = this.getBearing(),\n          n = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? +t.zoom : r,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, s) : s,\n          h = \"pitch\" in t ? +t.pitch : n,\n          u = \"padding\" in t ? t.padding : o.padding,\n          d = e.P.convert(t.offset);\n        let _, p, f;\n        if (\"globe\" === o.projection.name) {\n          const i = e.L.fromLngLat(o.center),\n            r = d.rotate(-o.angle);\n          i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;\n          const s = i.toLngLat(),\n            n = e.bn.convert(t.center || s);\n          this._normalizeCenter(n), _ = o.centerPoint.add(r), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.a5(n.lng), e.ae(n.lat)).mult(o.worldSize).sub(p);\n        } else {\n          _ = o.centerPoint.add(d);\n          const i = o.pointLocation(_),\n            r = e.bn.convert(t.center || i);\n          this._normalizeCenter(r), p = o.project(i), f = o.project(r).sub(p);\n        }\n        const m = o.zoomScale(l - r);\n        let g, v;\n        t.around && (g = e.bn.convert(t.around), v = o.locationPoint(g));\n        const x = this._zooming || l !== r,\n          y = this._rotating || s !== c,\n          b = this._pitching || h !== n,\n          w = !o.isPaddingEqual(u),\n          T = o => T => {\n            if (x && (o.zoom = e.U(r, l, T)), y && (o.bearing = e.U(s, c, T)), b && (o.pitch = e.U(n, h, T)), w && (o.interpolatePadding(a, u, T), _ = o.centerPoint.add(d)), g) o.setLocationAtPoint(g, v);else {\n              const e = o.zoomScale(o.zoom - r),\n                t = l > r ? Math.min(2, m) : Math.max(.5, m),\n                i = Math.pow(t, 1 - T),\n                s = o.unproject(p.add(f.mult(T * i)).mult(e));\n              o.setLocationAtPoint(o.renderWorldCopies ? s.wrap() : s, _);\n            }\n            return t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(T, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        const E = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = x, this._rotating = y, this._pitching = b, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E), this._ease(T(o), e => {\n          \"sea\" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);\n        }, t), this;\n      }\n      _prepareEase(t, i, o = {}) {\n        this._moving = !0, this.transform.cameraElevationReference = \"sea\", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && \"globe\" !== this.transform.projection.name && (this.transform.cameraElevationReference = \"ground\"), i || o.moving || this.fire(new e.b(\"movestart\", t)), this._zooming && !o.zooming && this.fire(new e.b(\"zoomstart\", t)), this._rotating && !o.rotating && this.fire(new e.b(\"rotatestart\", t)), this._pitching && !o.pitching && this.fire(new e.b(\"pitchstart\", t));\n      }\n      _fireMoveEvents(t) {\n        this.fire(new e.b(\"move\", t)), this._zooming && this.fire(new e.b(\"zoom\", t)), this._rotating && this.fire(new e.b(\"rotate\", t)), this._pitching && this.fire(new e.b(\"pitch\", t));\n      }\n      _afterEase(t, i) {\n        if (this._easeId && i && this._easeId === i) return;\n        this._easeId = void 0, this.transform.cameraElevationReference = \"ground\";\n        const o = this._zooming,\n          r = this._rotating,\n          s = this._pitching;\n        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, o && this.fire(new e.b(\"zoomend\", t)), r && this.fire(new e.b(\"rotateend\", t)), s && this.fire(new e.b(\"pitchend\", t)), this.fire(new e.b(\"moveend\", t));\n      }\n      flyTo(t, i) {\n        if (this._prefersReducedMotion(t)) {\n          const o = e.ac(t, [\"center\", \"zoom\", \"bearing\", \"pitch\", \"around\"]);\n          return this.jumpTo(o, i);\n        }\n        this.stop(), t = e.e({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: e.d0\n        }, t);\n        const o = this.transform,\n          r = this.getZoom(),\n          s = this.getBearing(),\n          n = this.getPitch(),\n          a = \"zoom\" in t ? e.aa(+t.zoom, o.minZoom, o.maxZoom) : r,\n          l = \"bearing\" in t ? this._normalizeBearing(t.bearing, s) : s,\n          c = \"pitch\" in t ? +t.pitch : n,\n          h = o.zoomScale(a - r),\n          u = e.P.convert(t.offset),\n          d = o.centerPoint.add(u),\n          _ = o.pointLocation(d);\n        let p = t.center;\n        if (p && t.padding) {\n          const e = this._cameraForBounds(this.transform, p, p, l, c, t);\n          e && (p = e.center);\n        }\n        p = e.bn.convert(p || _), this._normalizeCenter(p);\n        const f = o.project(_),\n          m = o.project(p).sub(f);\n        let g = t.curve;\n        const v = Math.max(o.width, o.height),\n          x = v / h,\n          y = m.mag();\n        if (\"minZoom\" in t) {\n          const i = e.aa(Math.min(t.minZoom, r, a), o.minZoom, o.maxZoom),\n            s = v / o.zoomScale(i - r);\n          g = Math.sqrt(s / y * 2);\n        }\n        const b = g * g;\n        function w(e) {\n          const t = (x * x - v * v + (e ? -1 : 1) * b * b * y * y) / (2 * (e ? x : v) * b * y);\n          return Math.log(Math.sqrt(t * t + 1) - t);\n        }\n        function T(e) {\n          return (Math.exp(e) - Math.exp(-e)) / 2;\n        }\n        function E(e) {\n          return (Math.exp(e) + Math.exp(-e)) / 2;\n        }\n        const S = w(0);\n        let C = function (e) {\n            return E(S) / E(S + g * e);\n          },\n          I = function (e) {\n            return v * ((E(S) * (T(t = S + g * e) / E(t)) - T(S)) / b) / y;\n            var t;\n          },\n          D = (w(1) - S) / g;\n        if (Math.abs(y) < 1e-6 || !isFinite(D)) {\n          if (Math.abs(v - x) < 1e-6) return this.easeTo(t, i);\n          const e = x < v ? -1 : 1;\n          D = Math.abs(Math.log(x / v)) / g, I = function () {\n            return 0;\n          }, C = function (t) {\n            return Math.exp(e * g * t);\n          };\n        }\n        t.duration = \"duration\" in t ? +t.duration : 1e3 * D / (\"screenSpeed\" in t ? +t.screenSpeed / g : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);\n        const L = s !== l,\n          A = c !== n,\n          R = o => h => {\n            const u = h * D,\n              _ = 1 / C(u);\n            o.zoom = 1 === h ? a : r + o.scaleZoom(_), L && (o.bearing = e.U(s, l, h)), A && (o.pitch = e.U(n, c, h));\n            const g = 1 === h ? p : o.unproject(f.add(m.mult(I(u))).mult(_));\n            return o.setLocationAtPoint(o.renderWorldCopies ? g.wrap() : g, d), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(R, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        return this._zooming = !0, this._rotating = L, this._pitching = A, this._prepareEase(i, !1), this._ease(R(o), () => this._afterEase(i), t), this;\n      }\n      isEasing() {\n        return !!this._easeFrameId;\n      }\n      stop() {\n        return this._stop();\n      }\n      _stop(e, t) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {\n          const e = this._onEaseEnd;\n          this._onEaseEnd = void 0, e.call(this, t);\n        }\n        if (!e) {\n          const e = this.handlers;\n          e && e.stop(!1);\n        }\n        return this;\n      }\n      _ease(t, i, o) {\n        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.f.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }\n      _renderFrameCallback() {\n        const t = Math.min((e.f.now() - this._easeStart) / this._easeOptions.duration, 1),\n          i = this._onEaseFrame;\n        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }\n      _normalizeBearing(t, i) {\n        t = e.bh(t, -180, 180);\n        const o = Math.abs(t - i);\n        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;\n      }\n      _normalizeCenter(e) {\n        const t = this.transform;\n        if (t.maxBounds) return;\n        if (\"globe\" !== t.projection.name && !t.renderWorldCopies) return;\n        const i = e.lng - t.center.lng;\n        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n      }\n      _prefersReducedMotion(t) {\n        return this._respectPrefersReducedMotion && e.f.prefersReducedMotion && !(t && t.essential);\n      }\n      _emulate(e, t, i) {\n        const o = Math.ceil(15 * t / 1e3),\n          r = [],\n          s = e(i.clone());\n        for (let e = 0; e <= o; e++) {\n          const t = s(e / o);\n          r.push(t.clone());\n        }\n        return r;\n      }\n    }\n    class oa {\n      constructor(t = {}) {\n        this.options = t, e.aY([\"_toggleAttribution\", \"_updateEditLink\", \"_updateData\", \"_updateCompact\"], this);\n      }\n      getDefaultPosition() {\n        return \"bottom-right\";\n      }\n      onAdd(e) {\n        const t = this.options && this.options.compact;\n        return this._map = e, this._container = s(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-attrib\"), this._compactButton = s(\"button\", \"mapboxgl-ctrl-attrib-button\", this._container), s(\"span\", \"mapboxgl-ctrl-icon\", this._compactButton).setAttribute(\"aria-hidden\", \"true\"), this._compactButton.type = \"button\", this._compactButton.addEventListener(\"click\", this._toggleAttribution), this._setElementTitle(this._compactButton, \"ToggleAttribution\"), this._innerContainer = s(\"div\", \"mapboxgl-ctrl-attrib-inner\", this._container), t && this._container.classList.add(\"mapboxgl-compact\"), this._updateAttributions(), this._updateEditLink(), this._map.on(\"styledata\", this._updateData), this._map.on(\"sourcedata\", this._updateData), this._map.on(\"moveend\", this._updateEditLink), void 0 === t && (this._map.on(\"resize\", this._updateCompact), this._updateCompact()), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"styledata\", this._updateData), this._map.off(\"sourcedata\", this._updateData), this._map.off(\"moveend\", this._updateEditLink), this._map.off(\"resize\", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n      }\n      _setElementTitle(e, t) {\n        const i = this._map._getUIString(`AttributionControl.${t}`);\n        e.removeAttribute(\"title\"), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n      }\n      _toggleAttribution() {\n        this._container.classList.contains(\"mapboxgl-compact-show\") ? (this._container.classList.remove(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"false\")) : (this._container.classList.add(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"true\"));\n      }\n      _updateEditLink() {\n        let t = this._editLink;\n        t || (t = this._editLink = this._container.querySelector(\".mapbox-improve-map\"));\n        const i = [{\n          key: \"owner\",\n          value: this.styleOwner\n        }, {\n          key: \"id\",\n          value: this.styleId\n        }, {\n          key: \"access_token\",\n          value: this._map._requestManager._customAccessToken || e.d5.ACCESS_TOKEN\n        }];\n        if (t) {\n          const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? \"&\" : \"\"}`), e), \"?\");\n          t.href = `${e.d5.FEEDBACK_URL}/${o}#${sn(this._map, !0)}`, t.rel = \"noopener nofollow\", this._setElementTitle(t, \"MapFeedback\");\n        }\n      }\n      _updateData(e) {\n        !e || \"metadata\" !== e.sourceDataType && \"visibility\" !== e.sourceDataType && \"style\" !== e.dataType || (this._updateAttributions(), this._updateEditLink());\n      }\n      _updateAttributions() {\n        if (!this._map.style) return;\n        let e = [];\n        if (this._map.style.stylesheet) {\n          const e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n        const t = this._map.style._mergedSourceCaches;\n        for (const i in t) {\n          const o = t[i];\n          if (o.used) {\n            const t = o.getSource();\n            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);\n          }\n        }\n        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {\n          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;\n          return !0;\n        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));\n        const i = e.join(\" | \");\n        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove(\"mapboxgl-attrib-empty\")) : this._container.classList.add(\"mapboxgl-attrib-empty\"), this._editLink = null);\n      }\n      _updateCompact() {\n        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add(\"mapboxgl-compact\") : this._container.classList.remove(\"mapboxgl-compact\", \"mapboxgl-compact-show\");\n      }\n    }\n    class ra {\n      constructor() {\n        e.aY([\"_updateLogo\", \"_updateCompact\"], this);\n      }\n      onAdd(e) {\n        this._map = e, this._container = s(\"div\", \"mapboxgl-ctrl\");\n        const t = s(\"a\", \"mapboxgl-ctrl-logo\");\n        return t.target = \"_blank\", t.rel = \"noopener nofollow\", t.href = \"https://www.mapbox.com/\", t.setAttribute(\"aria-label\", this._map._getUIString(\"LogoControl.Title\")), t.setAttribute(\"rel\", \"noopener nofollow\"), this._container.appendChild(t), this._container.style.display = \"none\", this._map.on(\"sourcedata\", this._updateLogo), this._updateLogo(), this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"sourcedata\", this._updateLogo), this._map.off(\"resize\", this._updateCompact);\n      }\n      getDefaultPosition() {\n        return \"bottom-left\";\n      }\n      _updateLogo(e) {\n        e && \"metadata\" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? \"block\" : \"none\");\n      }\n      _logoRequired() {\n        if (!this._map.style) return !0;\n        const e = this._map.style._sourceCaches;\n        if (0 === Object.entries(e).length) return !0;\n        for (const t in e) {\n          const i = e[t].getSource();\n          if (i.hasOwnProperty(\"mapbox_logo\") && !i.mapbox_logo) return !1;\n        }\n        return !0;\n      }\n      _updateCompact() {\n        const e = this._container.children;\n        if (e.length) {\n          const t = e[0];\n          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add(\"mapboxgl-compact\") : t.classList.remove(\"mapboxgl-compact\");\n        }\n      }\n    }\n    class sa {\n      constructor() {\n        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n      }\n      add(e) {\n        const t = ++this._id;\n        return this._queue.push({\n          callback: e,\n          id: t,\n          cancelled: !1\n        }), t;\n      }\n      remove(e) {\n        const t = this._currentlyRunning,\n          i = t ? this._queue.concat(t) : this._queue;\n        for (const t of i) if (t.id === e) return void (t.cancelled = !0);\n      }\n      run(e = 0) {\n        const t = this._currentlyRunning = this._queue;\n        this._queue = [];\n        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;\n        this._cleared = !1, this._currentlyRunning = !1;\n      }\n      clear() {\n        this._currentlyRunning && (this._cleared = !0), this._queue = [];\n      }\n    }\n    function na(t, i, o) {\n      if (t = new e.bn(t.lng, t.lat), i) {\n        const r = new e.bn(t.lng - 360, t.lat),\n          s = new e.bn(t.lng + 360, t.lat),\n          n = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),\n          a = o.locationPoint(t).distSqr(i),\n          l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;\n        o.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < n) ? t = r : o.locationPoint(s).distSqr(i) < a && (l || Math.abs(s.lng - o.center.lng) < n) && (t = s);\n      }\n      for (; Math.abs(t.lng - o.center.lng) > 180;) {\n        const e = o.locationPoint(t);\n        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;\n        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;\n      }\n      return t;\n    }\n    const aa = {\n      center: \"translate(-50%,-50%)\",\n      top: \"translate(-50%,0)\",\n      \"top-left\": \"translate(0,0)\",\n      \"top-right\": \"translate(-100%,0)\",\n      bottom: \"translate(-50%,-100%)\",\n      \"bottom-left\": \"translate(0,-100%)\",\n      \"bottom-right\": \"translate(-100%,-100%)\",\n      left: \"translate(0,-50%)\",\n      right: \"translate(-100%,-50%)\"\n    };\n    class la extends e.E {\n      constructor(t, i) {\n        if (super(), (t instanceof HTMLElement || i) && (t = e.e({\n          element: t\n        }, i)), e.aY([\"_update\", \"_onMove\", \"_onUp\", \"_addDragHandler\", \"_onMapClick\", \"_onKeyPress\", \"_clearFadeTimer\"], this), this._anchor = t && t.anchor || \"center\", this._color = t && t.color || \"#3FB1CE\", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = \"inactive\", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || \"auto\", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || \"auto\", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || .2, t && t.element) this._element = t.element, this._offset = e.P.convert(t && t.offset || [0, 0]);else {\n          this._defaultMarker = !0, this._element = s(\"div\");\n          const i = 41,\n            o = 27,\n            r = n(\"svg\", {\n              display: \"block\",\n              height: i * this._scale + \"px\",\n              width: o * this._scale + \"px\",\n              viewBox: `0 0 ${o} ${i}`\n            }, this._element),\n            a = n(\"radialGradient\", {\n              id: \"shadowGradient\"\n            }, n(\"defs\", {}, r));\n          n(\"stop\", {\n            offset: \"10%\",\n            \"stop-opacity\": .4\n          }, a), n(\"stop\", {\n            offset: \"100%\",\n            \"stop-opacity\": .05\n          }, a), n(\"ellipse\", {\n            cx: 13.5,\n            cy: 34.8,\n            rx: 10.5,\n            ry: 5.25,\n            fill: \"url(#shadowGradient)\"\n          }, r), n(\"path\", {\n            fill: this._color,\n            d: \"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z\"\n          }, r), n(\"path\", {\n            opacity: .25,\n            d: \"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z\"\n          }, r), n(\"circle\", {\n            fill: \"white\",\n            cx: 13.5,\n            cy: 13.5,\n            r: 5.5\n          }, r), this._offset = e.P.convert(t && t.offset || [0, -14]);\n        }\n        this._element.hasAttribute(\"aria-label\") || this._element.setAttribute(\"aria-label\", \"Map marker\"), this._element.hasAttribute(\"role\") || this._element.setAttribute(\"role\", \"img\"), this._element.classList.add(\"mapboxgl-marker\"), this._element.addEventListener(\"dragstart\", e => {\n          e.preventDefault();\n        }), this._element.addEventListener(\"mousedown\", e => {\n          e.preventDefault();\n        });\n        const o = this._element.classList;\n        for (const e in aa) o.remove(`mapboxgl-marker-anchor-${e}`);\n        o.add(`mapboxgl-marker-anchor-${this._anchor}`);\n        const r = t && t.className ? t.className.trim().split(/\\s+/) : [];\n        o.add(...r), this._popup = null;\n      }\n      addTo(e) {\n        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on(\"move\", this._updateMoving), e.on(\"moveend\", this._update), e.on(\"remove\", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on(\"click\", this._onMapClick)), this;\n      }\n      remove() {\n        const e = this._map;\n        return e && (e.off(\"click\", this._onMapClick), e.off(\"move\", this._updateMoving), e.off(\"moveend\", this._update), e.off(\"mousedown\", this._addDragHandler), e.off(\"touchstart\", this._addDragHandler), e.off(\"mouseup\", this._onUp), e.off(\"touchend\", this._onUp), e.off(\"mousemove\", this._onMove), e.off(\"touchmove\", this._onMove), e.off(\"remove\", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;\n      }\n      getLngLat() {\n        return this._lngLat;\n      }\n      setLngLat(t) {\n        return this._lngLat = e.bn.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;\n      }\n      getElement() {\n        return this._element;\n      }\n      setPopup(e) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute(\"role\"), this._element.removeEventListener(\"keypress\", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(\"tabindex\")), e) {\n          if (!(\"offset\" in e.options)) {\n            const t = 38.1,\n              i = 13.5,\n              o = Math.sqrt(Math.pow(i, 2) / 2);\n            e.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              \"top-left\": [0, 0],\n              \"top-right\": [0, 0],\n              bottom: [0, -t],\n              \"bottom-left\": [o, -1 * (t - i + o)],\n              \"bottom-right\": [-o, -1 * (t - i + o)],\n              left: [i, -1 * (t - i)],\n              right: [-i, -1 * (t - i)]\n            } : this._offset;\n          }\n          this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute(\"role\", \"button\"), this._originalTabIndex = this._element.getAttribute(\"tabindex\"), this._originalTabIndex || this._element.setAttribute(\"tabindex\", \"0\"), this._element.addEventListener(\"keypress\", this._onKeyPress), this._element.setAttribute(\"aria-expanded\", \"false\");\n        }\n        return this;\n      }\n      _onKeyPress(e) {\n        const t = e.code,\n          i = e.charCode || e.keyCode;\n        \"Space\" !== t && \"Enter\" !== t && 32 !== i && 13 !== i || this.togglePopup();\n      }\n      _onMapClick(e) {\n        const t = e.originalEvent.target,\n          i = this._element;\n        this._popup && (t === i || i.contains(t)) && this.togglePopup();\n      }\n      getPopup() {\n        return this._popup;\n      }\n      togglePopup() {\n        const e = this._popup;\n        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute(\"aria-expanded\", \"false\")) : this._map && (e.addTo(this._map), this._element.setAttribute(\"aria-expanded\", \"true\")), this) : this;\n      }\n      _behindTerrain() {\n        const e = this._map,\n          t = this._pos;\n        if (!e || !t) return !1;\n        const i = e.unproject(t),\n          o = e.getFreeCameraOptions();\n        if (!o.position) return !1;\n        const r = o.position.toLngLat();\n        return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);\n      }\n      _evaluateOpacity() {\n        const t = this._map;\n        if (!t) return;\n        const i = this._pos;\n        if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();\n        const o = t.unproject(i);\n        let r;\n        t._showingGlobe() && e.d6(t.transform, this._lngLat) ? r = 0 : (r = 1 - t._queryFogOpacity(o), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? \"auto\" : \"none\", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;\n      }\n      _clearFadeTimer() {\n        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);\n      }\n      _updateDOM() {\n        const e = this._pos;\n        if (!e || !this._map) return;\n        const t = this._offset.mult(this._scale);\n        this._element.style.transform = `\\n            translate(${e.x}px,${e.y}px)\\n            ${aa[this._anchor]}\\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\\n            translate(${t.x}px,${t.y}px)\\n        `;\n      }\n      _calculateXYTransform() {\n        const t = this._pos,\n          i = this._map,\n          o = this.getPitchAlignment();\n        if (!i || !t || \"map\" !== o) return \"\";\n        if (!i._showingGlobe()) {\n          const e = i.getPitch();\n          return e ? `rotateX(${e}deg)` : \"\";\n        }\n        const r = e.bF(e.d7(i.transform, this._lngLat)),\n          s = t.sub(e.d8(i.transform)),\n          n = Math.abs(s.x) + Math.abs(s.y);\n        if (0 === n) return \"\";\n        const a = r / n;\n        return `rotateX(${-s.y * a}deg) rotateY(${s.x * a}deg)`;\n      }\n      _calculateZTransform() {\n        const t = this._pos,\n          i = this._map;\n        if (!i || !t) return \"\";\n        let o = 0;\n        const r = this.getRotationAlignment();\n        if (\"map\" === r) {\n          if (i._showingGlobe()) {\n            const t = i.project(new e.bn(this._lngLat.lng, this._lngLat.lat + .001)),\n              r = i.project(new e.bn(this._lngLat.lng, this._lngLat.lat - .001)).sub(t);\n            o = e.bF(Math.atan2(r.y, r.x)) - 90;\n          } else o = -i.getBearing();\n        } else if (\"horizon\" === r) {\n          const r = e.O(4, 6, i.getZoom()),\n            s = e.d8(i.transform);\n          s.y += r * i.transform.height;\n          const n = t.sub(s),\n            a = e.bF(Math.atan2(n.y, n.x));\n          o = (a > 90 ? a - 270 : a + 90) * (1 - r);\n        }\n        return o += this._rotation, o ? `rotateZ(${o}deg)` : \"\";\n      }\n      _update(e) {\n        cancelAnimationFrame(this._updateFrameId);\n        const t = this._map;\n        t && (t.transform.renderWorldCopies && (this._lngLat = na(this._lngLat, this._pos, t.transform)), this._pos = t.project(this._lngLat), !0 === e ? this._updateFrameId = requestAnimationFrame(() => {\n          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());\n        }) : this._pos = this._pos.round(), t._requestDomTask(() => {\n          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t._showingGlobe() || t.getTerrain() || t.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));\n        }));\n      }\n      getOffset() {\n        return this._offset;\n      }\n      setOffset(t) {\n        return this._offset = e.P.convert(t), this._update(), this;\n      }\n      addClassName(e) {\n        return this._element.classList.add(e), this;\n      }\n      removeClassName(e) {\n        return this._element.classList.remove(e), this;\n      }\n      toggleClassName(e) {\n        return this._element.classList.toggle(e);\n      }\n      _onMove(t) {\n        const i = this._map;\n        if (!i) return;\n        const o = this._pointerdownPos,\n          r = this._positionDelta;\n        if (o && r) {\n          if (!this._isDragging) {\n            const e = this._clickTolerance || i._clickTolerance;\n            if (t.point.dist(o) < e) return;\n            this._isDragging = !0;\n          }\n          this._pos = t.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = \"none\", \"pending\" === this._state && (this._state = \"active\", this.fire(new e.b(\"dragstart\"))), this.fire(new e.b(\"drag\"));\n        }\n      }\n      _onUp() {\n        this._element.style.pointerEvents = \"auto\", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;\n        const t = this._map;\n        t && (t.off(\"mousemove\", this._onMove), t.off(\"touchmove\", this._onMove)), \"active\" === this._state && this.fire(new e.b(\"dragend\")), this._state = \"inactive\";\n      }\n      _addDragHandler(e) {\n        const t = this._map,\n          i = this._pos;\n        t && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = \"pending\", t.on(\"mousemove\", this._onMove), t.on(\"touchmove\", this._onMove), t.once(\"mouseup\", this._onUp), t.once(\"touchend\", this._onUp));\n      }\n      setDraggable(e) {\n        this._draggable = !!e;\n        const t = this._map;\n        return t && (e ? (t.on(\"mousedown\", this._addDragHandler), t.on(\"touchstart\", this._addDragHandler)) : (t.off(\"mousedown\", this._addDragHandler), t.off(\"touchstart\", this._addDragHandler))), this;\n      }\n      isDraggable() {\n        return this._draggable;\n      }\n      setRotation(e) {\n        return this._rotation = e || 0, this._update(), this;\n      }\n      getRotation() {\n        return this._rotation;\n      }\n      setRotationAlignment(e) {\n        return this._rotationAlignment = e || \"auto\", this._update(), this;\n      }\n      getRotationAlignment() {\n        return \"auto\" === this._rotationAlignment || \"horizon\" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? \"viewport\" : this._rotationAlignment;\n      }\n      setPitchAlignment(e) {\n        return this._pitchAlignment = e || \"auto\", this._update(), this;\n      }\n      getPitchAlignment() {\n        return \"auto\" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;\n      }\n      setOccludedOpacity(e) {\n        return this._occludedOpacity = e || .2, this._update(), this;\n      }\n      getOccludedOpacity() {\n        return this._occludedOpacity;\n      }\n    }\n    const ca = {\n        closeButton: !0,\n        closeOnClick: !0,\n        focusAfterOpen: !0,\n        className: \"\",\n        maxWidth: \"240px\"\n      },\n      ha = [\"a[href]\", \"[tabindex]:not([tabindex='-1'])\", \"[contenteditable]:not([contenteditable='false'])\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].join(\", \");\n    function ua(t = new e.P(0, 0), i = \"bottom\") {\n      if (\"number\" == typeof t) {\n        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));\n        switch (i) {\n          case \"top\":\n            return new e.P(0, t);\n          case \"top-left\":\n            return new e.P(o, o);\n          case \"top-right\":\n            return new e.P(-o, o);\n          case \"bottom\":\n            return new e.P(0, -t);\n          case \"bottom-left\":\n            return new e.P(o, -o);\n          case \"bottom-right\":\n            return new e.P(-o, -o);\n          case \"left\":\n            return new e.P(t, 0);\n          case \"right\":\n            return new e.P(-t, 0);\n        }\n        return new e.P(0, 0);\n      }\n      return t instanceof e.P || Array.isArray(t) ? e.P.convert(t) : e.P.convert(t[i] || [0, 0]);\n    }\n    class da {\n      constructor(e) {\n        this.jumpTo(e);\n      }\n      getValue(t) {\n        if (t <= this._startTime) return this._start;\n        if (t >= this._endTime) return this._end;\n        const i = e.cc((t - this._startTime) / (this._endTime - this._startTime));\n        return this._start * (1 - i) + this._end * i;\n      }\n      isEasing(e) {\n        return e >= this._startTime && e <= this._endTime;\n      }\n      jumpTo(e) {\n        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;\n      }\n      easeTo(e, t, i) {\n        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;\n      }\n    }\n    const _a = {\n        \"AttributionControl.ToggleAttribution\": \"Toggle attribution\",\n        \"AttributionControl.MapFeedback\": \"Map feedback\",\n        \"FullscreenControl.Enter\": \"Enter fullscreen\",\n        \"FullscreenControl.Exit\": \"Exit fullscreen\",\n        \"GeolocateControl.FindMyLocation\": \"Find my location\",\n        \"GeolocateControl.LocationNotAvailable\": \"Location not available\",\n        \"LogoControl.Title\": \"Mapbox logo\",\n        \"Map.Title\": \"Map\",\n        \"NavigationControl.ResetBearing\": \"Reset bearing to north\",\n        \"NavigationControl.ZoomIn\": \"Zoom in\",\n        \"NavigationControl.ZoomOut\": \"Zoom out\",\n        \"ScrollZoomBlocker.CtrlMessage\": \"Use ctrl + scroll to zoom the map\",\n        \"ScrollZoomBlocker.CmdMessage\": \"Use â + scroll to zoom the map\",\n        \"TouchPanBlocker.Message\": \"Use two fingers to move the map\"\n      },\n      pa = {\n        center: [0, 0],\n        zoom: 0,\n        bearing: 0,\n        pitch: 0,\n        minZoom: -2,\n        maxZoom: 22,\n        minPitch: 0,\n        maxPitch: 85,\n        interactive: !0,\n        scrollZoom: !0,\n        boxZoom: !0,\n        dragRotate: !0,\n        dragPan: !0,\n        keyboard: !0,\n        doubleClickZoom: !0,\n        touchZoomRotate: !0,\n        touchPitch: !0,\n        cooperativeGestures: !1,\n        performanceMetricsCollection: !0,\n        bearingSnap: 7,\n        clickTolerance: 3,\n        pitchWithRotate: !0,\n        hash: !1,\n        attributionControl: !0,\n        antialias: !1,\n        failIfMajorPerformanceCaveat: !1,\n        preserveDrawingBuffer: !1,\n        trackResize: !0,\n        renderWorldCopies: !0,\n        refreshExpiredTiles: !0,\n        minTileCacheSize: null,\n        maxTileCacheSize: null,\n        localIdeographFontFamily: \"sans-serif\",\n        localFontFamily: null,\n        transformRequest: null,\n        accessToken: null,\n        fadeDuration: 300,\n        respectPrefersReducedMotion: !0,\n        crossSourceCollisions: !0,\n        collectResourceTiming: !1,\n        testMode: !1\n      };\n    class fa {\n      constructor() {\n        this.showOverdrawInspector = !1, this.showTileBoundaries = !1, this.showParseStatus = !1, this.continuousRedraw = !1, this.showTileAABBs = !1, this.showPadding = !1, this.showTerrainWireframe = !1, this.showLayers2DWireframe = !1, this.showLayers3DWireframe = !1;\n      }\n    }\n    const ma = {\n      showCompass: !0,\n      showZoom: !0,\n      visualizePitch: !1\n    };\n    class ga {\n      constructor(t, i, o = !1) {\n        this._clickTolerance = 10, this.element = i, this.mouseRotate = new In({\n          clickTolerance: t.dragRotate._mouseRotate._clickTolerance\n        }), this.map = t, o && (this.mousePitch = new Dn({\n          clickTolerance: t.dragRotate._mousePitch._clickTolerance\n        })), e.aY([\"mousedown\", \"mousemove\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\", \"reset\"], this), i.addEventListener(\"mousedown\", this.mousedown), i.addEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), i.addEventListener(\"touchmove\", this.touchmove), i.addEventListener(\"touchend\", this.touchend), i.addEventListener(\"touchcancel\", this.reset);\n      }\n      down(e, t) {\n        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h();\n      }\n      move(e, t) {\n        const i = this.map,\n          o = this.mouseRotate.mousemoveWindow(e, t),\n          r = o && o.bearingDelta;\n        if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {\n          const o = this.mousePitch.mousemoveWindow(e, t),\n            r = o && o.pitchDelta;\n          r && i.setPitch(i.getPitch() + r);\n        }\n      }\n      off() {\n        const e = this.element;\n        e.removeEventListener(\"mousedown\", this.mousedown), e.removeEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), e.removeEventListener(\"touchmove\", this.touchmove), e.removeEventListener(\"touchend\", this.touchend), e.removeEventListener(\"touchcancel\", this.reset), this.offTemp();\n      }\n      offTemp() {\n        u(), window.removeEventListener(\"mousemove\", this.mousemove), window.removeEventListener(\"mouseup\", this.mouseup);\n      }\n      mousedown(t) {\n        this.down(e.e({}, t, {\n          ctrlKey: !0,\n          preventDefault: () => t.preventDefault()\n        }), p(this.element, t)), window.addEventListener(\"mousemove\", this.mousemove), window.addEventListener(\"mouseup\", this.mouseup);\n      }\n      mousemove(e) {\n        this.move(e, p(this.element, e));\n      }\n      mouseup(e) {\n        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();\n      }\n      touchstart(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = f(this.element, e.targetTouches)[0], this.down({\n          type: \"mousedown\",\n          button: 0,\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }, this._startPos));\n      }\n      touchmove(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = f(this.element, e.targetTouches)[0], this.move({\n          preventDefault: () => e.preventDefault()\n        }, this._lastPos));\n      }\n      touchend(e) {\n        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n      }\n      reset() {\n        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n      }\n    }\n    const va = {\n        positionOptions: {\n          enableHighAccuracy: !1,\n          maximumAge: 0,\n          timeout: 6e3\n        },\n        fitBoundsOptions: {\n          maxZoom: 15\n        },\n        trackUserLocation: !1,\n        showAccuracyCircle: !0,\n        showUserLocation: !0,\n        showUserHeading: !1\n      },\n      xa = {\n        maxWidth: 100,\n        unit: \"metric\"\n      },\n      ya = {\n        kilometer: \"km\",\n        meter: \"m\",\n        mile: \"mi\",\n        foot: \"ft\",\n        \"nautical-mile\": \"nm\"\n      },\n      ba = {\n        version: e.dk,\n        supported: i,\n        setRTLTextPlugin: e.dm,\n        getRTLTextPluginStatus: e.dn,\n        Map: class extends ia {\n          constructor(t) {\n            const i = t;\n            if (null != (t = e.e({}, pa, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error(\"maxZoom must be greater than or equal to minZoom\");\n            if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n            if (null != t.minPitch && t.minPitch < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n            if (null != t.maxPitch && t.maxPitch > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n            if (t.antialias && e.d9(window) && (t.antialias = !1, e.w(\"Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609\")), super(new mo(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._repaint = !1, this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new sa(), this._domRenderTaskQueue = new sa(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.aC(), this._locale = e.e({}, _a, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new da(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e.da(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, this._contextCreateOptions = t.contextCreateOptions ? {\n              ...t.contextCreateOptions\n            } : {}, \"string\" == typeof t.container) {\n              const e = document.getElementById(t.container);\n              if (!e) throw new Error(`Container '${t.container.toString()}' not found.`);\n              this._container = e;\n            } else {\n              if (!(t.container instanceof HTMLElement)) throw new Error(\"Invalid type: 'container' must be a String or HTMLElement.\");\n              this._container = t.container;\n            }\n            if (this._container.childNodes.length > 0 && e.w(\"The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.\"), t.maxBounds && this.setMaxBounds(t.maxBounds), e.aY([\"_onWindowOnline\", \"_onWindowResize\", \"_onVisibilityChange\", \"_onMapScroll\", \"_contextLost\", \"_contextRestored\"], this), this._setupContainer(), this._debugParams = new fa(), this._tp = t.devtools ? new Js(this) : new Js(), this._tp.registerParameter(this._debugParams, [\"Debug\"], \"showOverdrawInspector\", void 0, () => {\n              this._update();\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\"], \"showTileBoundaries\", void 0, () => {\n              this._update();\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\"], \"showParseStatus\", void 0, () => {\n              this._update();\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\"], \"continuousRedraw\", void 0, e => {\n              this.repaint = e;\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\"], \"showTileAABBs\", void 0, e => {\n              this.showTileAABBs = e;\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\"], \"showPadding\", void 0, e => {\n              this.showPadding = e;\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\", \"Wireframe\"], \"showTerrainWireframe\", void 0, () => {\n              this._update();\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\", \"Wireframe\"], \"showLayers2DWireframe\", void 0, () => {\n              this._update();\n            }), this._tp.registerParameter(this._debugParams, [\"Debug\", \"Wireframe\"], \"showLayers3DWireframe\", void 0, () => {\n              this._update();\n            }), this._setupPainter(), void 0 === this.painter) throw new Error(\"Failed to initialize WebGL.\");\n            if (this.on(\"move\", () => this._update(!1)), this.on(\"moveend\", () => this._update(!1)), this.on(\"zoom\", () => this._update(!0)), this._fullscreenchangeEvent = \"onfullscreenchange\" in document ? \"fullscreenchange\" : \"webkitfullscreenchange\", window.addEventListener(\"online\", this._onWindowOnline, !1), window.addEventListener(\"resize\", this._onWindowResize, !1), window.addEventListener(\"orientationchange\", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener(\"visibilitychange\", this._onVisibilityChange, !1), this.handlers = new ea(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, (t.style || !t.testMode) && this.setStyle(t.style || e.d5.DEFAULT_STYLE, {\n              localFontFamily: this._localFontFamily,\n              localIdeographFontFamily: this._localIdeographFontFamily\n            }), t.projection && this.setProjection(t.projection), t.hash && (this._hash = new rn(\"string\" == typeof t.hash && t.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {\n              null == i.center && null == i.zoom || (this.transform._unmodified = !1), this.jumpTo({\n                center: t.center,\n                zoom: t.zoom,\n                bearing: t.bearing,\n                pitch: t.pitch\n              });\n              const o = t.bounds;\n              o && (this.resize(), this.fitBounds(o, e.e({}, t.fitBoundsOptions, {\n                duration: 0\n              })));\n            }\n            this.resize(), t.attributionControl && this.addControl(new oa({\n              customAttribution: t.customAttribution\n            })), this._logoControl = new ra(), this.addControl(this._logoControl, t.logoPosition), this.on(\"style.load\", () => {\n              this.transform.unmodified && this.jumpTo(this.style.stylesheet);\n            }), this.on(\"data\", t => {\n              this._update(\"style\" === t.dataType), this.fire(new e.b(`${t.dataType}data`, t));\n            }), this.on(\"dataloading\", t => {\n              this.fire(new e.b(`${t.dataType}dataloading`, t));\n            });\n          }\n          _getMapId() {\n            return this._mapId;\n          }\n          addControl(t, i) {\n            if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : \"top-right\"), !t || !t.onAdd) return this.fire(new e.a(new Error(\"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.\")));\n            const o = t.onAdd(this);\n            this._controls.push(t);\n            const r = this._controlPositions[i];\n            return -1 !== i.indexOf(\"bottom\") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;\n          }\n          removeControl(t) {\n            if (!t || !t.onRemove) return this.fire(new e.a(new Error(\"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.\")));\n            const i = this._controls.indexOf(t);\n            return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;\n          }\n          hasControl(e) {\n            return this._controls.indexOf(e) > -1;\n          }\n          getContainer() {\n            return this._container;\n          }\n          getCanvasContainer() {\n            return this._canvasContainer;\n          }\n          getCanvas() {\n            return this._canvas;\n          }\n          resize(t) {\n            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;\n            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));\n            const i = !this._moving;\n            return i && this.fire(new e.b(\"movestart\", t)).fire(new e.b(\"move\", t)), this.fire(new e.b(\"resize\", t)), i && this.fire(new e.b(\"moveend\", t)), this;\n          }\n          getBounds() {\n            return this.transform.getBounds();\n          }\n          getMaxBounds() {\n            return this.transform.getMaxBounds() || null;\n          }\n          setMaxBounds(t) {\n            return this.transform.setMaxBounds(e.ad.convert(t)), this._update();\n          }\n          setMinZoom(t) {\n            if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.b(\"zoomstart\")).fire(new e.b(\"zoom\")).fire(new e.b(\"zoomend\")), this;\n            throw new Error(\"minZoom must be between -2 and the current maxZoom, inclusive\");\n          }\n          getMinZoom() {\n            return this.transform.minZoom;\n          }\n          setMaxZoom(t) {\n            if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.b(\"zoomstart\")).fire(new e.b(\"zoom\")).fire(new e.b(\"zoomend\")), this;\n            throw new Error(\"maxZoom must be greater than the current minZoom\");\n          }\n          getMaxZoom() {\n            return this.transform.maxZoom;\n          }\n          setMinPitch(t) {\n            if ((t = null == t ? 0 : t) < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n            if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.b(\"pitchstart\")).fire(new e.b(\"pitch\")).fire(new e.b(\"pitchend\")), this;\n            throw new Error(\"minPitch must be between 0 and the current maxPitch, inclusive\");\n          }\n          getMinPitch() {\n            return this.transform.minPitch;\n          }\n          setMaxPitch(t) {\n            if ((t = null == t ? 85 : t) > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n            if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.b(\"pitchstart\")).fire(new e.b(\"pitch\")).fire(new e.b(\"pitchend\")), this;\n            throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n          }\n          getMaxPitch() {\n            return this.transform.maxPitch;\n          }\n          getRenderWorldCopies() {\n            return this.transform.renderWorldCopies;\n          }\n          setRenderWorldCopies(e) {\n            return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();\n          }\n          getLanguage() {\n            return this._language;\n          }\n          _parseLanguage(e) {\n            return \"auto\" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map(e => \"auto\" === e ? navigator.language : e) : e;\n          }\n          setLanguage(e) {\n            const t = this._parseLanguage(e);\n            if (!this.style || t === this._language) return this;\n            this._language = t, this.style.reloadSources();\n            for (const e of this._controls) e._setLanguage && e._setLanguage(this._language);\n            return this;\n          }\n          getWorldview() {\n            return this._worldview;\n          }\n          setWorldview(e) {\n            return this.style && e !== this._worldview ? (this._worldview = e, this.style.reloadSources(), this) : this;\n          }\n          getProjection() {\n            return this.transform.mercatorFromTransition ? {\n              name: \"globe\",\n              center: [0, 0]\n            } : this.transform.getProjection();\n          }\n          _showingGlobe() {\n            return \"globe\" === this.transform.projection.name;\n          }\n          setProjection(e) {\n            return this._lazyInitEmptyStyle(), e ? \"string\" == typeof e && (e = {\n              name: e\n            }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);\n          }\n          _updateProjectionTransition() {\n            if (\"globe\" !== this.getProjection().name) return;\n            const t = this.transform,\n              i = t.projection.name;\n            let o;\n            \"globe\" === i && t.zoom >= e.bx ? (t.setMercatorFromTransition(), o = !0) : \"mercator\" === i && t.zoom < e.bx && (t.setProjection({\n              name: \"globe\"\n            }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());\n          }\n          _prioritizeAndUpdateProjection(e, t) {\n            return this._updateProjection(e || t || {\n              name: \"mercator\"\n            });\n          }\n          _updateProjection(t) {\n            let i;\n            return i = \"globe\" === t.name && this.transform.zoom >= e.bx ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;\n          }\n          project(t) {\n            return this.transform.locationPoint3D(e.bn.convert(t));\n          }\n          unproject(t) {\n            return this.transform.pointLocation3D(e.P.convert(t));\n          }\n          isMoving() {\n            return this._moving || this.handlers && this.handlers.isMoving() || !1;\n          }\n          isZooming() {\n            return this._zooming || this.handlers && this.handlers.isZooming() || !1;\n          }\n          isRotating() {\n            return this._rotating || this.handlers && this.handlers.isRotating() || !1;\n          }\n          _isDragging() {\n            return this.handlers && this.handlers._isDragging() || !1;\n          }\n          _createDelegatedListener(e, t, i) {\n            if (\"mouseenter\" === e || \"mouseover\" === e) {\n              let o = !1;\n              const r = r => {\n                  const s = t.filter(e => this.getLayer(e)),\n                    n = s.length ? this.queryRenderedFeatures(r.point, {\n                      layers: s\n                    }) : [];\n                  n.length ? o || (o = !0, i.call(this, new pn(e, this, r.originalEvent, {\n                    features: n\n                  }))) : o = !1;\n                },\n                s = () => {\n                  o = !1;\n                };\n              return {\n                layers: new Set(t),\n                listener: i,\n                delegates: {\n                  mousemove: r,\n                  mouseout: s\n                }\n              };\n            }\n            if (\"mouseleave\" === e || \"mouseout\" === e) {\n              let o = !1;\n              const r = r => {\n                  const s = t.filter(e => this.getLayer(e));\n                  (s.length ? this.queryRenderedFeatures(r.point, {\n                    layers: s\n                  }) : []).length ? o = !0 : o && (o = !1, i.call(this, new pn(e, this, r.originalEvent)));\n                },\n                s = t => {\n                  o && (o = !1, i.call(this, new pn(e, this, t.originalEvent)));\n                };\n              return {\n                layers: new Set(t),\n                listener: i,\n                delegates: {\n                  mousemove: r,\n                  mouseout: s\n                }\n              };\n            }\n            {\n              const o = e => {\n                const o = t.filter(e => this.getLayer(e)),\n                  r = o.length ? this.queryRenderedFeatures(e.point, {\n                    layers: o\n                  }) : [];\n                r.length && (e.features = r, i.call(this, e), delete e.features);\n              };\n              return {\n                layers: new Set(t),\n                listener: i,\n                delegates: {\n                  [e]: o\n                }\n              };\n            }\n          }\n          on(e, t, i) {\n            if (void 0 === i) return super.on(e, t);\n            if (Array.isArray(t) || (t = [t]), t) for (const e of t) if (!this._isValidId(e)) return this;\n            const o = this._createDelegatedListener(e, t, i);\n            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);\n            for (const e in o.delegates) this.on(e, o.delegates[e]);\n            return this;\n          }\n          once(e, t, i) {\n            if (void 0 === i) return super.once(e, t);\n            if (Array.isArray(t) || (t = [t]), t) for (const e of t) if (!this._isValidId(e)) return this;\n            const o = this._createDelegatedListener(e, t, i);\n            for (const e in o.delegates) this.once(e, o.delegates[e]);\n            return this;\n          }\n          off(e, t, i) {\n            if (void 0 === i) return super.off(e, t);\n            t = new Set(Array.isArray(t) ? t : [t]);\n            for (const e of t) if (!this._isValidId(e)) return this;\n            const o = (e, t) => {\n                if (e.size !== t.size) return !1;\n                for (const i of e) if (!t.has(i)) return !1;\n                return !0;\n              },\n              r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;\n            return r && (e => {\n              for (let r = 0; r < e.length; r++) {\n                const s = e[r];\n                if (s.listener === i && o(s.layers, t)) {\n                  for (const e in s.delegates) this.off(e, s.delegates[e]);\n                  return e.splice(r, 1), this;\n                }\n              }\n            })(r), this;\n          }\n          queryRenderedFeatures(t, i) {\n            if (!this.style) return [];\n            if (void 0 !== i || void 0 === t || t instanceof e.P || Array.isArray(t) || (i = t, t = void 0), t = t || [[0, 0], [this.transform.width, this.transform.height]], (i = i || {}).layers && Array.isArray(i.layers)) for (const e of i.layers) if (!this._isValidId(e)) return [];\n            return this.style.queryRenderedFeatures(t, i, this.transform);\n          }\n          querySourceFeatures(e, t) {\n            return this._isValidId(e) ? this.style.querySourceFeatures(e, t) : [];\n          }\n          isPointOnSurface(t) {\n            const {\n              name: i\n            } = this.transform.projection;\n            return \"globe\" !== i && \"mercator\" !== i && e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t));\n          }\n          setStyle(t, i) {\n            return !1 !== (i = e.e({}, {\n              localIdeographFontFamily: this._localIdeographFontFamily,\n              localFontFamily: this._localFontFamily\n            }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));\n          }\n          _getUIString(e) {\n            const t = this._locale[e];\n            if (null == t) throw new Error(`Missing UI string '${e}'`);\n            return t;\n          }\n          _updateStyle(e, t) {\n            return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new Mo(this, t || {}), this.style.setEventedParent(this, {\n              style: this.style\n            }), \"string\" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;\n          }\n          _lazyInitEmptyStyle() {\n            this.style || (this.style = new Mo(this, {}), this.style.setEventedParent(this, {\n              style: this.style\n            }), this.style.loadEmpty());\n          }\n          _diffStyle(t, i) {\n            if (\"string\" == typeof t) {\n              const o = this._requestManager.normalizeStyleURL(t),\n                r = this._requestManager.transformRequest(o, e.R.Style);\n              e.g(r, (t, o) => {\n                t ? this.fire(new e.a(t)) : o && this._updateDiff(o, i);\n              });\n            } else \"object\" == typeof t && this._updateDiff(t, i);\n          }\n          _updateDiff(t, i) {\n            try {\n              this.style.setState(t) && this._update(!0);\n            } catch (o) {\n              e.w(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);\n            }\n          }\n          getStyle() {\n            if (this.style) return this.style.serialize();\n          }\n          isStyleLoaded() {\n            return this.style ? this.style.loaded() : (e.w(\"There is no style added to the map.\"), !1);\n          }\n          _isValidId(t) {\n            return null == t ? (this.fire(new e.a(new Error(\"IDs can't be empty.\"))), !1) : !e.c4(t) || (this.fire(new e.a(new Error(`IDs can't contain special symbols: \"${t}\".`))), !1);\n          }\n          addSource(e, t) {\n            return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0)) : this;\n          }\n          isSourceLoaded(e) {\n            return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);\n          }\n          areTilesLoaded() {\n            return this.style.areTilesLoaded();\n          }\n          addSourceType(e, t, i) {\n            this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);\n          }\n          removeSource(e) {\n            return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;\n          }\n          getSource(e) {\n            return this._isValidId(e) ? this.style.getOwnSource(e) : null;\n          }\n          addImage(t, i, {\n            pixelRatio: o = 1,\n            sdf: r = !1,\n            stretchX: s,\n            stretchY: n,\n            content: a\n          } = {}) {\n            if (this._lazyInitEmptyStyle(), i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {\n              const {\n                width: l,\n                height: c,\n                data: h\n              } = e.f.getImageData(i);\n              this.style.addImage(t, {\n                data: new e.h({\n                  width: l,\n                  height: c\n                }, h),\n                pixelRatio: o,\n                stretchX: s,\n                stretchY: n,\n                content: a,\n                sdf: r,\n                version: 0\n              });\n            } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.a(new Error(\"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));else {\n              const {\n                  width: l,\n                  height: c\n                } = i,\n                h = i;\n              this.style.addImage(t, {\n                data: new e.h({\n                  width: l,\n                  height: c\n                }, new Uint8Array(h.data)),\n                pixelRatio: o,\n                stretchX: s,\n                stretchY: n,\n                content: a,\n                sdf: r,\n                version: 0,\n                userImage: h\n              }), h.onAdd && h.onAdd(this, t);\n            }\n          }\n          updateImage(t, i) {\n            this._lazyInitEmptyStyle();\n            const o = this.style.getImage(t);\n            if (!o) return void this.fire(new e.a(new Error(\"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.\")));\n            const r = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.f.getImageData(i) : i,\n              {\n                width: s,\n                height: n\n              } = r,\n              a = r.data;\n            if (void 0 === s || void 0 === n) return void this.fire(new e.a(new Error(\"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n            if (s !== o.data.width || n !== o.data.height) return void this.fire(new e.a(new Error(`The width and height of the updated image (${s}, ${n})\\n                must be that same as the previous version of the image\\n                (${o.data.width}, ${o.data.height})`)));\n            const l = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);\n            o.data.replace(a, l), this.style.updateImage(t, o);\n          }\n          hasImage(t) {\n            return t ? !!this.style && !!this.style.getImage(t) : (this.fire(new e.a(new Error(\"Missing required image id\"))), !1);\n          }\n          removeImage(e) {\n            this.style.removeImage(e);\n          }\n          loadImage(t, i) {\n            e.d(this._requestManager.transformRequest(t, e.R.Image), (t, o) => {\n              i(t, o instanceof HTMLImageElement ? e.f.getImageData(o) : o);\n            });\n          }\n          listImages() {\n            return this.style.listImages();\n          }\n          addModel(e, t) {\n            this._lazyInitEmptyStyle(), this.style.addModel(e, t);\n          }\n          hasModel(t) {\n            return t ? this.style.hasModel(t) : (this.fire(new e.a(new Error(\"Missing required model id\"))), !1);\n          }\n          removeModel(e) {\n            this.style.removeModel(e);\n          }\n          listModels() {\n            return this.style.listModels();\n          }\n          addLayer(e, t) {\n            return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0)) : this;\n          }\n          getSlot(e) {\n            const t = this.getLayer(e);\n            return t && t.slot || null;\n          }\n          setSlot(e, t) {\n            return this.style.setSlot(e, t), this.style.mergeLayers(), this._update(!0);\n          }\n          addImport(e, t) {\n            return this.style.addImport(e, t), this;\n          }\n          updateImport(e, t) {\n            return \"string\" != typeof t && t.id !== e ? (this.removeImport(e), this.addImport(t)) : (this.style.updateImport(e, t), this._update(!0));\n          }\n          removeImport(e) {\n            return this.style.removeImport(e), this;\n          }\n          moveImport(e, t) {\n            return this.style.moveImport(e, t), this._update(!0);\n          }\n          moveLayer(e, t) {\n            return this._isValidId(e) ? (this.style.moveLayer(e, t), this._update(!0)) : this;\n          }\n          removeLayer(e) {\n            return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;\n          }\n          getLayer(e) {\n            return this._isValidId(e) ? this.style.getOwnLayer(e) : null;\n          }\n          setLayerZoomRange(e, t, i) {\n            return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t, i), this._update(!0)) : this;\n          }\n          setFilter(e, t, i = {}) {\n            return this._isValidId(e) ? (this.style.setFilter(e, t, i), this._update(!0)) : this;\n          }\n          getFilter(e) {\n            return this._isValidId(e) ? this.style.getFilter(e) : null;\n          }\n          setPaintProperty(e, t, i, o = {}) {\n            return this._isValidId(e) ? (this.style.setPaintProperty(e, t, i, o), this._update(!0)) : this;\n          }\n          getPaintProperty(e, t) {\n            return this._isValidId(e) ? this.style.getPaintProperty(e, t) : null;\n          }\n          setLayoutProperty(e, t, i, o = {}) {\n            return this._isValidId(e) ? (this.style.setLayoutProperty(e, t, i, o), this._update(!0)) : this;\n          }\n          getLayoutProperty(e, t) {\n            return this._isValidId(e) ? this.style.getLayoutProperty(e, t) : null;\n          }\n          getConfigProperty(e, t) {\n            return this.style.getConfigProperty(e, t);\n          }\n          setConfigProperty(e, t, i) {\n            return this.style.setConfigProperty(e, t, i), this._update(!0);\n          }\n          setLights(e) {\n            if (this._lazyInitEmptyStyle(), e && 1 === e.length && \"flat\" === e[0].type) {\n              const t = e[0];\n              t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, \"flat\");\n            } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);\n            return this._update(!0);\n          }\n          getLights() {\n            const e = this.style.getLights() || [];\n            return 0 === e.length && e.push({\n              id: this.style.light.id,\n              type: \"flat\",\n              properties: this.style.getFlatLight()\n            }), e;\n          }\n          setLight(e, t = {}) {\n            return console.log(\"The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead.\"), this.setLights([{\n              id: \"flat\",\n              type: \"flat\",\n              properties: e\n            }]);\n          }\n          getLight() {\n            return console.log(\"The `map.getLight` function is deprecated, prefer using `map.getLights` instead.\"), this.style.getFlatLight();\n          }\n          setTerrain(e) {\n            return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);\n          }\n          getTerrain() {\n            return this.style ? this.style.getTerrain() : null;\n          }\n          setFog(e) {\n            return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);\n          }\n          getFog() {\n            return this.style ? this.style.getFog() : null;\n          }\n          setCamera(e) {\n            return this.style.setCamera(e), this._triggerCameraUpdate(e);\n          }\n          _triggerCameraUpdate(e) {\n            return this._update(this.transform.setOrthographicProjectionAtLowPitch(\"orthographic\" === e[\"camera-projection\"]));\n          }\n          getCamera() {\n            return this.style.camera;\n          }\n          _queryFogOpacity(t) {\n            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.bn.convert(t), this.transform) : 0;\n          }\n          setFeatureState(e, t) {\n            return this._isValidId(e.source) ? (this.style.setFeatureState(e, t), this._update()) : this;\n          }\n          removeFeatureState(e, t) {\n            return this._isValidId(e.source) ? (this.style.removeFeatureState(e, t), this._update()) : this;\n          }\n          getFeatureState(e) {\n            return this._isValidId(e.source) ? this.style.getFeatureState(e) : null;\n          }\n          _updateContainerDimensions() {\n            if (!this._container) return;\n            const e = this._container.getBoundingClientRect().width || 400,\n              t = this._container.getBoundingClientRect().height || 300;\n            let i,\n              o,\n              r,\n              s = this._container;\n            for (; s && (!o || !r);) {\n              const e = window.getComputedStyle(s).transform;\n              e && \"none\" !== e && (i = e.match(/matrix.*\\((.+)\\)/)[1].split(\", \"), i[0] && \"0\" !== i[0] && \"1\" !== i[0] && (o = i[0]), i[3] && \"0\" !== i[3] && \"1\" !== i[3] && (r = i[3])), s = s.parentElement;\n            }\n            this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = r ? Math.abs(t / r) : t;\n          }\n          _detectMissingCSS() {\n            \"rgb(250, 128, 114)\" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue(\"background-color\") && e.w(\"This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.\");\n          }\n          _setupContainer() {\n            const e = this._container;\n            e.classList.add(\"mapboxgl-map\"), (this._missingCSSCanary = s(\"div\", \"mapboxgl-canary\", e)).style.visibility = \"hidden\", this._detectMissingCSS();\n            const t = this._canvasContainer = s(\"div\", \"mapboxgl-canvas-container\", e);\n            this._canvas = s(\"canvas\", \"mapboxgl-canvas\", t), this._interactive && (t.classList.add(\"mapboxgl-interactive\"), this._canvas.setAttribute(\"tabindex\", \"0\")), this._canvas.addEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.addEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.setAttribute(\"aria-label\", this._getUIString(\"Map.Title\")), this._canvas.setAttribute(\"role\", \"region\"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);\n            const i = this._controlContainer = s(\"div\", \"mapboxgl-control-container\", e),\n              o = this._controlPositions = {};\n            [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"].forEach(e => {\n              o[e] = s(\"div\", `mapboxgl-ctrl-${e}`, i);\n            }), this._container.addEventListener(\"scroll\", this._onMapScroll, !1);\n          }\n          _resizeCanvas(t, i) {\n            const o = e.f.devicePixelRatio || 1;\n            this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;\n          }\n          _addMarker(e) {\n            this._markers.push(e);\n          }\n          _removeMarker(e) {\n            const t = this._markers.indexOf(e);\n            -1 !== t && this._markers.splice(t, 1);\n          }\n          _addPopup(e) {\n            this._popups.push(e);\n          }\n          _removePopup(e) {\n            const t = this._popups.indexOf(e);\n            -1 !== t && this._popups.splice(t, 1);\n          }\n          _setupPainter() {\n            const t = e.e({}, i.webGLContextAttributes, {\n                failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n                preserveDrawingBuffer: this._preserveDrawingBuffer,\n                antialias: this._antialias || !1\n              }),\n              o = this._canvas.getContext(\"webgl2\", t);\n            o ? (e.db(o, !0), this.painter = new tn(o, this._contextCreateOptions, this.transform, this._tp), this.on(\"data\", e => {\n              \"source\" === e.dataType && this.painter.setTileLoadedFlag(!0);\n            }), e.dc.testSupport(o)) : this.fire(new e.a(new Error(\"Failed to initialize WebGL\")));\n          }\n          _contextLost(t) {\n            t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.b(\"webglcontextlost\", {\n              originalEvent: t\n            }));\n          }\n          _contextRestored(t) {\n            this._setupPainter(), this.resize(), this._update(), this.fire(new e.b(\"webglcontextrestored\", {\n              originalEvent: t\n            }));\n          }\n          _onMapScroll(e) {\n            if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n          }\n          loaded() {\n            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n          }\n          _update(e) {\n            return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n          }\n          _requestRenderFrame(e) {\n            return this._update(), this._renderTaskQueue.add(e);\n          }\n          _cancelRenderFrame(e) {\n            this._renderTaskQueue.remove(e);\n          }\n          _requestDomTask(e) {\n            !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);\n          }\n          _render(t) {\n            let i;\n            this.fire(new e.b(\"renderstart\"));\n            const o = this.painter.context.extTimerQuery,\n              r = e.f.now(),\n              s = this.painter.context.gl;\n            if (this.listens(\"gpu-timing-frame\") && (i = s.createQuery(), s.beginQuery(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;\n            this._updateProjectionTransition();\n            const n = this._isInitialLoad ? 0 : this._fadeDuration;\n            if (this.style && this._styleDirty) {\n              this._styleDirty = !1;\n              const t = this.transform.zoom,\n                i = this.transform.pitch,\n                o = e.f.now(),\n                r = new e.K(t, {\n                  now: o,\n                  fadeDuration: n,\n                  pitch: i,\n                  transition: this.style.transition\n                });\n              this.style.update(r);\n            }\n            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);\n            let a = !1;\n            if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), a = this._updateAverageElevation(r), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : a = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.style && this.painter.render(this.style, {\n              showTileBoundaries: this.showTileBoundaries || this._debugParams.showTileBoundaries,\n              showParseStatus: this.showParseStatus || this._debugParams.showParseStatus,\n              wireframe: {\n                terrain: this.showTerrainWireframe || this._debugParams.showTerrainWireframe,\n                layers2D: this.showLayers2DWireframe || this._debugParams.showLayers2DWireframe,\n                layers3D: this.showLayers3DWireframe || this._debugParams.showLayers3DWireframe\n              },\n              showOverdrawInspector: this._showOverdrawInspector || this._debugParams.showOverdrawInspector,\n              showQueryGeometry: !!this._showQueryGeometry,\n              showTileAABBs: this.showTileAABBs || this._debugParams.showTileAABBs,\n              rotating: this.isRotating(),\n              zooming: this.isZooming(),\n              moving: this.isMoving(),\n              fadeDuration: n,\n              isInitialLoad: this._isInitialLoad,\n              showPadding: this.showPadding || this._debugParams.showPadding,\n              gpuTiming: !!this.listens(\"gpu-timing-layer\"),\n              gpuTimingDeferredRender: !!this.listens(\"gpu-timing-deferred-render\"),\n              speedIndexTiming: this.speedIndexTiming\n            }), this.fire(new e.b(\"render\")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.b(\"load\"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {\n              const t = e.f.now() - r;\n              s.endQuery(o.TIME_ELAPSED_EXT), setTimeout(() => {\n                const o = s.getQueryParameter(i, s.QUERY_RESULT) / 1e6;\n                s.deleteQuery(i), this.fire(new e.b(\"gpu-timing-frame\", {\n                  cpuTime: t,\n                  gpuTime: o\n                }));\n              }, 50);\n            }\n            if (this.listens(\"gpu-timing-layer\")) {\n              const t = this.painter.collectGpuTimers();\n              setTimeout(() => {\n                const i = this.painter.queryGpuTimers(t);\n                this.fire(new e.b(\"gpu-timing-layer\", {\n                  layerTimes: i\n                }));\n              }, 50);\n            }\n            if (this.listens(\"gpu-timing-deferred-render\")) {\n              const t = this.painter.collectDeferredRenderGpuQueries();\n              setTimeout(() => {\n                const i = this.painter.queryGpuTimeDeferredRender(t);\n                this.fire(new e.b(\"gpu-timing-deferred-render\", {\n                  gpuTime: i\n                }));\n              }, 50);\n            }\n            const l = this._sourcesDirty || this._styleDirty || this._placementDirty || a;\n            if (l || this._repaint) this.triggerRepaint();else {\n              const t = !this.isMoving() && this.loaded();\n              if (t && (a = this._updateAverageElevation(r, !0)), a) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.b(\"idle\")), this._isInitialLoad = !1, this.speedIndexTiming)) {\n                const t = this._calculateSpeedIndex();\n                this.fire(new e.b(\"speedindexcompleted\", {\n                  speedIndex: t\n                })), this.speedIndexTiming = !1;\n              }\n            }\n            !this._loaded || this._fullyLoaded || l || (this._fullyLoaded = !0, this._performanceMetricsCollection && e.dd(this._requestManager._customAccessToken, {\n              width: this.painter.width,\n              height: this.painter.height,\n              interactionRange: this._interactionRange,\n              visibilityHidden: this._visibilityHidden,\n              terrainEnabled: !!this.painter.style.getTerrain(),\n              fogEnabled: !!this.painter.style.getFog(),\n              projection: this.getProjection().name,\n              zoom: this.transform.zoom,\n              renderer: this.painter.context.renderer,\n              vendor: this.painter.context.vendor\n            }), this._authenticate());\n          }\n          _forceMarkerAndPopupUpdate(e) {\n            for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();\n            for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();\n          }\n          _updateAverageElevation(e, t = !1) {\n            const i = e => (this.transform.averageElevation = e, this._update(!1), !0);\n            if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);\n            const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;\n            if (o || (t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {\n              const t = this.transform.averageElevation;\n              let r = this.transform.sampleAverageElevation();\n              this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r) ? r = 0 : this._averageElevationLastSampledAt = e;\n              const s = Math.abs(t - r);\n              if (s > 1) {\n                if (this._isInitialLoad || o) return this._averageElevation.jumpTo(r), i(r);\n                this._averageElevation.easeTo(r, e, 300);\n              } else if (s > 1e-4) return this._averageElevation.jumpTo(r), i(r);\n            }\n            return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));\n          }\n          _authenticate() {\n            e.de(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {\n              if (t && (t.message === e.df || 401 === t.status)) {\n                const t = this.painter.context.gl;\n                e.db(t, !1), this._logoControl instanceof ra && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.a(new Error(\"A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/\")));\n              }\n            }), e.dg(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});\n          }\n          _updateTerrain() {\n            const e = this._isDragging();\n            this.painter.updateTerrain(this.style, e);\n          }\n          _calculateSpeedIndex() {\n            const e = this.painter.canvasCopy(),\n              t = this.painter.getCanvasCopiesAndTimestamps();\n            t.timeStamps.push(performance.now());\n            const i = this.painter.context.gl,\n              o = i.createFramebuffer();\n            function r(e) {\n              i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);\n              const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);\n              return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;\n            }\n            return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps);\n          }\n          _canvasPixelComparison(e, t, i) {\n            let o = i[1] - i[0];\n            const r = e.length / 4;\n            for (let s = 0; s < t.length; s++) {\n              const n = t[s];\n              let a = 0;\n              for (let t = 0; t < n.length; t += 4) n[t] === e[t] && n[t + 1] === e[t + 1] && n[t + 2] === e[t + 2] && n[t + 3] === e[t + 3] && (a += 1);\n              o += (i[s + 2] - i[s + 1]) * (1 - a / r);\n            }\n            return o;\n          }\n          remove() {\n            this._hash && this._hash.remove();\n            for (const e of this._controls) e.onRemove(this);\n            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener(\"resize\", this._onWindowResize, !1), window.removeEventListener(\"orientationchange\", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener(\"online\", this._onWindowOnline, !1), window.removeEventListener(\"visibilitychange\", this._onVisibilityChange, !1);\n            const t = this.painter.context.gl.getExtension(\"WEBGL_lose_context\");\n            t && t.loseContext(), this._canvas.removeEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.removeEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove(\"mapboxgl-map\"), this._container.removeEventListener(\"scroll\", this._onMapScroll, !1), e.dh(this.painter.context.gl), e.di.remove(), e.dj.remove(), this._removed = !0, this.fire(new e.b(\"remove\"));\n          }\n          triggerRepaint() {\n            this._triggerFrame(!0);\n          }\n          _triggerFrame(t) {\n            this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.f.frame(e => {\n              const t = !!this._renderNextFrame;\n              this._frame = null, this._renderNextFrame = null, t && this._render(e);\n            }));\n          }\n          _preloadTiles(t) {\n            const i = this.style ? Object.values(this.style._sourceCaches) : [];\n            return e.b1(i, (e, i) => e._preloadTiles(t, i), () => {\n              this.triggerRepaint();\n            }), this;\n          }\n          _onWindowOnline() {\n            this._update();\n          }\n          _onWindowResize(e) {\n            this._trackResize && this.resize({\n              originalEvent: e\n            })._update();\n          }\n          _onVisibilityChange() {\n            \"hidden\" === document.visibilityState && this._visibilityHidden++;\n          }\n          get showTileBoundaries() {\n            return !!this._showTileBoundaries;\n          }\n          set showTileBoundaries(e) {\n            this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());\n          }\n          get showParseStatus() {\n            return !!this._showParseStatus;\n          }\n          set showParseStatus(e) {\n            this._showParseStatus !== e && (this._showParseStatus = e, this._update());\n          }\n          get showTerrainWireframe() {\n            return !!this._showTerrainWireframe;\n          }\n          set showTerrainWireframe(e) {\n            this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());\n          }\n          get showLayers2DWireframe() {\n            return !!this._showLayers2DWireframe;\n          }\n          set showLayers2DWireframe(e) {\n            this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._update());\n          }\n          get showLayers3DWireframe() {\n            return !!this._showLayers3DWireframe;\n          }\n          set showLayers3DWireframe(e) {\n            this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._update());\n          }\n          get speedIndexTiming() {\n            return !!this._speedIndexTiming;\n          }\n          set speedIndexTiming(e) {\n            this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());\n          }\n          get showPadding() {\n            return !!this._showPadding;\n          }\n          set showPadding(e) {\n            this._showPadding !== e && (this._showPadding = e, this._update());\n          }\n          get showCollisionBoxes() {\n            return !!this._showCollisionBoxes;\n          }\n          set showCollisionBoxes(e) {\n            this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());\n          }\n          get showOverdrawInspector() {\n            return !!this._showOverdrawInspector;\n          }\n          set showOverdrawInspector(e) {\n            this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());\n          }\n          get repaint() {\n            return !!this._repaint;\n          }\n          set repaint(e) {\n            this._repaint !== e && (this._repaint = e, this.triggerRepaint());\n          }\n          get vertices() {\n            return !!this._vertices;\n          }\n          set vertices(e) {\n            this._vertices = e, this._update();\n          }\n          get showTileAABBs() {\n            return !!this._showTileAABBs;\n          }\n          set showTileAABBs(e) {\n            this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update());\n          }\n          _setCacheLimits(t, i) {\n            e.dl(t, i);\n          }\n          get version() {\n            return e.dk;\n          }\n        },\n        NavigationControl: class {\n          constructor(t) {\n            this.options = e.e({}, ma, t), this._container = s(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this.options.showZoom && (e.aY([\"_setButtonTitle\", \"_updateZoomButtons\"], this), this._zoomInButton = this._createButton(\"mapboxgl-ctrl-zoom-in\", e => {\n              this._map && this._map.zoomIn({}, {\n                originalEvent: e\n              });\n            }), s(\"span\", \"mapboxgl-ctrl-icon\", this._zoomInButton).setAttribute(\"aria-hidden\", \"true\"), this._zoomOutButton = this._createButton(\"mapboxgl-ctrl-zoom-out\", e => {\n              this._map && this._map.zoomOut({}, {\n                originalEvent: e\n              });\n            }), s(\"span\", \"mapboxgl-ctrl-icon\", this._zoomOutButton).setAttribute(\"aria-hidden\", \"true\")), this.options.showCompass && (e.aY([\"_rotateCompassArrow\"], this), this._compass = this._createButton(\"mapboxgl-ctrl-compass\", e => {\n              const t = this._map;\n              t && (this.options.visualizePitch ? t.resetNorthPitch({}, {\n                originalEvent: e\n              }) : t.resetNorth({}, {\n                originalEvent: e\n              }));\n            }), this._compassIcon = s(\"span\", \"mapboxgl-ctrl-icon\", this._compass), this._compassIcon.setAttribute(\"aria-hidden\", \"true\"));\n          }\n          _updateZoomButtons() {\n            const e = this._map;\n            if (!e) return;\n            const t = e.getZoom(),\n              i = t === e.getMaxZoom(),\n              o = t === e.getMinZoom();\n            this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute(\"aria-disabled\", i.toString()), this._zoomOutButton.setAttribute(\"aria-disabled\", o.toString());\n          }\n          _rotateCompassArrow() {\n            const e = this._map;\n            if (!e) return;\n            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;\n            e._requestDomTask(() => {\n              this._compassIcon && (this._compassIcon.style.transform = t);\n            });\n          }\n          onAdd(e) {\n            return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, \"ZoomIn\"), this._setButtonTitle(this._zoomOutButton, \"ZoomOut\"), e.on(\"zoom\", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, \"ResetBearing\"), this.options.visualizePitch && e.on(\"pitch\", this._rotateCompassArrow), e.on(\"rotate\", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ga(e, this._compass, this.options.visualizePitch)), this._container;\n          }\n          onRemove() {\n            const e = this._map;\n            e && (this._container.remove(), this.options.showZoom && e.off(\"zoom\", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off(\"pitch\", this._rotateCompassArrow), e.off(\"rotate\", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);\n          }\n          _createButton(e, t) {\n            const i = s(\"button\", e, this._container);\n            return i.type = \"button\", i.addEventListener(\"click\", t), i;\n          }\n          _setButtonTitle(e, t) {\n            if (!this._map) return;\n            const i = this._map._getUIString(`NavigationControl.${t}`);\n            e.setAttribute(\"aria-label\", i), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n          }\n        },\n        GeolocateControl: class extends e.E {\n          constructor(t) {\n            super();\n            const i = navigator.geolocation;\n            this.options = e.e({\n              geolocation: i\n            }, va, t), e.aY([\"_onSuccess\", \"_onError\", \"_onZoom\", \"_finish\", \"_setupUI\", \"_updateCamera\", \"_updateMarker\", \"_updateMarkerRotation\", \"_onDeviceOrientation\"], this), this._updateMarkerRotationThrottled = on(this._updateMarkerRotation, 20), this._numberOfWatches = 0;\n          }\n          onAdd(e) {\n            return this._map = e, this._container = s(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkGeolocationSupport(this._setupUI), this._container;\n          }\n          onRemove() {\n            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off(\"zoom\", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;\n          }\n          _checkGeolocationSupport(e) {\n            const t = (t = !!this.options.geolocation) => {\n              this._supportsGeolocation = t, e(t);\n            };\n            void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({\n              name: \"geolocation\"\n            }).then(e => t(\"denied\" !== e.state)).catch(() => t()) : t();\n          }\n          _isOutOfMapMaxBounds(e) {\n            const t = this._map.getMaxBounds(),\n              i = e.coords;\n            return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());\n          }\n          _setErrorState() {\n            switch (this._watchState) {\n              case \"WAITING_ACTIVE\":\n                this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                break;\n              case \"ACTIVE_LOCK\":\n                this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n                break;\n              case \"BACKGROUND\":\n                this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n            }\n          }\n          _onSuccess(t) {\n            if (this._map) {\n              if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.b(\"outofmaxbounds\", t)), this._updateMarker(), void this._finish();\n              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {\n                case \"WAITING_ACTIVE\":\n                case \"ACTIVE_LOCK\":\n                case \"ACTIVE_ERROR\":\n                  this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                  break;\n                case \"BACKGROUND\":\n                case \"BACKGROUND_ERROR\":\n                  this._watchState = \"BACKGROUND\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n              }\n              this.options.showUserLocation && \"OFF\" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && \"ACTIVE_LOCK\" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._userLocationDotMarker.removeClassName(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.b(\"geolocate\", t)), this._finish();\n            }\n          }\n          _updateCamera(t) {\n            const i = new e.bn(t.coords.longitude, t.coords.latitude),\n              o = t.coords.accuracy,\n              r = this._map.getBearing(),\n              s = e.e({\n                bearing: r\n              }, this.options.fitBoundsOptions);\n            this._map.fitBounds(i.toBounds(o), s, {\n              geolocateSource: !0\n            });\n          }\n          _updateMarker(t) {\n            if (t) {\n              const i = new e.bn(t.coords.longitude, t.coords.latitude);\n              this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n          }\n          _updateCircleRadius() {\n            const t = this._map.transform,\n              i = e.bl(1, t._center.lat) * t.worldSize,\n              o = Math.ceil(2 * this._accuracy * i);\n            this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;\n          }\n          _onZoom() {\n            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          }\n          _updateMarkerRotation() {\n            this._userLocationDotMarker && \"number\" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName(\"mapboxgl-user-location-show-heading\")) : (this._userLocationDotMarker.removeClassName(\"mapboxgl-user-location-show-heading\"), this._userLocationDotMarker.setRotation(0));\n          }\n          _onError(t) {\n            if (this._map) {\n              if (this.options.trackUserLocation) if (1 === t.code) {\n                this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.disabled = !0;\n                const e = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n                this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e), void 0 !== this._geolocationWatchID && this._clearWatch();\n              } else {\n                if (3 === t.code && this._noTimeout) return;\n                this._setErrorState();\n              }\n              \"OFF\" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.b(\"error\", t)), this._finish();\n            }\n          }\n          _finish() {\n            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n          }\n          _setupUI(t) {\n            if (void 0 !== this._map) {\n              if (this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this._geolocateButton = s(\"button\", \"mapboxgl-ctrl-geolocate\", this._container), s(\"span\", \"mapboxgl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\"), this._geolocateButton.type = \"button\", !1 === t) {\n                e.w(\"Geolocation support is not available so the GeolocateControl will be disabled.\");\n                const t = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n                this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute(\"aria-label\", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", t);\n              } else {\n                const e = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n                this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e);\n              }\n              this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = s(\"div\", \"mapboxgl-user-location\"), this._dotElement.appendChild(s(\"div\", \"mapboxgl-user-location-dot\")), this._dotElement.appendChild(s(\"div\", \"mapboxgl-user-location-heading\")), this._userLocationDotMarker = new la({\n                element: this._dotElement,\n                rotationAlignment: \"map\",\n                pitchAlignment: \"map\"\n              }), this._circleElement = s(\"div\", \"mapboxgl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new la({\n                element: this._circleElement,\n                pitchAlignment: \"map\"\n              }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"zoom\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"movestart\", t => {\n                t.geolocateSource || \"ACTIVE_LOCK\" !== this._watchState || t.originalEvent && \"resize\" === t.originalEvent.type || (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this.fire(new e.b(\"trackuserlocationend\")));\n              });\n            }\n          }\n          _onDeviceOrientation(e) {\n            this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());\n          }\n          trigger() {\n            if (!this._setup) return e.w(\"Geolocate control triggered before added to a map\"), !1;\n            if (this.options.trackUserLocation) {\n              switch (this._watchState) {\n                case \"OFF\":\n                  this._watchState = \"WAITING_ACTIVE\", this.fire(new e.b(\"trackuserlocationstart\"));\n                  break;\n                case \"WAITING_ACTIVE\":\n                case \"ACTIVE_LOCK\":\n                case \"ACTIVE_ERROR\":\n                case \"BACKGROUND_ERROR\":\n                  this._numberOfWatches--, this._noTimeout = !1, this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this.fire(new e.b(\"trackuserlocationend\"));\n                  break;\n                case \"BACKGROUND\":\n                  this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.b(\"trackuserlocationstart\"));\n              }\n              switch (this._watchState) {\n                case \"WAITING_ACTIVE\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                  break;\n                case \"ACTIVE_LOCK\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                  break;\n                case \"ACTIVE_ERROR\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                  break;\n                case \"BACKGROUND\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n                  break;\n                case \"BACKGROUND_ERROR\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\");\n              }\n              if (\"OFF\" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n                let e;\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"true\"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {\n                  maximumAge: 6e5,\n                  timeout: 0\n                }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();\n              }\n            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n            return !0;\n          }\n          _addDeviceOrientationListener() {\n            const e = () => {\n              \"ondeviceorientationabsolute\" in window ? window.addEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation) : window.addEventListener(\"deviceorientation\", this._onDeviceOrientation);\n            };\n            \"undefined\" != typeof DeviceMotionEvent && \"function\" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(t => {\n              \"granted\" === t && e();\n            }).catch(console.error) : e();\n          }\n          _clearWatch() {\n            this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener(\"deviceorientation\", this._onDeviceOrientation), window.removeEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this.options.showUserLocation && this._updateMarker(null);\n          }\n        },\n        AttributionControl: oa,\n        ScaleControl: class {\n          constructor(t) {\n            this.options = e.e({}, xa, t), this._isNumberFormatSupported = function () {\n              try {\n                return new Intl.NumberFormat(\"en\", {\n                  style: \"unit\",\n                  unitDisplay: \"short\",\n                  unit: \"meter\"\n                }), !0;\n              } catch (e) {\n                return !1;\n              }\n            }(), e.aY([\"_update\", \"_setScale\", \"setUnit\"], this);\n          }\n          getDefaultPosition() {\n            return \"bottom-left\";\n          }\n          _update() {\n            const e = this.options.maxWidth || 100,\n              t = this._map,\n              i = t._containerHeight / 2,\n              o = t._containerWidth / 2 - e / 2,\n              r = t.unproject([o, i]),\n              s = t.unproject([o + e, i]),\n              n = r.distanceTo(s);\n            if (\"imperial\" === this.options.unit) {\n              const t = 3.2808 * n;\n              t > 5280 ? this._setScale(e, t / 5280, \"mile\") : this._setScale(e, t, \"foot\");\n            } else \"nautical\" === this.options.unit ? this._setScale(e, n / 1852, \"nautical-mile\") : n >= 1e3 ? this._setScale(e, n / 1e3, \"kilometer\") : this._setScale(e, n, \"meter\");\n          }\n          _setScale(e, t, i) {\n            this._map._requestDomTask(() => {\n              const o = function (e) {\n                  const t = Math.pow(10, `${Math.floor(e)}`.length - 1);\n                  let i = e / t;\n                  return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {\n                    const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));\n                    return Math.round(e * t) / t;\n                  }(i), t * i;\n                }(t),\n                r = o / t;\n              this._container.innerHTML = this._isNumberFormatSupported && \"nautical-mile\" !== i ? new Intl.NumberFormat(this._language, {\n                style: \"unit\",\n                unitDisplay: \"short\",\n                unit: i\n              }).format(o) : `${o}&nbsp;${ya[i]}`, this._container.style.width = e * r + \"px\";\n            });\n          }\n          onAdd(e) {\n            return this._map = e, this._language = e.getLanguage(), this._container = s(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-scale\", e.getContainer()), this._container.dir = \"auto\", this._map.on(\"move\", this._update), this._update(), this._container;\n          }\n          onRemove() {\n            this._container.remove(), this._map.off(\"move\", this._update), this._map = void 0;\n          }\n          _setLanguage(e) {\n            this._language = e, this._update();\n          }\n          setUnit(e) {\n            this.options.unit = e, this._update();\n          }\n        },\n        FullscreenControl: class {\n          constructor(t) {\n            this._fullscreen = !1, t && t.container && (t.container instanceof HTMLElement ? this._container = t.container : e.w(\"Full screen control 'container' must be a DOM element.\")), e.aY([\"_onClickFullscreen\", \"_changeIcon\"], this), \"onfullscreenchange\" in document ? this._fullscreenchange = \"fullscreenchange\" : \"onwebkitfullscreenchange\" in document && (this._fullscreenchange = \"webkitfullscreenchange\");\n          }\n          onAdd(t) {\n            return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = s(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = \"none\", e.w(\"This device does not support fullscreen mode.\")), this._controlContainer;\n          }\n          onRemove() {\n            this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);\n          }\n          _checkFullscreenSupport() {\n            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);\n          }\n          _setupUI() {\n            const e = this._fullscreenButton = s(\"button\", \"mapboxgl-ctrl-fullscreen\", this._controlContainer);\n            s(\"span\", \"mapboxgl-ctrl-icon\", e).setAttribute(\"aria-hidden\", \"true\"), e.type = \"button\", this._updateTitle(), this._fullscreenButton.addEventListener(\"click\", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);\n          }\n          _updateTitle() {\n            const e = this._getTitle();\n            this._fullscreenButton.setAttribute(\"aria-label\", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute(\"title\", e);\n          }\n          _getTitle() {\n            return this._map._getUIString(this._isFullscreen() ? \"FullscreenControl.Exit\" : \"FullscreenControl.Enter\");\n          }\n          _isFullscreen() {\n            return this._fullscreen;\n          }\n          _changeIcon() {\n            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-fullscreen\"), this._updateTitle());\n          }\n          _onClickFullscreen() {\n            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n          }\n        },\n        Popup: class extends e.E {\n          constructor(t) {\n            super(), this.options = e.e(Object.create(ca), t), e.aY([\"_update\", \"_onClose\", \"remove\", \"_onMouseEvent\"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\\s+/) : []);\n          }\n          addTo(t) {\n            return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on(\"preclick\", this._onClose), this.options.closeOnMove && t.on(\"move\", this._onClose), t.on(\"remove\", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on(\"mousemove\", this._onMouseEvent), t.on(\"mouseup\", this._onMouseEvent), t._canvasContainer.classList.add(\"mapboxgl-track-pointer\")) : t.on(\"move\", this._update), this.fire(new e.b(\"open\")), this;\n          }\n          isOpen() {\n            return !!this._map;\n          }\n          remove() {\n            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);\n            const t = this._map;\n            return t && (t.off(\"move\", this._update), t.off(\"move\", this._onClose), t.off(\"preclick\", this._onClose), t.off(\"click\", this._onClose), t.off(\"remove\", this.remove), t.off(\"mousemove\", this._onMouseEvent), t.off(\"mouseup\", this._onMouseEvent), t.off(\"drag\", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove(\"mapboxgl-track-pointer\"), t._removePopup(this), this._map = void 0), this.fire(new e.b(\"close\")), this;\n          }\n          getLngLat() {\n            return this._lngLat;\n          }\n          setLngLat(t) {\n            this._lngLat = e.bn.convert(t), this._pos = null, this._trackPointer = !1, this._update();\n            const i = this._map;\n            return i && (i.on(\"move\", this._update), i.off(\"mousemove\", this._onMouseEvent), i._canvasContainer.classList.remove(\"mapboxgl-track-pointer\")), this;\n          }\n          trackPointer() {\n            this._trackPointer = !0, this._pos = null, this._update();\n            const e = this._map;\n            return e && (e.off(\"move\", this._update), e.on(\"mousemove\", this._onMouseEvent), e.on(\"drag\", this._onMouseEvent), e._canvasContainer.classList.add(\"mapboxgl-track-pointer\")), this;\n          }\n          getElement() {\n            return this._container;\n          }\n          setText(e) {\n            return this.setDOMContent(document.createTextNode(e));\n          }\n          setHTML(e) {\n            const t = document.createDocumentFragment(),\n              i = document.createElement(\"body\");\n            let o;\n            for (i.innerHTML = e; o = i.firstChild, o;) t.appendChild(o);\n            return this.setDOMContent(t);\n          }\n          getMaxWidth() {\n            return this._container && this._container.style.maxWidth;\n          }\n          setMaxWidth(e) {\n            return this.options.maxWidth = e, this._update(), this;\n          }\n          setDOMContent(e) {\n            let t = this._content;\n            if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = s(\"div\", \"mapboxgl-popup-content\", this._container || void 0);\n            if (t.appendChild(e), this.options.closeButton) {\n              const e = this._closeButton = s(\"button\", \"mapboxgl-popup-close-button\", t);\n              e.type = \"button\", e.setAttribute(\"aria-label\", \"Close popup\"), e.setAttribute(\"aria-hidden\", \"true\"), e.innerHTML = \"&#215;\", e.addEventListener(\"click\", this._onClose);\n            }\n            return this._update(), this._focusFirstElement(), this;\n          }\n          addClassName(e) {\n            return this._classList.add(e), this._updateClassList(), this;\n          }\n          removeClassName(e) {\n            return this._classList.delete(e), this._updateClassList(), this;\n          }\n          setOffset(e) {\n            return this.options.offset = e, this._update(), this;\n          }\n          toggleClassName(e) {\n            let t;\n            return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;\n          }\n          _onMouseEvent(e) {\n            this._update(e.point);\n          }\n          _getAnchor(e) {\n            if (this.options.anchor) return this.options.anchor;\n            const t = this._map,\n              i = this._container,\n              o = this._pos;\n            if (!t || !i || !o) return \"bottom\";\n            const r = i.offsetWidth,\n              s = i.offsetHeight,\n              n = o.x < r / 2,\n              a = o.x > t.transform.width - r / 2;\n            if (o.y + e < s) return n ? \"top-left\" : a ? \"top-right\" : \"top\";\n            if (o.y > t.transform.height - s) {\n              if (n) return \"bottom-left\";\n              if (a) return \"bottom-right\";\n            }\n            return n ? \"left\" : a ? \"right\" : \"bottom\";\n          }\n          _updateClassList() {\n            const e = this._container;\n            if (!e) return;\n            const t = [...this._classList];\n            t.push(\"mapboxgl-popup\"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push(\"mapboxgl-popup-track-pointer\"), e.className = t.join(\" \");\n          }\n          _update(t) {\n            const i = this._map,\n              o = this._content;\n            if (!i || !this._lngLat && !this._trackPointer || !o) return;\n            let r = this._container;\n            if (r || (r = this._container = s(\"div\", \"mapboxgl-popup\", i.getContainer()), this._tip = s(\"div\", \"mapboxgl-popup-tip\", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = na(this._lngLat, this._pos, i.transform)), !this._trackPointer || t) {\n              const e = this._pos = this._trackPointer && t ? t : i.project(this._lngLat),\n                o = ua(this.options.offset),\n                r = this._anchor = this._getAnchor(o.y),\n                s = ua(this.options.offset, r),\n                n = e.add(s).round();\n              i._requestDomTask(() => {\n                this._container && r && (this._container.style.transform = `${aa[r]} translate(${n.x}px,${n.y}px)`);\n              });\n            }\n            if (!this._marker && i._showingGlobe()) {\n              const t = e.d6(i.transform, this._lngLat) ? 0 : 1;\n              this._setOpacity(t);\n            }\n            this._updateClassList();\n          }\n          _focusFirstElement() {\n            if (!this.options.focusAfterOpen || !this._container) return;\n            const e = this._container.querySelector(ha);\n            e && e.focus();\n          }\n          _onClose() {\n            this.remove();\n          }\n          _setOpacity(e) {\n            this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? \"auto\" : \"none\");\n          }\n        },\n        Marker: la,\n        Style: Mo,\n        LngLat: e.bn,\n        LngLatBounds: e.ad,\n        Point: e.P,\n        MercatorCoordinate: e.L,\n        FreeCameraOptions: uo,\n        Evented: e.E,\n        config: e.d5,\n        prewarm: e.dp,\n        clearPrewarmedResources: e.dq,\n        get accessToken() {\n          return e.d5.ACCESS_TOKEN;\n        },\n        set accessToken(t) {\n          e.d5.ACCESS_TOKEN = t;\n        },\n        get baseApiUrl() {\n          return e.d5.API_URL;\n        },\n        set baseApiUrl(t) {\n          e.d5.API_URL = t;\n        },\n        get workerCount() {\n          return e.dr.workerCount;\n        },\n        set workerCount(t) {\n          e.dr.workerCount = t;\n        },\n        get maxParallelImageRequests() {\n          return e.d5.MAX_PARALLEL_IMAGE_REQUESTS;\n        },\n        set maxParallelImageRequests(t) {\n          e.d5.MAX_PARALLEL_IMAGE_REQUESTS = t;\n        },\n        clearStorage(t) {\n          e.ds(t);\n        },\n        get workerUrl() {\n          return e.dt.workerUrl;\n        },\n        set workerUrl(t) {\n          e.dt.workerUrl = t;\n        },\n        get workerClass() {\n          return e.dt.workerClass;\n        },\n        set workerClass(t) {\n          e.dt.workerClass = t;\n        },\n        get workerParams() {\n          return e.dt.workerParams;\n        },\n        set workerParams(t) {\n          e.dt.workerParams = t;\n        },\n        get dracoUrl() {\n          return e.du();\n        },\n        set dracoUrl(t) {\n          e.dv(t);\n        },\n        get meshoptUrl() {\n          return e.dw();\n        },\n        set meshoptUrl(t) {\n          e.dx(t);\n        },\n        setNow: e.f.setNow,\n        restoreNow: e.f.restoreNow\n      };\n    return ba;\n  });\n\n  //\n  // Our custom intro provides a specialized \"define()\" function, called by the\n  // AMD modules below, that sets up the worker blob URL and then executes the\n  // main module, storing its exported value as 'mapboxgl'\n\n  var mapboxgl$1 = mapboxgl;\n  return mapboxgl$1;\n});","map":null,"metadata":{},"sourceType":"script"}